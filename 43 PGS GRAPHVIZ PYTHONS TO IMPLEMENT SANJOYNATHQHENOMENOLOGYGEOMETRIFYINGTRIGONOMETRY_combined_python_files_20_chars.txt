File 1 - dot.py:

1: (0)              """Create DOT code with method-calls."""
2: (0)              import contextlib
3: (0)              import typing
4: (0)              from . import _tools
5: (0)              from . import base
6: (0)              from . import quoting
7: (0)              __all__ = ['GraphSyntax', 'DigraphSyntax', 'Dot']
8: (0)              def comment(line: str) -> str:
9: (4)                  """Return comment header line."""
10: (4)                 return f'// {line}\n'
11: (0)             def graph_head(name: str) -> str:
12: (4)                 """Return DOT graph head line."""
13: (4)                 return f'graph {name}{{\n'
14: (0)             def digraph_head(name: str) -> str:
15: (4)                 """Return DOT digraph head line."""
16: (4)                 return f'digraph {name}{{\n'
17: (0)             def graph_edge(*, tail: str, head: str, attr: str) -> str:
18: (4)                 """Return DOT graph edge statement line."""
19: (4)                 return f'\t{tail} -- {head}{attr}\n'
20: (0)             def digraph_edge(*, tail: str, head: str, attr: str) -> str:
21: (4)                 """Return DOT digraph edge statement line."""
22: (4)                 return f'\t{tail} -> {head}{attr}\n'
23: (0)             class GraphSyntax:
24: (4)                 """DOT graph head and edge syntax."""
25: (4)                 _head = staticmethod(graph_head)
26: (4)                 _edge = staticmethod(graph_edge)
27: (0)             class DigraphSyntax:
28: (4)                 """DOT digraph head and edge syntax."""
29: (4)                 _head = staticmethod(digraph_head)
30: (4)                 _edge = staticmethod(digraph_edge)
31: (0)             def subgraph(name: str) -> str:
32: (4)                 """Return DOT subgraph head line."""
33: (4)                 return f'subgraph {name}{{\n'
34: (0)             def subgraph_plain(name: str) -> str:
35: (4)                 """Return plain DOT subgraph head line."""
36: (4)                 return f'{name}{{\n'
37: (0)             def node(left: str, right: str) -> str:
38: (4)                 """Return DOT node statement line."""
39: (4)                 return f'\t{left}{right}\n'
40: (0)             class Dot(quoting.Quote, base.Base):
41: (4)                 """Assemble DOT source code."""
42: (4)                 directed: bool
43: (4)                 _comment = staticmethod(comment)
44: (4)                 @staticmethod
45: (4)                 def _head(name: str) -> str:  # pragma: no cover
46: (8)                     """Return DOT head line."""
47: (8)                     raise NotImplementedError('must be implemented by concrete subclasses')
48: (4)                 @classmethod
49: (4)                 def _head_strict(cls, name: str) -> str:
50: (8)                     """Return DOT strict head line."""
51: (8)                     return f'strict {cls._head(name)}'
52: (4)                 _tail = '}\n'
53: (4)                 _subgraph = staticmethod(subgraph)
54: (4)                 _subgraph_plain = staticmethod(subgraph_plain)
55: (4)                 _node = _attr = staticmethod(node)
56: (4)                 @classmethod
57: (4)                 def _attr_plain(cls, left: str) -> str:
58: (8)                     return cls._attr(left, '')
59: (4)                 @staticmethod
60: (4)                 def _edge(*, tail: str, head: str, attr: str) -> str:  # pragma: no cover
61: (8)                     """Return DOT edge statement line."""
62: (8)                     raise NotImplementedError('must be implemented by concrete subclasses')
63: (4)                 @classmethod
64: (4)                 def _edge_plain(cls, *, tail: str, head: str) -> str:
65: (8)                     """Return plain DOT edge statement line."""
66: (8)                     return cls._edge(tail=tail, head=head, attr='')
67: (4)                 def __init__(self, *,
68: (17)                             name: typing.Optional[str] = None,
69: (17)                             comment: typing.Optional[str] = None,
70: (17)                             graph_attr=None, node_attr=None, edge_attr=None, body=None,
71: (17)                             strict: bool = False, **kwargs) -> None:
72: (8)                     super().__init__(**kwargs)
73: (8)                     self.name = name
74: (8)                     """str: DOT source identifier for the ``graph`` or ``digraph`` statement."""
75: (8)                     self.comment = comment
76: (8)                     """str: DOT source comment for the first source line."""
77: (8)                     self.graph_attr = dict(graph_attr) if graph_attr is not None else {}
78: (8)                     """~typing.Dict[str, str]: Attribute-value pairs applying to the graph."""
79: (8)                     self.node_attr = dict(node_attr) if node_attr is not None else {}
80: (8)                     """~typing.Dict[str, str]: Attribute-value pairs applying to all nodes."""
81: (8)                     self.edge_attr = dict(edge_attr) if edge_attr is not None else {}
82: (8)                     """~typing.Dict[str, str]: Attribute-value pairs applying to all edges."""
83: (8)                     self.body = list(body) if body is not None else []
84: (8)                     """~typing.List[str]: Verbatim DOT source lines including final newline."""
85: (8)                     self.strict = strict
86: (8)                     """bool: Rendering should merge multi-edges."""
87: (4)                 def _copy_kwargs(self, **kwargs):
88: (8)                     """Return the kwargs to create a copy of the instance."""
89: (8)                     return super()._copy_kwargs(name=self.name,
90: (36)                                                comment=self.comment,
91: (36)                                                graph_attr=dict(self.graph_attr),
92: (36)                                                node_attr=dict(self.node_attr),
93: (36)                                                edge_attr=dict(self.edge_attr),
94: (36)                                                body=list(self.body),
95: (36)                                                strict=self.strict)
96: (4)                 @_tools.deprecate_positional_args(supported_number=1)
97: (4)                 def clear(self, keep_attrs: bool = False) -> None:
98: (8)                     """Reset content to an empty body, clear graph/node/egde_attr mappings.
99: (8)                     Args:
100: (12)                       keep_attrs (bool): preserve graph/node/egde_attr mappings
101: (8)                    """
102: (8)                    if not keep_attrs:
103: (12)                       for a in (self.graph_attr, self.node_attr, self.edge_attr):
104: (16)                           a.clear()
105: (8)                    self.body.clear()
106: (4)                @_tools.deprecate_positional_args(supported_number=1)
107: (4)                def __iter__(self, subgraph: bool = False) -> typing.Iterator[str]:
108: (8)                    r"""Yield the DOT source code line by line (as graph or subgraph).
109: (8)                    Yields: Line ending with a newline (``'\n'``).
110: (8)                    """
111: (8)                    if self.comment:
112: (12)                       yield self._comment(self.comment)
113: (8)                    if subgraph:
114: (12)                       if self.strict:
115: (16)                           raise ValueError('subgraphs cannot be strict')
116: (12)                       head = self._subgraph if self.name else self._subgraph_plain
117: (8)                    else:
118: (12)                       head = self._head_strict if self.strict else self._head
119: (8)                    yield head(self._quote(self.name) + ' ' if self.name else '')
120: (8)                    for kw in ('graph', 'node', 'edge'):
121: (12)                       attrs = getattr(self, f'{kw}_attr')
122: (12)                       if attrs:
123: (16)                           yield self._attr(kw, self._attr_list(None, kwargs=attrs))
124: (8)                    yield from self.body
125: (8)                    yield self._tail
126: (4)                @_tools.deprecate_positional_args(supported_number=3)
127: (4)                def node(self, name: str,
128: (13)                        label: typing.Optional[str] = None,
129: (13)                        _attributes=None, **attrs) -> None:
130: (8)                    """Create a node.
131: (8)                    Args:
132: (12)                       name: Unique identifier for the node inside the source.
133: (12)                       label: Caption to be displayed (defaults to the node ``name``).
134: (12)                       attrs: Any additional node attributes (must be strings).
135: (8)                    Attention:
136: (12)                       When rendering ``label``, backslash-escapes
137: (12)                       and strings of the form ``<...>`` have a special meaning.
138: (12)                       See the sections :ref:`backslash-escapes` and
139: (12)                       :ref:`quoting-and-html-like-labels` in the user guide for details.
140: (8)                    """
141: (8)                    name = self._quote(name)
142: (8)                    attr_list = self._attr_list(label, kwargs=attrs, attributes=_attributes)
143: (8)                    line = self._node(name, attr_list)
144: (8)                    self.body.append(line)
145: (4)                @_tools.deprecate_positional_args(supported_number=4)
146: (4)                def edge(self, tail_name: str, head_name: str,
147: (13)                        label: typing.Optional[str] = None,
148: (13)                        _attributes=None, **attrs) -> None:
149: (8)                    """Create an edge between two nodes.
150: (8)                    Args:
151: (12)                       tail_name: Start node identifier
152: (16)                           (format: ``node[:port[:compass]]``).
153: (12)                       head_name: End node identifier
154: (16)                           (format: ``node[:port[:compass]]``).
155: (12)                       label: Caption to be displayed near the edge.
156: (12)                       attrs: Any additional edge attributes (must be strings).
157: (8)                    Note:
158: (12)                       The ``tail_name`` and ``head_name`` strings are separated
159: (12)                       by (optional) colon(s) into ``node`` name, ``port`` name,
160: (12)                       and ``compass`` (e.g. ``sw``).
161: (12)                       See :ref:`details in the User Guide <node-ports-compass>`.
162: (8)                    Attention:
163: (12)                       When rendering ``label``, backslash-escapes
164: (12)                       and strings of the form ``<...>`` have a special meaning.
165: (12)                       See the sections :ref:`backslash-escapes` and
166: (12)                       :ref:`quoting-and-html-like-labels` in the user guide for details.
167: (8)                    """
168: (8)                    tail_name = self._quote_edge(tail_name)
169: (8)                    head_name = self._quote_edge(head_name)
170: (8)                    attr_list = self._attr_list(label, kwargs=attrs, attributes=_attributes)
171: (8)                    line = self._edge(tail=tail_name, head=head_name, attr=attr_list)
172: (8)                    self.body.append(line)
173: (4)                def edges(self, tail_head_iter) -> None:
174: (8)                    """Create a bunch of edges.
175: (8)                    Args:
176: (12)                       tail_head_iter: Iterable of ``(tail_name, head_name)`` pairs
177: (16)                           (format:``node[:port[:compass]]``).
178: (8)                    Note:
179: (12)                       The ``tail_name`` and ``head_name`` strings are separated
180: (12)                       by (optional) colon(s) into ``node`` name, ``port`` name,
181: (12)                       and ``compass`` (e.g. ``sw``).
182: (12)                       See :ref:`details in the User Guide <node-ports-compass>`.
183: (8)                    """
184: (8)                    edge = self._edge_plain
185: (8)                    quote = self._quote_edge
186: (8)                    self.body += [edge(tail=quote(t), head=quote(h))
187: (22)                                 for t, h in tail_head_iter]
188: (4)                @_tools.deprecate_positional_args(supported_number=2)
189: (4)                def attr(self, kw: typing.Optional[str] = None,
190: (13)                        _attributes=None, **attrs) -> None:
191: (8)                    """Add a general or graph/node/edge attribute statement.
192: (8)                    Args:
193: (12)                       kw: Attributes target
194: (16)                           (``None`` or ``'graph'``, ``'node'``, ``'edge'``).
195: (12)                       attrs: Attributes to be set (must be strings, may be empty).
196: (8)                    See the :ref:`usage examples in the User Guide <attributes>`.
197: (8)                    """
198: (8)                    if kw is not None and kw.lower() not in ('graph', 'node', 'edge'):
199: (12)                       raise ValueError('attr statement must target graph, node, or edge:'
200: (29)                                        f' {kw!r}')
201: (8)                    if attrs or _attributes:
202: (12)                       if kw is None:
203: (16)                           a_list = self._a_list(None, kwargs=attrs, attributes=_attributes)
204: (16)                           line = self._attr_plain(a_list)
205: (12)                       else:
206: (16)                           attr_list = self._attr_list(None, kwargs=attrs, attributes=_attributes)
207: (16)                           line = self._attr(kw, attr_list)
208: (12)                       self.body.append(line)
209: (4)                @_tools.deprecate_positional_args(supported_number=2)
210: (4)                def subgraph(self, graph=None,
211: (17)                            name: typing.Optional[str] = None,
212: (17)                            comment: typing.Optional[str] = None,
213: (17)                            graph_attr=None, node_attr=None, edge_attr=None,
214: (17)                            body=None):
215: (8)                    """Add the current content of the given sole ``graph`` argument
216: (12)                       as subgraph or return a context manager
217: (12)                       returning a new graph instance
218: (12)                       created with the given (``name``, ``comment``, etc.) arguments
219: (12)                       whose content is added as subgraph
220: (12)                       when leaving the context manager's ``with``-block.
221: (8)                    Args:
222: (12)                       graph: An instance of the same kind
223: (16)                           (:class:`.Graph`, :class:`.Digraph`) as the current graph
224: (16)                           (sole argument in non-with-block use).
225: (12)                       name: Subgraph name (``with``-block use).
226: (12)                       comment: Subgraph comment (``with``-block use).
227: (12)                       graph_attr: Subgraph-level attribute-value mapping
228: (16)                           (``with``-block use).
229: (12)                       node_attr: Node-level attribute-value mapping
230: (16)                           (``with``-block use).
231: (12)                       edge_attr: Edge-level attribute-value mapping
232: (16)                           (``with``-block use).
233: (12)                       body: Verbatim lines to add to the subgraph ``body``
234: (16)                           (``with``-block use).
235: (8)                    See the :ref:`usage examples in the User Guide <subgraphs-clusters>`.
236: (8)                    When used as a context manager, the returned new graph instance
237: (8)                    uses ``strict=None`` and the parent graph's values
238: (8)                    for ``directory``, ``format``, ``engine``, and ``encoding`` by default.
239: (8)                    Note:
240: (12)                       If the ``name`` of the subgraph begins with
241: (12)                       ``'cluster'`` (all lowercase)
242: (12)                       the layout engine will treat it as a special cluster subgraph.
243: (8)                    """
244: (8)                    if graph is None:
245: (12)                       kwargs = self._copy_kwargs()
246: (12)                       kwargs.pop('filename', None)
247: (12)                       kwargs.update(name=name, comment=comment,
248: (26)                                     graph_attr=graph_attr, node_attr=node_attr, edge_attr=edge_attr,
249: (26)                                     body=body, strict=None)
250: (12)                       subgraph = self.__class__(**kwargs)
251: (12)                       @contextlib.contextmanager
252: (12)                       def subgraph_contextmanager(*, parent):
253: (16)                           """Return subgraph and add to parent on exit."""
254: (16)                           yield subgraph
255: (16)                           parent.subgraph(subgraph)
256: (12)                       return subgraph_contextmanager(parent=self)
257: (8)                    args = [name, comment, graph_attr, node_attr, edge_attr, body]
258: (8)                    if not all(a is None for a in args):
259: (12)                       raise ValueError('graph must be sole argument of subgraph()')
260: (8)                    if graph.directed != self.directed:
261: (12)                       raise ValueError(f'{self!r} cannot add subgraph of different kind:'
262: (29)                                        f' {graph!r}')
263: (8)                    self.body += [f'\t{line}' for line in graph.__iter__(subgraph=True)]

----------------------------------------

File 2 - base.py:

1: (0)              """Iterables of DOT source code lines (including final newline)."""
2: (0)              import typing
3: (0)              from . import copying
4: (0)              __all__ = ['Base']
5: (0)              class LineIterable:
6: (4)                  """Iterable of DOT Source code lines
7: (8)                      (mimics ``file`` objects in text mode)."""
8: (4)                  def __iter__(self) -> typing.Iterator[str]:  # pragma: no cover
9: (8)                      r"""Yield the generated DOT source line by line.
10: (8)                     Yields: Line ending with a newline (``'\n'``).
11: (8)                     """
12: (8)                     raise NotImplementedError('to be implemented by concrete subclasses')
13: (0)             class Base(LineIterable, copying.CopyBase):
14: (4)                 """LineIterator with ``.source`` attribute, that it returns for ``str()``."""
15: (4)                 @property
16: (4)                 def source(self) -> str:  # pragma: no cover
17: (8)                     raise NotImplementedError('to be implemented by concrete subclasses')
18: (4)                 def __str__(self) -> str:
19: (8)                     """The DOT source code as string."""
20: (8)                     return self.source

----------------------------------------

File 3 - _tools.py:

1: (0)              """Generic re-useable self-contained helper functions."""
2: (0)              import functools
3: (0)              import inspect
4: (0)              import itertools
5: (0)              import logging
6: (0)              import os
7: (0)              import pathlib
8: (0)              import typing
9: (0)              import warnings
10: (0)             __all__ = ['attach',
11: (11)                       'mkdirs',
12: (11)                       'mapping_items',
13: (11)                       'promote_pathlike',
14: (11)                       'promote_pathlike_directory',
15: (11)                       'deprecate_positional_args']
16: (0)             log = logging.getLogger(__name__)
17: (0)             def attach(object: typing.Any, /, name: str) -> typing.Callable:
18: (4)                 """Return a decorator doing ``setattr(object, name)`` with its argument.
19: (4)                 >>> spam = type('Spam', (object,), {})()  # doctest: +NO_EXE
20: (4)                 >>> @attach(spam, 'eggs')
21: (4)                 ... def func():
22: (4)                 ...     pass
23: (4)                 >>> spam.eggs  # doctest: +ELLIPSIS
24: (4)                 <function func at 0x...>
25: (4)                 """
26: (4)                 def decorator(func):
27: (8)                     setattr(object, name, func)
28: (8)                     return func
29: (4)                 return decorator
30: (0)             def mkdirs(filename: typing.Union[os.PathLike, str], /, *, mode: int = 0o777) -> None:
31: (4)                 """Recursively create directories up to the path of ``filename``
32: (8)                     as needed."""
33: (4)                 dirname = os.path.dirname(filename)
34: (4)                 if not dirname:
35: (8)                     return
36: (4)                 log.debug('os.makedirs(%r)', dirname)
37: (4)                 os.makedirs(dirname, mode=mode, exist_ok=True)
38: (0)             def mapping_items(mapping, /):
39: (4)                 """Return an iterator over the ``mapping`` items,
40: (8)                     sort if it's a plain dict.
41: (4)                 >>> list(mapping_items({'spam': 0, 'ham': 1, 'eggs': 2}))  # doctest: +NO_EXE
42: (4)                 [('eggs', 2), ('ham', 1), ('spam', 0)]
43: (4)                 >>> from collections import OrderedDict
44: (4)                 >>> list(mapping_items(OrderedDict(enumerate(['spam', 'ham', 'eggs']))))
45: (4)                 [(0, 'spam'), (1, 'ham'), (2, 'eggs')]
46: (4)                 """
47: (4)                 result = iter(mapping.items())
48: (4)                 if type(mapping) is dict:
49: (8)                     result = iter(sorted(result))
50: (4)                 return result
51: (0)             @typing.overload
52: (0)             def promote_pathlike(filepath: typing.Union[os.PathLike, str], /) -> pathlib.Path:
53: (4)                 """Return path object for path-like-object."""
54: (0)             @typing.overload
55: (0)             def promote_pathlike(filepath: None, /) -> None:
56: (4)                 """Return None for None."""
57: (0)             @typing.overload
58: (0)             def promote_pathlike(filepath: typing.Union[os.PathLike, str, None], /,
59: (21)                                 ) -> typing.Optional[pathlib.Path]:
60: (4)                 """Return path object or ``None`` depending on ``filepath``."""
61: (0)             def promote_pathlike(filepath: typing.Union[os.PathLike, str, None]
62: (21)                                 ) -> typing.Optional[pathlib.Path]:
63: (4)                 """Return path-like object ``filepath`` promoted into a path object.
64: (4)                 See also:
65: (8)                     https://docs.python.org/3/glossary.html#term-path-like-object
66: (4)                 """
67: (4)                 return pathlib.Path(filepath) if filepath is not None else None
68: (0)             def promote_pathlike_directory(directory: typing.Union[os.PathLike, str, None], /, *,
69: (31)                                           default: typing.Union[os.PathLike, str, None] = None,
70: (31)                                           ) -> pathlib.Path:
71: (4)                 """Return path-like object ``directory`` promoted into a path object (default to ``os.curdir``).
72: (4)                 See also:
73: (8)                     https://docs.python.org/3/glossary.html#term-path-like-object
74: (4)                 """
75: (4)                 return pathlib.Path(directory if directory is not None
76: (24)                                    else default or os.curdir)
77: (0)             def deprecate_positional_args(*,
78: (30)                                          supported_number: int,
79: (30)                                          category: typing.Type[Warning] = PendingDeprecationWarning,
80: (30)                                          stacklevel: int = 1):
81: (4)                 """Mark supported_number of positional arguments as the maximum.
82: (4)                 Args:
83: (8)                     supported_number: Number of positional arguments
84: (12)                        for which no warning is raised.
85: (8)                     category: Type of Warning to raise
86: (12)                        or None to return a nulldecorator
87: (12)                        returning the undecorated function.
88: (8)                     stacklevel: See :func:`warning.warn`.
89: (4)                 Returns:
90: (8)                     Return a decorator raising a category warning
91: (12)                        on more than supported_number positional args.
92: (4)                 See also:
93: (8)                     https://docs.python.org/3/library/exceptions.html#FutureWarning
94: (8)                     https://docs.python.org/3/library/exceptions.html#DeprecationWarning
95: (8)                     https://docs.python.org/3/library/exceptions.html#PendingDeprecationWarning
96: (4)                 """
97: (4)                 assert supported_number > 0, f'supported_number at least one: {supported_number!r}'
98: (4)                 if category is None:
99: (8)                     def nulldecorator(func):
100: (12)                       """Return the undecorated function."""
101: (12)                       return func
102: (8)                    return nulldecorator
103: (4)                assert issubclass(category, Warning)
104: (4)                stacklevel += 1
105: (4)                def decorator(func):
106: (8)                    signature = inspect.signature(func)
107: (8)                    argnames = [name for name, param in signature.parameters.items()
108: (20)                               if param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD]
109: (8)                    log.debug('deprecate positional args: %s.%s(%r)',
110: (18)                             func.__module__, func.__qualname__,
111: (18)                             argnames[supported_number:])
112: (8)                    @functools.wraps(func)
113: (8)                    def wrapper(*args, **kwargs):
114: (12)                       if len(args) > supported_number:
115: (16)                           call_args = zip(argnames, args)
116: (16)                           supported = itertools.islice(call_args, supported_number)
117: (16)                           supported = dict(supported)
118: (16)                           deprecated = dict(call_args)
119: (16)                           assert deprecated
120: (16)                           func_name = func.__name__.lstrip('_')
121: (16)                           func_name, sep, rest = func_name.partition('_legacy')
122: (16)                           assert not set or not rest
123: (16)                           wanted = ', '.join(f'{name}={value!r}'
124: (35)                                              for name, value in deprecated.items())
125: (16)                           warnings.warn(f'The signature of {func.__name__} will be reduced'
126: (30)                                         f' to {supported_number} positional args'
127: (30)                                         f' {list(supported)}: pass {wanted}'
128: (30)                                         ' as keyword arg(s)',
129: (30)                                         stacklevel=stacklevel,
130: (30)                                         category=category)
131: (12)                       return func(*args, **kwargs)
132: (8)                    return wrapper
133: (4)                return decorator

----------------------------------------

File 4 - copying.py:

1: (0)              """Create new instance copies with cooperative ``super()`` calls."""
2: (0)              __all__ = ['CopyBase']
3: (0)              class CopyBase:
4: (4)                  """Create new instance copies with cooperative ``super()`` calls."""
5: (4)                  def copy(self):
6: (8)                      """Return a copied instance of the object.
7: (8)                      Returns:
8: (12)                         An independent copy of the current object.
9: (8)                      """
10: (8)                     kwargs = self._copy_kwargs()
11: (8)                     return self.__class__(**kwargs)
12: (4)                 def _copy_kwargs(self, **kwargs):
13: (8)                     """Return the kwargs to create a copy of the instance."""
14: (8)                     return kwargs

----------------------------------------

File 5 - _compat.py:

1: (0)              """Python 3.8 compatibility and platform compatibility."""
2: (0)              import platform
3: (0)              import sys
4: (0)              if sys.version_info < (3, 9):  # pragma: no cover
5: (4)                  import unittest.mock
6: (4)                  Literal = unittest.mock.MagicMock(name='Literal')
7: (0)              else:  # pragma: no cover
8: (4)                  from typing import Literal
9: (4)                  Literal = Literal  # CAVEAT: use None instead of Literal[None]
10: (0)             def get_startupinfo() -> None:
11: (4)                 """Return None for startupinfo argument of ``subprocess.Popen``."""
12: (4)                 return None
13: (0)             assert get_startupinfo() is None, 'get_startupinfo() defaults to a no-op'
14: (0)             if platform.system() == 'Windows':  # pragma: no cover
15: (4)                 import subprocess
16: (4)                 def get_startupinfo() -> subprocess.STARTUPINFO:  # pytype: disable=module-attr
17: (8)                     """Return subprocess.STARTUPINFO instance hiding the console window."""
18: (8)                     startupinfo = subprocess.STARTUPINFO()  # pytype: disable=module-attr
19: (8)                     startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW  # pytype: disable=module-attr
20: (8)                     startupinfo.wShowWindow = subprocess.SW_HIDE  # pytype: disable=module-attr
21: (8)                     return startupinfo

----------------------------------------

File 6 - encoding.py:

1: (0)              """Encoding parameter handling and default."""
2: (0)              import typing
3: (0)              import codecs
4: (0)              import locale
5: (0)              from . import copying
6: (0)              __all__ = ['DEFAULT_ENCODING', 'Encoding']
7: (0)              DEFAULT_ENCODING = 'utf-8'
8: (0)              class Encoding(copying.CopyBase):
9: (4)                  """Encoding used for input and output with ``'utf-8'`` default."""
10: (4)                 _encoding = DEFAULT_ENCODING
11: (4)                 def __init__(self, *, encoding: typing.Optional[str] = DEFAULT_ENCODING,
12: (17)                             **kwargs) -> None:
13: (8)                     super().__init__(**kwargs)
14: (8)                     self.encoding = encoding
15: (4)                 def _copy_kwargs(self, **kwargs):
16: (8)                     """Return the kwargs to create a copy of the instance."""
17: (8)                     return super()._copy_kwargs(encoding=self._encoding, **kwargs)
18: (4)                 @property
19: (4)                 def encoding(self) -> str:
20: (8)                     """The encoding for the saved source file."""
21: (8)                     return self._encoding
22: (4)                 @encoding.setter
23: (4)                 def encoding(self, encoding: typing.Optional[str]) -> None:
24: (8)                     if encoding is None:
25: (12)                        encoding = locale.getpreferredencoding()
26: (8)                     codecs.lookup(encoding)  # raise early
27: (8)                     self._encoding = encoding

----------------------------------------

File 7 - __init__.py:

1: (0)              """Assemble DOT source code and render it with Graphviz.
2: (0)              Example:
3: (4)                  >>> import graphviz  # doctest: +NO_EXE
4: (4)                  >>> dot = graphviz.Digraph(comment='The Round Table')
5: (4)                  >>> dot.node('A', 'King Arthur')
6: (4)                  >>> dot.node('B', 'Sir Bedevere the Wise')
7: (4)                  >>> dot.node('L', 'Sir Lancelot the Brave')
8: (4)                  >>> dot.edges(['AB', 'AL'])
9: (4)                  >>> dot.edge('B', 'L', constraint='false')
10: (4)                 >>> print(dot)  #doctest: +NORMALIZE_WHITESPACE
11: (4)                 // The Round Table
12: (4)                 digraph {
13: (8)                     A [label="King Arthur"]
14: (8)                     B [label="Sir Bedevere the Wise"]
15: (8)                     L [label="Sir Lancelot the Brave"]
16: (8)                     A -> B
17: (8)                     A -> L
18: (8)                     B -> L [constraint=false]
19: (4)                 }
20: (0)             """
21: (0)             from ._defaults import set_default_engine, set_default_format, set_jupyter_format
22: (0)             from .backend import (DOT_BINARY, UNFLATTEN_BINARY,
23: (22)                                  render, pipe, pipe_string, pipe_lines, pipe_lines_string,
24: (22)                                  unflatten, version, view)
25: (0)             from .exceptions import (ExecutableNotFound, CalledProcessError,
26: (25)                                     RequiredArgumentError, FileExistsError,
27: (25)                                     UnknownSuffixWarning, FormatSuffixMismatchWarning,
28: (25)                                     DotSyntaxWarning)
29: (0)             from .graphs import Graph, Digraph
30: (0)             from .jupyter_integration import SUPPORTED_JUPYTER_FORMATS
31: (0)             from .parameters import ENGINES, FORMATS, RENDERERS, FORMATTERS
32: (0)             from .quoting import escape, nohtml
33: (0)             from .sources import Source
34: (0)             __all__ = ['ENGINES', 'FORMATS', 'RENDERERS', 'FORMATTERS',
35: (11)                       'DOT_BINARY', 'UNFLATTEN_BINARY',
36: (11)                       'SUPPORTED_JUPYTER_FORMATS',
37: (11)                       'Graph', 'Digraph',
38: (11)                       'Source',
39: (11)                       'escape', 'nohtml',
40: (11)                       'render', 'pipe', 'pipe_string', 'pipe_lines', 'pipe_lines_string',
41: (11)                       'unflatten', 'version', 'view',
42: (11)                       'ExecutableNotFound', 'CalledProcessError',
43: (11)                       'RequiredArgumentError', 'FileExistsError',
44: (11)                       'UnknownSuffixWarning', 'FormatSuffixMismatchWarning',
45: (11)                       'DotSyntaxWarning',
46: (11)                       'set_default_engine', 'set_default_format', 'set_jupyter_format']
47: (0)             __title__ = 'graphviz'
48: (0)             __version__ = '0.20.3'
49: (0)             __author__ = 'Sebastian Bank <sebastian.bank@uni-leipzig.de>'
50: (0)             __license__ = 'MIT, see LICENSE.txt'
51: (0)             __copyright__ = 'Copyright (c) 2013-2024 Sebastian Bank'
52: (0)             ENGINES = ENGINES
53: (0)             """:class:`set` of known layout commands used for rendering
54: (0)             (``'dot'``, ``'neato'``, ...)."""
55: (0)             FORMATS = FORMATS
56: (0)             """:class:`set` of known output formats for rendering
57: (0)             (``'pdf'``, ``'png'``, ...)."""
58: (0)             RENDERERS = RENDERERS
59: (0)             """:class:`set` of known output renderers for rendering
60: (0)             (``'cairo'``, ``'gd'``, ...)."""
61: (0)             FORMATTERS = FORMATTERS
62: (0)             """:class:`set` of known output formatters for rendering
63: (0)             (``'cairo'``, ``'gd'``, ...)."""
64: (0)             SUPPORTED_JUPYTER_FORMATS = SUPPORTED_JUPYTER_FORMATS
65: (0)             """:class:`set` of supported formats for ``_repr_mimebundle_()``
66: (0)             (``'svg'``, ``'png'``, ...)."""
67: (0)             DOT_BINARY = DOT_BINARY
68: (0)             """:class:`pathlib.Path` of rendering command (``Path('dot')``)."""
69: (0)             UNFLATTEN_BINARY = UNFLATTEN_BINARY
70: (0)             """:class:`pathlib.Path` of unflatten command (``Path('unflatten')``)."""
71: (0)             ExecutableNotFound = ExecutableNotFound
72: (0)             CalledProcessError = CalledProcessError
73: (0)             RequiredArgumentError = RequiredArgumentError
74: (0)             FileExistsError = FileExistsError
75: (0)             UnknownSuffixWarning = UnknownSuffixWarning
76: (0)             FormatSuffixMismatchWarning = FormatSuffixMismatchWarning
77: (0)             DotSyntaxWarning = DotSyntaxWarning

----------------------------------------

File 8 - _defaults.py:

1: (0)              """Set package-wide default parameters and IPython/Jupyter display format."""
2: (0)              __all_ = ['DEFAULT_SOURCE_EXTENSION',
3: (10)                       'set_default_engine', 'set_default_format', 'set_jupyter_format']
4: (0)              DEFAULT_SOURCE_EXTENSION = 'gv'
5: (0)              def set_default_engine(engine: str) -> str:
6: (4)                  """Change the default ``engine`` and return the old default value.
7: (4)                  Args:
8: (8)                      engine: new default ``engine``
9: (12)                         used by all present and newly created instances
10: (12)                        without explicitly set ``engine``
11: (12)                        (``'dot'``, ``'neato'``, ...).
12: (4)                 Returns:
13: (8)                     The old default value used for ``engine``.
14: (4)                 """
15: (4)                 from . import parameters
16: (4)                 parameters.verify_engine(engine)
17: (4)                 old_default_engine = parameters.Parameters._engine
18: (4)                 parameters.Parameters._engine = engine
19: (4)                 return old_default_engine
20: (0)             def set_default_format(format: str) -> str:
21: (4)                 """Change the default ``format`` and return the old default value.
22: (4)                 Args:
23: (8)                     format: new default ``format``
24: (12)                        used by all present and newly created instances
25: (12)                        without explicitly set ``format``
26: (12)                        (``'pdf'``, ``'png'``, ...).
27: (4)                 Returns:
28: (8)                     The old default value used for ``format``.
29: (4)                 """
30: (4)                 from . import parameters
31: (4)                 parameters.verify_format(format)
32: (4)                 old_default_format = parameters.Parameters._format
33: (4)                 parameters.Parameters._format = format
34: (4)                 return old_default_format
35: (0)             def set_jupyter_format(jupyter_format: str) -> str:
36: (4)                 """Change the default mimetype format for ``_repr_mimebundle_()`` and return the old value.
37: (4)                 Args:
38: (8)                     jupyter_format: new default IPython/Jupyter display format
39: (12)                        used by all present and newly created instances
40: (12)                        (``'svg'``, ``'png'``, ...).
41: (4)                 Returns:
42: (8)                     The old default value used for IPython/Jupyter display format.
43: (4)                 """
44: (4)                 from . import jupyter_integration
45: (4)                 mimetype = jupyter_integration.get_jupyter_format_mimetype(jupyter_format)
46: (4)                 old_mimetype = jupyter_integration.JupyterIntegration._jupyter_mimetype
47: (4)                 old_format = jupyter_integration.get_jupyter_mimetype_format(old_mimetype)
48: (4)                 jupyter_integration.JupyterIntegration._jupyter_mimetype = mimetype
49: (4)                 return old_format

----------------------------------------

File 9 - exceptions.py:

1: (0)              """Commonly used exception classes."""
2: (0)              from .backend.execute import ExecutableNotFound, CalledProcessError
3: (0)              __all__ = ['ExecutableNotFound', 'CalledProcessError',
4: (11)                        'RequiredArgumentError', 'FileExistsError',
5: (11)                        'UnknownSuffixWarning', 'FormatSuffixMismatchWarning',
6: (11)                        'DotSyntaxWarning']
7: (0)              class RequiredArgumentError(TypeError):
8: (4)                  """:exc:`TypeError` raised if a required argument is missing."""
9: (0)              class FileExistsError(FileExistsError):
10: (4)                 """:exc:`FileExistsError` raised with ``raise_if_exists=True``."""
11: (0)             class UnknownSuffixWarning(RuntimeWarning):
12: (4)                 """:exc:`RuntimeWarning` raised if the suffix of ``outfile`` is unknown
13: (8)                     and the given ``format`` is used instead."""
14: (0)             class FormatSuffixMismatchWarning(UserWarning):
15: (4)                 """:exc:`UserWarning` raised if the suffix ``outfile``
16: (8)                     does not match the given ``format``."""
17: (0)             class DotSyntaxWarning(RuntimeWarning):
18: (4)                 """:exc:`RuntimeWarning` raised if a quoted string
19: (8)                     is expected to cause a ``CalledProcessError`` from rendering."""

----------------------------------------

File 10 - graphs.py:

1: (0)              r"""Assemble DOT source code objects.
2: (0)              Example:
3: (4)                  >>> doctest_mark_exe()
4: (4)                  >>> import graphviz
5: (4)                  >>> dot = graphviz.Graph(comment='Mønti Pythøn ik den Hølie Grailen')
6: (4)                  >>> dot.node('Møøse')
7: (4)                  >>> dot.node('trained_by', 'trained by')
8: (4)                  >>> dot.node('tutte', 'TUTTE HERMSGERVORDENBROTBORDA')
9: (4)                  >>> dot.edge('Møøse', 'trained_by')
10: (4)                 >>> dot.edge('trained_by', 'tutte')
11: (4)                 >>> dot.node_attr['shape'] = 'rectangle'
12: (4)                 >>> print(dot.source)  #doctest: +NORMALIZE_WHITESPACE
13: (4)                 // Mønti Pythøn ik den Hølie Grailen
14: (4)                 graph {
15: (8)                     node [shape=rectangle]
16: (8)                     "Møøse"
17: (8)                     trained_by [label="trained by"]
18: (8)                     tutte [label="TUTTE HERMSGERVORDENBROTBORDA"]
19: (8)                     "Møøse" -- trained_by
20: (8)                     trained_by -- tutte
21: (4)                 }
22: (4)                 >>> dot.render('doctest-output/m00se.gv').replace('\\', '/')
23: (4)                 'doctest-output/m00se.gv.pdf'
24: (0)             """
25: (0)             import typing
26: (0)             from .encoding import DEFAULT_ENCODING
27: (0)             from . import _tools
28: (0)             from . import dot
29: (0)             from . import jupyter_integration
30: (0)             from . import piping
31: (0)             from . import rendering
32: (0)             from . import unflattening
33: (0)             __all__ = ['Graph', 'Digraph']
34: (0)             class BaseGraph(dot.Dot,
35: (16)                            rendering.Render,
36: (16)                            jupyter_integration.JupyterIntegration, piping.Pipe,
37: (16)                            unflattening.Unflatten):
38: (4)                 """Dot language creation and source code rendering."""
39: (4)                 @_tools.deprecate_positional_args(supported_number=2)
40: (4)                 def __init__(self, name: typing.Optional[str] = None,
41: (17)                             comment: typing.Optional[str] = None,
42: (17)                             filename=None, directory=None,
43: (17)                             format: typing.Optional[str] = None,
44: (17)                             engine: typing.Optional[str] = None,
45: (17)                             encoding: typing.Optional[str] = DEFAULT_ENCODING,
46: (17)                             graph_attr=None, node_attr=None, edge_attr=None,
47: (17)                             body=None,
48: (17)                             strict: bool = False, *,
49: (17)                             renderer: typing.Optional[str] = None,
50: (17)                             formatter: typing.Optional[str] = None) -> None:
51: (8)                     if filename is None and name is not None:
52: (12)                        filename = f'{name}.{self._default_extension}'
53: (8)                     super().__init__(name=name, comment=comment,
54: (25)                                     graph_attr=graph_attr,
55: (25)                                     node_attr=node_attr, edge_attr=edge_attr,
56: (25)                                     body=body, strict=strict,
57: (25)                                     filename=filename, directory=directory,
58: (25)                                     encoding=encoding,
59: (25)                                     format=format, engine=engine,
60: (25)                                     renderer=renderer, formatter=formatter)
61: (4)                 @property
62: (4)                 def source(self) -> str:
63: (8)                     """The generated DOT source code as string."""
64: (8)                     return ''.join(self)
65: (0)             class Graph(dot.GraphSyntax, BaseGraph):
66: (4)                 """Graph source code in the DOT language.
67: (4)                 Args:
68: (8)                     name: Graph name used in the source code.
69: (8)                     comment: Comment added to the first line of the source.
70: (8)                     filename: Filename for saving the source
71: (12)                        (defaults to ``name`` + ``'.gv'``).
72: (8)                     directory: (Sub)directory for source saving and rendering.
73: (8)                     format: Rendering output format (``'pdf'``, ``'png'``, ...).
74: (8)                     engine: Layout command used (``'dot'``, ``'neato'``, ...).
75: (8)                     renderer: Output renderer used (``'cairo'``, ``'gd'``, ...).
76: (8)                     formatter: Output formatter used (``'cairo'``, ``'gd'``, ...).
77: (8)                     encoding: Encoding for saving the source.
78: (8)                     graph_attr: Mapping of ``(attribute, value)`` pairs for the graph.
79: (8)                     node_attr: Mapping of ``(attribute, value)`` pairs set for all nodes.
80: (8)                     edge_attr: Mapping of ``(attribute, value)`` pairs set for all edges.
81: (8)                     body: Iterable of verbatim lines (including their final newline)
82: (12)                        to add to the graph ``body``.
83: (8)                     strict (bool): Rendering should merge multi-edges.
84: (4)                 Note:
85: (8)                     All parameters are `optional` and can be changed under their
86: (8)                     corresponding attribute name after instance creation.
87: (4)                 """
88: (4)                 @property
89: (4)                 def directed(self) -> bool:
90: (8)                     """``False``"""
91: (8)                     return False
92: (0)             class Digraph(dot.DigraphSyntax, BaseGraph):
93: (4)                 """Directed graph source code in the DOT language."""
94: (4)                 if Graph.__doc__ is not None:
95: (8)                     __doc__ += Graph.__doc__.partition('.')[2]
96: (4)                 @property
97: (4)                 def directed(self) -> bool:
98: (8)                     """``True``"""
99: (8)                     return True

----------------------------------------

File 11 - base.py:

1: (0)              """Rendering parameter handling."""
2: (0)              from .. import copying
3: (0)              __all__ = ['ParameterBase']
4: (0)              class ParameterBase(copying.CopyBase):
5: (4)                  """Rendering parameter."""
6: (4)                  def _getattr_from_dict(self, attrname: str, *, default=None):
7: (8)                      """Return self.attrname if attrname is in the instance dictionary
8: (12)                         (as oposed to on the type)."""
9: (8)                      if attrname in self.__dict__:
10: (12)                        return getattr(self, attrname)
11: (8)                     return default

----------------------------------------

File 12 - piping.py:

1: (0)              """Pipe DOT code objects through Graphviz ``dot``."""
2: (0)              import codecs
3: (0)              import logging
4: (0)              import typing
5: (0)              from . import _tools
6: (0)              from . import backend
7: (0)              from . import exceptions
8: (0)              from . import base
9: (0)              from . import encoding
10: (0)             __all__ = ['Pipe']
11: (0)             log = logging.getLogger(__name__)
12: (0)             class Pipe(encoding.Encoding, base.Base, backend.Pipe):
13: (4)                 """Pipe source lines through the Graphviz layout command."""
14: (4)                 @typing.overload
15: (4)                 def pipe(self,
16: (13)                         format: typing.Optional[str] = ...,
17: (13)                         renderer: typing.Optional[str] = ...,
18: (13)                         formatter: typing.Optional[str] = ...,
19: (13)                         neato_no_op: typing.Union[bool, int, None] = ...,
20: (13)                         quiet: bool = ..., *,
21: (13)                         engine: typing.Optional[str] = ...,
22: (13)                         encoding: None = ...) -> bytes:
23: (8)                     """Return bytes with default ``encoding=None``."""
24: (4)                 @typing.overload
25: (4)                 def pipe(self,
26: (13)                         format: typing.Optional[str] = ...,
27: (13)                         renderer: typing.Optional[str] = ...,
28: (13)                         formatter: typing.Optional[str] = ...,
29: (13)                         neato_no_op: typing.Union[bool, int, None] = ...,
30: (13)                         quiet: bool = ..., *,
31: (13)                         engine: typing.Optional[str] = ...,
32: (13)                         encoding: str) -> str:
33: (8)                     """Return string when given encoding."""
34: (4)                 @typing.overload
35: (4)                 def pipe(self,
36: (13)                         format: typing.Optional[str] = ...,
37: (13)                         renderer: typing.Optional[str] = ...,
38: (13)                         formatter: typing.Optional[str] = ...,
39: (13)                         neato_no_op: typing.Union[bool, int, None] = ...,
40: (13)                         quiet: bool = ..., *,
41: (13)                         engine: typing.Optional[str] = ...,
42: (13)                         encoding: typing.Optional[str]) -> typing.Union[bytes, str]:
43: (8)                     """Return bytes or string depending on encoding argument."""
44: (4)                 def pipe(self,
45: (13)                         format: typing.Optional[str] = None,
46: (13)                         renderer: typing.Optional[str] = None,
47: (13)                         formatter: typing.Optional[str] = None,
48: (13)                         neato_no_op: typing.Union[bool, int, None] = None,
49: (13)                         quiet: bool = False, *,
50: (13)                         engine: typing.Optional[str] = None,
51: (13)                         encoding: typing.Optional[str] = None) -> typing.Union[bytes, str]:
52: (8)                     """Return the source piped through the Graphviz layout command.
53: (8)                     Args:
54: (12)                        format: The output format used for rendering
55: (16)                            (``'pdf'``, ``'png'``, etc.).
56: (12)                        renderer: The output renderer used for rendering
57: (16)                            (``'cairo'``, ``'gd'``, ...).
58: (12)                        formatter: The output formatter used for rendering
59: (16)                            (``'cairo'``, ``'gd'``, ...).
60: (12)                        neato_no_op: Neato layout engine no-op flag.
61: (12)                        quiet (bool): Suppress ``stderr`` output
62: (16)                            from the layout subprocess.
63: (12)                        engine: Layout engine for rendering
64: (16)                            (``'dot'``, ``'neato'``, ...).
65: (12)                        encoding: Encoding for decoding the stdout.
66: (8)                     Returns:
67: (12)                        Bytes or if encoding is given decoded string
68: (16)                            (stdout of the layout command).
69: (8)                     Raises:
70: (12)                        ValueError: If ``engine``, ``format``, ``renderer``, or ``formatter``
71: (16)                            are unknown.
72: (12)                        graphviz.RequiredArgumentError: If ``formatter`` is given
73: (16)                            but ``renderer`` is None.
74: (12)                        graphviz.ExecutableNotFound: If the Graphviz ``dot`` executable
75: (16)                            is not found.
76: (12)                        graphviz.CalledProcessError: If the returncode (exit status)
77: (16)                            of the rendering ``dot`` subprocess is non-zero.
78: (8)                     Example:
79: (12)                        >>> doctest_mark_exe()
80: (12)                        >>> import graphviz
81: (12)                        >>> source = 'graph { spam }'
82: (12)                        >>> graphviz.Source(source, format='svg').pipe()[:14]
83: (12)                        b'<?xml version='
84: (12)                        >>> graphviz.Source(source, format='svg').pipe(encoding='ascii')[:14]
85: (12)                        '<?xml version='
86: (12)                        >>> graphviz.Source(source, format='svg').pipe(encoding='utf-8')[:14]
87: (12)                        '<?xml version='
88: (8)                     """
89: (8)                     return self._pipe_legacy(format,
90: (33)                                             renderer=renderer,
91: (33)                                             formatter=formatter,
92: (33)                                             neato_no_op=neato_no_op,
93: (33)                                             quiet=quiet,
94: (33)                                             engine=engine,
95: (33)                                             encoding=encoding)
96: (4)                 @_tools.deprecate_positional_args(supported_number=2)
97: (4)                 def _pipe_legacy(self,
98: (21)                                 format: typing.Optional[str] = None,
99: (21)                                 renderer: typing.Optional[str] = None,
100: (21)                                formatter: typing.Optional[str] = None,
101: (21)                                neato_no_op: typing.Union[bool, int, None] = None,
102: (21)                                quiet: bool = False, *,
103: (21)                                engine: typing.Optional[str] = None,
104: (21)                                encoding: typing.Optional[str] = None) -> typing.Union[bytes, str]:
105: (8)                    return self._pipe_future(format,
106: (33)                                            renderer=renderer,
107: (33)                                            formatter=formatter,
108: (33)                                            neato_no_op=neato_no_op,
109: (33)                                            quiet=quiet,
110: (33)                                            engine=engine,
111: (33)                                            encoding=encoding)
112: (4)                def _pipe_future(self, format: typing.Optional[str] = None, *,
113: (21)                                renderer: typing.Optional[str] = None,
114: (21)                                formatter: typing.Optional[str] = None,
115: (21)                                neato_no_op: typing.Union[bool, int, None] = None,
116: (21)                                quiet: bool = False,
117: (21)                                engine: typing.Optional[str] = None,
118: (21)                                encoding: typing.Optional[str] = None) -> typing.Union[bytes, str]:
119: (8)                    args, kwargs = self._get_pipe_parameters(engine=engine,
120: (49)                                                            format=format,
121: (49)                                                            renderer=renderer,
122: (49)                                                            formatter=formatter,
123: (49)                                                            neato_no_op=neato_no_op,
124: (49)                                                            quiet=quiet,
125: (49)                                                            verify=True)
126: (8)                    args.append(iter(self))
127: (8)                    if encoding is not None:
128: (12)                       if codecs.lookup(encoding) is codecs.lookup(self.encoding):
129: (16)                           return self._pipe_lines_string(*args, encoding=encoding, **kwargs)
130: (12)                       try:
131: (16)                           raw = self._pipe_lines(*args, input_encoding=self.encoding, **kwargs)
132: (12)                       except exceptions.CalledProcessError as e:
133: (16)                           *args, output, stderr = e.args
134: (16)                           if output is not None:
135: (20)                               output = output.decode(self.encoding)
136: (16)                           if stderr is not None:
137: (20)                               stderr = stderr.decode(self.encoding)
138: (16)                           raise e.__class__(*args, output=output, stderr=stderr)
139: (12)                       else:
140: (16)                           return raw.decode(encoding)
141: (8)                    return self._pipe_lines(*args, input_encoding=self.encoding, **kwargs)

----------------------------------------

File 13 - saving.py:

1: (0)              """Save DOT source lines to a file."""
2: (0)              import logging
3: (0)              import os
4: (0)              import typing
5: (0)              from . import _defaults
6: (0)              from . import _tools
7: (0)              from . import base
8: (0)              from . import encoding
9: (0)              __all__ = ['Save']
10: (0)             log = logging.getLogger(__name__)
11: (0)             class Save(encoding.Encoding, base.Base):
12: (4)                 """Save DOT source lines to file."""
13: (4)                 directory: typing.Union[str, bytes] = ''
14: (4)                 _default_extension = _defaults.DEFAULT_SOURCE_EXTENSION
15: (4)                 _mkdirs = staticmethod(_tools.mkdirs)
16: (4)                 def __init__(self, *,
17: (17)                             filename: typing.Union[os.PathLike, str],
18: (17)                             directory: typing.Union[os.PathLike, str, None] = None,
19: (17)                             **kwargs) -> None:
20: (8)                     super().__init__(**kwargs)
21: (8)                     if filename is None:
22: (12)                        filename = f'{self.__class__.__name__}.{self._default_extension}'
23: (8)                     self.filename = os.fspath(filename)
24: (8)                     """str: Target file name for saving the DOT source file."""
25: (8)                     if directory is not None:
26: (12)                        self.directory = os.fspath(directory)
27: (4)                 def _copy_kwargs(self, **kwargs):
28: (8)                     """Return the kwargs to create a copy of the instance."""
29: (8)                     assert 'directory' not in kwargs
30: (8)                     if 'directory' in self.__dict__:
31: (12)                        kwargs['directory'] = self.directory
32: (8)                     return super()._copy_kwargs(filename=self.filename, **kwargs)
33: (4)                 @property
34: (4)                 def filepath(self) -> str:
35: (8)                     """The target path for saving the DOT source file."""
36: (8)                     return os.path.join(self.directory, self.filename)
37: (4)                 @_tools.deprecate_positional_args(supported_number=2)
38: (4)                 def save(self, filename: typing.Union[os.PathLike, str, None] = None,
39: (13)                         directory: typing.Union[os.PathLike, str, None] = None, *,
40: (13)                         skip_existing: typing.Optional[bool] = False) -> str:
41: (8)                     """Save the DOT source to file. Ensure the file ends with a newline.
42: (8)                     Args:
43: (12)                        filename: Filename for saving the source (defaults to ``name`` + ``'.gv'``)
44: (12)                        directory: (Sub)directory for source saving and rendering.
45: (12)                        skip_existing: Skip write if file exists (default: ``False``).
46: (8)                     Returns:
47: (12)                        The (possibly relative) path of the saved source file.
48: (8)                     """
49: (8)                     if filename is not None:
50: (12)                        self.filename = filename
51: (8)                     if directory is not None:
52: (12)                        self.directory = directory
53: (8)                     filepath = self.filepath
54: (8)                     if skip_existing and os.path.exists(filepath):
55: (12)                        return filepath
56: (8)                     self._mkdirs(filepath)
57: (8)                     log.debug('write lines to %r', filepath)
58: (8)                     with open(filepath, 'w', encoding=self.encoding) as fd:
59: (12)                        for uline in self:
60: (16)                            fd.write(uline)
61: (8)                     return filepath

----------------------------------------

File 14 - mixins.py:

1: (0)              """Mixin classes used by Base subclasses to inherit backend functionality."""
2: (0)              import os
3: (0)              import typing
4: (0)              from .. import parameters
5: (0)              from . import piping
6: (0)              from . import rendering
7: (0)              from . import unflattening
8: (0)              from . import viewing
9: (0)              __all__ = ['Render', 'Pipe', 'Unflatten', 'View']
10: (0)             class Render(parameters.Parameters):
11: (4)                 """Parameters for calling and calling ``graphviz.render()``."""
12: (4)                 def _get_render_parameters(self,
13: (31)                                           outfile: typing.Union[os.PathLike, str, None] = None,
14: (31)                                           raise_if_result_exists: bool = False,
15: (31)                                           overwrite_source: bool = False,
16: (31)                                           **kwargs):
17: (8)                     kwargs = self._get_parameters(**kwargs)
18: (8)                     kwargs.update(outfile=outfile,
19: (22)                                  raise_if_result_exists=raise_if_result_exists,
20: (22)                                  overwrite_filepath=overwrite_source)
21: (8)                     return [kwargs.pop('engine'), kwargs.pop('format')], kwargs
22: (4)                 @property
23: (4)                 def _render(_):  # noqa: N805
24: (8)                     """Simplify ``._render()`` mocking."""
25: (8)                     return rendering.render
26: (0)             class Pipe(parameters.Parameters):
27: (4)                 """Parameters for calling and calling ``graphviz.pipe()``."""
28: (4)                 _get_format = staticmethod(rendering.get_format)
29: (4)                 _get_filepath = staticmethod(rendering.get_filepath)
30: (4)                 def _get_pipe_parameters(self, **kwargs):
31: (8)                     kwargs = self._get_parameters(**kwargs)
32: (8)                     return [kwargs.pop('engine'), kwargs.pop('format')], kwargs
33: (4)                 @property
34: (4)                 def _pipe_lines(_):  # noqa: N805
35: (8)                     """Simplify ``._pipe_lines()`` mocking."""
36: (8)                     return piping.pipe_lines
37: (4)                 @property
38: (4)                 def _pipe_lines_string(_):  # noqa: N805
39: (8)                     """Simplify ``._pipe_lines_string()`` mocking."""
40: (8)                     return piping.pipe_lines_string
41: (0)             class Unflatten:
42: (4)                 @property
43: (4)                 def _unflatten(_):  # noqa: N805
44: (8)                     """Simplify ``._unflatten mocking."""
45: (8)                     return unflattening.unflatten
46: (0)             class View:
47: (4)                 """Open filepath with its default viewing application
48: (8)                     (platform-specific)."""
49: (4)                 _view_darwin = staticmethod(viewing.view_darwin)
50: (4)                 _view_freebsd = staticmethod(viewing.view_unixoid)
51: (4)                 _view_linux = staticmethod(viewing.view_unixoid)
52: (4)                 _view_windows = staticmethod(viewing.view_windows)

----------------------------------------

File 15 - piping.py:

1: (0)              """Pipe bytes, strings, or string iterators through Graphviz ``dot``."""
2: (0)              import typing
3: (0)              from .. import _tools
4: (0)              from . import dot_command
5: (0)              from . import execute
6: (0)              __all__ = ['pipe', 'pipe_string',
7: (11)                        'pipe_lines', 'pipe_lines_string']
8: (0)              @_tools.deprecate_positional_args(supported_number=3)
9: (0)              def pipe(engine: str, format: str, data: bytes,
10: (9)                      renderer: typing.Optional[str] = None,
11: (9)                      formatter: typing.Optional[str] = None,
12: (9)                      neato_no_op: typing.Union[bool, int, None] = None,
13: (9)                      quiet: bool = False) -> bytes:
14: (4)                 """Return ``data`` (``bytes``) piped through ``engine`` into ``format`` as ``bytes``.
15: (4)                 Args:
16: (8)                     engine: Layout engine for rendering (``'dot'``, ``'neato'``, ...).
17: (8)                     format: Output format for rendering (``'pdf'``, ``'png'``, ...).
18: (8)                     data: Binary (encoded) DOT source bytes to render.
19: (8)                     renderer: Output renderer (``'cairo'``, ``'gd'``, ...).
20: (8)                     formatter: Output formatter (``'cairo'``, ``'gd'``, ...).
21: (8)                     neato_no_op: Neato layout engine no-op flag.
22: (8)                     quiet: Suppress ``stderr`` output from the layout subprocess.
23: (4)                 Returns:
24: (8)                     Binary (encoded) stdout of the layout command.
25: (4)                 Raises:
26: (8)                     ValueError: If ``engine``, ``format``, ``renderer``, or ``formatter``
27: (12)                        are unknown.
28: (8)                     graphviz.RequiredArgumentError: If ``formatter`` is given
29: (12)                        but ``renderer`` is None.
30: (8)                     graphviz.ExecutableNotFound: If the Graphviz ``dot`` executable
31: (12)                        is not found.
32: (8)                     graphviz.CalledProcessError: If the returncode (exit status)
33: (12)                        of the rendering ``dot`` subprocess is non-zero.
34: (4)                 Example:
35: (8)                     >>> doctest_mark_exe()
36: (8)                     >>> import graphviz
37: (8)                     >>> graphviz.pipe('dot', 'svg', b'graph { hello -- world }')[:14]
38: (8)                     b'<?xml version='
39: (4)                 Note:
40: (8)                     The layout command is started from the current directory.
41: (4)                 """
42: (4)                 cmd = dot_command.command(engine, format,
43: (30)                                          renderer=renderer,
44: (30)                                          formatter=formatter,
45: (30)                                          neato_no_op=neato_no_op)
46: (4)                 kwargs = {'input': data}
47: (4)                 proc = execute.run_check(cmd, capture_output=True, quiet=quiet, **kwargs)
48: (4)                 return proc.stdout
49: (0)             def pipe_string(engine: str, format: str, input_string: str, *,
50: (16)                            encoding: str,
51: (16)                            renderer: typing.Optional[str] = None,
52: (16)                            formatter: typing.Optional[str] = None,
53: (16)                            neato_no_op: typing.Union[bool, int, None] = None,
54: (16)                            quiet: bool = False) -> str:
55: (4)                 """Return ``input_string`` piped through ``engine`` into ``format`` as string.
56: (4)                 Args:
57: (8)                     engine: Layout engine for rendering (``'dot'``, ``'neato'``, ...).
58: (8)                     format: Output format for rendering (``'pdf'``, ``'png'``, ...).
59: (8)                     input_string: Binary (encoded) DOT source bytes to render.
60: (8)                     encoding: Encoding to en/decode subprocess stdin and stdout (required).
61: (8)                     renderer: Output renderer (``'cairo'``, ``'gd'``, ...).
62: (8)                     formatter: Output formatter (``'cairo'``, ``'gd'``, ...).
63: (8)                     neato_no_op: Neato layout engine no-op flag.
64: (8)                     quiet: Suppress ``stderr`` output from the layout subprocess.
65: (4)                 Returns:
66: (8)                     Decoded stdout of the layout command.
67: (4)                 Raises:
68: (8)                     ValueError: If ``engine``, ``format``, ``renderer``, or ``formatter``
69: (12)                        are unknown.
70: (8)                     graphviz.RequiredArgumentError: If ``formatter`` is given
71: (12)                        but ``renderer`` is None.
72: (8)                     graphviz.ExecutableNotFound: If the Graphviz ``dot`` executable
73: (12)                        is not found.
74: (8)                     graphviz.CalledProcessError: If the returncode (exit status)
75: (12)                        of the rendering ``dot`` subprocess is non-zero.
76: (4)                 Example:
77: (8)                     >>> doctest_mark_exe()
78: (8)                     >>> import graphviz
79: (8)                     >>> graphviz.pipe_string('dot', 'svg', 'graph { spam }',
80: (8)                     ...                      encoding='ascii')[:14]
81: (8)                     '<?xml version='
82: (4)                 Note:
83: (8)                     The layout command is started from the current directory.
84: (4)                 """
85: (4)                 cmd = dot_command.command(engine, format,
86: (30)                                          renderer=renderer,
87: (30)                                          formatter=formatter,
88: (30)                                          neato_no_op=neato_no_op)
89: (4)                 kwargs = {'input': input_string, 'encoding': encoding}
90: (4)                 proc = execute.run_check(cmd, capture_output=True, quiet=quiet, **kwargs)
91: (4)                 return proc.stdout
92: (0)             def pipe_lines(engine: str, format: str, input_lines: typing.Iterator[str], *,
93: (15)                           input_encoding: str,
94: (15)                           renderer: typing.Optional[str] = None,
95: (15)                           formatter: typing.Optional[str] = None,
96: (15)                           neato_no_op: typing.Union[bool, int, None] = None,
97: (15)                           quiet: bool = False) -> bytes:
98: (4)                 r"""Return ``input_lines`` piped through ``engine`` into ``format`` as ``bytes``.
99: (4)                 Args:
100: (8)                    engine: Layout engine for rendering (``'dot'``, ``'neato'``, ...).
101: (8)                    format: Output format for rendering (``'pdf'``, ``'png'``, ...).
102: (8)                    input_lines: DOT source lines to render (including final newline).
103: (8)                    input_encoding: Encode input_lines for subprocess stdin (required).
104: (8)                    renderer: Output renderer (``'cairo'``, ``'gd'``, ...).
105: (8)                    formatter: Output formatter (``'cairo'``, ``'gd'``, ...).
106: (8)                    neato_no_op: Neato layout engine no-op flag.
107: (8)                    quiet: Suppress ``stderr`` output from the layout subprocess.
108: (4)                Returns:
109: (8)                    Binary stdout of the layout command.
110: (4)                Raises:
111: (8)                    ValueError: If ``engine``, ``format``, ``renderer``, or ``formatter``
112: (12)                       are unknown.
113: (8)                    graphviz.RequiredArgumentError: If ``formatter`` is given
114: (12)                       but ``renderer`` is None.
115: (8)                    graphviz.ExecutableNotFound: If the Graphviz ``dot`` executable
116: (12)                       is not found.
117: (8)                    graphviz.CalledProcessError: If the returncode (exit status)
118: (12)                       of the rendering ``dot`` subprocess is non-zero.
119: (4)                Example:
120: (8)                    >>> doctest_mark_exe()
121: (8)                    >>> import graphviz
122: (8)                    >>> graphviz.pipe_lines('dot', 'svg', iter(['graph { spam }\n']),
123: (8)                    ...                     input_encoding='ascii')[:14]
124: (8)                    b'<?xml version='
125: (4)                Note:
126: (8)                    The layout command is started from the current directory.
127: (4)                """
128: (4)                cmd = dot_command.command(engine, format,
129: (30)                                         renderer=renderer,
130: (30)                                         formatter=formatter,
131: (30)                                         neato_no_op=neato_no_op)
132: (4)                kwargs = {'input_lines': (line.encode(input_encoding) for line in input_lines)}
133: (4)                proc = execute.run_check(cmd, capture_output=True, quiet=quiet, **kwargs)
134: (4)                return proc.stdout
135: (0)            def pipe_lines_string(engine: str, format: str, input_lines: typing.Iterator[str], *,
136: (22)                                 encoding: str,
137: (22)                                 renderer: typing.Optional[str] = None,
138: (22)                                 formatter: typing.Optional[str] = None,
139: (22)                                 neato_no_op: typing.Union[bool, int, None] = None,
140: (22)                                 quiet: bool = False) -> str:
141: (4)                r"""Return ``input_lines`` piped through ``engine`` into ``format`` as string.
142: (4)                Args:
143: (8)                    engine: Layout engine for rendering (``'dot'``, ``'neato'``, ...).
144: (8)                    format: Output format for rendering (``'pdf'``, ``'png'``, ...).
145: (8)                    input_lines: DOT source lines to render (including final newline).
146: (8)                    encoding: Encoding to en/decode subprocess stdin and stdout (required).
147: (8)                    renderer: Output renderer (``'cairo'``, ``'gd'``, ...).
148: (8)                    formatter: Output formatter (``'cairo'``, ``'gd'``, ...).
149: (8)                    neato_no_op: Neato layout engine no-op flag.
150: (8)                    quiet: Suppress ``stderr`` output from the layout subprocess.
151: (4)                Returns:
152: (8)                    Decoded stdout of the layout command.
153: (4)                Raises:
154: (8)                    ValueError: If ``engine``, ``format``, ``renderer``, or ``formatter``
155: (12)                       are unknown.
156: (8)                    graphviz.RequiredArgumentError: If ``formatter`` is given
157: (12)                       but ``renderer`` is None.
158: (8)                    graphviz.ExecutableNotFound: If the Graphviz ``dot`` executable
159: (12)                       is not found.
160: (8)                    graphviz.CalledProcessError: If the returncode (exit status)
161: (12)                       of the rendering ``dot`` subprocess is non-zero.
162: (4)                Example:
163: (8)                    >>> doctest_mark_exe()
164: (8)                    >>> import graphviz
165: (8)                    >>> graphviz.pipe_lines_string('dot', 'svg', iter(['graph { spam }\n']),
166: (8)                    ...                            encoding='ascii')[:14]
167: (8)                    '<?xml version='
168: (4)                Note:
169: (8)                    The layout command is started from the current directory.
170: (4)                """
171: (4)                cmd = dot_command.command(engine, format,
172: (30)                                         renderer=renderer,
173: (30)                                         formatter=formatter,
174: (30)                                         neato_no_op=neato_no_op)
175: (4)                kwargs = {'input_lines': input_lines, 'encoding': encoding}
176: (4)                proc = execute.run_check(cmd, capture_output=True, quiet=quiet, **kwargs)
177: (4)                return proc.stdout

----------------------------------------

File 16 - mixins.py:

1: (0)              """Mixin classes used to inherit parameter functionality."""
2: (0)              import typing
3: (0)              from . import engines
4: (0)              from . import formats
5: (0)              from . import renderers
6: (0)              from . import formatters
7: (0)              __all__ = ['Parameters']
8: (0)              class Parameters(engines.Engine, formats.Format,
9: (17)                              renderers.Renderer, formatters.Formatter):
10: (4)                 """Parameters for calling ``graphviz.render()`` and ``graphviz.pipe()``."""
11: (4)                 def _get_parameters(self, *,
12: (24)                                    engine: typing.Optional[str] = None,
13: (24)                                    format: typing.Optional[str] = None,
14: (24)                                    renderer: typing.Optional[str] = None,
15: (24)                                    formatter: typing.Optional[str] = None,
16: (24)                                    verify: bool = False,
17: (24)                                    **kwargs):
18: (8)                     if engine is None:
19: (12)                        engine = self.engine
20: (8)                     elif verify:
21: (12)                        self._verify_engine(engine)
22: (8)                     if format is None:
23: (12)                        format = self.format
24: (8)                     elif verify:
25: (12)                        self._verify_format(format)
26: (8)                     if renderer is None:
27: (12)                        renderer = self.renderer
28: (8)                     elif verify:
29: (12)                        self._verify_renderer(renderer)
30: (8)                     if formatter is None:
31: (12)                        formatter = self.formatter
32: (8)                     elif verify:
33: (12)                        self._verify_formatter(formatter)
34: (8)                     kwargs.update(engine=engine, format=format,
35: (22)                                  renderer=renderer, formatter=formatter)
36: (8)                     return kwargs

----------------------------------------

File 17 - quoting.py:

1: (0)              """Quote strings to be valid DOT identifiers, assemble quoted attribute lists."""
2: (0)              import functools
3: (0)              import re
4: (0)              import typing
5: (0)              import warnings
6: (0)              from . import _tools
7: (0)              from . import exceptions
8: (0)              __all__ = ['quote', 'quote_edge',
9: (11)                        'a_list', 'attr_list',
10: (11)                       'escape', 'nohtml']
11: (0)             HTML_STRING = re.compile(r'<.*>$', re.DOTALL)
12: (0)             ID = re.compile(r'([a-zA-Z_][a-zA-Z0-9_]*|-?(\.[0-9]+|[0-9]+(\.[0-9]*)?))$')
13: (0)             KEYWORDS = {'node', 'edge', 'graph', 'digraph', 'subgraph', 'strict'}
14: (0)             COMPASS = {'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw', 'c', '_'}  # TODO
15: (0)             FINAL_ODD_BACKSLASHES = re.compile(r'(?<!\\)(?:\\{2})*\\$')
16: (0)             QUOTE_WITH_OPTIONAL_BACKSLASHES = re.compile(r'''
17: (44)                                                        (?P<escaped_backslashes>(?:\\{2})*)
18: (44)                                                        \\?  # treat \" same as "
19: (44)                                                        (?P<literal_quote>")
20: (44)                                                        ''', flags=re.VERBOSE)
21: (0)             ESCAPE_UNESCAPED_QUOTES = functools.partial(QUOTE_WITH_OPTIONAL_BACKSLASHES.sub,
22: (44)                                                        r'\g<escaped_backslashes>'
23: (44)                                                        r'\\'
24: (44)                                                        r'\g<literal_quote>')
25: (0)             @_tools.deprecate_positional_args(supported_number=1)
26: (0)             def quote(identifier: str,
27: (10)                      is_html_string=HTML_STRING.match,
28: (10)                      is_valid_id=ID.match,
29: (10)                      dot_keywords=KEYWORDS,
30: (10)                      endswith_odd_number_of_backslashes=FINAL_ODD_BACKSLASHES.search,
31: (10)                      escape_unescaped_quotes=ESCAPE_UNESCAPED_QUOTES) -> str:
32: (4)                 r"""Return DOT identifier from string, quote if needed.
33: (4)                 >>> quote('')  # doctest: +NO_EXE
34: (4)                 '""'
35: (4)                 >>> quote('spam')
36: (4)                 'spam'
37: (4)                 >>> quote('spam spam')
38: (4)                 '"spam spam"'
39: (4)                 >>> quote('-4.2')
40: (4)                 '-4.2'
41: (4)                 >>> quote('.42')
42: (4)                 '.42'
43: (4)                 >>> quote('<<b>spam</b>>')
44: (4)                 '<<b>spam</b>>'
45: (4)                 >>> quote(nohtml('<>'))
46: (4)                 '"<>"'
47: (4)                 >>> print(quote('"'))
48: (4)                 "\""
49: (4)                 >>> print(quote('\\"'))
50: (4)                 "\""
51: (4)                 >>> print(quote('\\\\"'))
52: (4)                 "\\\""
53: (4)                 >>> print(quote('\\\\\\"'))
54: (4)                 "\\\""
55: (4)                 """
56: (4)                 if is_html_string(identifier) and not isinstance(identifier, NoHtml):
57: (8)                     pass
58: (4)                 elif not is_valid_id(identifier) or identifier.lower() in dot_keywords:
59: (8)                     if endswith_odd_number_of_backslashes(identifier):
60: (12)                        warnings.warn('expect syntax error scanning invalid quoted string:'
61: (26)                                      f' {identifier!r}',
62: (26)                                      category=exceptions.DotSyntaxWarning)
63: (8)                     return f'"{escape_unescaped_quotes(identifier)}"'
64: (4)                 return identifier
65: (0)             def quote_edge(identifier: str) -> str:
66: (4)                 """Return DOT edge statement node_id from string, quote if needed.
67: (4)                 >>> quote_edge('spam')  # doctest: +NO_EXE
68: (4)                 'spam'
69: (4)                 >>> quote_edge('spam spam:eggs eggs')
70: (4)                 '"spam spam":"eggs eggs"'
71: (4)                 >>> quote_edge('spam:eggs:s')
72: (4)                 'spam:eggs:s'
73: (4)                 """
74: (4)                 node, _, rest = identifier.partition(':')
75: (4)                 parts = [quote(node)]
76: (4)                 if rest:
77: (8)                     port, _, compass = rest.partition(':')
78: (8)                     parts.append(quote(port))
79: (8)                     if compass:
80: (12)                        parts.append(compass)
81: (4)                 return ':'.join(parts)
82: (0)             @_tools.deprecate_positional_args(supported_number=1)
83: (0)             def a_list(label: typing.Optional[str] = None,
84: (11)                       kwargs=None, attributes=None) -> str:
85: (4)                 """Return assembled DOT a_list string.
86: (4)                 >>> a_list('spam', kwargs={'spam': None, 'ham': 'ham ham', 'eggs': ''})  # doctest: +NO_EXE
87: (4)                 'label=spam eggs="" ham="ham ham"'
88: (4)                 """
89: (4)                 result = [f'label={quote(label)}'] if label is not None else []
90: (4)                 if kwargs:
91: (8)                     result += [f'{quote(k)}={quote(v)}'
92: (19)                               for k, v in _tools.mapping_items(kwargs) if v is not None]
93: (4)                 if attributes:
94: (8)                     if hasattr(attributes, 'items'):
95: (12)                        attributes = _tools.mapping_items(attributes)
96: (8)                     result += [f'{quote(k)}={quote(v)}'
97: (19)                               for k, v in attributes if v is not None]
98: (4)                 return ' '.join(result)
99: (0)             @_tools.deprecate_positional_args(supported_number=1)
100: (0)            def attr_list(label: typing.Optional[str] = None,
101: (14)                         kwargs=None, attributes=None) -> str:
102: (4)                """Return assembled DOT attribute list string.
103: (4)                Sorts ``kwargs`` and ``attributes`` if they are plain dicts
104: (4)                (to avoid unpredictable order from hash randomization in Python < 3.7).
105: (4)                >>> attr_list()  # doctest: +NO_EXE
106: (4)                ''
107: (4)                >>> attr_list('spam spam', kwargs={'eggs': 'eggs', 'ham': 'ham ham'})
108: (4)                ' [label="spam spam" eggs=eggs ham="ham ham"]'
109: (4)                >>> attr_list(kwargs={'spam': None, 'eggs': ''})
110: (4)                ' [eggs=""]'
111: (4)                """
112: (4)                content = a_list(label, kwargs=kwargs, attributes=attributes)
113: (4)                if not content:
114: (8)                    return ''
115: (4)                return f' [{content}]'
116: (0)            class Quote:
117: (4)                """Quote strings to be valid DOT identifiers, assemble quoted attribute lists."""
118: (4)                _quote = staticmethod(quote)
119: (4)                _quote_edge = staticmethod(quote_edge)
120: (4)                _a_list = staticmethod(a_list)
121: (4)                _attr_list = staticmethod(attr_list)
122: (0)            def escape(s: str) -> str:
123: (4)                r"""Return string disabling special meaning of backslashes and ``'<...>'``.
124: (4)                Args:
125: (8)                    s: String in which backslashes and ``'<...>'``
126: (12)                       should be treated as literal.
127: (4)                Returns:
128: (8)                    Escaped string subclass instance.
129: (4)                Raises:
130: (8)                    TypeError: If ``s`` is not a ``str``.
131: (4)                Example:
132: (8)                    >>> import graphviz  # doctest: +NO_EXE
133: (8)                    >>> print(graphviz.escape(r'\l'))
134: (8)                    \\l
135: (4)                See also:
136: (8)                    Upstream documentation:
137: (8)                    https://www.graphviz.org/doc/info/attrs.html#k:escString
138: (4)                """
139: (4)                return nohtml(s.replace('\\', '\\\\'))
140: (0)            class NoHtml(str):
141: (4)                """String subclass that does not treat ``'<...>'`` as DOT HTML string."""
142: (4)                __slots__ = ()
143: (0)            def nohtml(s: str) -> str:
144: (4)                """Return string not treating ``'<...>'`` as DOT HTML string in quoting.
145: (4)                Args:
146: (8)                    s: String in which leading ``'<'`` and trailing ``'>'``
147: (12)                       should be treated as literal.
148: (4)                Returns:
149: (8)                    String subclass instance.
150: (4)                Raises:
151: (8)                    TypeError: If ``s`` is not a ``str``.
152: (4)                Example:
153: (8)                    >>> import graphviz  # doctest: +NO_EXE
154: (8)                    >>> g = graphviz.Graph()
155: (8)                    >>> g.node(graphviz.nohtml('<>-*-<>'))
156: (8)                    >>> print(g.source)  # doctest: +NORMALIZE_WHITESPACE
157: (8)                    graph {
158: (12)                       "<>-*-<>"
159: (8)                    }
160: (4)                """
161: (4)                return NoHtml(s)

----------------------------------------

File 18 - sources.py:

1: (0)              """Save DOT code objects, render with Graphviz dot, and open in viewer."""
2: (0)              import locale
3: (0)              import logging
4: (0)              import os
5: (0)              import typing
6: (0)              from .encoding import DEFAULT_ENCODING
7: (0)              from . import _tools
8: (0)              from . import saving
9: (0)              from . import jupyter_integration
10: (0)             from . import piping
11: (0)             from . import rendering
12: (0)             from . import unflattening
13: (0)             __all__ = ['Source']
14: (0)             log = logging.getLogger(__name__)
15: (0)             class Source(rendering.Render, saving.Save,
16: (13)                         jupyter_integration.JupyterIntegration, piping.Pipe,
17: (13)                         unflattening.Unflatten):
18: (4)                 """Verbatim DOT source code string to be rendered by Graphviz.
19: (4)                 Args:
20: (8)                     source: The verbatim DOT source code string.
21: (8)                     filename: Filename for saving the source (defaults to ``'Source.gv'``).
22: (8)                     directory: (Sub)directory for source saving and rendering.
23: (8)                     format: Rendering output format (``'pdf'``, ``'png'``, ...).
24: (8)                     engine: Layout engine used (``'dot'``, ``'neato'``, ...).
25: (8)                     encoding: Encoding for saving the source.
26: (4)                 Note:
27: (8)                     All parameters except ``source`` are optional. All of them
28: (8)                     can be changed under their corresponding attribute name
29: (8)                     after instance creation.
30: (4)                 """
31: (4)                 @classmethod
32: (4)                 @_tools.deprecate_positional_args(supported_number=2)
33: (4)                 def from_file(cls, filename: typing.Union[os.PathLike, str],
34: (18)                              directory: typing.Union[os.PathLike, str, None] = None,
35: (18)                              format: typing.Optional[str] = None,
36: (18)                              engine: typing.Optional[str] = None,
37: (18)                              encoding: typing.Optional[str] = DEFAULT_ENCODING,
38: (18)                              renderer: typing.Optional[str] = None,
39: (18)                              formatter: typing.Optional[str] = None) -> 'Source':
40: (8)                     """Return an instance with the source string read from the given file.
41: (8)                     Args:
42: (12)                        filename: Filename for loading/saving the source.
43: (12)                        directory: (Sub)directory for source loading/saving and rendering.
44: (12)                        format: Rendering output format (``'pdf'``, ``'png'``, ...).
45: (12)                        engine: Layout command used (``'dot'``, ``'neato'``, ...).
46: (12)                        encoding: Encoding for loading/saving the source.
47: (8)                     """
48: (8)                     directory = _tools.promote_pathlike_directory(directory)
49: (8)                     filepath = (os.path.join(directory, filename) if directory.parts
50: (20)                                else os.fspath(filename))
51: (8)                     if encoding is None:
52: (12)                        encoding = locale.getpreferredencoding()
53: (8)                     log.debug('read %r with encoding %r', filepath, encoding)
54: (8)                     with open(filepath, encoding=encoding) as fd:
55: (12)                        source = fd.read()
56: (8)                     return cls(source,
57: (19)                               filename=filename, directory=directory,
58: (19)                               format=format, engine=engine, encoding=encoding,
59: (19)                               renderer=renderer, formatter=formatter,
60: (19)                               loaded_from_path=filepath)
61: (4)                 @_tools.deprecate_positional_args(supported_number=2)
62: (4)                 def __init__(self, source: str,
63: (17)                             filename: typing.Union[os.PathLike, str, None] = None,
64: (17)                             directory: typing.Union[os.PathLike, str, None] = None,
65: (17)                             format: typing.Optional[str] = None,
66: (17)                             engine: typing.Optional[str] = None,
67: (17)                             encoding: typing.Optional[str] = DEFAULT_ENCODING, *,
68: (17)                             renderer: typing.Optional[str] = None,
69: (17)                             formatter: typing.Optional[str] = None,
70: (17)                             loaded_from_path: typing.Optional[os.PathLike] = None) -> None:
71: (8)                     super().__init__(filename=filename, directory=directory,
72: (25)                                     format=format, engine=engine,
73: (25)                                     renderer=renderer, formatter=formatter,
74: (25)                                     encoding=encoding)
75: (8)                     self._loaded_from_path = loaded_from_path
76: (8)                     self._source = source
77: (4)                 _source: str
78: (4)                 _loaded_from_path: typing.Optional[os.PathLike]
79: (4)                 def _copy_kwargs(self, **kwargs):
80: (8)                     """Return the kwargs to create a copy of the instance."""
81: (8)                     return super()._copy_kwargs(source=self._source,
82: (36)                                                loaded_from_path=self._loaded_from_path,
83: (36)                                                **kwargs)
84: (4)                 def __iter__(self) -> typing.Iterator[str]:
85: (8)                     r"""Yield the DOT source code read from file line by line.
86: (8)                     Yields: Line ending with a newline (``'\n'``).
87: (8)                     """
88: (8)                     lines = self._source.splitlines(keepends=True)
89: (8)                     yield from lines[:-1]
90: (8)                     for line in lines[-1:]:
91: (12)                        suffix = '\n' if not line.endswith('\n') else ''
92: (12)                        yield line + suffix
93: (4)                 @property
94: (4)                 def source(self) -> str:
95: (8)                     """The DOT source code as string.
96: (8)                     Normalizes so that the string always ends in a final newline.
97: (8)                     """
98: (8)                     source = self._source
99: (8)                     if not source.endswith('\n'):
100: (12)                       source += '\n'
101: (8)                    return source
102: (4)                @_tools.deprecate_positional_args(supported_number=2)
103: (4)                def save(self, filename: typing.Union[os.PathLike, str, None] = None,
104: (13)                        directory: typing.Union[os.PathLike, str, None] = None, *,
105: (13)                        skip_existing: typing.Optional[bool] = None) -> str:
106: (8)                    """Save the DOT source to file. Ensure the file ends with a newline.
107: (8)                    Args:
108: (12)                       filename: Filename for saving the source (defaults to ``name`` + ``'.gv'``)
109: (12)                       directory: (Sub)directory for source saving and rendering.
110: (12)                       skip_existing: Skip write if file exists (default: ``None``).
111: (16)                           By default skips if instance was loaded from the target path:
112: (16)                           ``.from_file(self.filepath)``.
113: (8)                    Returns:
114: (12)                       The (possibly relative) path of the saved source file.
115: (8)                    """
116: (8)                    skip = (skip_existing is None and self._loaded_from_path
117: (16)                           and os.path.samefile(self._loaded_from_path, self.filepath))
118: (8)                    if skip:
119: (12)                       log.debug('.save(skip_existing=None) skip writing Source.from_file(%r)',
120: (22)                                 self.filepath)
121: (8)                    return super().save(filename=filename, directory=directory,
122: (28)                                       skip_existing=skip)

----------------------------------------

File 19 - execute.py:

1: (0)              """Run subprocesses with ``subprocess.run()`` and ``subprocess.Popen()``."""
2: (0)              import errno
3: (0)              import logging
4: (0)              import os
5: (0)              import subprocess
6: (0)              import sys
7: (0)              import typing
8: (0)              from .. import _compat
9: (0)              __all__ = ['run_check', 'ExecutableNotFound', 'CalledProcessError']
10: (0)             log = logging.getLogger(__name__)
11: (0)             BytesOrStrIterator = typing.Union[typing.Iterator[bytes],
12: (34)                                              typing.Iterator[str]]
13: (0)             @typing.overload
14: (0)             def run_check(cmd: typing.Sequence[typing.Union[os.PathLike, str]], *,
15: (14)                          input_lines: typing.Optional[typing.Iterator[bytes]] = ...,
16: (14)                          encoding: None = ...,
17: (14)                          quiet: bool = ...,
18: (14)                          **kwargs) -> subprocess.CompletedProcess:
19: (4)                 """Accept bytes input_lines with default ``encoding=None```."""
20: (0)             @typing.overload
21: (0)             def run_check(cmd: typing.Sequence[typing.Union[os.PathLike, str]], *,
22: (14)                          input_lines: typing.Optional[typing.Iterator[str]] = ...,
23: (14)                          encoding: str,
24: (14)                          quiet: bool = ...,
25: (14)                          **kwargs) -> subprocess.CompletedProcess:
26: (4)                 """Accept string input_lines when given ``encoding``."""
27: (0)             @typing.overload
28: (0)             def run_check(cmd: typing.Sequence[typing.Union[os.PathLike, str]], *,
29: (14)                          input_lines: typing.Optional[BytesOrStrIterator] = ...,
30: (14)                          encoding: typing.Optional[str] = ...,
31: (14)                          capture_output: bool = ...,
32: (14)                          quiet: bool = ...,
33: (14)                          **kwargs) -> subprocess.CompletedProcess:
34: (4)                 """Accept bytes or string input_lines depending on ``encoding``."""
35: (0)             def run_check(cmd: typing.Sequence[typing.Union[os.PathLike, str]], *,
36: (14)                          input_lines: typing.Optional[BytesOrStrIterator] = None,
37: (14)                          encoding: typing.Optional[str] = None,
38: (14)                          quiet: bool = False,
39: (14)                          **kwargs) -> subprocess.CompletedProcess:
40: (4)                 """Run the command described by ``cmd``
41: (8)                     with ``check=True`` and return its completed process.
42: (4)                 Raises:
43: (8)                     CalledProcessError: if the returncode of the subprocess is non-zero.
44: (4)                 """
45: (4)                 log.debug('run %r', cmd)
46: (4)                 if not kwargs.pop('check', True):  # pragma: no cover
47: (8)                     raise NotImplementedError('check must be True or omited')
48: (4)                 if encoding is not None:
49: (8)                     kwargs['encoding'] = encoding
50: (4)                 kwargs.setdefault('startupinfo', _compat.get_startupinfo())
51: (4)                 try:
52: (8)                     if input_lines is not None:
53: (12)                        assert kwargs.get('input') is None
54: (12)                        assert iter(input_lines) is input_lines
55: (12)                        if kwargs.pop('capture_output'):
56: (16)                            kwargs['stdout'] = kwargs['stderr'] = subprocess.PIPE
57: (12)                        proc = _run_input_lines(cmd, input_lines, kwargs=kwargs)
58: (8)                     else:
59: (12)                        proc = subprocess.run(cmd, **kwargs)
60: (4)                 except OSError as e:
61: (8)                     if e.errno == errno.ENOENT:
62: (12)                        raise ExecutableNotFound(cmd) from e
63: (8)                     raise
64: (4)                 if not quiet and proc.stderr:
65: (8)                     _write_stderr(proc.stderr)
66: (4)                 try:
67: (8)                     proc.check_returncode()
68: (4)                 except subprocess.CalledProcessError as e:
69: (8)                     raise CalledProcessError(*e.args)
70: (4)                 return proc
71: (0)             def _run_input_lines(cmd, input_lines, *, kwargs):
72: (4)                 popen = subprocess.Popen(cmd, stdin=subprocess.PIPE, **kwargs)
73: (4)                 stdin_write = popen.stdin.write
74: (4)                 for line in input_lines:
75: (8)                     stdin_write(line)
76: (4)                 stdout, stderr = popen.communicate()
77: (4)                 return subprocess.CompletedProcess(popen.args, popen.returncode,
78: (39)                                                   stdout=stdout, stderr=stderr)
79: (0)             def _write_stderr(stderr) -> None:
80: (4)                 if isinstance(stderr, bytes):
81: (8)                     stderr_encoding = (getattr(sys.stderr, 'encoding', None)
82: (27)                                       or sys.getdefaultencoding())
83: (8)                     stderr = stderr.decode(stderr_encoding)
84: (4)                 sys.stderr.write(stderr)
85: (4)                 sys.stderr.flush()
86: (4)                 return None
87: (0)             class ExecutableNotFound(RuntimeError):
88: (4)                 """:exc:`RuntimeError` raised if the Graphviz executable is not found."""
89: (4)                 _msg = ('failed to execute {!r}, '
90: (12)                        'make sure the Graphviz executables are on your systems\' PATH')
91: (4)                 def __init__(self, args) -> None:
92: (8)                     super().__init__(self._msg.format(*args))
93: (0)             class CalledProcessError(subprocess.CalledProcessError):
94: (4)                 """:exc:`~subprocess.CalledProcessError` raised if a subprocess ``returncode`` is not ``0``."""  # noqa: E501
95: (4)                 def __str__(self) -> 'str':
96: (8)                     return f'{super().__str__()} [stderr: {self.stderr!r}]'

----------------------------------------

File 20 - viewing.py:

1: (0)              """Open files in platform-specific default viewing application."""
2: (0)              import logging
3: (0)              import os
4: (0)              import platform
5: (0)              import subprocess
6: (0)              import typing
7: (0)              from .. import _tools
8: (0)              __all__ = ['view']
9: (0)              PLATFORM = platform.system().lower()
10: (0)             log = logging.getLogger(__name__)
11: (0)             @_tools.deprecate_positional_args(supported_number=1)
12: (0)             def view(filepath: typing.Union[os.PathLike, str],
13: (9)                      quiet: bool = False) -> None:
14: (4)                 """Open filepath with its default viewing application (platform-specific).
15: (4)                 Args:
16: (8)                     filepath: Path to the file to open in viewer.
17: (8)                     quiet: Suppress ``stderr`` output
18: (12)                        from the viewer process (ineffective on Windows).
19: (4)                 Raises:
20: (8)                     RuntimeError: If the current platform is not supported.
21: (4)                 Note:
22: (8)                     There is no option to wait for the application to close,
23: (8)                     and no way to retrieve the application's exit status.
24: (4)                 """
25: (4)                 try:
26: (8)                     view_func = getattr(view, PLATFORM)
27: (4)                 except AttributeError:
28: (8)                     raise RuntimeError(f'platform {PLATFORM!r} not supported')
29: (4)                 view_func(filepath, quiet=quiet)
30: (0)             @_tools.attach(view, 'darwin')
31: (0)             def view_darwin(filepath: typing.Union[os.PathLike, str], *,
32: (16)                            quiet: bool) -> None:
33: (4)                 """Open filepath with its default application (mac)."""
34: (4)                 cmd = ['open', filepath]
35: (4)                 log.debug('view: %r', cmd)
36: (4)                 kwargs = {'stderr': subprocess.DEVNULL} if quiet else {}
37: (4)                 subprocess.Popen(cmd, **kwargs)
38: (0)             @_tools.attach(view, 'linux')
39: (0)             @_tools.attach(view, 'freebsd')
40: (0)             def view_unixoid(filepath: typing.Union[os.PathLike, str], *,
41: (17)                             quiet: bool) -> None:
42: (4)                 """Open filepath in the user's preferred application (linux, freebsd)."""
43: (4)                 cmd = ['xdg-open', filepath]
44: (4)                 log.debug('view: %r', cmd)
45: (4)                 kwargs = {'stderr': subprocess.DEVNULL} if quiet else {}
46: (4)                 subprocess.Popen(cmd, **kwargs)
47: (0)             @_tools.attach(view, 'windows')
48: (0)             def view_windows(filepath: typing.Union[os.PathLike, str], *,
49: (17)                             quiet: bool) -> None:
50: (4)                 """Start filepath with its associated application (windows)."""
51: (4)                 filepath = os.path.normpath(filepath)
52: (4)                 log.debug('view: %r', filepath)
53: (4)                 os.startfile(filepath)  # pytype: disable=module-attr

----------------------------------------

File 21 - engines.py:

1: (0)              """Rendering engine parameter handling."""
2: (0)              import typing
3: (0)              from . import base
4: (0)              __all__ = ['ENGINES', 'verify_engine', 'Engine']
5: (0)              ENGINES = {'dot',  # https://www.graphviz.org/pdf/dot.1.pdf
6: (11)                        'neato',
7: (11)                        'twopi',
8: (11)                        'circo',
9: (11)                        'fdp',
10: (11)                       'sfdp',
11: (11)                       'patchwork',
12: (11)                       'osage'}
13: (0)             DEFAULT_ENGINE = 'dot'
14: (0)             REQUIRED = True
15: (0)             def verify_engine(engine: str, *, required: bool = REQUIRED) -> None:
16: (4)                 if engine is None:
17: (8)                     if required:
18: (12)                        raise ValueError('missing engine')
19: (4)                 elif engine.lower() not in ENGINES:
20: (8)                     raise ValueError(f'unknown engine: {engine!r}'
21: (25)                                     f' (must be one of {sorted(ENGINES)})')
22: (0)             class Engine(base.ParameterBase):
23: (4)                 """Rendering engine parameter with ``'dot''`` default."""
24: (4)                 _engine = DEFAULT_ENGINE
25: (4)                 _verify_engine = staticmethod(verify_engine)
26: (4)                 def __init__(self, *, engine: typing.Optional[str] = None, **kwargs) -> None:
27: (8)                     super().__init__(**kwargs)
28: (8)                     if engine is not None:
29: (12)                        self.engine = engine
30: (4)                 def _copy_kwargs(self, **kwargs):
31: (8)                     """Return the kwargs to create a copy of the instance."""
32: (8)                     engine = self._getattr_from_dict('_engine')
33: (8)                     if engine is not None:
34: (12)                        kwargs['engine'] = engine
35: (8)                     return super()._copy_kwargs(**kwargs)
36: (4)                 @property
37: (4)                 def engine(self) -> str:
38: (8)                     """The layout engine used for rendering
39: (12)                        (``'dot'``, ``'neato'``, ...)."""
40: (8)                     return self._engine
41: (4)                 @engine.setter
42: (4)                 def engine(self, engine: str) -> None:
43: (8)                     engine = engine.lower()
44: (8)                     self._verify_engine(engine)
45: (8)                     self._engine = engine

----------------------------------------

File 22 - formats.py:

1: (0)              """Rendering format parameter handling."""
2: (0)              import typing
3: (0)              from . import base
4: (0)              __all__ = ['FORMATS', 'verify_format', 'Format']
5: (0)              FORMATS = {'bmp',  # https://graphviz.org/docs/outputs/
6: (11)                        'canon', 'dot', 'gv', 'xdot', 'xdot1.2', 'xdot1.4',
7: (11)                        'cgimage',
8: (11)                        'cmap',
9: (11)                        'eps',
10: (11)                       'exr',
11: (11)                       'fig',
12: (11)                       'gd', 'gd2',
13: (11)                       'gif',
14: (11)                       'gtk',
15: (11)                       'ico',
16: (11)                       'imap', 'cmapx',
17: (11)                       'imap_np', 'cmapx_np',
18: (11)                       'ismap',
19: (11)                       'jp2',
20: (11)                       'jpg', 'jpeg', 'jpe',
21: (11)                       'json', 'json0', 'dot_json', 'xdot_json',  # Graphviz 2.40
22: (11)                       'pct', 'pict',
23: (11)                       'pdf',
24: (11)                       'pic',
25: (11)                       'plain', 'plain-ext',
26: (11)                       'png',
27: (11)                       'pov',
28: (11)                       'ps',
29: (11)                       'ps2',
30: (11)                       'psd',
31: (11)                       'sgi',
32: (11)                       'svg', 'svgz',
33: (11)                       'tga',
34: (11)                       'tif', 'tiff',
35: (11)                       'tk',
36: (11)                       'vml', 'vmlz',
37: (11)                       'vrml',
38: (11)                       'wbmp',
39: (11)                       'webp',
40: (11)                       'xlib', 'x11'}
41: (0)             DEFAULT_FORMAT = 'pdf'
42: (0)             REQUIRED = True
43: (0)             def verify_format(format: str, *, required: bool = REQUIRED) -> None:
44: (4)                 if format is None:
45: (8)                     if required:
46: (12)                        raise ValueError('missing format')
47: (4)                 elif format.lower() not in FORMATS:
48: (8)                     raise ValueError(f'unknown format: {format!r}'
49: (25)                                     f' (must be one of {sorted(FORMATS)})')
50: (0)             class Format(base.ParameterBase):
51: (4)                 """Rendering format parameter with ``'pdf'`` default."""
52: (4)                 _format = DEFAULT_FORMAT
53: (4)                 _verify_format = staticmethod(verify_format)
54: (4)                 def __init__(self, *, format: typing.Optional[str] = None, **kwargs) -> None:
55: (8)                     super().__init__(**kwargs)
56: (8)                     if format is not None:
57: (12)                        self.format = format
58: (4)                 def _copy_kwargs(self, **kwargs):
59: (8)                     """Return the kwargs to create a copy of the instance."""
60: (8)                     format = self._getattr_from_dict('_format')
61: (8)                     if format is not None:
62: (12)                        kwargs['format'] = format
63: (8)                     return super()._copy_kwargs(**kwargs)
64: (4)                 @property
65: (4)                 def format(self) -> str:
66: (8)                     """The output format used for rendering
67: (12)                        (``'pdf'``, ``'png'``, ...)."""
68: (8)                     return self._format
69: (4)                 @format.setter
70: (4)                 def format(self, format: str) -> None:
71: (8)                     format = format.lower()
72: (8)                     self._verify_format(format)
73: (8)                     self._format = format

----------------------------------------

File 23 - __init__.py:

1: (0)              """Execute rendering and unflattening subprocesses, open files in viewer."""
2: (0)              from .dot_command import DOT_BINARY
3: (0)              from .execute import ExecutableNotFound, CalledProcessError
4: (0)              from .mixins import Render, Pipe, Unflatten, View
5: (0)              from .piping import pipe, pipe_string, pipe_lines, pipe_lines_string
6: (0)              from .rendering import render
7: (0)              from .unflattening import UNFLATTEN_BINARY, unflatten
8: (0)              from .upstream_version import version
9: (0)              from .viewing import view
10: (0)             __all__ = ['DOT_BINARY', 'UNFLATTEN_BINARY',
11: (11)                       'render',
12: (11)                       'pipe', 'pipe_string',
13: (11)                       'pipe_lines', 'pipe_lines_string',
14: (11)                       'unflatten',
15: (11)                       'version',
16: (11)                       'view',
17: (11)                       'ExecutableNotFound', 'CalledProcessError',
18: (11)                       'Render', 'Pipe', 'Unflatten', 'View']

----------------------------------------

File 24 - __init__.py:

1: (0)              """Hold and verify parameters for running Graphviz ``dot``."""
2: (0)              from .engines import ENGINES, verify_engine
3: (0)              from .formats import FORMATS, verify_format
4: (0)              from .renderers import RENDERERS, verify_renderer
5: (0)              from .formatters import FORMATTERS, verify_formatter
6: (0)              from . mixins import Parameters
7: (0)              __all__ = ['ENGINES', 'FORMATS', 'RENDERERS', 'FORMATTERS',
8: (11)                        'verify_engine', 'verify_format',
9: (11)                        'verify_renderer', 'verify_formatter',
10: (11)                       'Parameters']

----------------------------------------

File 25 - rendering.py:

1: (0)              """Save DOT code objects, render with Graphviz ``dot``, and open in viewer."""
2: (0)              import logging
3: (0)              import os
4: (0)              import pathlib
5: (0)              import typing
6: (0)              from . import _tools
7: (0)              from . import backend
8: (0)              from . import saving
9: (0)              __all__ = ['Render']
10: (0)             log = logging.getLogger(__name__)
11: (0)             class Render(saving.Save, backend.Render, backend.View):
12: (4)                 """Write source lines to file and render with Graphviz."""
13: (4)                 @_tools.deprecate_positional_args(supported_number=2)
14: (4)                 def render(self,
15: (15)                           filename: typing.Union[os.PathLike, str, None] = None,
16: (15)                           directory: typing.Union[os.PathLike, str, None] = None,
17: (15)                           view: bool = False,
18: (15)                           cleanup: bool = False,
19: (15)                           format: typing.Optional[str] = None,
20: (15)                           renderer: typing.Optional[str] = None,
21: (15)                           formatter: typing.Optional[str] = None,
22: (15)                           neato_no_op: typing.Union[bool, int, None] = None,
23: (15)                           quiet: bool = False,
24: (15)                           quiet_view: bool = False, *,
25: (15)                           outfile: typing.Union[os.PathLike, str, None] = None,
26: (15)                           engine: typing.Optional[str] = None,
27: (15)                           raise_if_result_exists: bool = False,
28: (15)                           overwrite_source: bool = False) -> str:
29: (8)                     r"""Save the source to file and render with the Graphviz engine.
30: (8)                     Args:
31: (12)                        filename: Filename for saving the source
32: (16)                            (defaults to ``name`` + ``'.gv'``).s
33: (12)                        directory: (Sub)directory for source saving and rendering.
34: (12)                        view (bool): Open the rendered result
35: (16)                            with the default application.
36: (12)                        cleanup (bool): Delete the source file
37: (16)                            after successful rendering.
38: (12)                        format: The output format used for rendering
39: (16)                            (``'pdf'``, ``'png'``, etc.).
40: (12)                        renderer: The output renderer used for rendering
41: (16)                            (``'cairo'``, ``'gd'``, ...).
42: (12)                        formatter: The output formatter used for rendering
43: (16)                            (``'cairo'``, ``'gd'``, ...).
44: (12)                        neato_no_op: Neato layout engine no-op flag.
45: (12)                        quiet (bool): Suppress ``stderr`` output
46: (16)                            from the layout subprocess.
47: (12)                        quiet_view (bool): Suppress ``stderr`` output
48: (16)                            from the viewer process
49: (16)                            (implies ``view=True``, ineffective on Windows platform).
50: (12)                        outfile: Path for the rendered output file.
51: (12)                        engine: Layout engine for rendering
52: (16)                            (``'dot'``, ``'neato'``, ...).
53: (12)                        raise_if_result_exists: Raise :exc:`graphviz.FileExistsError`
54: (16)                            if the result file exists.
55: (12)                        overwrite_source: Allow ``dot`` to write to the file it reads from.
56: (16)                            Incompatible with ``raise_if_result_exists``.
57: (8)                     Returns:
58: (12)                        The (possibly relative) path of the rendered file.
59: (8)                     Raises:
60: (12)                        ValueError: If ``engine``, ``format``, ``renderer``, or ``formatter``
61: (16)                            are unknown.
62: (12)                        graphviz.RequiredArgumentError: If ``formatter`` is given
63: (16)                            but ``renderer`` is None.
64: (12)                        ValueError: If ``outfile`` is the same file as the source file
65: (16)                            unless ``overwite_source=True``.
66: (12)                        graphviz.ExecutableNotFound: If the Graphviz ``dot`` executable
67: (16)                            is not found.
68: (12)                        graphviz.CalledProcessError: If the returncode (exit status)
69: (16)                            of the rendering ``dot`` subprocess is non-zero.
70: (12)                        RuntimeError: If viewer opening is requested but not supported.
71: (8)                     Example:
72: (12)                        >>> doctest_mark_exe()
73: (12)                        >>> import graphviz
74: (12)                        >>> dot = graphviz.Graph(name='spam', directory='doctest-output')
75: (12)                        >>> dot.render(format='png').replace('\\', '/')
76: (12)                        'doctest-output/spam.gv.png'
77: (12)                        >>> dot.render(outfile='spam.svg').replace('\\', '/')
78: (12)                        'doctest-output/spam.svg'
79: (8)                     Note:
80: (12)                        The layout command is started from the directory of ``filepath``,
81: (12)                        so that references to external files
82: (12)                        (e.g. ``[image=images/camelot.png]``)
83: (12)                        can be given as paths relative to the DOT source file.
84: (8)                     """
85: (8)                     outfile = _tools.promote_pathlike(outfile)
86: (8)                     if outfile is not None:
87: (12)                        format = self._get_format(outfile, format=format)
88: (12)                        if directory is None:
89: (16)                            outfile = pathlib.Path(self.directory, outfile)
90: (8)                     args, kwargs = self._get_render_parameters(engine=engine,
91: (51)                                                               format=format,
92: (51)                                                               renderer=renderer,
93: (51)                                                               formatter=formatter,
94: (51)                                                               neato_no_op=neato_no_op,
95: (51)                                                               quiet=quiet,
96: (51)                                                               outfile=outfile,
97: (51)                                                               raise_if_result_exists=raise_if_result_exists,
98: (51)                                                               overwrite_source=overwrite_source,
99: (51)                                                               verify=True)
100: (8)                    if outfile is not None and filename is None:
101: (12)                       filename = self._get_filepath(outfile)
102: (8)                    filepath = self.save(filename, directory=directory, skip_existing=None)
103: (8)                    args.append(filepath)
104: (8)                    rendered = self._render(*args, **kwargs)
105: (8)                    if cleanup:
106: (12)                       log.debug('delete %r', filepath)
107: (12)                       os.remove(filepath)
108: (8)                    if quiet_view or view:
109: (12)                       self._view(rendered, format=self._format, quiet=quiet_view)
110: (8)                    return rendered
111: (4)                def _view(self, filepath: typing.Union[os.PathLike, str], *,
112: (14)                         format: str, quiet: bool) -> None:
113: (8)                    """Start the right viewer based on file format and platform."""
114: (8)                    methodnames = [
115: (12)                       f'_view_{format}_{backend.viewing.PLATFORM}',
116: (12)                       f'_view_{backend.viewing.PLATFORM}',
117: (8)                    ]
118: (8)                    for name in methodnames:
119: (12)                       view_method = getattr(self, name, None)
120: (12)                       if view_method is not None:
121: (16)                           break
122: (8)                    else:
123: (12)                       raise RuntimeError(f'{self.__class__!r} has no built-in viewer'
124: (31)                                          f' support for {format!r}'
125: (31)                                          f' on {backend.viewing.PLATFORM!r} platform')
126: (8)                    view_method(filepath, quiet=quiet)
127: (4)                @_tools.deprecate_positional_args(supported_number=2)
128: (4)                def view(self,
129: (13)                        filename: typing.Union[os.PathLike, str, None] = None,
130: (13)                        directory: typing.Union[os.PathLike, str, None] = None,
131: (13)                        cleanup: bool = False,
132: (13)                        quiet: bool = False,
133: (13)                        quiet_view: bool = False) -> str:
134: (8)                    """Save the source to file, open the rendered result in a viewer.
135: (8)                    Convenience short-cut for running ``.render(view=True)``.
136: (8)                    Args:
137: (12)                       filename: Filename for saving the source
138: (16)                           (defaults to ``name`` + ``'.gv'``).
139: (12)                       directory: (Sub)directory for source saving and rendering.
140: (12)                       cleanup (bool): Delete the source file after successful rendering.
141: (12)                       quiet (bool): Suppress ``stderr`` output from the layout subprocess.
142: (12)                       quiet_view (bool): Suppress ``stderr`` output
143: (16)                           from the viewer process (ineffective on Windows).
144: (8)                    Returns:
145: (12)                       The (possibly relative) path of the rendered file.
146: (8)                    Raises:
147: (12)                       graphviz.ExecutableNotFound: If the Graphviz executable
148: (16)                           is not found.
149: (12)                       graphviz.CalledProcessError: If the exit status is non-zero.
150: (12)                       RuntimeError: If opening the viewer is not supported.
151: (8)                    Short-cut method for calling :meth:`.render` with ``view=True``.
152: (8)                    Note:
153: (12)                       There is no option to wait for the application to close,
154: (12)                       and no way to retrieve the application's exit status.
155: (8)                    """
156: (8)                    return self.render(filename=filename, directory=directory, view=True,
157: (27)                                      cleanup=cleanup, quiet=quiet, quiet_view=quiet_view)

----------------------------------------

File 26 - rendering.py:

1: (0)              """Render DOT source files with Graphviz ``dot``."""
2: (0)              import os
3: (0)              import pathlib
4: (0)              import typing
5: (0)              import warnings
6: (0)              from .._defaults import DEFAULT_SOURCE_EXTENSION
7: (0)              from .. import _tools
8: (0)              from .. import exceptions
9: (0)              from .. import parameters
10: (0)             from . import dot_command
11: (0)             from . import execute
12: (0)             __all__ = ['get_format', 'get_filepath', 'render']
13: (0)             def get_format(outfile: pathlib.Path, *, format: typing.Optional[str]) -> str:
14: (4)                 """Return format inferred from outfile suffix and/or given ``format``.
15: (4)                 Args:
16: (8)                     outfile: Path for the rendered output file.
17: (8)                     format: Output format for rendering (``'pdf'``, ``'png'``, ...).
18: (4)                 Returns:
19: (8)                     The given ``format`` falling back to the inferred format.
20: (4)                 Warns:
21: (8)                     graphviz.UnknownSuffixWarning: If the suffix of ``outfile``
22: (12)                        is empty/unknown.
23: (8)                     graphviz.FormatSuffixMismatchWarning: If the suffix of ``outfile``
24: (12)                        does not match the given ``format``.
25: (4)                 """
26: (4)                 try:
27: (8)                     inferred_format = infer_format(outfile)
28: (4)                 except ValueError:
29: (8)                     if format is None:
30: (12)                        msg = ('cannot infer rendering format'
31: (19)                               f' from suffix {outfile.suffix!r}'
32: (19)                               f' of outfile: {os.fspath(outfile)!r}'
33: (19)                               ' (provide format or outfile with a suffix'
34: (19)                               f' from {get_supported_suffixes()!r})')
35: (12)                        raise exceptions.RequiredArgumentError(msg)
36: (8)                     warnings.warn(f'unknown outfile suffix {outfile.suffix!r}'
37: (22)                                  f' (expected: {"." + format!r})',
38: (22)                                  category=exceptions.UnknownSuffixWarning)
39: (8)                     return format
40: (4)                 else:
41: (8)                     assert inferred_format is not None
42: (8)                     if format is not None and format.lower() != inferred_format:
43: (12)                        warnings.warn(f'expected format {inferred_format!r} from outfile'
44: (26)                                      f' differs from given format: {format!r}',
45: (26)                                      category=exceptions.FormatSuffixMismatchWarning)
46: (12)                        return format
47: (8)                     return inferred_format
48: (0)             def get_supported_suffixes() -> typing.List[str]:
49: (4)                 """Return a sorted list of supported outfile suffixes for exception/warning messages.
50: (4)                 >>> get_supported_suffixes()  # doctest: +ELLIPSIS
51: (4)                 ['.bmp', ...]
52: (4)                 """
53: (4)                 return [f'.{format}' for format in get_supported_formats()]
54: (0)             def get_supported_formats() -> typing.List[str]:
55: (4)                 """Return a sorted list of supported formats for exception/warning messages.
56: (4)                 >>> get_supported_formats()  # doctest: +ELLIPSIS
57: (4)                 ['bmp', ...]
58: (4)                 """
59: (4)                 return sorted(parameters.FORMATS)
60: (0)             def infer_format(outfile: pathlib.Path) -> str:
61: (4)                 """Return format inferred from outfile suffix.
62: (4)                 Args:
63: (8)                     outfile: Path for the rendered output file.
64: (4)                 Returns:
65: (8)                     The inferred format.
66: (4)                 Raises:
67: (8)                     ValueError: If the suffix of ``outfile`` is empty/unknown.
68: (4)                 >>> infer_format(pathlib.Path('spam.pdf'))  # doctest: +NO_EXE
69: (4)                 'pdf'
70: (4)                 >>> infer_format(pathlib.Path('spam.gv.svg'))
71: (4)                 'svg'
72: (4)                 >>> infer_format(pathlib.Path('spam.PNG'))
73: (4)                 'png'
74: (4)                 >>> infer_format(pathlib.Path('spam'))
75: (4)                 Traceback (most recent call last):
76: (8)                     ...
77: (4)                 ValueError: cannot infer rendering format from outfile: 'spam' (missing suffix)
78: (4)                 >>> infer_format(pathlib.Path('spam.wav'))  # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
79: (4)                 Traceback (most recent call last):
80: (8)                     ...
81: (4)                 ValueError: cannot infer rendering format from suffix '.wav' of outfile: 'spam.wav'
82: (4)                 (unknown format: 'wav', provide outfile with a suffix from ['.bmp', ...])
83: (4)                 """
84: (4)                 if not outfile.suffix:
85: (8)                     raise ValueError('cannot infer rendering format from outfile:'
86: (25)                                     f' {os.fspath(outfile)!r} (missing suffix)')
87: (4)                 start, sep, format_ = outfile.suffix.partition('.')
88: (4)                 assert sep and not start, f"{outfile.suffix!r}.startswith('.')"
89: (4)                 format_ = format_.lower()
90: (4)                 try:
91: (8)                     parameters.verify_format(format_)
92: (4)                 except ValueError:
93: (8)                     raise ValueError('cannot infer rendering format'
94: (25)                                     f' from suffix {outfile.suffix!r}'
95: (25)                                     f' of outfile: {os.fspath(outfile)!r}'
96: (25)                                     f' (unknown format: {format_!r},'
97: (25)                                     ' provide outfile with a suffix'
98: (25)                                     f' from {get_supported_suffixes()!r})')
99: (4)                 return format_
100: (0)            def get_outfile(filepath: typing.Union[os.PathLike, str], *,
101: (16)                           format: str,
102: (16)                           renderer: typing.Optional[str] = None,
103: (16)                           formatter: typing.Optional[str] = None) -> pathlib.Path:
104: (4)                """Return ``filepath`` + ``[[.formatter].renderer].format``.
105: (4)                See also:
106: (8)                    https://www.graphviz.org/doc/info/command.html#-O
107: (4)                """
108: (4)                filepath = _tools.promote_pathlike(filepath)
109: (4)                parameters.verify_format(format, required=True)
110: (4)                parameters.verify_renderer(renderer, required=False)
111: (4)                parameters.verify_formatter(formatter, required=False)
112: (4)                suffix_args = (formatter, renderer, format)
113: (4)                suffix = '.'.join(a for a in suffix_args if a is not None)
114: (4)                return filepath.with_suffix(f'{filepath.suffix}.{suffix}')
115: (0)            def get_filepath(outfile: typing.Union[os.PathLike, str]) -> pathlib.Path:
116: (4)                """Return ``outfile.with_suffix('.gv')``."""
117: (4)                outfile = _tools.promote_pathlike(outfile)
118: (4)                return outfile.with_suffix(f'.{DEFAULT_SOURCE_EXTENSION}')
119: (0)            @typing.overload
120: (0)            def render(engine: str,
121: (11)                      format: str,
122: (11)                      filepath: typing.Union[os.PathLike, str],
123: (11)                      renderer: typing.Optional[str] = ...,
124: (11)                      formatter: typing.Optional[str] = ...,
125: (11)                      neato_no_op: typing.Union[bool, int, None] = ...,
126: (11)                      quiet: bool = ..., *,
127: (11)                      outfile: typing.Union[os.PathLike, str, None] = ...,
128: (11)                      raise_if_result_exists: bool = ...,
129: (11)                      overwrite_filepath: bool = ...) -> str:
130: (4)                """Require ``format`` and ``filepath`` with default ``outfile=None``."""
131: (0)            @typing.overload
132: (0)            def render(engine: str,
133: (11)                      format: typing.Optional[str] = ...,
134: (11)                      filepath: typing.Union[os.PathLike, str, None] = ...,
135: (11)                      renderer: typing.Optional[str] = ...,
136: (11)                      formatter: typing.Optional[str] = ...,
137: (11)                      neato_no_op: typing.Union[bool, int, None] = ...,
138: (11)                      quiet: bool = False, *,
139: (11)                      outfile: typing.Union[os.PathLike, str, None] = ...,
140: (11)                      raise_if_result_exists: bool = ...,
141: (11)                      overwrite_filepath: bool = ...) -> str:
142: (4)                """Optional ``format`` and ``filepath`` with given ``outfile``."""
143: (0)            @typing.overload
144: (0)            def render(engine: str,
145: (11)                      format: typing.Optional[str] = ...,
146: (11)                      filepath: typing.Union[os.PathLike, str, None] = ...,
147: (11)                      renderer: typing.Optional[str] = ...,
148: (11)                      formatter: typing.Optional[str] = ...,
149: (11)                      neato_no_op: typing.Union[bool, int, None] = ...,
150: (11)                      quiet: bool = False, *,
151: (11)                      outfile: typing.Union[os.PathLike, str, None] = ...,
152: (11)                      raise_if_result_exists: bool = ...,
153: (11)                      overwrite_filepath: bool = ...) -> str:
154: (4)                """Required/optional ``format`` and ``filepath`` depending on ``outfile``."""
155: (0)            @_tools.deprecate_positional_args(supported_number=3)
156: (0)            def render(engine: str,
157: (11)                      format: typing.Optional[str] = None,
158: (11)                      filepath: typing.Union[os.PathLike, str, None] = None,
159: (11)                      renderer: typing.Optional[str] = None,
160: (11)                      formatter: typing.Optional[str] = None,
161: (11)                      neato_no_op: typing.Union[bool, int, None] = None,
162: (11)                      quiet: bool = False, *,
163: (11)                      outfile: typing.Union[os.PathLike, str, None] = None,
164: (11)                      raise_if_result_exists: bool = False,
165: (11)                      overwrite_filepath: bool = False) -> str:
166: (4)                r"""Render file with ``engine`` into ``format`` and return result filename.
167: (4)                Args:
168: (8)                    engine: Layout engine for rendering (``'dot'``, ``'neato'``, ...).
169: (8)                    format: Output format for rendering (``'pdf'``, ``'png'``, ...).
170: (12)                       Can be omitted if an ``outfile`` with a known ``format`` is given,
171: (12)                       i.e. if ``outfile`` ends  with a known ``.{format}`` suffix.
172: (8)                    filepath: Path to the DOT source file to render.
173: (12)                       Can be omitted if ``outfile`` is given,
174: (12)                       in which case it defaults to ``outfile.with_suffix('.gv')``.
175: (8)                    renderer: Output renderer (``'cairo'``, ``'gd'``, ...).
176: (8)                    formatter: Output formatter (``'cairo'``, ``'gd'``, ...).
177: (8)                    neato_no_op: Neato layout engine no-op flag.
178: (8)                    quiet: Suppress ``stderr`` output from the layout subprocess.
179: (8)                    outfile: Path for the rendered output file.
180: (8)                    raise_if_result_exists: Raise :exc:`graphviz.FileExistsError`
181: (12)                       if the result file exists.
182: (8)                    overwrite_filepath: Allow ``dot`` to write to the file it reads from.
183: (12)                       Incompatible with ``raise_if_result_exists``.
184: (4)                Returns:
185: (8)                    The (possibly relative) path of the rendered file.
186: (4)                Raises:
187: (8)                    ValueError: If ``engine``, ``format``, ``renderer``, or ``formatter``
188: (12)                       are unknown.
189: (8)                    graphviz.RequiredArgumentError: If ``format`` or ``filepath`` are None
190: (12)                       unless ``outfile`` is given.
191: (8)                    graphviz.RequiredArgumentError: If ``formatter`` is given
192: (12)                       but ``renderer`` is None.
193: (8)                    ValueError: If ``outfile`` and ``filename`` are the same file
194: (12)                       unless ``overwite_filepath=True``.
195: (8)                    graphviz.ExecutableNotFound: If the Graphviz ``dot`` executable
196: (12)                       is not found.
197: (8)                    graphviz.CalledProcessError: If the returncode (exit status)
198: (12)                       of the rendering ``dot`` subprocess is non-zero.
199: (8)                    graphviz.FileExistsError: If ``raise_if_exists``
200: (12)                       and the result file exists.
201: (4)                Warns:
202: (8)                    graphviz.UnknownSuffixWarning: If the suffix of ``outfile``
203: (12)                       is empty or unknown.
204: (8)                    graphviz.FormatSuffixMismatchWarning: If the suffix of ``outfile``
205: (12)                       does not match the given ``format``.
206: (4)                Example:
207: (8)                    >>> doctest_mark_exe()
208: (8)                    >>> import pathlib
209: (8)                    >>> import graphviz
210: (8)                    >>> assert pathlib.Path('doctest-output/spam.gv').write_text('graph { spam }') == 14
211: (8)                    >>> graphviz.render('dot', 'png', 'doctest-output/spam.gv').replace('\\', '/')
212: (8)                    'doctest-output/spam.gv.png'
213: (8)                    >>> graphviz.render('dot', filepath='doctest-output/spam.gv',
214: (8)                    ...                 outfile='doctest-output/spam.png').replace('\\', '/')
215: (8)                    'doctest-output/spam.png'
216: (8)                    >>> graphviz.render('dot', outfile='doctest-output/spam.pdf').replace('\\', '/')
217: (8)                    'doctest-output/spam.pdf'
218: (4)                Note:
219: (8)                    The layout command is started from the directory of ``filepath``,
220: (8)                    so that references to external files
221: (8)                    (e.g. ``[image=images/camelot.png]``)
222: (8)                    can be given as paths relative to the DOT source file.
223: (4)                See also:
224: (8)                    Upstream docs: https://www.graphviz.org/doc/info/command.html
225: (4)                """
226: (4)                if raise_if_result_exists and overwrite_filepath:
227: (8)                    raise ValueError('overwrite_filepath cannot be combined'
228: (25)                                    ' with raise_if_result_exists')
229: (4)                filepath, outfile = map(_tools.promote_pathlike, (filepath, outfile))
230: (4)                if outfile is not None:
231: (8)                    format = get_format(outfile, format=format)
232: (8)                    if filepath is None:
233: (12)                       filepath = get_filepath(outfile)
234: (8)                    if (not overwrite_filepath and outfile.name == filepath.name
235: (12)                       and outfile.resolve() == filepath.resolve()):  # noqa: E129
236: (12)                       raise ValueError(f'outfile {outfile.name!r} must be different'
237: (29)                                        f' from input file {filepath.name!r}'
238: (29)                                        ' (pass overwrite_filepath=True to override)')
239: (8)                    outfile_arg = (outfile.resolve() if outfile.parent != filepath.parent
240: (23)                                  else outfile.name)
241: (8)                    args = ['-o', outfile_arg, filepath.name]
242: (4)                elif filepath is None:
243: (8)                    raise exceptions.RequiredArgumentError('filepath: (required if outfile is not given,'
244: (47)                                                          f' got {filepath!r})')
245: (4)                elif format is None:
246: (8)                    raise exceptions.RequiredArgumentError('format: (required if outfile is not given,'
247: (47)                                                          f' got {format!r})')
248: (4)                else:
249: (8)                    outfile = get_outfile(filepath,
250: (30)                                         format=format,
251: (30)                                         renderer=renderer,
252: (30)                                         formatter=formatter)
253: (8)                    args = ['-O', filepath.name]
254: (4)                cmd = dot_command.command(engine, format,
255: (30)                                         renderer=renderer,
256: (30)                                         formatter=formatter,
257: (30)                                         neato_no_op=neato_no_op)
258: (4)                if raise_if_result_exists and os.path.exists(outfile):
259: (8)                    raise exceptions.FileExistsError(f'output file exists: {os.fspath(outfile)!r}')
260: (4)                cmd += args
261: (4)                assert filepath is not None, 'work around pytype false alarm'
262: (4)                execute.run_check(cmd,
263: (22)                                 cwd=filepath.parent if filepath.parent.parts else None,
264: (22)                                 quiet=quiet,
265: (22)                                 capture_output=True)
266: (4)                return os.fspath(outfile)

----------------------------------------

File 27 - renderers.py:

1: (0)              """Rendering renderer parameter handling."""
2: (0)              import typing
3: (0)              from . import base
4: (0)              __all__ = ['RENDERERS', 'verify_renderer', 'Renderer']
5: (0)              RENDERERS = {'cairo',  # $ dot -T:
6: (13)                          'dot',
7: (13)                          'fig',
8: (13)                          'gd',
9: (13)                          'gdiplus',
10: (13)                         'map',
11: (13)                         'pic',
12: (13)                         'pov',
13: (13)                         'ps',
14: (13)                         'svg',
15: (13)                         'tk',
16: (13)                         'vml',
17: (13)                         'vrml',
18: (13)                         'xdot'}
19: (0)             REQUIRED = False
20: (0)             def verify_renderer(renderer: typing.Optional[str], *,
21: (20)                                required: bool = REQUIRED) -> None:
22: (4)                 if renderer is None:
23: (8)                     if required:
24: (12)                        raise ValueError('missing renderer')
25: (4)                 elif renderer.lower() not in RENDERERS:
26: (8)                     raise ValueError(f'unknown renderer: {renderer!r}'
27: (25)                                     f' (must be None or one of {sorted(RENDERERS)})')
28: (0)             class Renderer(base.ParameterBase):
29: (4)                 """Rendering renderer parameter (no default)."""
30: (4)                 _renderer = None
31: (4)                 _verify_renderer = staticmethod(verify_renderer)
32: (4)                 def __init__(self, *, renderer: typing.Optional[str] = None, **kwargs) -> None:
33: (8)                     super().__init__(**kwargs)
34: (8)                     self.renderer = renderer
35: (4)                 def _copy_kwargs(self, **kwargs):
36: (8)                     """Return the kwargs to create a copy of the instance."""
37: (8)                     renderer = self._getattr_from_dict('_renderer')
38: (8)                     if renderer is not None:
39: (12)                        kwargs['renderer'] = renderer
40: (8)                     return super()._copy_kwargs(**kwargs)
41: (4)                 @property
42: (4)                 def renderer(self) -> typing.Optional[str]:
43: (8)                     """The output renderer used for rendering
44: (12)                        (``'cairo'``, ``'gd'``, ...)."""
45: (8)                     return self._renderer
46: (4)                 @renderer.setter
47: (4)                 def renderer(self, renderer: typing.Optional[str]) -> None:
48: (8)                     if renderer is None:
49: (12)                        self.__dict__.pop('_renderer', None)
50: (8)                     else:
51: (12)                        renderer = renderer.lower()
52: (12)                        self._verify_renderer(renderer)
53: (12)                        self._renderer = renderer

----------------------------------------

File 28 - formatters.py:

1: (0)              """Rendering formatter parameter handling."""
2: (0)              import typing
3: (0)              from . import base
4: (0)              __all__ = ['FORMATTERS', 'verify_formatter', 'Formatter']
5: (0)              FORMATTERS = {'cairo',
6: (14)                           'core',
7: (14)                           'gd',
8: (14)                           'gdiplus',
9: (14)                           'gdwbmp',
10: (14)                          'xlib'}
11: (0)             REQUIRED = False
12: (0)             def verify_formatter(formatter: typing.Optional[str], *,
13: (21)                                 required: bool = REQUIRED) -> None:
14: (4)                 if formatter is None:
15: (8)                     if required:
16: (12)                        raise ValueError('missing formatter')
17: (4)                 elif formatter.lower() not in FORMATTERS:
18: (8)                     raise ValueError(f'unknown formatter: {formatter!r}'
19: (25)                                     f' (must be None or one of {sorted(FORMATTERS)})')
20: (0)             class Formatter(base.ParameterBase):
21: (4)                 """Rendering engine parameter (no default)."""
22: (4)                 _formatter = None
23: (4)                 _verify_formatter = staticmethod(verify_formatter)
24: (4)                 def __init__(self, *, formatter: typing.Optional[str] = None, **kwargs) -> None:
25: (8)                     super().__init__(**kwargs)
26: (8)                     self.formatter = formatter
27: (4)                 def _copy_kwargs(self, **kwargs):
28: (8)                     """Return the kwargs to create a copy of the instance."""
29: (8)                     formatter = self._getattr_from_dict('_formatter')
30: (8)                     if formatter is not None:
31: (12)                        kwargs['formatter'] = formatter
32: (8)                     return super()._copy_kwargs(**kwargs)
33: (4)                 @property
34: (4)                 def formatter(self) -> typing.Optional[str]:
35: (8)                     """The output formatter used for rendering
36: (12)                        (``'cairo'``, ``'gd'``, ...)."""
37: (8)                     return self._formatter
38: (4)                 @formatter.setter
39: (4)                 def formatter(self, formatter: typing.Optional[str]) -> None:
40: (8)                     if formatter is None:
41: (12)                        self.__dict__.pop('_formatter', None)
42: (8)                     else:
43: (12)                        formatter = formatter.lower()
44: (12)                        self._verify_formatter(formatter)
45: (12)                        self._formatter = formatter

----------------------------------------

File 29 - dot_command.py:

1: (0)              """Check and assemble commands for running Graphviz ``dot``."""
2: (0)              import os
3: (0)              import pathlib
4: (0)              import typing
5: (0)              from .. import exceptions
6: (0)              from .. import parameters
7: (0)              __all__ = ['DOT_BINARY', 'command']
8: (0)              DOT_BINARY = pathlib.Path('dot')
9: (0)              def command(engine: str, format_: str, *,
10: (12)                        renderer: typing.Optional[str] = None,
11: (12)                        formatter: typing.Optional[str] = None,
12: (12)                        neato_no_op: typing.Union[bool, int, None] = None
13: (12)                        ) -> typing.List[typing.Union[os.PathLike, str]]:
14: (4)                 """Return ``subprocess.Popen`` argument list for rendering.
15: (4)                 See also:
16: (8)                     Upstream documentation:
17: (8)                     - https://www.graphviz.org/doc/info/command.html#-K
18: (8)                     - https://www.graphviz.org/doc/info/command.html#-T
19: (8)                     - https://www.graphviz.org/doc/info/command.html#-n
20: (4)                 """
21: (4)                 if formatter is not None and renderer is None:
22: (8)                     raise exceptions.RequiredArgumentError('formatter given without renderer')
23: (4)                 parameters.verify_engine(engine, required=True)
24: (4)                 parameters.verify_format(format_, required=True)
25: (4)                 parameters.verify_renderer(renderer, required=False)
26: (4)                 parameters.verify_formatter(formatter, required=False)
27: (4)                 output_format = [f for f in (format_, renderer, formatter) if f is not None]
28: (4)                 output_format_flag = ':'.join(output_format)
29: (4)                 cmd = [DOT_BINARY, f'-K{engine}', f'-T{output_format_flag}']
30: (4)                 if neato_no_op:
31: (8)                     cmd.append(f'-n{neato_no_op:d}')
32: (4)                 return cmd

----------------------------------------

File 30 - unflattening.py:

1: (0)              """Pipe source through the Graphviz *unflatten* preprocessor."""
2: (0)              import typing
3: (0)              import graphviz
4: (0)              from . import _tools
5: (0)              from . import base
6: (0)              from . import backend
7: (0)              from . import encoding
8: (0)              __all__ = ['Unflatten']
9: (0)              class Unflatten(encoding.Encoding, base.Base, backend.Unflatten):
10: (4)                 """Pipe source through the Graphviz *unflatten* preprocessor."""
11: (4)                 @_tools.deprecate_positional_args(supported_number=1)
12: (4)                 def unflatten(self,
13: (18)                              stagger: typing.Optional[int] = None,
14: (18)                              fanout: bool = False,
15: (18)                              chain: typing.Optional[int] = None) -> 'graphviz.Source':
16: (8)                     """Return a new :class:`.Source` instance with the source
17: (12)                        piped through the Graphviz *unflatten* preprocessor.
18: (8)                     Args:
19: (12)                        stagger: Stagger the minimum length
20: (16)                            of leaf edges between 1 and this small integer.
21: (12)                        fanout: Fanout nodes with indegree = outdegree = 1
22: (16)                            when staggering (requires ``stagger``).
23: (12)                        chain: Form disconnected nodes into chains
24: (16)                            of up to this many nodes.
25: (8)                     Returns:
26: (12)                        Prepocessed DOT source code (improved layout aspect ratio).
27: (8)                     Raises:
28: (12)                        graphviz.RequiredArgumentError: If ``fanout`` is given
29: (16)                            but ``stagger`` is None.
30: (12)                        graphviz.ExecutableNotFound: If the Graphviz ``unflatten`` executable
31: (16)                            is not found.
32: (12)                        graphviz.CalledProcessError: If the returncode (exit status)
33: (16)                            of the unflattening 'unflatten' subprocess is non-zero.
34: (8)                     See also:
35: (12)                        Upstream documentation:
36: (12)                        https://www.graphviz.org/pdf/unflatten.1.pdf
37: (8)                     """
38: (8)                     from . import sources
39: (8)                     out = self._unflatten(self.source,
40: (30)                                          stagger=stagger, fanout=fanout, chain=chain,
41: (30)                                          encoding=self.encoding)
42: (8)                     kwargs = self._copy_kwargs()
43: (8)                     return sources.Source(out,
44: (30)                                          filename=kwargs.get('filename'),
45: (30)                                          directory=kwargs.get('directory'),
46: (30)                                          format=kwargs.get('format'),
47: (30)                                          engine=kwargs.get('engine'),
48: (30)                                          encoding=kwargs.get('encoding'),
49: (30)                                          renderer=kwargs.get('renderer'),
50: (30)                                          formatter=kwargs.get('formatter'),
51: (30)                                          loaded_from_path=None)

----------------------------------------

File 31 - unflattening.py:

1: (0)              """Pipe DOT source code through ``unflatten``."""
2: (0)              import pathlib
3: (0)              import typing
4: (0)              from ..encoding import DEFAULT_ENCODING
5: (0)              from .. import _tools
6: (0)              from .. import exceptions
7: (0)              from . import execute
8: (0)              __all__ = ['UNFLATTEN_BINARY', 'unflatten']
9: (0)              UNFLATTEN_BINARY = pathlib.Path('unflatten')
10: (0)             @_tools.deprecate_positional_args(supported_number=1)
11: (0)             def unflatten(source: str,
12: (14)                          stagger: typing.Optional[int] = None,
13: (14)                          fanout: bool = False,
14: (14)                          chain: typing.Optional[int] = None,
15: (14)                          encoding: str = DEFAULT_ENCODING) -> str:
16: (4)                 """Return DOT ``source`` piped through ``unflatten`` preprocessor as string.
17: (4)                 Args:
18: (8)                     source: DOT source to process
19: (12)                        (improve layout aspect ratio).
20: (8)                     stagger: Stagger the minimum length of leaf edges
21: (12)                        between 1 and this small integer.
22: (8)                     fanout: Fanout nodes with indegree = outdegree = 1
23: (12)                        when staggering (requires ``stagger``).
24: (8)                     chain: Form disconnected nodes into chains of up to this many nodes.
25: (8)                     encoding: Encoding to encode unflatten stdin and decode its stdout.
26: (4)                 Returns:
27: (8)                     Decoded stdout of the Graphviz unflatten command.
28: (4)                 Raises:
29: (8)                     graphviz.RequiredArgumentError: If ``fanout`` is given
30: (12)                        but no ``stagger``.
31: (8)                     graphviz.ExecutableNotFound: If the Graphviz 'unflatten' executable
32: (12)                        is not found.
33: (8)                     graphviz.CalledProcessError: If the returncode (exit status)
34: (12)                        of the unflattening 'unflatten' subprocess is non-zero.
35: (4)                 See also:
36: (8)                     Upstream documentation:
37: (8)                     https://www.graphviz.org/pdf/unflatten.1.pdf
38: (4)                 """
39: (4)                 if fanout and stagger is None:
40: (8)                     raise exceptions.RequiredArgumentError('fanout given without stagger')
41: (4)                 cmd = [UNFLATTEN_BINARY]
42: (4)                 if stagger is not None:
43: (8)                     cmd += ['-l', str(stagger)]
44: (4)                 if fanout:
45: (8)                     cmd.append('-f')
46: (4)                 if chain is not None:
47: (8)                     cmd += ['-c', str(chain)]
48: (4)                 proc = execute.run_check(cmd, input=source, encoding=encoding,
49: (29)                                         capture_output=True)
50: (4)                 return proc.stdout

----------------------------------------

File 32 - upstream_version.py:

1: (0)              """Return the version number from running ``dot -V``."""
2: (0)              import logging
3: (0)              import re
4: (0)              import subprocess
5: (0)              import typing
6: (0)              from . import dot_command
7: (0)              from . import execute
8: (0)              VERSION_PATTERN = re.compile(r'''
9: (29)                                          graphviz[ ]
10: (29)                                         version[ ]
11: (29)                                         (\d+)\.(\d+)
12: (29)                                         (?:\.(\d+)
13: (31)                                           (?:
14: (33)                                             ~dev\.\d{8}\.\d{4}
15: (33)                                             |
16: (33)                                             \.(\d+)
17: (31)                                           )?
18: (29)                                         )?
19: (29)                                         [ ]
20: (29)                                         ''', re.VERBOSE)
21: (0)             log = logging.getLogger(__name__)
22: (0)             def version() -> typing.Tuple[int, ...]:
23: (4)                 """Return the upstream version number tuple from ``stderr`` of ``dot -V``.
24: (4)                 Returns:
25: (8)                     Two, three, or four ``int`` version ``tuple``.
26: (4)                 Raises:
27: (8)                     graphviz.ExecutableNotFound: If the Graphviz executable is not found.
28: (8)                     graphviz.CalledProcessError: If the exit status is non-zero.
29: (8)                     RuntimeError: If the output cannot be parsed into a version number.
30: (4)                 Example:
31: (8)                     >>> doctest_mark_exe()
32: (8)                     >>> import graphviz
33: (8)                     >>> graphviz.version()  # doctest: +ELLIPSIS
34: (8)                     (...)
35: (4)                 Note:
36: (8)                     Ignores the ``~dev.<YYYYmmdd.HHMM>`` portion of development versions.
37: (4)                 See also:
38: (8)                     Upstream release version entry format:
39: (8)                     https://gitlab.com/graphviz/graphviz/-/blob/f94e91ba819cef51a4b9dcb2d76153684d06a913/gen_version.py#L17-20
40: (4)                 """
41: (4)                 cmd = [dot_command.DOT_BINARY, '-V']
42: (4)                 proc = execute.run_check(cmd,
43: (29)                                         stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
44: (29)                                         encoding='ascii')
45: (4)                 ma = VERSION_PATTERN.search(proc.stdout)
46: (4)                 if ma is None:
47: (8)                     raise RuntimeError(f'cannot parse {cmd!r} output: {proc.stdout!r}')
48: (4)                 return tuple(int(d) for d in ma.groups() if d is not None)

----------------------------------------

File 33 - jupyter_integration.py:

1: (0)              """Display rendered graph as SVG in Jupyter Notebooks and QtConsole."""
2: (0)              import typing
3: (0)              from . import piping
4: (0)              __all__ = ['JUPYTER_FORMATS',
5: (11)                        'SUPPORTED_JUPYTER_FORMATS', 'DEFAULT_JUPYTER_FORMAT',
6: (11)                        'get_jupyter_format_mimetype',
7: (11)                        'JupyterIntegration']
8: (0)              _IMAGE_JPEG = 'image/jpeg'
9: (0)              JUPYTER_FORMATS = {'jpeg': _IMAGE_JPEG,
10: (19)                               'jpg': _IMAGE_JPEG,
11: (19)                               'png': 'image/png',
12: (19)                               'svg': 'image/svg+xml'}
13: (0)             SUPPORTED_JUPYTER_FORMATS = set(JUPYTER_FORMATS)
14: (0)             DEFAULT_JUPYTER_FORMAT = next(_ for _ in SUPPORTED_JUPYTER_FORMATS if _ == 'svg')
15: (0)             MIME_TYPES = {'image/jpeg': '_repr_image_jpeg',
16: (14)                          'image/png': '_repr_image_png',
17: (14)                          'image/svg+xml': '_repr_image_svg_xml'}
18: (0)             assert MIME_TYPES.keys() == set(JUPYTER_FORMATS.values())
19: (0)             SVG_ENCODING = 'utf-8'
20: (0)             def get_jupyter_format_mimetype(jupyter_format: str) -> str:
21: (4)                 try:
22: (8)                     return JUPYTER_FORMATS[jupyter_format]
23: (4)                 except KeyError:
24: (8)                     raise ValueError(f'unknown jupyter_format: {jupyter_format!r}'
25: (25)                                     f' (must be one of {sorted(JUPYTER_FORMATS)})')
26: (0)             def get_jupyter_mimetype_format(mimetype: str) -> str:
27: (4)                 if mimetype not in MIME_TYPES:
28: (8)                     raise ValueError(f'unsupported mimetype: {mimetype!r}'
29: (25)                                     f' (must be one of {sorted(MIME_TYPES)})')
30: (4)                 assert mimetype in JUPYTER_FORMATS.values()
31: (4)                 for format, jupyter_mimetype in JUPYTER_FORMATS.items():
32: (8)                     if jupyter_mimetype == mimetype:
33: (12)                        return format
34: (4)                 raise RuntimeError  # pragma: no cover
35: (0)             class JupyterIntegration(piping.Pipe):
36: (4)                 """Display rendered graph as SVG in Jupyter Notebooks and QtConsole."""
37: (4)                 _jupyter_mimetype = get_jupyter_format_mimetype(DEFAULT_JUPYTER_FORMAT)
38: (4)                 def _repr_mimebundle_(self,
39: (26)                                      include: typing.Optional[typing.Iterable[str]] = None,
40: (26)                                      exclude: typing.Optional[typing.Iterable[str]] = None,
41: (26)                                      **_) -> typing.Dict[str, typing.Union[bytes, str]]:
42: (8)                     r"""Return the rendered graph as IPython mimebundle.
43: (8)                     Args:
44: (12)                        include: Iterable of mimetypes to include in the result.
45: (16)                            If not given or ``None``: ``['image/sxg+xml']``.
46: (12)                        exclude: Iterable of minetypes to exclude from the result.
47: (16)                            Overrides ``include``.
48: (8)                     Returns:
49: (12)                        Mapping from mimetypes to data.
50: (8)                     Example:
51: (12)                        >>> doctest_mark_exe()
52: (12)                        >>> import graphviz
53: (12)                        >>> dot = graphviz.Graph()
54: (12)                        >>> dot._repr_mimebundle_()  # doctest: +ELLIPSIS
55: (12)                        {'image/svg+xml': '<?xml version=...
56: (12)                        >>> dot._repr_mimebundle_(include=['image/png'])  # doctest: +ELLIPSIS
57: (12)                        {'image/png': b'\x89PNG...
58: (12)                        >>> dot._repr_mimebundle_(include=[])
59: (12)                        {}
60: (12)                        >>> dot._repr_mimebundle_(include=['image/svg+xml', 'image/jpeg'],
61: (12)                        ...                       exclude=['image/svg+xml'])  # doctest: +ELLIPSIS
62: (12)                        {'image/jpeg': b'\xff...
63: (12)                        >>> list(dot._repr_mimebundle_(include=['image/png', 'image/jpeg']))
64: (12)                        ['image/jpeg', 'image/png']
65: (8)                     See also:
66: (12)                        IPython documentation:
67: (12)                        - https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html#functions
68: (12)                        - https://ipython.readthedocs.io/en/stable/config/integrating.html#MyObject._repr_mimebundle_  # noqa: E501
69: (12)                        - https://nbviewer.org/github/ipython/ipython/blob/master/examples/IPython%20Kernel/Custom%20Display%20Logic.ipynb#Custom-Mimetypes-with-_repr_mimebundle_  # noqa: E501
70: (8)                     """
71: (8)                     include = set(include) if include is not None else {self._jupyter_mimetype}
72: (8)                     include -= set(exclude or [])
73: (8)                     return {mimetype: getattr(self, method_name)()
74: (16)                            for mimetype, method_name in MIME_TYPES.items()
75: (16)                            if mimetype in include}
76: (4)                 def _repr_image_jpeg(self) -> bytes:
77: (8)                     """Return the rendered graph as JPEG bytes."""
78: (8)                     return self.pipe(format='jpeg')
79: (4)                 def _repr_image_png(self) -> bytes:
80: (8)                     """Return the rendered graph as PNG bytes."""
81: (8)                     return self.pipe(format='png')
82: (4)                 def _repr_image_svg_xml(self) -> str:
83: (8)                     """Return the rendered graph as SVG string."""
84: (8)                     return self.pipe(format='svg', encoding=SVG_ENCODING)

----------------------------------------

File 34 - SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRYCOMBINER_aligner_20_characters_for_pythons_codes.py:

1: (0)              import os
2: (0)              from datetime import datetime
3: (0)              def get_file_info(root_folder):
4: (4)                  file_info_list = []
5: (4)                  for root, dirs, files in os.walk(root_folder):
6: (8)                      for file in files:
7: (12)                         try:
8: (16)                             if file.endswith('.py'):
9: (20)                                 file_path = os.path.join(root, file)
10: (20)                                creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
11: (20)                                modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))
12: (20)                                file_extension = os.path.splitext(file)[1].lower()
13: (20)                                file_info_list.append([file, file_path, creation_time, modified_time, file_extension, root])
14: (12)                        except Exception as e:
15: (16)                            print(f"Error processing file {file}: {e}")
16: (4)                 file_info_list.sort(key=lambda x: (x[2], x[3], len(x[0]), x[4]))  # Sort by creation, modification time, name length, extension
17: (4)                 return file_info_list
18: (0)             def process_file(file_info_list):
19: (4)                 combined_output = []
20: (4)                 for idx, (file_name, file_path, creation_time, modified_time, file_extension, root) in enumerate(file_info_list):
21: (8)                     with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
22: (12)                        content = f.read()
23: (12)                        content = "\n".join([line for line in content.split('\n') if line.strip() and not line.strip().startswith("#")])
24: (12)                        content = content.replace('\t', '    ')
25: (12)                        processed_lines = []
26: (12)                        for i, line in enumerate(content.split('\n')):
27: (16)                            leading_spaces = len(line) - len(line.lstrip(' '))
28: (16)                            line_number_str = f"{i+1}: ({leading_spaces})"
29: (16)                            padding = ' ' * (20 - len(line_number_str))
30: (16)                            processed_line = f"{line_number_str}{padding}{line}"
31: (16)                            processed_lines.append(processed_line)
32: (12)                        content_with_line_numbers = "\n".join(processed_lines)
33: (12)                        combined_output.append(f"File {idx + 1} - {file_name}:\n")
34: (12)                        combined_output.append(content_with_line_numbers)
35: (12)                        combined_output.append("\n" + "-"*40 + "\n")
36: (4)                 return combined_output
37: (0)             root_folder_path = '.'  # Set this to the desired folder
38: (0)             file_info_list = get_file_info(root_folder_path)
39: (0)             combined_output = process_file(file_info_list)
40: (0)             output_file = 'SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRY_combined_python_files_20_chars.txt'
41: (0)             with open(output_file, 'w', encoding='utf-8') as logfile:
42: (4)                 logfile.write("\n".join(combined_output))
43: (0)             print(f"Processed file info logged to {output_file}")

----------------------------------------
