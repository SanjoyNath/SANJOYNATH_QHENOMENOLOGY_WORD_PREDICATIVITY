File 1 - .\geometry \arc.py:

1: (0)              r"""Mobjects that are curved.
2: (0)              Examples
3: (0)              --------
4: (0)              .. manim:: UsefulAnnotations
5: (4)                  :save_last_frame:
6: (4)                  class UsefulAnnotations(Scene):
7: (8)                      def construct(self):
8: (12)                         m0 = Dot()
9: (12)                         m1 = AnnotationDot()
10: (12)                        m2 = LabeledDot("ii")
11: (12)                        m3 = LabeledDot(MathTex(r"\alpha").set_color(ORANGE))
12: (12)                        m4 = CurvedArrow(2*LEFT, 2*RIGHT, radius= -5)
13: (12)                        m5 = CurvedArrow(2*LEFT, 2*RIGHT, radius= 8)
14: (12)                        m6 = CurvedDoubleArrow(ORIGIN, 2*RIGHT)
15: (12)                        self.add(m0, m1, m2, m3, m4, m5, m6)
16: (12)                        for i, mobj in enumerate(self.mobjects):
17: (16)                            mobj.shift(DOWN * (i-3))
18: (0)             """
19: (0)             from __future__ import annotations
20: (0)             __all__ = [
21: (4)                 "TipableVMobject",
22: (4)                 "Arc",
23: (4)                 "ArcBetweenPoints",
24: (4)                 "CurvedArrow",
25: (4)                 "CurvedDoubleArrow",
26: (4)                 "Circle",
27: (4)                 "Dot",
28: (4)                 "AnnotationDot",
29: (4)                 "LabeledDot",
30: (4)                 "Ellipse",
31: (4)                 "AnnularSector",
32: (4)                 "Sector",
33: (4)                 "Annulus",
34: (4)                 "CubicBezier",
35: (4)                 "ArcPolygon",
36: (4)                 "ArcPolygonFromArcs",
37: (0)             ]
38: (0)             import itertools
39: (0)             import warnings
40: (0)             from typing import TYPE_CHECKING
41: (0)             import numpy as np
42: (0)             from typing_extensions import Self
43: (0)             from manim.constants import *
44: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
45: (0)             from manim.mobject.types.vectorized_mobject import VGroup, VMobject
46: (0)             from manim.utils.color import BLACK, BLUE, RED, WHITE, ParsableManimColor
47: (0)             from manim.utils.iterables import adjacent_pairs
48: (0)             from manim.utils.space_ops import (
49: (4)                 angle_of_vector,
50: (4)                 cartesian_to_spherical,
51: (4)                 line_intersection,
52: (4)                 perpendicular_bisector,
53: (4)                 rotate_vector,
54: (0)             )
55: (0)             if TYPE_CHECKING:
56: (4)                 import manim.mobject.geometry.tips as tips
57: (4)                 from manim.mobject.mobject import Mobject
58: (4)                 from manim.mobject.text.tex_mobject import SingleStringMathTex, Tex
59: (4)                 from manim.mobject.text.text_mobject import Text
60: (4)                 from manim.typing import CubicBezierPoints, Point3D, QuadraticBezierPoints, Vector3D
61: (0)             class TipableVMobject(VMobject, metaclass=ConvertToOpenGL):
62: (4)                 """Meant for shared functionality between Arc and Line.
63: (4)                 Functionality can be classified broadly into these groups:
64: (8)                     * Adding, Creating, Modifying tips
65: (12)                        - add_tip calls create_tip, before pushing the new tip
66: (16)                            into the TipableVMobject's list of submobjects
67: (12)                        - stylistic and positional configuration
68: (8)                     * Checking for tips
69: (12)                        - Boolean checks for whether the TipableVMobject has a tip
70: (16)                            and a starting tip
71: (8)                     * Getters
72: (12)                        - Straightforward accessors, returning information pertaining
73: (16)                            to the TipableVMobject instance's tip(s), its length etc
74: (4)                 """
75: (4)                 def __init__(
76: (8)                     self,
77: (8)                     tip_length: float = DEFAULT_ARROW_TIP_LENGTH,
78: (8)                     normal_vector: Vector3D = OUT,
79: (8)                     tip_style: dict = {},
80: (8)                     **kwargs,
81: (4)                 ) -> None:
82: (8)                     self.tip_length: float = tip_length
83: (8)                     self.normal_vector: Vector3D = normal_vector
84: (8)                     self.tip_style: dict = tip_style
85: (8)                     super().__init__(**kwargs)
86: (4)                 # Adding, Creating, Modifying tips
87: (4)                 def add_tip(
88: (8)                     self,
89: (8)                     tip: tips.ArrowTip | None = None,
90: (8)                     tip_shape: type[tips.ArrowTip] | None = None,
91: (8)                     tip_length: float | None = None,
92: (8)                     tip_width: float | None = None,
93: (8)                     at_start: bool = False,
94: (4)                 ) -> Self:
95: (8)                     """Adds a tip to the TipableVMobject instance, recognising
96: (8)                     that the endpoints might need to be switched if it's
97: (8)                     a 'starting tip' or not.
98: (8)                     """
99: (8)                     if tip is None:
100: (12)                       tip = self.create_tip(tip_shape, tip_length, tip_width, at_start)
101: (8)                    else:
102: (12)                       self.position_tip(tip, at_start)
103: (8)                    self.reset_endpoints_based_on_tip(tip, at_start)
104: (8)                    self.asign_tip_attr(tip, at_start)
105: (8)                    self.add(tip)
106: (8)                    return self
107: (4)                def create_tip(
108: (8)                    self,
109: (8)                    tip_shape: type[tips.ArrowTip] | None = None,
110: (8)                    tip_length: float = None,
111: (8)                    tip_width: float = None,
112: (8)                    at_start: bool = False,
113: (4)                ):
114: (8)                    """Stylises the tip, positions it spatially, and returns
115: (8)                    the newly instantiated tip to the caller.
116: (8)                    """
117: (8)                    tip = self.get_unpositioned_tip(tip_shape, tip_length, tip_width)
118: (8)                    self.position_tip(tip, at_start)
119: (8)                    return tip
120: (4)                def get_unpositioned_tip(
121: (8)                    self,
122: (8)                    tip_shape: type[tips.ArrowTip] | None = None,
123: (8)                    tip_length: float | None = None,
124: (8)                    tip_width: float | None = None,
125: (4)                ):
126: (8)                    """Returns a tip that has been stylistically configured,
127: (8)                    but has not yet been given a position in space.
128: (8)                    """
129: (8)                    from manim.mobject.geometry.tips import ArrowTriangleFilledTip
130: (8)                    style = {}
131: (8)                    if tip_shape is None:
132: (12)                       tip_shape = ArrowTriangleFilledTip
133: (8)                    if tip_shape is ArrowTriangleFilledTip:
134: (12)                       if tip_width is None:
135: (16)                           tip_width = self.get_default_tip_length()
136: (12)                       style.update({"width": tip_width})
137: (8)                    if tip_length is None:
138: (12)                       tip_length = self.get_default_tip_length()
139: (8)                    color = self.get_color()
140: (8)                    style.update({"fill_color": color, "stroke_color": color})
141: (8)                    style.update(self.tip_style)
142: (8)                    tip = tip_shape(length=tip_length, **style)
143: (8)                    return tip
144: (4)                def position_tip(self, tip: tips.ArrowTip, at_start: bool = False):
145: (8)                    # Last two control points, defining both
146: (8)                    # the end, and the tangency direction
147: (8)                    if at_start:
148: (12)                       anchor = self.get_start()
149: (12)                       handle = self.get_first_handle()
150: (8)                    else:
151: (12)                       handle = self.get_last_handle()
152: (12)                       anchor = self.get_end()
153: (8)                    angles = cartesian_to_spherical(handle - anchor)
154: (8)                    tip.rotate(
155: (12)                       angles[1] - PI - tip.tip_angle,
156: (8)                    )  # Rotates the tip along the azimuthal
157: (8)                    if not hasattr(self, "_init_positioning_axis"):
158: (12)                       axis = [
159: (16)                           np.sin(angles[1]),
160: (16)                           -np.cos(angles[1]),
161: (16)                           0,
162: (12)                       ]  # Obtains the perpendicular of the tip
163: (12)                       tip.rotate(
164: (16)                           -angles[2] + PI / 2,
165: (16)                           axis=axis,
166: (12)                       )  # Rotates the tip along the vertical wrt the axis
167: (12)                       self._init_positioning_axis = axis
168: (8)                    tip.shift(anchor - tip.tip_point)
169: (8)                    return tip
170: (4)                def reset_endpoints_based_on_tip(self, tip: tips.ArrowTip, at_start: bool) -> Self:
171: (8)                    if self.get_length() == 0:
172: (12)                       # Zero length, put_start_and_end_on wouldn't work
173: (12)                       return self
174: (8)                    if at_start:
175: (12)                       self.put_start_and_end_on(tip.base, self.get_end())
176: (8)                    else:
177: (12)                       self.put_start_and_end_on(self.get_start(), tip.base)
178: (8)                    return self
179: (4)                def asign_tip_attr(self, tip: tips.ArrowTip, at_start: bool) -> Self:
180: (8)                    if at_start:
181: (12)                       self.start_tip = tip
182: (8)                    else:
183: (12)                       self.tip = tip
184: (8)                    return self
185: (4)                # Checking for tips
186: (4)                def has_tip(self) -> bool:
187: (8)                    return hasattr(self, "tip") and self.tip in self
188: (4)                def has_start_tip(self) -> bool:
189: (8)                    return hasattr(self, "start_tip") and self.start_tip in self
190: (4)                # Getters
191: (4)                def pop_tips(self) -> VGroup:
192: (8)                    start, end = self.get_start_and_end()
193: (8)                    result = self.get_group_class()()
194: (8)                    if self.has_tip():
195: (12)                       result.add(self.tip)
196: (12)                       self.remove(self.tip)
197: (8)                    if self.has_start_tip():
198: (12)                       result.add(self.start_tip)
199: (12)                       self.remove(self.start_tip)
200: (8)                    self.put_start_and_end_on(start, end)
201: (8)                    return result
202: (4)                def get_tips(self) -> VGroup:
203: (8)                    """Returns a VGroup (collection of VMobjects) containing
204: (8)                    the TipableVMObject instance's tips.
205: (8)                    """
206: (8)                    result = self.get_group_class()()
207: (8)                    if hasattr(self, "tip"):
208: (12)                       result.add(self.tip)
209: (8)                    if hasattr(self, "start_tip"):
210: (12)                       result.add(self.start_tip)
211: (8)                    return result
212: (4)                def get_tip(self):
213: (8)                    """Returns the TipableVMobject instance's (first) tip,
214: (8)                    otherwise throws an exception."""
215: (8)                    tips = self.get_tips()
216: (8)                    if len(tips) == 0:
217: (12)                       raise Exception("tip not found")
218: (8)                    else:
219: (12)                       return tips[0]
220: (4)                def get_default_tip_length(self) -> float:
221: (8)                    return self.tip_length
222: (4)                def get_first_handle(self) -> Point3D:
223: (8)                    return self.points[1]
224: (4)                def get_last_handle(self) -> Point3D:
225: (8)                    return self.points[-2]
226: (4)                def get_end(self) -> Point3D:
227: (8)                    if self.has_tip():
228: (12)                       return self.tip.get_start()
229: (8)                    else:
230: (12)                       return super().get_end()
231: (4)                def get_start(self) -> Point3D:
232: (8)                    if self.has_start_tip():
233: (12)                       return self.start_tip.get_start()
234: (8)                    else:
235: (12)                       return super().get_start()
236: (4)                def get_length(self) -> np.floating:
237: (8)                    start, end = self.get_start_and_end()
238: (8)                    return np.linalg.norm(start - end)
239: (0)            class Arc(TipableVMobject):
240: (4)                """A circular arc.
241: (4)                Examples
242: (4)                --------
243: (4)                A simple arc of angle Pi.
244: (4)                .. manim:: ArcExample
245: (8)                    :save_last_frame:
246: (8)                    class ArcExample(Scene):
247: (12)                       def construct(self):
248: (16)                           self.add(Arc(angle=PI))
249: (4)                """
250: (4)                def __init__(
251: (8)                    self,
252: (8)                    radius: float = 1.0,
253: (8)                    start_angle: float = 0,
254: (8)                    angle: float = TAU / 4,
255: (8)                    num_components: int = 9,
256: (8)                    arc_center: Point3D = ORIGIN,
257: (8)                    **kwargs,
258: (4)                ):
259: (8)                    if radius is None:  # apparently None is passed by ArcBetweenPoints
260: (12)                       radius = 1.0
261: (8)                    self.radius = radius
262: (8)                    self.num_components: int = num_components
263: (8)                    self.arc_center: Point3D = arc_center
264: (8)                    self.start_angle: float = start_angle
265: (8)                    self.angle: float = angle
266: (8)                    self._failed_to_get_center: bool = False
267: (8)                    super().__init__(**kwargs)
268: (4)                def generate_points(self) -> None:
269: (8)                    self._set_pre_positioned_points()
270: (8)                    self.scale(self.radius, about_point=ORIGIN)
271: (8)                    self.shift(self.arc_center)
272: (4)                # Points are set a bit differently when rendering via OpenGL.
273: (4)                # TODO: refactor Arc so that only one strategy for setting points
274: (4)                # has to be used.
275: (4)                def init_points(self) -> None:
276: (8)                    self.set_points(
277: (12)                       Arc._create_quadratic_bezier_points(
278: (16)                           angle=self.angle,
279: (16)                           start_angle=self.start_angle,
280: (16)                           n_components=self.num_components,
281: (12)                       ),
282: (8)                    )
283: (8)                    self.scale(self.radius, about_point=ORIGIN)
284: (8)                    self.shift(self.arc_center)
285: (4)                @staticmethod
286: (4)                def _create_quadratic_bezier_points(
287: (8)                    angle: float, start_angle: float = 0, n_components: int = 8
288: (4)                ) -> QuadraticBezierPoints:
289: (8)                    samples = np.array(
290: (12)                       [
291: (16)                           [np.cos(a), np.sin(a), 0]
292: (16)                           for a in np.linspace(
293: (20)                               start_angle,
294: (20)                               start_angle + angle,
295: (20)                               2 * n_components + 1,
296: (16)                           )
297: (12)                       ],
298: (8)                    )
299: (8)                    theta = angle / n_components
300: (8)                    samples[1::2] /= np.cos(theta / 2)
301: (8)                    points = np.zeros((3 * n_components, 3))
302: (8)                    points[0::3] = samples[0:-1:2]
303: (8)                    points[1::3] = samples[1::2]
304: (8)                    points[2::3] = samples[2::2]
305: (8)                    return points
306: (4)                def _set_pre_positioned_points(self) -> None:
307: (8)                    anchors = np.array(
308: (12)                       [
309: (16)                           np.cos(a) * RIGHT + np.sin(a) * UP
310: (16)                           for a in np.linspace(
311: (20)                               self.start_angle,
312: (20)                               self.start_angle + self.angle,
313: (20)                               self.num_components,
314: (16)                           )
315: (12)                       ],
316: (8)                    )
317: (8)                    # Figure out which control points will give the
318: (8)                    # Appropriate tangent lines to the circle
319: (8)                    d_theta = self.angle / (self.num_components - 1.0)
320: (8)                    tangent_vectors = np.zeros(anchors.shape)
321: (8)                    # Rotate all 90 degrees, via (x, y) -> (-y, x)
322: (8)                    tangent_vectors[:, 1] = anchors[:, 0]
323: (8)                    tangent_vectors[:, 0] = -anchors[:, 1]
324: (8)                    # Use tangent vectors to deduce anchors
325: (8)                    handles1 = anchors[:-1] + (d_theta / 3) * tangent_vectors[:-1]
326: (8)                    handles2 = anchors[1:] - (d_theta / 3) * tangent_vectors[1:]
327: (8)                    self.set_anchors_and_handles(anchors[:-1], handles1, handles2, anchors[1:])
328: (4)                def get_arc_center(self, warning: bool = True) -> Point3D:
329: (8)                    """Looks at the normals to the first two
330: (8)                    anchors, and finds their intersection points
331: (8)                    """
332: (8)                    # First two anchors and handles
333: (8)                    a1, h1, h2, a2 = self.points[:4]
334: (8)                    if np.all(a1 == a2):
335: (12)                       # For a1 and a2 to lie at the same point arc radius
336: (12)                       # must be zero. Thus arc_center will also lie at
337: (12)                       # that point.
338: (12)                       return np.copy(a1)
339: (8)                    # Tangent vectors
340: (8)                    t1 = h1 - a1
341: (8)                    t2 = h2 - a2
342: (8)                    # Normals
343: (8)                    n1 = rotate_vector(t1, TAU / 4)
344: (8)                    n2 = rotate_vector(t2, TAU / 4)
345: (8)                    try:
346: (12)                       return line_intersection(line1=(a1, a1 + n1), line2=(a2, a2 + n2))
347: (8)                    except Exception:
348: (12)                       if warning:
349: (16)                           warnings.warn("Can't find Arc center, using ORIGIN instead")
350: (12)                       self._failed_to_get_center = True
351: (12)                       return np.array(ORIGIN)
352: (4)                def move_arc_center_to(self, point: Point3D) -> Self:
353: (8)                    self.shift(point - self.get_arc_center())
354: (8)                    return self
355: (4)                def stop_angle(self) -> float:
356: (8)                    return angle_of_vector(self.points[-1] - self.get_arc_center()) % TAU
357: (0)            class ArcBetweenPoints(Arc):
358: (4)                """Inherits from Arc and additionally takes 2 points between which the arc is spanned.
359: (4)                Example
360: (4)                -------
361: (4)                .. manim:: ArcBetweenPointsExample
362: (6)                  class ArcBetweenPointsExample(Scene):
363: (10)                     def construct(self):
364: (14)                         circle = Circle(radius=2, stroke_color=GREY)
365: (14)                         dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)
366: (14)                         dot_1_text = Tex("(2,0)").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)
367: (14)                         dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)
368: (14)                         dot_2_text = Tex("(0,2)").scale(0.5).next_to(dot_2, UP).set_color(BLUE)
369: (14)                         arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)
370: (14)                         self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)
371: (14)                         self.play(Create(arc))
372: (4)                """
373: (4)                def __init__(
374: (8)                    self,
375: (8)                    start: Point3D,
376: (8)                    end: Point3D,
377: (8)                    angle: float = TAU / 4,
378: (8)                    radius: float = None,
379: (8)                    **kwargs,
380: (4)                ) -> None:
381: (8)                    if radius is not None:
382: (12)                       self.radius = radius
383: (12)                       if radius < 0:
384: (16)                           sign = -2
385: (16)                           radius *= -1
386: (12)                       else:
387: (16)                           sign = 2
388: (12)                       halfdist = np.linalg.norm(np.array(start) - np.array(end)) / 2
389: (12)                       if radius < halfdist:
390: (16)                           raise ValueError(
391: (20)                               """ArcBetweenPoints called with a radius that is
392: (28)                                       smaller than half the distance between the points.""",
393: (16)                           )
394: (12)                       arc_height = radius - np.sqrt(radius**2 - halfdist**2)
395: (12)                       angle = np.arccos((radius - arc_height) / radius) * sign
396: (8)                    super().__init__(radius=radius, angle=angle, **kwargs)
397: (8)                    if angle == 0:
398: (12)                       self.set_points_as_corners([LEFT, RIGHT])
399: (8)                    self.put_start_and_end_on(start, end)
400: (8)                    if radius is None:
401: (12)                       center = self.get_arc_center(warning=False)
402: (12)                       if not self._failed_to_get_center:
403: (16)                           self.radius = np.linalg.norm(np.array(start) - np.array(center))
404: (12)                       else:
405: (16)                           self.radius = np.inf
406: (0)            class CurvedArrow(ArcBetweenPoints):
407: (4)                def __init__(self, start_point: Point3D, end_point: Point3D, **kwargs) -> None:
408: (8)                    from manim.mobject.geometry.tips import ArrowTriangleFilledTip
409: (8)                    tip_shape = kwargs.pop("tip_shape", ArrowTriangleFilledTip)
410: (8)                    super().__init__(start_point, end_point, **kwargs)
411: (8)                    self.add_tip(tip_shape=tip_shape)
412: (0)            class CurvedDoubleArrow(CurvedArrow):
413: (4)                def __init__(self, start_point: Point3D, end_point: Point3D, **kwargs) -> None:
414: (8)                    if "tip_shape_end" in kwargs:
415: (12)                       kwargs["tip_shape"] = kwargs.pop("tip_shape_end")
416: (8)                    from manim.mobject.geometry.tips import ArrowTriangleFilledTip
417: (8)                    tip_shape_start = kwargs.pop("tip_shape_start", ArrowTriangleFilledTip)
418: (8)                    super().__init__(start_point, end_point, **kwargs)
419: (8)                    self.add_tip(at_start=True, tip_shape=tip_shape_start)
420: (0)            class Circle(Arc):
421: (4)                """A circle.
422: (4)                Parameters
423: (4)                ----------
424: (4)                color
425: (8)                    The color of the shape.
426: (4)                kwargs
427: (8)                    Additional arguments to be passed to :class:`Arc`
428: (4)                Examples
429: (4)                --------
430: (4)                .. manim:: CircleExample
431: (8)                    :save_last_frame:
432: (8)                    class CircleExample(Scene):
433: (12)                       def construct(self):
434: (16)                           circle_1 = Circle(radius=1.0)
435: (16)                           circle_2 = Circle(radius=1.5, color=GREEN)
436: (16)                           circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)
437: (16)                           circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)
438: (16)                           self.add(circle_group)
439: (4)                """
440: (4)                def __init__(
441: (8)                    self,
442: (8)                    radius: float | None = None,
443: (8)                    color: ParsableManimColor = RED,
444: (8)                    **kwargs,
445: (4)                ) -> None:
446: (8)                    super().__init__(
447: (12)                       radius=radius,
448: (12)                       start_angle=0,
449: (12)                       angle=TAU,
450: (12)                       color=color,
451: (12)                       **kwargs,
452: (8)                    )
453: (4)                def surround(
454: (8)                    self,
455: (8)                    mobject: Mobject,
456: (8)                    dim_to_match: int = 0,
457: (8)                    stretch: bool = False,
458: (8)                    buffer_factor: float = 1.2,
459: (4)                ) -> Self:
460: (8)                    """Modifies a circle so that it surrounds a given mobject.
461: (8)                    Parameters
462: (8)                    ----------
463: (8)                    mobject
464: (12)                       The mobject that the circle will be surrounding.
465: (8)                    dim_to_match
466: (8)                    buffer_factor
467: (12)                       Scales the circle with respect to the mobject. A `buffer_factor` < 1 makes the circle smaller than the mobject.
468: (8)                    stretch
469: (12)                       Stretches the circle to fit more tightly around the mobject. Note: Does not work with :class:`Line`
470: (8)                    Examples
471: (8)                    --------
472: (8)                    .. manim:: CircleSurround
473: (12)                       :save_last_frame:
474: (12)                       class CircleSurround(Scene):
475: (16)                           def construct(self):
476: (20)                               triangle1 = Triangle()
477: (20)                               circle1 = Circle().surround(triangle1)
478: (20)                               group1 = Group(triangle1,circle1) # treat the two mobjects as one
479: (20)                               line2 = Line()
480: (20)                               circle2 = Circle().surround(line2, buffer_factor=2.0)
481: (20)                               group2 = Group(line2,circle2)
482: (20)                               # buffer_factor < 1, so the circle is smaller than the square
483: (20)                               square3 = Square()
484: (20)                               circle3 = Circle().surround(square3, buffer_factor=0.5)
485: (20)                               group3 = Group(square3, circle3)
486: (20)                               group = Group(group1, group2, group3).arrange(buff=1)
487: (20)                               self.add(group)
488: (8)                    """
489: (8)                    # Ignores dim_to_match and stretch; result will always be a circle
490: (8)                    # TODO: Perhaps create an ellipse class to handle single-dimension stretching
491: (8)                    # Something goes wrong here when surrounding lines?
492: (8)                    # TODO: Figure out and fix
493: (8)                    self.replace(mobject, dim_to_match, stretch)
494: (8)                    self.width = np.sqrt(mobject.width**2 + mobject.height**2)
495: (8)                    return self.scale(buffer_factor)
496: (4)                def point_at_angle(self, angle: float) -> Point3D:
497: (8)                    """Returns the position of a point on the circle.
498: (8)                    Parameters
499: (8)                    ----------
500: (8)                    angle
501: (12)                       The angle of the point along the circle in radians.
502: (8)                    Returns
503: (8)                    -------
504: (8)                    :class:`numpy.ndarray`
505: (12)                       The location of the point along the circle's circumference.
506: (8)                    Examples
507: (8)                    --------
508: (8)                    .. manim:: PointAtAngleExample
509: (12)                       :save_last_frame:
510: (12)                       class PointAtAngleExample(Scene):
511: (16)                           def construct(self):
512: (20)                               circle = Circle(radius=2.0)
513: (20)                               p1 = circle.point_at_angle(PI/2)
514: (20)                               p2 = circle.point_at_angle(270*DEGREES)
515: (20)                               s1 = Square(side_length=0.25).move_to(p1)
516: (20)                               s2 = Square(side_length=0.25).move_to(p2)
517: (20)                               self.add(circle, s1, s2)
518: (8)                    """
519: (8)                    start_angle = angle_of_vector(self.points[0] - self.get_center())
520: (8)                    proportion = (angle - start_angle) / TAU
521: (8)                    proportion -= np.floor(proportion)
522: (8)                    return self.point_from_proportion(proportion)
523: (4)                @staticmethod
524: (4)                def from_three_points(p1: Point3D, p2: Point3D, p3: Point3D, **kwargs) -> Self:
525: (8)                    """Returns a circle passing through the specified
526: (8)                    three points.
527: (8)                    Example
528: (8)                    -------
529: (8)                    .. manim:: CircleFromPointsExample
530: (12)                       :save_last_frame:
531: (12)                       class CircleFromPointsExample(Scene):
532: (16)                           def construct(self):
533: (20)                               circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)
534: (20)                               dots = VGroup(
535: (24)                                   Dot(LEFT),
536: (24)                                   Dot(LEFT + UP),
537: (24)                                   Dot(UP * 2),
538: (20)                               )
539: (20)                               self.add(NumberPlane(), circle, dots)
540: (8)                    """
541: (8)                    center = line_intersection(
542: (12)                       perpendicular_bisector([p1, p2]),
543: (12)                       perpendicular_bisector([p2, p3]),
544: (8)                    )
545: (8)                    radius = np.linalg.norm(p1 - center)
546: (8)                    return Circle(radius=radius, **kwargs).shift(center)
547: (0)            class Dot(Circle):
548: (4)                """A circle with a very small radius.
549: (4)                Parameters
550: (4)                ----------
551: (4)                point
552: (8)                    The location of the dot.
553: (4)                radius
554: (8)                    The radius of the dot.
555: (4)                stroke_width
556: (8)                    The thickness of the outline of the dot.
557: (4)                fill_opacity
558: (8)                    The opacity of the dot's fill_colour
559: (4)                color
560: (8)                    The color of the dot.
561: (4)                kwargs
562: (8)                    Additional arguments to be passed to :class:`Circle`
563: (4)                Examples
564: (4)                --------
565: (4)                .. manim:: DotExample
566: (8)                    :save_last_frame:
567: (8)                    class DotExample(Scene):
568: (12)                       def construct(self):
569: (16)                           dot1 = Dot(point=LEFT, radius=0.08)
570: (16)                           dot2 = Dot(point=ORIGIN)
571: (16)                           dot3 = Dot(point=RIGHT)
572: (16)                           self.add(dot1,dot2,dot3)
573: (4)                """
574: (4)                def __init__(
575: (8)                    self,
576: (8)                    point: Point3D = ORIGIN,
577: (8)                    radius: float = DEFAULT_DOT_RADIUS,
578: (8)                    stroke_width: float = 0,
579: (8)                    fill_opacity: float = 1.0,
580: (8)                    color: ParsableManimColor = WHITE,
581: (8)                    **kwargs,
582: (4)                ) -> None:
583: (8)                    super().__init__(
584: (12)                       arc_center=point,
585: (12)                       radius=radius,
586: (12)                       stroke_width=stroke_width,
587: (12)                       fill_opacity=fill_opacity,
588: (12)                       color=color,
589: (12)                       **kwargs,
590: (8)                    )
591: (0)            class AnnotationDot(Dot):
592: (4)                """A dot with bigger radius and bold stroke to annotate scenes."""
593: (4)                def __init__(
594: (8)                    self,
595: (8)                    radius: float = DEFAULT_DOT_RADIUS * 1.3,
596: (8)                    stroke_width: float = 5,
597: (8)                    stroke_color: ParsableManimColor = WHITE,
598: (8)                    fill_color: ParsableManimColor = BLUE,
599: (8)                    **kwargs,
600: (4)                ) -> None:
601: (8)                    super().__init__(
602: (12)                       radius=radius,
603: (12)                       stroke_width=stroke_width,
604: (12)                       stroke_color=stroke_color,
605: (12)                       fill_color=fill_color,
606: (12)                       **kwargs,
607: (8)                    )
608: (0)            class LabeledDot(Dot):
609: (4)                """A :class:`Dot` containing a label in its center.
610: (4)                Parameters
611: (4)                ----------
612: (4)                label
613: (8)                    The label of the :class:`Dot`. This is rendered as :class:`~.MathTex`
614: (8)                    by default (i.e., when passing a :class:`str`), but other classes
615: (8)                    representing rendered strings like :class:`~.Text` or :class:`~.Tex`
616: (8)                    can be passed as well.
617: (4)                radius
618: (8)                    The radius of the :class:`Dot`. If ``None`` (the default), the radius
619: (8)                    is calculated based on the size of the ``label``.
620: (4)                Examples
621: (4)                --------
622: (4)                .. manim:: SeveralLabeledDots
623: (8)                    :save_last_frame:
624: (8)                    class SeveralLabeledDots(Scene):
625: (12)                       def construct(self):
626: (16)                           sq = Square(fill_color=RED, fill_opacity=1)
627: (16)                           self.add(sq)
628: (16)                           dot1 = LabeledDot(Tex("42", color=RED))
629: (16)                           dot2 = LabeledDot(MathTex("a", color=GREEN))
630: (16)                           dot3 = LabeledDot(Text("ii", color=BLUE))
631: (16)                           dot4 = LabeledDot("3")
632: (16)                           dot1.next_to(sq, UL)
633: (16)                           dot2.next_to(sq, UR)
634: (16)                           dot3.next_to(sq, DL)
635: (16)                           dot4.next_to(sq, DR)
636: (16)                           self.add(dot1, dot2, dot3, dot4)
637: (4)                """
638: (4)                def __init__(
639: (8)                    self,
640: (8)                    label: str | SingleStringMathTex | Text | Tex,
641: (8)                    radius: float | None = None,
642: (8)                    **kwargs,
643: (4)                ) -> None:
644: (8)                    if isinstance(label, str):
645: (12)                       from manim import MathTex
646: (12)                       rendered_label = MathTex(label, color=BLACK)
647: (8)                    else:
648: (12)                       rendered_label = label
649: (8)                    if radius is None:
650: (12)                       radius = 0.1 + max(rendered_label.width, rendered_label.height) / 2
651: (8)                    super().__init__(radius=radius, **kwargs)
652: (8)                    rendered_label.move_to(self.get_center())
653: (8)                    self.add(rendered_label)
654: (0)            class Ellipse(Circle):
655: (4)                """A circular shape; oval, circle.
656: (4)                Parameters
657: (4)                ----------
658: (4)                width
659: (7)                   The horizontal width of the ellipse.
660: (4)                height
661: (7)                   The vertical height of the ellipse.
662: (4)                kwargs
663: (7)                   Additional arguments to be passed to :class:`Circle`.
664: (4)                Examples
665: (4)                --------
666: (4)                .. manim:: EllipseExample
667: (8)                    :save_last_frame:
668: (8)                    class EllipseExample(Scene):
669: (12)                       def construct(self):
670: (16)                           ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)
671: (16)                           ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)
672: (16)                           ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)
673: (16)                           self.add(ellipse_group)
674: (4)                """
675: (4)                def __init__(self, width: float = 2, height: float = 1, **kwargs) -> None:
676: (8)                    super().__init__(**kwargs)
677: (8)                    self.stretch_to_fit_width(width)
678: (8)                    self.stretch_to_fit_height(height)
679: (0)            class AnnularSector(Arc):
680: (4)                """A sector of an annulus.
681: (4)                Parameters
682: (4)                ----------
683: (4)                inner_radius
684: (7)                   The inside radius of the Annular Sector.
685: (4)                outer_radius
686: (7)                   The outside radius of the Annular Sector.
687: (4)                angle
688: (7)                   The clockwise angle of the Annular Sector.
689: (4)                start_angle
690: (7)                   The starting clockwise angle of the Annular Sector.
691: (4)                fill_opacity
692: (7)                   The opacity of the color filled in the Annular Sector.
693: (4)                stroke_width
694: (7)                   The stroke width of the Annular Sector.
695: (4)                color
696: (7)                   The color filled into the Annular Sector.
697: (4)                Examples
698: (4)                --------
699: (4)                .. manim:: AnnularSectorExample
700: (8)                    :save_last_frame:
701: (8)                    class AnnularSectorExample(Scene):
702: (12)                       def construct(self):
703: (16)                           # Changes background color to clearly visualize changes in fill_opacity.
704: (16)                           self.camera.background_color = WHITE
705: (16)                           # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.
706: (16)                           s1 = AnnularSector(color=YELLOW).move_to(2 * UL)
707: (16)                           # Different inner_radius and outer_radius than the default.
708: (16)                           s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)
709: (16)                           # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.
710: (16)                           s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)
711: (16)                           # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.
712: (16)                           s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)
713: (16)                           self.add(s1, s2, s3, s4)
714: (4)                """
715: (4)                def __init__(
716: (8)                    self,
717: (8)                    inner_radius: float = 1,
718: (8)                    outer_radius: float = 2,
719: (8)                    angle: float = TAU / 4,
720: (8)                    start_angle: float = 0,
721: (8)                    fill_opacity: float = 1,
722: (8)                    stroke_width: float = 0,
723: (8)                    color: ParsableManimColor = WHITE,
724: (8)                    **kwargs,
725: (4)                ) -> None:
726: (8)                    self.inner_radius = inner_radius
727: (8)                    self.outer_radius = outer_radius
728: (8)                    super().__init__(
729: (12)                       start_angle=start_angle,
730: (12)                       angle=angle,
731: (12)                       fill_opacity=fill_opacity,
732: (12)                       stroke_width=stroke_width,
733: (12)                       color=color,
734: (12)                       **kwargs,
735: (8)                    )
736: (4)                def generate_points(self) -> None:
737: (8)                    inner_arc, outer_arc = (
738: (12)                       Arc(
739: (16)                           start_angle=self.start_angle,
740: (16)                           angle=self.angle,
741: (16)                           radius=radius,
742: (16)                           arc_center=self.arc_center,
743: (12)                       )
744: (12)                       for radius in (self.inner_radius, self.outer_radius)
745: (8)                    )
746: (8)                    outer_arc.reverse_points()
747: (8)                    self.append_points(inner_arc.points)
748: (8)                    self.add_line_to(outer_arc.points[0])
749: (8)                    self.append_points(outer_arc.points)
750: (8)                    self.add_line_to(inner_arc.points[0])
751: (4)                init_points = generate_points
752: (0)            class Sector(AnnularSector):
753: (4)                """A sector of a circle.
754: (4)                Examples
755: (4)                --------
756: (4)                .. manim:: ExampleSector
757: (8)                    :save_last_frame:
758: (8)                    class ExampleSector(Scene):
759: (12)                       def construct(self):
760: (16)                           sector = Sector(outer_radius=2, inner_radius=1)
761: (16)                           sector2 = Sector(outer_radius=2.5, inner_radius=0.8).move_to([-3, 0, 0])
762: (16)                           sector.set_color(RED)
763: (16)                           sector2.set_color(PINK)
764: (16)                           self.add(sector, sector2)
765: (4)                """
766: (4)                def __init__(
767: (8)                    self, outer_radius: float = 1, inner_radius: float = 0, **kwargs
768: (4)                ) -> None:
769: (8)                    super().__init__(inner_radius=inner_radius, outer_radius=outer_radius, **kwargs)
770: (0)            class Annulus(Circle):
771: (4)                """Region between two concentric :class:`Circles <.Circle>`.
772: (4)                Parameters
773: (4)                ----------
774: (4)                inner_radius
775: (8)                    The radius of the inner :class:`Circle`.
776: (4)                outer_radius
777: (8)                    The radius of the outer :class:`Circle`.
778: (4)                kwargs
779: (8)                    Additional arguments to be passed to :class:`Annulus`
780: (4)                Examples
781: (4)                --------
782: (4)                .. manim:: AnnulusExample
783: (8)                    :save_last_frame:
784: (8)                    class AnnulusExample(Scene):
785: (12)                       def construct(self):
786: (16)                           annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)
787: (16)                           annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)
788: (16)                           self.add(annulus_1, annulus_2)
789: (4)                """
790: (4)                def __init__(
791: (8)                    self,
792: (8)                    inner_radius: float | None = 1,
793: (8)                    outer_radius: float | None = 2,
794: (8)                    fill_opacity: float = 1,
795: (8)                    stroke_width: float = 0,
796: (8)                    color: ParsableManimColor = WHITE,
797: (8)                    mark_paths_closed: bool = False,
798: (8)                    **kwargs,
799: (4)                ) -> None:
800: (8)                    self.mark_paths_closed = mark_paths_closed  # is this even used?
801: (8)                    self.inner_radius = inner_radius
802: (8)                    self.outer_radius = outer_radius
803: (8)                    super().__init__(
804: (12)                       fill_opacity=fill_opacity, stroke_width=stroke_width, color=color, **kwargs
805: (8)                    )
806: (4)                def generate_points(self) -> None:
807: (8)                    self.radius = self.outer_radius
808: (8)                    outer_circle = Circle(radius=self.outer_radius)
809: (8)                    inner_circle = Circle(radius=self.inner_radius)
810: (8)                    inner_circle.reverse_points()
811: (8)                    self.append_points(outer_circle.points)
812: (8)                    self.append_points(inner_circle.points)
813: (8)                    self.shift(self.arc_center)
814: (4)                init_points = generate_points
815: (0)            class CubicBezier(VMobject, metaclass=ConvertToOpenGL):
816: (4)                """A cubic Bézier curve.
817: (4)                Example
818: (4)                -------
819: (4)                .. manim:: BezierSplineExample
820: (8)                    :save_last_frame:
821: (8)                    class BezierSplineExample(Scene):
822: (12)                       def construct(self):
823: (16)                           p1 = np.array([-3, 1, 0])
824: (16)                           p1b = p1 + [1, 0, 0]
825: (16)                           d1 = Dot(point=p1).set_color(BLUE)
826: (16)                           l1 = Line(p1, p1b)
827: (16)                           p2 = np.array([3, -1, 0])
828: (16)                           p2b = p2 - [1, 0, 0]
829: (16)                           d2 = Dot(point=p2).set_color(RED)
830: (16)                           l2 = Line(p2, p2b)
831: (16)                           bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)
832: (16)                           self.add(l1, d1, l2, d2, bezier)
833: (4)                """
834: (4)                def __init__(
835: (8)                    self,
836: (8)                    start_anchor: CubicBezierPoints,
837: (8)                    start_handle: CubicBezierPoints,
838: (8)                    end_handle: CubicBezierPoints,
839: (8)                    end_anchor: CubicBezierPoints,
840: (8)                    **kwargs,
841: (4)                ) -> None:
842: (8)                    super().__init__(**kwargs)
843: (8)                    self.add_cubic_bezier_curve(start_anchor, start_handle, end_handle, end_anchor)
844: (0)            class ArcPolygon(VMobject, metaclass=ConvertToOpenGL):
845: (4)                """A generalized polygon allowing for points to be connected with arcs.
846: (4)                This version tries to stick close to the way :class:`Polygon` is used. Points
847: (4)                can be passed to it directly which are used to generate the according arcs
848: (4)                (using :class:`ArcBetweenPoints`). An angle or radius can be passed to it to
849: (4)                use across all arcs, but to configure arcs individually an ``arc_config`` list
850: (4)                has to be passed with the syntax explained below.
851: (4)                Parameters
852: (4)                ----------
853: (4)                vertices
854: (8)                    A list of vertices, start and end points for the arc segments.
855: (4)                angle
856: (8)                    The angle used for constructing the arcs. If no other parameters
857: (8)                    are set, this angle is used to construct all arcs.
858: (4)                radius
859: (8)                    The circle radius used to construct the arcs. If specified,
860: (8)                    overrides the specified ``angle``.
861: (4)                arc_config
862: (8)                    When passing a ``dict``, its content will be passed as keyword
863: (8)                    arguments to :class:`~.ArcBetweenPoints`. Otherwise, a list
864: (8)                    of dictionaries containing values that are passed as keyword
865: (8)                    arguments for every individual arc can be passed.
866: (4)                kwargs
867: (8)                    Further keyword arguments that are passed to the constructor of
868: (8)                    :class:`~.VMobject`.
869: (4)                Attributes
870: (4)                ----------
871: (4)                arcs : :class:`list`
872: (8)                    The arcs created from the input parameters::
873: (12)                       >>> from manim import ArcPolygon
874: (12)                       >>> ap = ArcPolygon([0, 0, 0], [2, 0, 0], [0, 2, 0])
875: (12)                       >>> ap.arcs
876: (12)                       [ArcBetweenPoints, ArcBetweenPoints, ArcBetweenPoints]
877: (4)                .. tip::
878: (8)                    Two instances of :class:`ArcPolygon` can be transformed properly into one
879: (8)                    another as well. Be advised that any arc initialized with ``angle=0``
880: (8)                    will actually be a straight line, so if a straight section should seamlessly
881: (8)                    transform into an arced section or vice versa, initialize the straight section
882: (8)                    with a negligible angle instead (such as ``angle=0.0001``).
883: (4)                .. note::
884: (8)                    There is an alternative version (:class:`ArcPolygonFromArcs`) that is instantiated
885: (8)                    with pre-defined arcs.
886: (4)                See Also
887: (4)                --------
888: (4)                :class:`ArcPolygonFromArcs`
889: (4)                Examples
890: (4)                --------
891: (4)                .. manim:: SeveralArcPolygons
892: (8)                    class SeveralArcPolygons(Scene):
893: (12)                       def construct(self):
894: (16)                           a = [0, 0, 0]
895: (16)                           b = [2, 0, 0]
896: (16)                           c = [0, 2, 0]
897: (16)                           ap1 = ArcPolygon(a, b, c, radius=2)
898: (16)                           ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)
899: (16)                           ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})
900: (16)                           ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,
901: (44)                                                       arc_config=[{'radius': 1.7, 'color': RED},
902: (44)                                                       {'angle': 20*DEGREES, 'color': BLUE},
903: (44)                                                       {'radius': 1}])
904: (16)                           ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()
905: (16)                           self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])
906: (16)                           self.wait()
907: (4)                For further examples see :class:`ArcPolygonFromArcs`.
908: (4)                """
909: (4)                def __init__(
910: (8)                    self,
911: (8)                    *vertices: Point3D,
912: (8)                    angle: float = PI / 4,
913: (8)                    radius: float | None = None,
914: (8)                    arc_config: list[dict] | None = None,
915: (8)                    **kwargs,
916: (4)                ) -> None:
917: (8)                    n = len(vertices)
918: (8)                    point_pairs = [(vertices[k], vertices[(k + 1) % n]) for k in range(n)]
919: (8)                    if not arc_config:
920: (12)                       if radius:
921: (16)                           all_arc_configs = itertools.repeat({"radius": radius}, len(point_pairs))
922: (12)                       else:
923: (16)                           all_arc_configs = itertools.repeat({"angle": angle}, len(point_pairs))
924: (8)                    elif isinstance(arc_config, dict):
925: (12)                       all_arc_configs = itertools.repeat(arc_config, len(point_pairs))
926: (8)                    else:
927: (12)                       assert len(arc_config) == n
928: (12)                       all_arc_configs = arc_config
929: (8)                    arcs = [
930: (12)                       ArcBetweenPoints(*pair, **conf)
931: (12)                       for (pair, conf) in zip(point_pairs, all_arc_configs)
932: (8)                    ]
933: (8)                    super().__init__(**kwargs)
934: (8)                    # Adding the arcs like this makes ArcPolygon double as a VGroup.
935: (8)                    # Also makes changes to the ArcPolygon, such as scaling, affect
936: (8)                    # the arcs, so that their new values are usable.
937: (8)                    self.add(*arcs)
938: (8)                    for arc in arcs:
939: (12)                       self.append_points(arc.points)
940: (8)                    # This enables the use of ArcPolygon.arcs as a convenience
941: (8)                    # because ArcPolygon[0] returns itself, not the first Arc.
942: (8)                    self.arcs = arcs
943: (0)            class ArcPolygonFromArcs(VMobject, metaclass=ConvertToOpenGL):
944: (4)                """A generalized polygon allowing for points to be connected with arcs.
945: (4)                This version takes in pre-defined arcs to generate the arcpolygon and introduces
946: (4)                little new syntax. However unlike :class:`Polygon` it can't be created with points
947: (4)                directly.
948: (4)                For proper appearance the passed arcs should connect seamlessly:
949: (4)                ``[a,b][b,c][c,a]``
950: (4)                If there are any gaps between the arcs, those will be filled in
951: (4)                with straight lines, which can be used deliberately for any straight
952: (4)                sections. Arcs can also be passed as straight lines such as an arc
953: (4)                initialized with ``angle=0``.
954: (4)                Parameters
955: (4)                ----------
956: (4)                arcs
957: (8)                    These are the arcs from which the arcpolygon is assembled.
958: (4)                kwargs
959: (8)                    Keyword arguments that are passed to the constructor of
960: (8)                    :class:`~.VMobject`. Affects how the ArcPolygon itself is drawn,
961: (8)                    but doesn't affect passed arcs.
962: (4)                Attributes
963: (4)                ----------
964: (4)                arcs
965: (8)                    The arcs used to initialize the ArcPolygonFromArcs::
966: (12)                       >>> from manim import ArcPolygonFromArcs, Arc, ArcBetweenPoints
967: (12)                       >>> ap = ArcPolygonFromArcs(Arc(), ArcBetweenPoints([1,0,0], [0,1,0]), Arc())
968: (12)                       >>> ap.arcs
969: (12)                       [Arc, ArcBetweenPoints, Arc]
970: (4)                .. tip::
971: (8)                    Two instances of :class:`ArcPolygon` can be transformed properly into
972: (8)                    one another as well. Be advised that any arc initialized with ``angle=0``
973: (8)                    will actually be a straight line, so if a straight section should seamlessly
974: (8)                    transform into an arced section or vice versa, initialize the straight
975: (8)                    section with a negligible angle instead (such as ``angle=0.0001``).
976: (4)                .. note::
977: (8)                    There is an alternative version (:class:`ArcPolygon`) that can be instantiated
978: (8)                    with points.
979: (4)                .. seealso::
980: (8)                    :class:`ArcPolygon`
981: (4)                Examples
982: (4)                --------
983: (4)                One example of an arcpolygon is the Reuleaux triangle.
984: (4)                Instead of 3 straight lines connecting the outer points,
985: (4)                a Reuleaux triangle has 3 arcs connecting those points,
986: (4)                making a shape with constant width.
987: (4)                Passed arcs are stored as submobjects in the arcpolygon.
988: (4)                This means that the arcs are changed along with the arcpolygon,
989: (4)                for example when it's shifted, and these arcs can be manipulated
990: (4)                after the arcpolygon has been initialized.
991: (4)                Also both the arcs contained in an :class:`~.ArcPolygonFromArcs`, as well as the
992: (4)                arcpolygon itself are drawn, which affects draw time in :class:`~.Create`
993: (4)                for example. In most cases the arcs themselves don't
994: (4)                need to be drawn, in which case they can be passed as invisible.
995: (4)                .. manim:: ArcPolygonExample
996: (8)                    class ArcPolygonExample(Scene):
997: (12)                       def construct(self):
998: (16)                           arc_conf = {"stroke_width": 0}
999: (16)                           poly_conf = {"stroke_width": 10, "stroke_color": BLUE,
1000: (22)                                "fill_opacity": 1, "color": PURPLE}
1001: (16)                          a = [-1, 0, 0]
1002: (16)                          b = [1, 0, 0]
1003: (16)                          c = [0, np.sqrt(3), 0]
1004: (16)                          arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
1005: (16)                          arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
1006: (16)                          arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)
1007: (16)                          reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
1008: (16)                          self.play(FadeIn(reuleaux_tri))
1009: (16)                          self.wait(2)
1010: (4)               The arcpolygon itself can also be hidden so that instead only the contained
1011: (4)               arcs are drawn. This can be used to easily debug arcs or to highlight them.
1012: (4)               .. manim:: ArcPolygonExample2
1013: (8)                   class ArcPolygonExample2(Scene):
1014: (12)                      def construct(self):
1015: (16)                          arc_conf = {"stroke_width": 3, "stroke_color": BLUE,
1016: (20)                              "fill_opacity": 0.5, "color": GREEN}
1017: (16)                          poly_conf = {"color": None}
1018: (16)                          a = [-1, 0, 0]
1019: (16)                          b = [1, 0, 0]
1020: (16)                          c = [0, np.sqrt(3), 0]
1021: (16)                          arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
1022: (16)                          arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
1023: (16)                          arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)
1024: (16)                          reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
1025: (16)                          self.play(FadeIn(reuleaux_tri))
1026: (16)                          self.wait(2)
1027: (4)               """
1028: (4)               def __init__(self, *arcs: Arc | ArcBetweenPoints, **kwargs) -> None:
1029: (8)                   if not all(isinstance(m, (Arc, ArcBetweenPoints)) for m in arcs):
1030: (12)                      raise ValueError(
1031: (16)                          "All ArcPolygon submobjects must be of type Arc/ArcBetweenPoints",
1032: (12)                      )
1033: (8)                   super().__init__(**kwargs)
1034: (8)                   # Adding the arcs like this makes ArcPolygonFromArcs double as a VGroup.
1035: (8)                   # Also makes changes to the ArcPolygonFromArcs, such as scaling, affect
1036: (8)                   # the arcs, so that their new values are usable.
1037: (8)                   self.add(*arcs)
1038: (8)                   # This enables the use of ArcPolygonFromArcs.arcs as a convenience
1039: (8)                   # because ArcPolygonFromArcs[0] returns itself, not the first Arc.
1040: (8)                   self.arcs = [*arcs]
1041: (8)                   from .line import Line
1042: (8)                   for arc1, arc2 in adjacent_pairs(arcs):
1043: (12)                      self.append_points(arc1.points)
1044: (12)                      line = Line(arc1.get_end(), arc2.get_start())
1045: (12)                      len_ratio = line.get_length() / arc1.get_arc_length()
1046: (12)                      if np.isnan(len_ratio) or np.isinf(len_ratio):
1047: (16)                          continue
1048: (12)                      line.insert_n_curves(int(arc1.get_num_curves() * len_ratio))
1049: (12)                      self.append_points(line.points)

----------------------------------------

File 2 - . \logo.py:

1: (0)              """Utilities for Manim's logo and banner."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["ManimBanner"]
4: (0)              import svgelements as se
5: (0)              from manim.animation.updaters.update import UpdateFromAlphaFunc
6: (0)              from manim.mobject.geometry.arc import Circle
7: (0)              from manim.mobject.geometry.polygram import Square, Triangle
8: (0)              from .. import constants as cst
9: (0)              from ..animation.animation import override_animation
10: (0)             from ..animation.composition import AnimationGroup, Succession
11: (0)             from ..animation.creation import Create, SpiralIn
12: (0)             from ..animation.fading import FadeIn
13: (0)             from ..mobject.svg.svg_mobject import VMobjectFromSVGPath
14: (0)             from ..mobject.types.vectorized_mobject import VGroup
15: (0)             from ..utils.rate_functions import ease_in_out_cubic, smooth
16: (0)             MANIM_SVG_PATHS: list[se.Path] = [
17: (4)                 se.Path(  # double stroke letter M
18: (8)                     "M4.64259-2.092154L2.739726-6.625156C2.660025-6.824408 2.650062-6.824408 "
19: (8)                     "2.381071-6.824408H.52802C.348692-6.824408 .199253-6.824408 .199253-6.645"
20: (8)                     "081C.199253-6.475716 .37858-6.475716 .428394-6.475716C.547945-6.475716 ."
21: (8)                     "816936-6.455791 1.036115-6.37609V-1.05604C1.036115-.846824 1.036115-.408"
22: (8)                     "468 .358655-.348692C.169365-.328767 .169365-.18929 .169365-.179328C.1693"
23: (8)                     "65 0 .328767 0 .508095 0H2.052304C2.231631 0 2.381071 0 2.381071-.179328"
24: (8)                     "C2.381071-.268991 2.30137-.33873 2.221669-.348692C1.454545-.408468 1.454"
25: (8)                     "545-.826899 1.454545-1.05604V-6.017435L1.464508-6.027397L3.895392-.20921"
26: (8)                     "5C3.975093-.029888 4.044832 0 4.104608 0C4.224159 0 4.254047-.079701 4.3"
27: (8)                     "03861-.199253L6.744707-6.027397L6.75467-6.017435V-1.05604C6.75467-.84682"
28: (8)                     "4 6.75467-.408468 6.07721-.348692C5.88792-.328767 5.88792-.18929 5.88792"
29: (8)                     "-.179328C5.88792 0 6.047323 0 6.22665 0H8.886675C9.066002 0 9.215442 0 9"
30: (8)                     ".215442-.179328C9.215442-.268991 9.135741-.33873 9.05604-.348692C8.28891"
31: (8)                     "7-.408468 8.288917-.826899 8.288917-1.05604V-5.768369C8.288917-5.977584 "
32: (8)                     "8.288917-6.41594 8.966376-6.475716C9.066002-6.485679 9.155666-6.535492 9"
33: (8)                     ".155666-6.645081C9.155666-6.824408 9.006227-6.824408 8.826899-6.824408H6"
34: (8)                     ".90411C6.645081-6.824408 6.625156-6.824408 6.535492-6.615193L4.64259-2.0"
35: (8)                     "92154ZM4.343711-1.912827C4.423412-1.743462 4.433375-1.733499 4.552927-1."
36: (8)                     "693649L4.11457-.637609H4.094645L1.823163-6.057285C1.77335-6.1868 1.69364"
37: (8)                     "9-6.356164 1.554172-6.475716H2.420922L4.343711-1.912827ZM1.334994-.34869"
38: (8)                     "2H1.165629C1.185554-.37858 1.205479-.408468 1.225405-.428394C1.235367-.4"
39: (8)                     "38356 1.235367-.448319 1.24533-.458281L1.334994-.348692ZM7.103362-6.4757"
40: (8)                     "16H8.159402C7.940224-6.22665 7.940224-5.967621 7.940224-5.788294V-1.0361"
41: (8)                     "15C7.940224-.856787 7.940224-.597758 8.169365-.348692H6.884184C7.103362-"
42: (8)                     ".597758 7.103362-.856787 7.103362-1.036115V-6.475716Z"
43: (4)                 ),
44: (4)                 se.Path(  # letter a
45: (8)                     "M1.464508-4.024907C1.464508-4.234122 1.743462-4.393524 2.092154-4.393524"
46: (8)                     "C2.669988-4.393524 2.929016-4.124533 2.929016-3.516812V-2.789539C1.77335"
47: (8)                     "-2.440847 .249066-2.042341 .249066-.916563C.249066-.308842 .71731 .13947"
48: (8)                     "7 1.354919 .139477C1.92279 .139477 2.381071-.059776 2.929016-.557908C3.0"
49: (8)                     "38605-.049813 3.257783 .139477 3.745953 .139477C4.174346 .139477 4.48318"
50: (8)                     "8-.019925 4.861768-.428394L4.712329-.637609L4.612702-.537983C4.582814-.5"
51: (8)                     "08095 4.552927-.498132 4.503113-.498132C4.363636-.498132 4.293898-.58779"
52: (8)                     "6 4.293898-.747198V-3.347447C4.293898-4.184309 3.536737-4.712329 2.32129"
53: (8)                     "5-4.712329C1.195517-4.712329 .438356-4.204234 .438356-3.457036C.438356-3"
54: (8)                     ".048568 .67746-2.799502 1.085928-2.799502C1.484433-2.799502 1.763387-3.0"
55: (8)                     "38605 1.763387-3.377335C1.763387-3.676214 1.464508-3.88543 1.464508-4.02"
56: (8)                     "4907ZM2.919054-.996264C2.650062-.687422 2.450809-.56787 2.211706-.56787C"
57: (8)                     "1.912827-.56787 1.703611-.836862 1.703611-1.235367C1.703611-1.8132 2.122"
58: (8)                     "042-2.231631 2.919054-2.440847V-.996264Z"
59: (4)                 ),
60: (4)                 se.Path(  # letter n
61: (8)                     "M2.948941-4.044832C3.297634-4.044832 3.466999-3.775841 3.466999-3.217933"
62: (8)                     "V-.806974C3.466999-.438356 3.337484-.278954 2.998755-.239103V0H5.339975V"
63: (8)                     "-.239103C4.951432-.268991 4.851806-.388543 4.851806-.806974V-3.307597C4."
64: (8)                     "851806-4.164384 4.323786-4.712329 3.506849-4.712329C2.909091-4.712329 2."
65: (8)                     "450809-4.433375 2.082192-3.845579V-4.592777H.179328V-4.353674C.617684-4."
66: (8)                     "283935 .707347-4.184309 .707347-3.765878V-.836862C.707347-.418431 .62764"
67: (8)                     "6-.328767 .179328-.239103V0H2.580324V-.239103C2.211706-.288917 2.092154-"
68: (8)                     ".438356 2.092154-.806974V-3.466999C2.092154-3.576588 2.530511-4.044832 2"
69: (8)                     ".948941-4.044832Z"
70: (4)                 ),
71: (4)                 se.Path(  # letter i
72: (8)                     "M2.15193-4.592777H.239103V-4.353674C.67746-4.26401 .767123-4.174346 .767"
73: (8)                     "123-3.765878V-.836862C.767123-.428394 .697385-.348692 .239103-.239103V0H"
74: (8)                     "2.6401V-.239103C2.291407-.288917 2.15193-.428394 2.15193-.806974V-4.5927"
75: (8)                     "77ZM1.454545-6.884184C1.026152-6.884184 .67746-6.535492 .67746-6.117061C"
76: (8)                     ".67746-5.668742 1.006227-5.339975 1.444583-5.339975S2.221669-5.668742 2."
77: (8)                     "221669-6.107098C2.221669-6.535492 1.882939-6.884184 1.454545-6.884184Z"
78: (4)                 ),
79: (4)                 se.Path(  # letter m
80: (8)                     "M2.929016-4.044832C3.317559-4.044832 3.466999-3.815691 3.466999-3.217933"
81: (8)                     "V-.806974C3.466999-.398506 3.35741-.268991 2.988792-.239103V0H5.32005V-."
82: (8)                     "239103C4.971357-.278954 4.851806-.428394 4.851806-.806974V-3.466999C4.85"
83: (8)                     "1806-3.576588 5.310087-4.044832 5.69863-4.044832C6.07721-4.044832 6.2266"
84: (8)                     "5-3.805729 6.22665-3.217933V-.806974C6.22665-.388543 6.117061-.268991 5."
85: (8)                     "738481-.239103V0H8.109589V-.239103C7.721046-.259029 7.611457-.37858 7.61"
86: (8)                     "1457-.806974V-3.307597C7.611457-4.164384 7.083437-4.712329 6.266501-4.71"
87: (8)                     "2329C5.69863-4.712329 5.32005-4.483188 4.801993-3.845579C4.503113-4.4732"
88: (8)                     "25 4.154421-4.712329 3.526775-4.712329S2.440847-4.443337 2.062267-3.8455"
89: (8)                     "79V-4.592777H.179328V-4.353674C.617684-4.293898 .707347-4.174346 .707347"
90: (8)                     "-3.765878V-.836862C.707347-.428394 .617684-.318804 .179328-.239103V0H2.5"
91: (8)                     "50436V-.239103C2.201743-.288917 2.092154-.428394 2.092154-.806974V-3.466"
92: (8)                     "999C2.092154-3.58655 2.530511-4.044832 2.929016-4.044832Z"
93: (4)                 ),
94: (0)             ]
95: (0)             class ManimBanner(VGroup):
96: (4)                 r"""Convenience class representing Manim's banner.
97: (4)                 Can be animated using custom methods.
98: (4)                 Parameters
99: (4)                 ----------
100: (4)                dark_theme
101: (8)                    If ``True`` (the default), the dark theme version of the logo
102: (8)                    (with light text font) will be rendered. Otherwise, if ``False``,
103: (8)                    the light theme version (with dark text font) is used.
104: (4)                Examples
105: (4)                --------
106: (4)                .. manim:: DarkThemeBanner
107: (8)                    class DarkThemeBanner(Scene):
108: (12)                       def construct(self):
109: (16)                           banner = ManimBanner()
110: (16)                           self.play(banner.create())
111: (16)                           self.play(banner.expand())
112: (16)                           self.wait()
113: (16)                           self.play(Unwrite(banner))
114: (4)                .. manim:: LightThemeBanner
115: (8)                    class LightThemeBanner(Scene):
116: (12)                       def construct(self):
117: (16)                           self.camera.background_color = "#ece6e2"
118: (16)                           banner = ManimBanner(dark_theme=False)
119: (16)                           self.play(banner.create())
120: (16)                           self.play(banner.expand())
121: (16)                           self.wait()
122: (16)                           self.play(Unwrite(banner))
123: (4)                """
124: (4)                def __init__(self, dark_theme: bool = True):
125: (8)                    super().__init__()
126: (8)                    logo_green = "#81b29a"
127: (8)                    logo_blue = "#454866"
128: (8)                    logo_red = "#e07a5f"
129: (8)                    m_height_over_anim_height = 0.75748
130: (8)                    self.font_color = "#ece6e2" if dark_theme else "#343434"
131: (8)                    self.scale_factor = 1
132: (8)                    self.M = VMobjectFromSVGPath(MANIM_SVG_PATHS[0]).flip(cst.RIGHT).center()
133: (8)                    self.M.set(stroke_width=0).scale(
134: (12)                       7 * cst.DEFAULT_FONT_SIZE * cst.SCALE_FACTOR_PER_FONT_POINT
135: (8)                    )
136: (8)                    self.M.set_fill(color=self.font_color, opacity=1).shift(
137: (12)                       2.25 * cst.LEFT + 1.5 * cst.UP
138: (8)                    )
139: (8)                    self.circle = Circle(color=logo_green, fill_opacity=1).shift(cst.LEFT)
140: (8)                    self.square = Square(color=logo_blue, fill_opacity=1).shift(cst.UP)
141: (8)                    self.triangle = Triangle(color=logo_red, fill_opacity=1).shift(cst.RIGHT)
142: (8)                    self.shapes = VGroup(self.triangle, self.square, self.circle)
143: (8)                    self.add(self.shapes, self.M)
144: (8)                    self.move_to(cst.ORIGIN)
145: (8)                    anim = VGroup()
146: (8)                    for ind, path in enumerate(MANIM_SVG_PATHS[1:]):
147: (12)                       tex = VMobjectFromSVGPath(path).flip(cst.RIGHT).center()
148: (12)                       tex.set(stroke_width=0).scale(
149: (16)                           cst.DEFAULT_FONT_SIZE * cst.SCALE_FACTOR_PER_FONT_POINT
150: (12)                       )
151: (12)                       if ind > 0:
152: (16)                           tex.next_to(anim, buff=0.01)
153: (12)                       tex.align_to(self.M, cst.DOWN)
154: (12)                       anim.add(tex)
155: (8)                    anim.set_fill(color=self.font_color, opacity=1)
156: (8)                    anim.height = m_height_over_anim_height * self.M.height
157: (8)                    # Note: "anim" is only shown in the expanded state
158: (8)                    # and thus not yet added to the submobjects of self.
159: (8)                    self.anim = anim
160: (4)                def scale(self, scale_factor: float, **kwargs) -> ManimBanner:
161: (8)                    """Scale the banner by the specified scale factor.
162: (8)                    Parameters
163: (8)                    ----------
164: (8)                    scale_factor
165: (12)                       The factor used for scaling the banner.
166: (8)                    Returns
167: (8)                    -------
168: (8)                    :class:`~.ManimBanner`
169: (12)                       The scaled banner.
170: (8)                    """
171: (8)                    self.scale_factor *= scale_factor
172: (8)                    # Note: self.anim is only added to self after expand()
173: (8)                    if self.anim not in self.submobjects:
174: (12)                       self.anim.scale(scale_factor, **kwargs)
175: (8)                    return super().scale(scale_factor, **kwargs)
176: (4)                @override_animation(Create)
177: (4)                def create(self, run_time: float = 2) -> AnimationGroup:
178: (8)                    """The creation animation for Manim's logo.
179: (8)                    Parameters
180: (8)                    ----------
181: (8)                    run_time
182: (12)                       The run time of the animation.
183: (8)                    Returns
184: (8)                    -------
185: (8)                    :class:`~.AnimationGroup`
186: (12)                       An animation to be used in a :meth:`.Scene.play` call.
187: (8)                    """
188: (8)                    return AnimationGroup(
189: (12)                       SpiralIn(self.shapes, run_time=run_time),
190: (12)                       FadeIn(self.M, run_time=run_time / 2),
191: (12)                       lag_ratio=0.1,
192: (8)                    )
193: (4)                def expand(self, run_time: float = 1.5, direction="center") -> Succession:
194: (8)                    """An animation that expands Manim's logo into its banner.
195: (8)                    The returned animation transforms the banner from its initial
196: (8)                    state (representing Manim's logo with just the icons) to its
197: (8)                    expanded state (showing the full name together with the icons).
198: (8)                    See the class documentation for how to use this.
199: (8)                    .. note::
200: (12)                       Before calling this method, the text "anim" is not a
201: (12)                       submobject of the banner object. After the expansion,
202: (12)                       it is added as a submobject so subsequent animations
203: (12)                       to the banner object apply to the text "anim" as well.
204: (8)                    Parameters
205: (8)                    ----------
206: (8)                    run_time
207: (12)                       The run time of the animation.
208: (8)                    direction
209: (12)                       The direction in which the logo is expanded.
210: (8)                    Returns
211: (8)                    -------
212: (8)                    :class:`~.Succession`
213: (12)                       An animation to be used in a :meth:`.Scene.play` call.
214: (8)                    Examples
215: (8)                    --------
216: (8)                    .. manim:: ExpandDirections
217: (12)                       class ExpandDirections(Scene):
218: (16)                           def construct(self):
219: (20)                               banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]
220: (20)                               self.play(
221: (24)                                   banners[0].expand(direction="right"),
222: (24)                                   banners[1].expand(direction="center"),
223: (24)                                   banners[2].expand(direction="left"),
224: (20)                               )
225: (8)                    """
226: (8)                    if direction not in ["left", "right", "center"]:
227: (12)                       raise ValueError("direction must be 'left', 'right' or 'center'.")
228: (8)                    m_shape_offset = 6.25 * self.scale_factor
229: (8)                    shape_sliding_overshoot = self.scale_factor * 0.8
230: (8)                    m_anim_buff = 0.06
231: (8)                    self.anim.next_to(self.M, buff=m_anim_buff).align_to(self.M, cst.DOWN)
232: (8)                    self.anim.set_opacity(0)
233: (8)                    self.shapes.save_state()
234: (8)                    m_clone = self.anim[-1].copy()
235: (8)                    self.add(m_clone)
236: (8)                    m_clone.move_to(self.shapes)
237: (8)                    self.M.save_state()
238: (8)                    left_group = VGroup(self.M, self.anim, m_clone)
239: (8)                    def shift(vector):
240: (12)                       self.shapes.restore()
241: (12)                       left_group.align_to(self.M.saved_state, cst.LEFT)
242: (12)                       if direction == "right":
243: (16)                           self.shapes.shift(vector)
244: (12)                       elif direction == "center":
245: (16)                           self.shapes.shift(vector / 2)
246: (16)                           left_group.shift(-vector / 2)
247: (12)                       elif direction == "left":
248: (16)                           left_group.shift(-vector)
249: (8)                    def slide_and_uncover(mob, alpha):
250: (12)                       shift(alpha * (m_shape_offset + shape_sliding_overshoot) * cst.RIGHT)
251: (12)                       # Add letters when they are covered
252: (12)                       for letter in mob.anim:
253: (16)                           if mob.square.get_center()[0] > letter.get_center()[0]:
254: (20)                               letter.set_opacity(1)
255: (20)                               self.add_to_back(letter)
256: (12)                       # Finish animation
257: (12)                       if alpha == 1:
258: (16)                           self.remove(*[self.anim])
259: (16)                           self.add_to_back(self.anim)
260: (16)                           mob.shapes.set_z_index(0)
261: (16)                           mob.shapes.save_state()
262: (16)                           mob.M.save_state()
263: (8)                    def slide_back(mob, alpha):
264: (12)                       if alpha == 0:
265: (16)                           m_clone.set_opacity(1)
266: (16)                           m_clone.move_to(mob.anim[-1])
267: (16)                           mob.anim.set_opacity(1)
268: (12)                       shift(alpha * shape_sliding_overshoot * cst.LEFT)
269: (12)                       if alpha == 1:
270: (16)                           mob.remove(m_clone)
271: (16)                           mob.add_to_back(mob.shapes)
272: (8)                    return Succession(
273: (12)                       UpdateFromAlphaFunc(
274: (16)                           self,
275: (16)                           slide_and_uncover,
276: (16)                           run_time=run_time * 2 / 3,
277: (16)                           rate_func=ease_in_out_cubic,
278: (12)                       ),
279: (12)                       UpdateFromAlphaFunc(
280: (16)                           self,
281: (16)                           slide_back,
282: (16)                           run_time=run_time * 1 / 3,
283: (16)                           rate_func=smooth,
284: (12)                       ),
285: (8)                    )

----------------------------------------

File 3 - .\geometry \line.py:

1: (0)              r"""Mobjects that are lines or variations of them."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "Line",
5: (4)                  "DashedLine",
6: (4)                  "TangentLine",
7: (4)                  "Elbow",
8: (4)                  "Arrow",
9: (4)                  "Vector",
10: (4)                 "DoubleArrow",
11: (4)                 "Angle",
12: (4)                 "RightAngle",
13: (0)             ]
14: (0)             from typing import TYPE_CHECKING
15: (0)             import numpy as np
16: (0)             from manim import config
17: (0)             from manim.constants import *
18: (0)             from manim.mobject.geometry.arc import Arc, ArcBetweenPoints, Dot, TipableVMobject
19: (0)             from manim.mobject.geometry.tips import ArrowTriangleFilledTip
20: (0)             from manim.mobject.mobject import Mobject
21: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
22: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLMobject
23: (0)             from manim.mobject.types.vectorized_mobject import DashedVMobject, VGroup, VMobject
24: (0)             from manim.utils.color import WHITE
25: (0)             from manim.utils.space_ops import angle_of_vector, line_intersection, normalize
26: (0)             if TYPE_CHECKING:
27: (4)                 from typing_extensions import Self
28: (4)                 from manim.typing import Point2D, Point3D, Vector3D
29: (4)                 from manim.utils.color import ParsableManimColor
30: (4)                 from ..matrix import Matrix  # Avoid circular import
31: (0)             class Line(TipableVMobject):
32: (4)                 def __init__(
33: (8)                     self,
34: (8)                     start: Point3D = LEFT,
35: (8)                     end: Point3D = RIGHT,
36: (8)                     buff: float = 0,
37: (8)                     path_arc: float | None = None,
38: (8)                     **kwargs,
39: (4)                 ) -> None:
40: (8)                     self.dim = 3
41: (8)                     self.buff = buff
42: (8)                     self.path_arc = path_arc
43: (8)                     self._set_start_and_end_attrs(start, end)
44: (8)                     super().__init__(**kwargs)
45: (4)                 def generate_points(self) -> None:
46: (8)                     self.set_points_by_ends(
47: (12)                        start=self.start,
48: (12)                        end=self.end,
49: (12)                        buff=self.buff,
50: (12)                        path_arc=self.path_arc,
51: (8)                     )
52: (4)                 def set_points_by_ends(
53: (8)                     self,
54: (8)                     start: Point3D,
55: (8)                     end: Point3D,
56: (8)                     buff: float = 0,
57: (8)                     path_arc: float = 0,
58: (4)                 ) -> None:
59: (8)                     if path_arc:
60: (12)                        arc = ArcBetweenPoints(self.start, self.end, angle=self.path_arc)
61: (12)                        self.set_points(arc.points)
62: (8)                     else:
63: (12)                        self.set_points_as_corners([start, end])
64: (8)                     self._account_for_buff(buff)
65: (4)                 init_points = generate_points
66: (4)                 def _account_for_buff(self, buff: float) -> Self:
67: (8)                     if buff == 0:
68: (12)                        return
69: (8)                     #
70: (8)                     if self.path_arc == 0:
71: (12)                        length = self.get_length()
72: (8)                     else:
73: (12)                        length = self.get_arc_length()
74: (8)                     #
75: (8)                     if length < 2 * buff:
76: (12)                        return
77: (8)                     buff_proportion = buff / length
78: (8)                     self.pointwise_become_partial(self, buff_proportion, 1 - buff_proportion)
79: (8)                     return self
80: (4)                 def _set_start_and_end_attrs(self, start: Point3D, end: Point3D) -> None:
81: (8)                     # If either start or end are Mobjects, this
82: (8)                     # gives their centers
83: (8)                     rough_start = self._pointify(start)
84: (8)                     rough_end = self._pointify(end)
85: (8)                     vect = normalize(rough_end - rough_start)
86: (8)                     # Now that we know the direction between them,
87: (8)                     # we can find the appropriate boundary point from
88: (8)                     # start and end, if they're mobjects
89: (8)                     self.start = self._pointify(start, vect)
90: (8)                     self.end = self._pointify(end, -vect)
91: (4)                 def _pointify(
92: (8)                     self,
93: (8)                     mob_or_point: Mobject | Point3D,
94: (8)                     direction: Vector3D | None = None,
95: (4)                 ) -> Point3D:
96: (8)                     """Transforms a mobject into its corresponding point. Does nothing if a point is passed.
97: (8)                     ``direction`` determines the location of the point along its bounding box in that direction.
98: (8)                     Parameters
99: (8)                     ----------
100: (8)                    mob_or_point
101: (12)                       The mobject or point.
102: (8)                    direction
103: (12)                       The direction.
104: (8)                    """
105: (8)                    if isinstance(mob_or_point, (Mobject, OpenGLMobject)):
106: (12)                       mob = mob_or_point
107: (12)                       if direction is None:
108: (16)                           return mob.get_center()
109: (12)                       else:
110: (16)                           return mob.get_boundary_point(direction)
111: (8)                    return np.array(mob_or_point)
112: (4)                def set_path_arc(self, new_value: float) -> None:
113: (8)                    self.path_arc = new_value
114: (8)                    self.init_points()
115: (4)                def put_start_and_end_on(self, start: Point3D, end: Point3D) -> Self:
116: (8)                    """Sets starts and end coordinates of a line.
117: (8)                    Examples
118: (8)                    --------
119: (8)                    .. manim:: LineExample
120: (12)                       class LineExample(Scene):
121: (16)                           def construct(self):
122: (20)                               d = VGroup()
123: (20)                               for i in range(0,10):
124: (24)                                   d.add(Dot())
125: (20)                               d.arrange_in_grid(buff=1)
126: (20)                               self.add(d)
127: (20)                               l= Line(d[0], d[1])
128: (20)                               self.add(l)
129: (20)                               self.wait()
130: (20)                               l.put_start_and_end_on(d[1].get_center(), d[2].get_center())
131: (20)                               self.wait()
132: (20)                               l.put_start_and_end_on(d[4].get_center(), d[7].get_center())
133: (20)                               self.wait()
134: (8)                    """
135: (8)                    curr_start, curr_end = self.get_start_and_end()
136: (8)                    if np.all(curr_start == curr_end):
137: (12)                       # TODO, any problems with resetting
138: (12)                       # these attrs?
139: (12)                       self.start = start
140: (12)                       self.end = end
141: (12)                       self.generate_points()
142: (8)                    return super().put_start_and_end_on(start, end)
143: (4)                def get_vector(self) -> Vector3D:
144: (8)                    return self.get_end() - self.get_start()
145: (4)                def get_unit_vector(self) -> Vector3D:
146: (8)                    return normalize(self.get_vector())
147: (4)                def get_angle(self) -> float:
148: (8)                    return angle_of_vector(self.get_vector())
149: (4)                def get_projection(self, point: Point3D) -> Vector3D:
150: (8)                    """Returns the projection of a point onto a line.
151: (8)                    Parameters
152: (8)                    ----------
153: (8)                    point
154: (12)                       The point to which the line is projected.
155: (8)                    """
156: (8)                    start = self.get_start()
157: (8)                    end = self.get_end()
158: (8)                    unit_vect = normalize(end - start)
159: (8)                    return start + np.dot(point - start, unit_vect) * unit_vect
160: (4)                def get_slope(self) -> float:
161: (8)                    return np.tan(self.get_angle())
162: (4)                def set_angle(self, angle: float, about_point: Point3D | None = None) -> Self:
163: (8)                    if about_point is None:
164: (12)                       about_point = self.get_start()
165: (8)                    self.rotate(
166: (12)                       angle - self.get_angle(),
167: (12)                       about_point=about_point,
168: (8)                    )
169: (8)                    return self
170: (4)                def set_length(self, length: float) -> Self:
171: (8)                    return self.scale(length / self.get_length())
172: (0)            class DashedLine(Line):
173: (4)                """A dashed :class:`Line`.
174: (4)                Parameters
175: (4)                ----------
176: (4)                args
177: (8)                    Arguments to be passed to :class:`Line`
178: (4)                dash_length
179: (8)                    The length of each individual dash of the line.
180: (4)                dashed_ratio
181: (8)                    The ratio of dash space to empty space. Range of 0-1.
182: (4)                kwargs
183: (8)                    Additional arguments to be passed to :class:`Line`
184: (4)                .. seealso::
185: (8)                    :class:`~.DashedVMobject`
186: (4)                Examples
187: (4)                --------
188: (4)                .. manim:: DashedLineExample
189: (8)                    :save_last_frame:
190: (8)                    class DashedLineExample(Scene):
191: (12)                       def construct(self):
192: (16)                           # dash_length increased
193: (16)                           dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)
194: (16)                           # normal
195: (16)                           dashed_2 = DashedLine(config.left_side, config.right_side)
196: (16)                           # dashed_ratio decreased
197: (16)                           dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)
198: (16)                           self.add(dashed_1, dashed_2, dashed_3)
199: (4)                """
200: (4)                def __init__(
201: (8)                    self,
202: (8)                    *args,
203: (8)                    dash_length: float = DEFAULT_DASH_LENGTH,
204: (8)                    dashed_ratio: float = 0.5,
205: (8)                    **kwargs,
206: (4)                ) -> None:
207: (8)                    self.dash_length = dash_length
208: (8)                    self.dashed_ratio = dashed_ratio
209: (8)                    super().__init__(*args, **kwargs)
210: (8)                    dashes = DashedVMobject(
211: (12)                       self,
212: (12)                       num_dashes=self._calculate_num_dashes(),
213: (12)                       dashed_ratio=dashed_ratio,
214: (8)                    )
215: (8)                    self.clear_points()
216: (8)                    self.add(*dashes)
217: (4)                def _calculate_num_dashes(self) -> int:
218: (8)                    """Returns the number of dashes in the dashed line.
219: (8)                    Examples
220: (8)                    --------
221: (8)                    ::
222: (12)                       >>> DashedLine()._calculate_num_dashes()
223: (12)                       20
224: (8)                    """
225: (8)                    # Minimum number of dashes has to be 2
226: (8)                    return max(
227: (12)                       2,
228: (12)                       int(np.ceil((self.get_length() / self.dash_length) * self.dashed_ratio)),
229: (8)                    )
230: (4)                def get_start(self) -> Point3D:
231: (8)                    """Returns the start point of the line.
232: (8)                    Examples
233: (8)                    --------
234: (8)                    ::
235: (12)                       >>> DashedLine().get_start()
236: (12)                       array([-1.,  0.,  0.])
237: (8)                    """
238: (8)                    if len(self.submobjects) > 0:
239: (12)                       return self.submobjects[0].get_start()
240: (8)                    else:
241: (12)                       return super().get_start()
242: (4)                def get_end(self) -> Point3D:
243: (8)                    """Returns the end point of the line.
244: (8)                    Examples
245: (8)                    --------
246: (8)                    ::
247: (12)                       >>> DashedLine().get_end()
248: (12)                       array([1., 0., 0.])
249: (8)                    """
250: (8)                    if len(self.submobjects) > 0:
251: (12)                       return self.submobjects[-1].get_end()
252: (8)                    else:
253: (12)                       return super().get_end()
254: (4)                def get_first_handle(self) -> Point3D:
255: (8)                    """Returns the point of the first handle.
256: (8)                    Examples
257: (8)                    --------
258: (8)                    ::
259: (12)                       >>> DashedLine().get_first_handle()
260: (12)                       array([-0.98333333,  0.        ,  0.        ])
261: (8)                    """
262: (8)                    return self.submobjects[0].points[1]
263: (4)                def get_last_handle(self) -> Point3D:
264: (8)                    """Returns the point of the last handle.
265: (8)                    Examples
266: (8)                    --------
267: (8)                    ::
268: (12)                       >>> DashedLine().get_last_handle()
269: (12)                       array([0.98333333, 0.        , 0.        ])
270: (8)                    """
271: (8)                    return self.submobjects[-1].points[-2]
272: (0)            class TangentLine(Line):
273: (4)                """Constructs a line tangent to a :class:`~.VMobject` at a specific point.
274: (4)                Parameters
275: (4)                ----------
276: (4)                vmob
277: (8)                    The VMobject on which the tangent line is drawn.
278: (4)                alpha
279: (8)                    How far along the shape that the line will be constructed. range: 0-1.
280: (4)                length
281: (8)                    Length of the tangent line.
282: (4)                d_alpha
283: (8)                    The ``dx`` value
284: (4)                kwargs
285: (8)                    Additional arguments to be passed to :class:`Line`
286: (4)                .. seealso::
287: (8)                    :meth:`~.VMobject.point_from_proportion`
288: (4)                Examples
289: (4)                --------
290: (4)                .. manim:: TangentLineExample
291: (8)                    :save_last_frame:
292: (8)                    class TangentLineExample(Scene):
293: (12)                       def construct(self):
294: (16)                           circle = Circle(radius=2)
295: (16)                           line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right
296: (16)                           line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left
297: (16)                           self.add(circle, line_1, line_2)
298: (4)                """
299: (4)                def __init__(
300: (8)                    self,
301: (8)                    vmob: VMobject,
302: (8)                    alpha: float,
303: (8)                    length: float = 1,
304: (8)                    d_alpha: float = 1e-6,
305: (8)                    **kwargs,
306: (4)                ) -> None:
307: (8)                    self.length = length
308: (8)                    self.d_alpha = d_alpha
309: (8)                    da = self.d_alpha
310: (8)                    a1 = np.clip(alpha - da, 0, 1)
311: (8)                    a2 = np.clip(alpha + da, 0, 1)
312: (8)                    super().__init__(
313: (12)                       vmob.point_from_proportion(a1), vmob.point_from_proportion(a2), **kwargs
314: (8)                    )
315: (8)                    self.scale(self.length / self.get_length())
316: (0)            class Elbow(VMobject, metaclass=ConvertToOpenGL):
317: (4)                """Two lines that create a right angle about each other: L-shape.
318: (4)                Parameters
319: (4)                ----------
320: (4)                width
321: (8)                    The length of the elbow's sides.
322: (4)                angle
323: (8)                    The rotation of the elbow.
324: (4)                kwargs
325: (8)                    Additional arguments to be passed to :class:`~.VMobject`
326: (4)                .. seealso::
327: (8)                    :class:`RightAngle`
328: (4)                Examples
329: (4)                --------
330: (4)                .. manim:: ElbowExample
331: (8)                    :save_last_frame:
332: (8)                    class ElbowExample(Scene):
333: (12)                       def construct(self):
334: (16)                           elbow_1 = Elbow()
335: (16)                           elbow_2 = Elbow(width=2.0)
336: (16)                           elbow_3 = Elbow(width=2.0, angle=5*PI/4)
337: (16)                           elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)
338: (16)                           self.add(elbow_group)
339: (4)                """
340: (4)                def __init__(self, width: float = 0.2, angle: float = 0, **kwargs) -> None:
341: (8)                    self.angle = angle
342: (8)                    super().__init__(**kwargs)
343: (8)                    self.set_points_as_corners([UP, UP + RIGHT, RIGHT])
344: (8)                    self.scale_to_fit_width(width, about_point=ORIGIN)
345: (8)                    self.rotate(self.angle, about_point=ORIGIN)
346: (0)            class Arrow(Line):
347: (4)                """An arrow.
348: (4)                Parameters
349: (4)                ----------
350: (4)                args
351: (8)                    Arguments to be passed to :class:`Line`.
352: (4)                stroke_width
353: (8)                    The thickness of the arrow. Influenced by :attr:`max_stroke_width_to_length_ratio`.
354: (4)                buff
355: (8)                    The distance of the arrow from its start and end points.
356: (4)                max_tip_length_to_length_ratio
357: (8)                    :attr:`tip_length` scales with the length of the arrow. Increasing this ratio raises the max value of :attr:`tip_length`.
358: (4)                max_stroke_width_to_length_ratio
359: (8)                    :attr:`stroke_width` scales with the length of the arrow. Increasing this ratio ratios the max value of :attr:`stroke_width`.
360: (4)                kwargs
361: (8)                    Additional arguments to be passed to :class:`Line`.
362: (4)                .. seealso::
363: (8)                    :class:`ArrowTip`
364: (8)                    :class:`CurvedArrow`
365: (4)                Examples
366: (4)                --------
367: (4)                .. manim:: ArrowExample
368: (8)                    :save_last_frame:
369: (8)                    from manim.mobject.geometry.tips import ArrowSquareTip
370: (8)                    class ArrowExample(Scene):
371: (12)                       def construct(self):
372: (16)                           arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)
373: (16)                           arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)
374: (16)                           g1 = Group(arrow_1, arrow_2)
375: (16)                           # the effect of buff
376: (16)                           square = Square(color=MAROON_A)
377: (16)                           arrow_3 = Arrow(start=LEFT, end=RIGHT)
378: (16)                           arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)
379: (16)                           g2 = Group(arrow_3, arrow_4, square)
380: (16)                           # a shorter arrow has a shorter tip and smaller stroke width
381: (16)                           arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)
382: (16)                           arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)
383: (16)                           g3 = Group(arrow_5, arrow_6)
384: (16)                           self.add(Group(g1, g2, g3).arrange(buff=2))
385: (4)                .. manim:: ArrowExample
386: (8)                    :save_last_frame:
387: (8)                    class ArrowExample(Scene):
388: (12)                       def construct(self):
389: (16)                           left_group = VGroup()
390: (16)                           # As buff increases, the size of the arrow decreases.
391: (16)                           for buff in np.arange(0, 2.2, 0.45):
392: (20)                               left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)
393: (16)                           # Required to arrange arrows.
394: (16)                           left_group.arrange(DOWN)
395: (16)                           left_group.move_to(4 * LEFT)
396: (16)                           middle_group = VGroup()
397: (16)                           # As max_stroke_width_to_length_ratio gets bigger,
398: (16)                           # the width of stroke increases.
399: (16)                           for i in np.arange(0, 5, 0.5):
400: (20)                               middle_group += Arrow(max_stroke_width_to_length_ratio=i)
401: (16)                           middle_group.arrange(DOWN)
402: (16)                           UR_group = VGroup()
403: (16)                           # As max_tip_length_to_length_ratio increases,
404: (16)                           # the length of the tip increases.
405: (16)                           for i in np.arange(0, 0.3, 0.1):
406: (20)                               UR_group += Arrow(max_tip_length_to_length_ratio=i)
407: (16)                           UR_group.arrange(DOWN)
408: (16)                           UR_group.move_to(4 * RIGHT + 2 * UP)
409: (16)                           DR_group = VGroup()
410: (16)                           DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)
411: (16)                           DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)
412: (16)                           DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)
413: (16)                           DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)
414: (16)                           DR_group.arrange(DOWN)
415: (16)                           DR_group.move_to(4 * RIGHT + 2 * DOWN)
416: (16)                           self.add(left_group, middle_group, UR_group, DR_group)
417: (4)                """
418: (4)                def __init__(
419: (8)                    self,
420: (8)                    *args,
421: (8)                    stroke_width: float = 6,
422: (8)                    buff: float = MED_SMALL_BUFF,
423: (8)                    max_tip_length_to_length_ratio: float = 0.25,
424: (8)                    max_stroke_width_to_length_ratio: float = 5,
425: (8)                    **kwargs,
426: (4)                ) -> None:
427: (8)                    self.max_tip_length_to_length_ratio = max_tip_length_to_length_ratio
428: (8)                    self.max_stroke_width_to_length_ratio = max_stroke_width_to_length_ratio
429: (8)                    tip_shape = kwargs.pop("tip_shape", ArrowTriangleFilledTip)
430: (8)                    super().__init__(*args, buff=buff, stroke_width=stroke_width, **kwargs)
431: (8)                    # TODO, should this be affected when
432: (8)                    # Arrow.set_stroke is called?
433: (8)                    self.initial_stroke_width = self.stroke_width
434: (8)                    self.add_tip(tip_shape=tip_shape)
435: (8)                    self._set_stroke_width_from_length()
436: (4)                def scale(self, factor: float, scale_tips: bool = False, **kwargs) -> Self:
437: (8)                    r"""Scale an arrow, but keep stroke width and arrow tip size fixed.
438: (8)                    .. seealso::
439: (12)                       :meth:`~.Mobject.scale`
440: (8)                    Examples
441: (8)                    --------
442: (8)                    ::
443: (12)                       >>> arrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)
444: (12)                       >>> scaled_arrow = arrow.scale(2)
445: (12)                       >>> np.round(scaled_arrow.get_start_and_end(), 8) + 0
446: (12)                       array([[-2., -2.,  0.],
447: (19)                              [ 2.,  2.,  0.]])
448: (12)                       >>> arrow.tip.length == scaled_arrow.tip.length
449: (12)                       True
450: (8)                    Manually scaling the object using the default method
451: (8)                    :meth:`~.Mobject.scale` does not have the same properties::
452: (12)                       >>> new_arrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)
453: (12)                       >>> another_scaled_arrow = VMobject.scale(new_arrow, 2)
454: (12)                       >>> another_scaled_arrow.tip.length == arrow.tip.length
455: (12)                       False
456: (8)                    """
457: (8)                    if self.get_length() == 0:
458: (12)                       return self
459: (8)                    if scale_tips:
460: (12)                       super().scale(factor, **kwargs)
461: (12)                       self._set_stroke_width_from_length()
462: (12)                       return self
463: (8)                    has_tip = self.has_tip()
464: (8)                    has_start_tip = self.has_start_tip()
465: (8)                    if has_tip or has_start_tip:
466: (12)                       old_tips = self.pop_tips()
467: (8)                    super().scale(factor, **kwargs)
468: (8)                    self._set_stroke_width_from_length()
469: (8)                    if has_tip:
470: (12)                       self.add_tip(tip=old_tips[0])
471: (8)                    if has_start_tip:
472: (12)                       self.add_tip(tip=old_tips[1], at_start=True)
473: (8)                    return self
474: (4)                def get_normal_vector(self) -> Vector3D:
475: (8)                    """Returns the normal of a vector.
476: (8)                    Examples
477: (8)                    --------
478: (8)                    ::
479: (12)                       >>> np.round(Arrow().get_normal_vector()) + 0. # add 0. to avoid negative 0 in output
480: (12)                       array([ 0.,  0., -1.])
481: (8)                    """
482: (8)                    p0, p1, p2 = self.tip.get_start_anchors()[:3]
483: (8)                    return normalize(np.cross(p2 - p1, p1 - p0))
484: (4)                def reset_normal_vector(self) -> Self:
485: (8)                    """Resets the normal of a vector"""
486: (8)                    self.normal_vector = self.get_normal_vector()
487: (8)                    return self
488: (4)                def get_default_tip_length(self) -> float:
489: (8)                    """Returns the default tip_length of the arrow.
490: (8)                    Examples
491: (8)                    --------
492: (8)                    ::
493: (12)                       >>> Arrow().get_default_tip_length()
494: (12)                       0.35
495: (8)                    """
496: (8)                    max_ratio = self.max_tip_length_to_length_ratio
497: (8)                    return min(self.tip_length, max_ratio * self.get_length())
498: (4)                def _set_stroke_width_from_length(self) -> Self:
499: (8)                    """Sets stroke width based on length."""
500: (8)                    max_ratio = self.max_stroke_width_to_length_ratio
501: (8)                    if config.renderer == RendererType.OPENGL:
502: (12)                       self.set_stroke(
503: (16)                           width=min(self.initial_stroke_width, max_ratio * self.get_length()),
504: (16)                           recurse=False,
505: (12)                       )
506: (8)                    else:
507: (12)                       self.set_stroke(
508: (16)                           width=min(self.initial_stroke_width, max_ratio * self.get_length()),
509: (16)                           family=False,
510: (12)                       )
511: (8)                    return self
512: (0)            class Vector(Arrow):
513: (4)                """A vector specialized for use in graphs.
514: (4)                .. caution::
515: (8)                    Do not confuse with the :class:`~.Vector2D`,
516: (8)                    :class:`~.Vector3D` or :class:`~.VectorND` type aliases,
517: (8)                    which are not Mobjects!
518: (4)                Parameters
519: (4)                ----------
520: (4)                direction
521: (8)                    The direction of the arrow.
522: (4)                buff
523: (9)                     The distance of the vector from its endpoints.
524: (4)                kwargs
525: (8)                    Additional arguments to be passed to :class:`Arrow`
526: (4)                Examples
527: (4)                --------
528: (4)                .. manim:: VectorExample
529: (8)                    :save_last_frame:
530: (8)                    class VectorExample(Scene):
531: (12)                       def construct(self):
532: (16)                           plane = NumberPlane()
533: (16)                           vector_1 = Vector([1,2])
534: (16)                           vector_2 = Vector([-5,-2])
535: (16)                           self.add(plane, vector_1, vector_2)
536: (4)                """
537: (4)                def __init__(
538: (8)                    self, direction: Point2D | Point3D = RIGHT, buff: float = 0, **kwargs
539: (4)                ) -> None:
540: (8)                    self.buff = buff
541: (8)                    if len(direction) == 2:
542: (12)                       direction = np.hstack([direction, 0])
543: (8)                    super().__init__(ORIGIN, direction, buff=buff, **kwargs)
544: (4)                def coordinate_label(
545: (8)                    self,
546: (8)                    integer_labels: bool = True,
547: (8)                    n_dim: int = 2,
548: (8)                    color: ParsableManimColor | None = None,
549: (8)                    **kwargs,
550: (4)                ) -> Matrix:
551: (8)                    """Creates a label based on the coordinates of the vector.
552: (8)                    Parameters
553: (8)                    ----------
554: (8)                    integer_labels
555: (12)                       Whether or not to round the coordinates to integers.
556: (8)                    n_dim
557: (12)                       The number of dimensions of the vector.
558: (8)                    color
559: (12)                       Sets the color of label, optional.
560: (8)                    kwargs
561: (12)                       Additional arguments to be passed to :class:`~.Matrix`.
562: (8)                    Returns
563: (8)                    -------
564: (8)                    :class:`~.Matrix`
565: (12)                       The label.
566: (8)                    Examples
567: (8)                    --------
568: (8)                    .. manim:: VectorCoordinateLabel
569: (12)                       :save_last_frame:
570: (12)                       class VectorCoordinateLabel(Scene):
571: (16)                           def construct(self):
572: (20)                               plane = NumberPlane()
573: (20)                               vec_1 = Vector([1, 2])
574: (20)                               vec_2 = Vector([-3, -2])
575: (20)                               label_1 = vec_1.coordinate_label()
576: (20)                               label_2 = vec_2.coordinate_label(color=YELLOW)
577: (20)                               self.add(plane, vec_1, vec_2, label_1, label_2)
578: (8)                    """
579: (8)                    # avoiding circular imports
580: (8)                    from ..matrix import Matrix
581: (8)                    vect = np.array(self.get_end())
582: (8)                    if integer_labels:
583: (12)                       vect = np.round(vect).astype(int)
584: (8)                    vect = vect[:n_dim]
585: (8)                    vect = vect.reshape((n_dim, 1))
586: (8)                    label = Matrix(vect, **kwargs)
587: (8)                    label.scale(LARGE_BUFF - 0.2)
588: (8)                    shift_dir = np.array(self.get_end())
589: (8)                    if shift_dir[0] >= 0:  # Pointing right
590: (12)                       shift_dir -= label.get_left() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * LEFT
591: (8)                    else:  # Pointing left
592: (12)                       shift_dir -= label.get_right() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * RIGHT
593: (8)                    label.shift(shift_dir)
594: (8)                    if color is not None:
595: (12)                       label.set_color(color)
596: (8)                    return label
597: (0)            class DoubleArrow(Arrow):
598: (4)                """An arrow with tips on both ends.
599: (4)                Parameters
600: (4)                ----------
601: (4)                args
602: (8)                    Arguments to be passed to :class:`Arrow`
603: (4)                kwargs
604: (8)                    Additional arguments to be passed to :class:`Arrow`
605: (4)                .. seealso::
606: (8)                    :class:`.~ArrowTip`
607: (8)                    :class:`.~CurvedDoubleArrow`
608: (4)                Examples
609: (4)                --------
610: (4)                .. manim:: DoubleArrowExample
611: (8)                    :save_last_frame:
612: (8)                    from manim.mobject.geometry.tips import ArrowCircleFilledTip
613: (8)                    class DoubleArrowExample(Scene):
614: (12)                       def construct(self):
615: (16)                           circle = Circle(radius=2.0)
616: (16)                           d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())
617: (16)                           d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)
618: (16)                           group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)
619: (16)                           self.add(group)
620: (4)                .. manim:: DoubleArrowExample2
621: (8)                    :save_last_frame:
622: (8)                    class DoubleArrowExample2(Scene):
623: (12)                       def construct(self):
624: (16)                           box = Square()
625: (16)                           p1 = box.get_left()
626: (16)                           p2 = box.get_right()
627: (16)                           d1 = DoubleArrow(p1, p2, buff=0)
628: (16)                           d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)
629: (16)                           d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)
630: (16)                           Group(d1, d2, d3).arrange(DOWN)
631: (16)                           self.add(box, d1, d2, d3)
632: (4)                """
633: (4)                def __init__(self, *args, **kwargs) -> None:
634: (8)                    if "tip_shape_end" in kwargs:
635: (12)                       kwargs["tip_shape"] = kwargs.pop("tip_shape_end")
636: (8)                    tip_shape_start = kwargs.pop("tip_shape_start", ArrowTriangleFilledTip)
637: (8)                    super().__init__(*args, **kwargs)
638: (8)                    self.add_tip(at_start=True, tip_shape=tip_shape_start)
639: (0)            class Angle(VMobject, metaclass=ConvertToOpenGL):
640: (4)                """A circular arc or elbow-type mobject representing an angle of two lines.
641: (4)                Parameters
642: (4)                ----------
643: (4)                line1 :
644: (8)                    The first line.
645: (4)                line2 :
646: (8)                    The second line.
647: (4)                radius :
648: (8)                    The radius of the :class:`Arc`.
649: (4)                quadrant
650: (8)                    A sequence of two :class:`int` numbers determining which of the 4 quadrants should be used.
651: (8)                    The first value indicates whether to anchor the arc on the first line closer to the end point (1)
652: (8)                    or start point (-1), and the second value functions similarly for the
653: (8)                    end (1) or start (-1) of the second line.
654: (8)                    Possibilities: (1,1), (-1,1), (1,-1), (-1,-1).
655: (4)                other_angle :
656: (8)                    Toggles between the two possible angles defined by two points and an arc center. If set to
657: (8)                    False (default), the arc will always go counterclockwise from the point on line1 until
658: (8)                    the point on line2 is reached. If set to True, the angle will go clockwise from line1 to line2.
659: (4)                dot
660: (8)                    Allows for a :class:`Dot` in the arc. Mainly used as an convention to indicate a right angle.
661: (8)                    The dot can be customized in the next three parameters.
662: (4)                dot_radius
663: (8)                    The radius of the :class:`Dot`. If not specified otherwise, this radius will be 1/10 of the arc radius.
664: (4)                dot_distance
665: (8)                    Relative distance from the center to the arc: 0 puts the dot in the center and 1 on the arc itself.
666: (4)                dot_color
667: (8)                    The color of the :class:`Dot`.
668: (4)                elbow
669: (8)                    Produces an elbow-type mobject indicating a right angle, see :class:`RightAngle` for more information
670: (8)                    and a shorthand.
671: (4)                **kwargs
672: (8)                    Further keyword arguments that are passed to the constructor of :class:`Arc` or :class:`Elbow`.
673: (4)                Examples
674: (4)                --------
675: (4)                The first example shows some right angles with a dot in the middle while the second example shows
676: (4)                all 8 possible angles defined by two lines.
677: (4)                .. manim:: RightArcAngleExample
678: (8)                    :save_last_frame:
679: (8)                    class RightArcAngleExample(Scene):
680: (12)                       def construct(self):
681: (16)                           line1 = Line( LEFT, RIGHT )
682: (16)                           line2 = Line( DOWN, UP )
683: (16)                           rightarcangles = [
684: (20)                               Angle(line1, line2, dot=True),
685: (20)                               Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),
686: (20)                               Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),
687: (20)                               Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),
688: (16)                           ]
689: (16)                           plots = VGroup()
690: (16)                           for angle in rightarcangles:
691: (20)                               plot=VGroup(line1.copy(),line2.copy(), angle)
692: (20)                               plots.add(plot)
693: (16)                           plots.arrange(buff=1.5)
694: (16)                           self.add(plots)
695: (4)                .. manim:: AngleExample
696: (8)                    :save_last_frame:
697: (8)                    class AngleExample(Scene):
698: (12)                       def construct(self):
699: (16)                           line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )
700: (16)                           line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )
701: (16)                           angles = [
702: (20)                               Angle(line1, line2),
703: (20)                               Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),
704: (20)                               Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),
705: (20)                               Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),
706: (20)                               Angle(line1, line2, other_angle=True),
707: (20)                               Angle(line1, line2, radius=0.4, quadrant=(1,-1)),
708: (20)                               Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),
709: (20)                               Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),
710: (16)                           ]
711: (16)                           plots = VGroup()
712: (16)                           for angle in angles:
713: (20)                               plot=VGroup(line1.copy(),line2.copy(), angle)
714: (20)                               plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))
715: (16)                           plots.arrange_in_grid(rows=2,buff=1)
716: (16)                           self.add(plots)
717: (4)                .. manim:: FilledAngle
718: (8)                    :save_last_frame:
719: (8)                    class FilledAngle(Scene):
720: (12)                       def construct(self):
721: (16)                           l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)
722: (16)                           l2 = (
723: (20)                               Line(ORIGIN, 2 * UP + RIGHT)
724: (20)                               .set_color(GREEN)
725: (20)                               .rotate(-20 * DEGREES, about_point=ORIGIN)
726: (16)                           )
727: (16)                           norm = l1.get_length()
728: (16)                           a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)
729: (16)                           a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)
730: (16)                           q1 = a1.points #  save all coordinates of points of angle a1
731: (16)                           q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)
732: (16)                           pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point
733: (16)                           mfill = VMobject().set_color(ORANGE)
734: (16)                           mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)
735: (16)                           self.add(l1, l2)
736: (16)                           self.add(mfill)
737: (4)                """
738: (4)                def __init__(
739: (8)                    self,
740: (8)                    line1: Line,
741: (8)                    line2: Line,
742: (8)                    radius: float | None = None,
743: (8)                    quadrant: Point2D = (1, 1),
744: (8)                    other_angle: bool = False,
745: (8)                    dot: bool = False,
746: (8)                    dot_radius: float | None = None,
747: (8)                    dot_distance: float = 0.55,
748: (8)                    dot_color: ParsableManimColor = WHITE,
749: (8)                    elbow: bool = False,
750: (8)                    **kwargs,
751: (4)                ) -> None:
752: (8)                    super().__init__(**kwargs)
753: (8)                    self.lines = (line1, line2)
754: (8)                    self.quadrant = quadrant
755: (8)                    self.dot_distance = dot_distance
756: (8)                    self.elbow = elbow
757: (8)                    inter = line_intersection(
758: (12)                       [line1.get_start(), line1.get_end()],
759: (12)                       [line2.get_start(), line2.get_end()],
760: (8)                    )
761: (8)                    if radius is None:
762: (12)                       if quadrant[0] == 1:
763: (16)                           dist_1 = np.linalg.norm(line1.get_end() - inter)
764: (12)                       else:
765: (16)                           dist_1 = np.linalg.norm(line1.get_start() - inter)
766: (12)                       if quadrant[1] == 1:
767: (16)                           dist_2 = np.linalg.norm(line2.get_end() - inter)
768: (12)                       else:
769: (16)                           dist_2 = np.linalg.norm(line2.get_start() - inter)
770: (12)                       if np.minimum(dist_1, dist_2) < 0.6:
771: (16)                           radius = (2 / 3) * np.minimum(dist_1, dist_2)
772: (12)                       else:
773: (16)                           radius = 0.4
774: (8)                    else:
775: (12)                       self.radius = radius
776: (8)                    anchor_angle_1 = inter + quadrant[0] * radius * line1.get_unit_vector()
777: (8)                    anchor_angle_2 = inter + quadrant[1] * radius * line2.get_unit_vector()
778: (8)                    if elbow:
779: (12)                       anchor_middle = (
780: (16)                           inter
781: (16)                           + quadrant[0] * radius * line1.get_unit_vector()
782: (16)                           + quadrant[1] * radius * line2.get_unit_vector()
783: (12)                       )
784: (12)                       angle_mobject = Elbow(**kwargs)
785: (12)                       angle_mobject.set_points_as_corners(
786: (16)                           [anchor_angle_1, anchor_middle, anchor_angle_2],
787: (12)                       )
788: (8)                    else:
789: (12)                       angle_1 = angle_of_vector(anchor_angle_1 - inter)
790: (12)                       angle_2 = angle_of_vector(anchor_angle_2 - inter)
791: (12)                       if not other_angle:
792: (16)                           start_angle = angle_1
793: (16)                           if angle_2 > angle_1:
794: (20)                               angle_fin = angle_2 - angle_1
795: (16)                           else:
796: (20)                               angle_fin = 2 * np.pi - (angle_1 - angle_2)
797: (12)                       else:
798: (16)                           start_angle = angle_1
799: (16)                           if angle_2 < angle_1:
800: (20)                               angle_fin = -angle_1 + angle_2
801: (16)                           else:
802: (20)                               angle_fin = -2 * np.pi + (angle_2 - angle_1)
803: (12)                       self.angle_value = angle_fin
804: (12)                       angle_mobject = Arc(
805: (16)                           radius=radius,
806: (16)                           angle=self.angle_value,
807: (16)                           start_angle=start_angle,
808: (16)                           arc_center=inter,
809: (16)                           **kwargs,
810: (12)                       )
811: (12)                       if dot:
812: (16)                           if dot_radius is None:
813: (20)                               dot_radius = radius / 10
814: (16)                           else:
815: (20)                               self.dot_radius = dot_radius
816: (16)                           right_dot = Dot(ORIGIN, radius=dot_radius, color=dot_color)
817: (16)                           dot_anchor = (
818: (20)                               inter
819: (20)                               + (angle_mobject.get_center() - inter)
820: (20)                               / np.linalg.norm(angle_mobject.get_center() - inter)
821: (20)                               * radius
822: (20)                               * dot_distance
823: (16)                           )
824: (16)                           right_dot.move_to(dot_anchor)
825: (16)                           self.add(right_dot)
826: (8)                    self.set_points(angle_mobject.points)
827: (4)                def get_lines(self) -> VGroup:
828: (8)                    """Get the lines forming an angle of the :class:`Angle` class.
829: (8)                    Returns
830: (8)                    -------
831: (8)                    :class:`~.VGroup`
832: (12)                       A :class:`~.VGroup` containing the lines that form the angle of the :class:`Angle` class.
833: (8)                    Examples
834: (8)                    --------
835: (8)                    ::
836: (12)                       >>> line_1, line_2 = Line(ORIGIN, RIGHT), Line(ORIGIN, UR)
837: (12)                       >>> angle = Angle(line_1, line_2)
838: (12)                       >>> angle.get_lines()
839: (12)                       VGroup(Line, Line)
840: (8)                    """
841: (8)                    return VGroup(*self.lines)
842: (4)                def get_value(self, degrees: bool = False) -> float:
843: (8)                    """Get the value of an angle of the :class:`Angle` class.
844: (8)                    Parameters
845: (8)                    ----------
846: (8)                    degrees
847: (12)                       A boolean to decide the unit (deg/rad) in which the value of the angle is returned.
848: (8)                    Returns
849: (8)                    -------
850: (8)                    :class:`float`
851: (12)                       The value in degrees/radians of an angle of the :class:`Angle` class.
852: (8)                    Examples
853: (8)                    --------
854: (8)                    .. manim:: GetValueExample
855: (12)                       :save_last_frame:
856: (12)                       class GetValueExample(Scene):
857: (16)                           def construct(self):
858: (20)                               line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)
859: (20)                               line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)
860: (20)                               angle = Angle(line1, line2, radius=0.4)
861: (20)                               value = DecimalNumber(angle.get_value(degrees=True), unit="^{\\circ}")
862: (20)                               value.next_to(angle, UR)
863: (20)                               self.add(line1, line2, angle, value)
864: (8)                    """
865: (8)                    return self.angle_value / DEGREES if degrees else self.angle_value
866: (4)                @staticmethod
867: (4)                def from_three_points(A: Point3D, B: Point3D, C: Point3D, **kwargs) -> Angle:
868: (8)                    """The angle between the lines AB and BC.
869: (8)                    This constructs the angle :math:`\\angle ABC`.
870: (8)                    Parameters
871: (8)                    ----------
872: (8)                    A
873: (12)                       The endpoint of the first angle leg
874: (8)                    B
875: (12)                       The vertex of the angle
876: (8)                    C
877: (12)                       The endpoint of the second angle leg
878: (8)                    **kwargs
879: (12)                       Further keyword arguments are passed to :class:`.Angle`
880: (8)                    Returns
881: (8)                    -------
882: (8)                    The Angle calculated from the three points
883: (20)                               Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),
884: (20)                               Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),
885: (8)                    Examples
886: (8)                    --------
887: (8)                    .. manim:: AngleFromThreePointsExample
888: (12)                       :save_last_frame:
889: (12)                       class AngleFromThreePointsExample(Scene):
890: (16)                           def construct(self):
891: (20)                               sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)
892: (20)                               red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)
893: (20)                               self.add(red_angle, sample_angle)
894: (8)                    """
895: (8)                    return Angle(Line(B, A), Line(B, C), **kwargs)
896: (0)            class RightAngle(Angle):
897: (4)                """An elbow-type mobject representing a right angle between two lines.
898: (4)                Parameters
899: (4)                ----------
900: (4)                line1
901: (8)                    The first line.
902: (4)                line2
903: (8)                    The second line.
904: (4)                length
905: (8)                    The length of the arms.
906: (4)                **kwargs
907: (8)                    Further keyword arguments that are passed to the constructor of :class:`Angle`.
908: (4)                Examples
909: (4)                --------
910: (4)                .. manim:: RightAngleExample
911: (8)                    :save_last_frame:
912: (8)                    class RightAngleExample(Scene):
913: (12)                       def construct(self):
914: (16)                           line1 = Line( LEFT, RIGHT )
915: (16)                           line2 = Line( DOWN, UP )
916: (16)                           rightangles = [
917: (20)                               RightAngle(line1, line2),
918: (20)                               RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),
919: (20)                               RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),
920: (20)                               RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),
921: (16)                           ]
922: (16)                           plots = VGroup()
923: (16)                           for rightangle in rightangles:
924: (20)                               plot=VGroup(line1.copy(),line2.copy(), rightangle)
925: (20)                               plots.add(plot)
926: (16)                           plots.arrange(buff=1.5)
927: (16)                           self.add(plots)
928: (4)                """
929: (4)                def __init__(
930: (8)                    self, line1: Line, line2: Line, length: float | None = None, **kwargs
931: (4)                ) -> None:
932: (8)                    super().__init__(line1, line2, radius=length, elbow=True, **kwargs)

----------------------------------------

File 4 - .\geometry \tips.py:

1: (0)              r"""A collection of tip mobjects for use with :class:`~.TipableVMobject`."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "ArrowTip",
5: (4)                  "ArrowCircleFilledTip",
6: (4)                  "ArrowCircleTip",
7: (4)                  "ArrowSquareTip",
8: (4)                  "ArrowSquareFilledTip",
9: (4)                  "ArrowTriangleTip",
10: (4)                 "ArrowTriangleFilledTip",
11: (4)                 "StealthTip",
12: (0)             ]
13: (0)             from typing import TYPE_CHECKING
14: (0)             import numpy as np
15: (0)             from manim.constants import *
16: (0)             from manim.mobject.geometry.arc import Circle
17: (0)             from manim.mobject.geometry.polygram import Square, Triangle
18: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
19: (0)             from manim.mobject.types.vectorized_mobject import VMobject
20: (0)             from manim.utils.space_ops import angle_of_vector
21: (0)             if TYPE_CHECKING:
22: (4)                 from manim.typing import Point3D, Vector3D
23: (0)             class ArrowTip(VMobject, metaclass=ConvertToOpenGL):
24: (4)                 r"""Base class for arrow tips.
25: (4)                 .. seealso::
26: (8)                     :class:`ArrowTriangleTip`
27: (8)                     :class:`ArrowTriangleFilledTip`
28: (8)                     :class:`ArrowCircleTip`
29: (8)                     :class:`ArrowCircleFilledTip`
30: (8)                     :class:`ArrowSquareTip`
31: (8)                     :class:`ArrowSquareFilledTip`
32: (8)                     :class:`StealthTip`
33: (4)                 Examples
34: (4)                 --------
35: (4)                 Cannot be used directly, only intended for inheritance::
36: (8)                     >>> tip = ArrowTip()
37: (8)                     Traceback (most recent call last):
38: (8)                     ...
39: (8)                     NotImplementedError: Has to be implemented in inheriting subclasses.
40: (4)                 Instead, use one of the pre-defined ones, or make
41: (4)                 a custom one like this:
42: (4)                 .. manim:: CustomTipExample
43: (8)                     >>> from manim import RegularPolygon, Arrow
44: (8)                     >>> class MyCustomArrowTip(ArrowTip, RegularPolygon):
45: (8)                     ...     def __init__(self, length=0.35, **kwargs):
46: (8)                     ...         RegularPolygon.__init__(self, n=5, **kwargs)
47: (8)                     ...         self.width = length
48: (8)                     ...         self.stretch_to_fit_height(length)
49: (8)                     >>> arr = Arrow(np.array([-2, -2, 0]), np.array([2, 2, 0]),
50: (8)                     ...             tip_shape=MyCustomArrowTip)
51: (8)                     >>> isinstance(arr.tip, RegularPolygon)
52: (8)                     True
53: (8)                     >>> from manim import Scene, Create
54: (8)                     >>> class CustomTipExample(Scene):
55: (8)                     ...     def construct(self):
56: (8)                     ...         self.play(Create(arr))
57: (4)                 Using a class inherited from :class:`ArrowTip` to get a non-filled
58: (4)                 tip is a shorthand to manually specifying the arrow tip style as follows::
59: (8)                     >>> arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]),
60: (8)                     ...               tip_style={'fill_opacity': 0, 'stroke_width': 3})
61: (4)                 The following example illustrates the usage of all of the predefined
62: (4)                 arrow tips.
63: (4)                 .. manim:: ArrowTipsShowcase
64: (8)                     :save_last_frame:
65: (8)                     class ArrowTipsShowcase(Scene):
66: (12)                        def construct(self):
67: (16)                            tip_names = [
68: (20)                                'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',
69: (20)                                'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'
70: (16)                            ]
71: (16)                            big_arrows = [
72: (20)                                Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),
73: (20)                                Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),
74: (20)                                Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),
75: (20)                                Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),
76: (20)                                Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),
77: (20)                                Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),
78: (20)                                Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),
79: (20)                                Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)
80: (16)                            ]
81: (16)                            small_arrows = (
82: (20)                                arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows
83: (16)                            )
84: (16)                            labels = (
85: (20)                                Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))
86: (16)                            )
87: (16)                            self.add(*big_arrows, *small_arrows, *labels)
88: (4)                 """
89: (4)                 def __init__(self, *args, **kwargs) -> None:
90: (8)                     raise NotImplementedError("Has to be implemented in inheriting subclasses.")
91: (4)                 @property
92: (4)                 def base(self) -> Point3D:
93: (8)                     r"""The base point of the arrow tip.
94: (8)                     This is the point connecting to the arrow line.
95: (8)                     Examples
96: (8)                     --------
97: (8)                     ::
98: (12)                        >>> from manim import Arrow
99: (12)                        >>> arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)
100: (12)                       >>> arrow.tip.base.round(2) + 0.  # add 0. to avoid negative 0 in output
101: (12)                       array([1.65, 0.  , 0.  ])
102: (8)                    """
103: (8)                    return self.point_from_proportion(0.5)
104: (4)                @property
105: (4)                def tip_point(self) -> Point3D:
106: (8)                    r"""The tip point of the arrow tip.
107: (8)                    Examples
108: (8)                    --------
109: (8)                    ::
110: (12)                       >>> from manim import Arrow
111: (12)                       >>> arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)
112: (12)                       >>> arrow.tip.tip_point.round(2) + 0.
113: (12)                       array([2., 0., 0.])
114: (8)                    """
115: (8)                    return self.points[0]
116: (4)                @property
117: (4)                def vector(self) -> Vector3D:
118: (8)                    r"""The vector pointing from the base point to the tip point.
119: (8)                    Examples
120: (8)                    --------
121: (8)                    ::
122: (12)                       >>> from manim import Arrow
123: (12)                       >>> arrow = Arrow(np.array([0, 0, 0]), np.array([2, 2, 0]), buff=0)
124: (12)                       >>> arrow.tip.vector.round(2) + 0.
125: (12)                       array([0.25, 0.25, 0.  ])
126: (8)                    """
127: (8)                    return self.tip_point - self.base
128: (4)                @property
129: (4)                def tip_angle(self) -> float:
130: (8)                    r"""The angle of the arrow tip.
131: (8)                    Examples
132: (8)                    --------
133: (8)                    ::
134: (12)                       >>> from manim import Arrow
135: (12)                       >>> arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]), buff=0)
136: (12)                       >>> round(arrow.tip.tip_angle, 5) == round(PI/4, 5)
137: (12)                       True
138: (8)                    """
139: (8)                    return angle_of_vector(self.vector)
140: (4)                @property
141: (4)                def length(self) -> np.floating:
142: (8)                    r"""The length of the arrow tip.
143: (8)                    Examples
144: (8)                    --------
145: (8)                    ::
146: (12)                       >>> from manim import Arrow
147: (12)                       >>> arrow = Arrow(np.array([0, 0, 0]), np.array([1, 2, 0]))
148: (12)                       >>> round(arrow.tip.length, 3)
149: (12)                       0.35
150: (8)                    """
151: (8)                    return np.linalg.norm(self.vector)
152: (0)            class StealthTip(ArrowTip):
153: (4)                r"""'Stealth' fighter / kite arrow shape.
154: (4)                Naming is inspired by the corresponding
155: (4)                `TikZ arrow shape <https://tikz.dev/tikz-arrows#sec-16.3>`__.
156: (4)                """
157: (4)                def __init__(
158: (8)                    self,
159: (8)                    fill_opacity=1,
160: (8)                    stroke_width=3,
161: (8)                    length=DEFAULT_ARROW_TIP_LENGTH / 2,
162: (8)                    start_angle=PI,
163: (8)                    **kwargs,
164: (4)                ):
165: (8)                    self.start_angle = start_angle
166: (8)                    VMobject.__init__(
167: (12)                       self, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs
168: (8)                    )
169: (8)                    self.set_points_as_corners(
170: (12)                       [
171: (16)                           [2, 0, 0],  # tip
172: (16)                           [-1.2, 1.6, 0],
173: (16)                           [0, 0, 0],  # base
174: (16)                           [-1.2, -1.6, 0],
175: (16)                           [2, 0, 0],  # close path, back to tip
176: (12)                       ]
177: (8)                    )
178: (8)                    self.scale(length / self.length)
179: (4)                @property
180: (4)                def length(self):
181: (8)                    """The length of the arrow tip.
182: (8)                    In this case, the length is computed as the height of
183: (8)                    the triangle encompassing the stealth tip (otherwise,
184: (8)                    the tip is scaled too large).
185: (8)                    """
186: (8)                    return np.linalg.norm(self.vector) * 1.6
187: (0)            class ArrowTriangleTip(ArrowTip, Triangle):
188: (4)                r"""Triangular arrow tip."""
189: (4)                def __init__(
190: (8)                    self,
191: (8)                    fill_opacity: float = 0,
192: (8)                    stroke_width: float = 3,
193: (8)                    length: float = DEFAULT_ARROW_TIP_LENGTH,
194: (8)                    width: float = DEFAULT_ARROW_TIP_LENGTH,
195: (8)                    start_angle: float = PI,
196: (8)                    **kwargs,
197: (4)                ) -> None:
198: (8)                    Triangle.__init__(
199: (12)                       self,
200: (12)                       fill_opacity=fill_opacity,
201: (12)                       stroke_width=stroke_width,
202: (12)                       start_angle=start_angle,
203: (12)                       **kwargs,
204: (8)                    )
205: (8)                    self.width = width
206: (8)                    self.stretch_to_fit_width(length)
207: (8)                    self.stretch_to_fit_height(width)
208: (0)            class ArrowTriangleFilledTip(ArrowTriangleTip):
209: (4)                r"""Triangular arrow tip with filled tip.
210: (4)                This is the default arrow tip shape.
211: (4)                """
212: (4)                def __init__(
213: (8)                    self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs
214: (4)                ) -> None:
215: (8)                    super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)
216: (0)            class ArrowCircleTip(ArrowTip, Circle):
217: (4)                r"""Circular arrow tip."""
218: (4)                def __init__(
219: (8)                    self,
220: (8)                    fill_opacity: float = 0,
221: (8)                    stroke_width: float = 3,
222: (8)                    length: float = DEFAULT_ARROW_TIP_LENGTH,
223: (8)                    start_angle: float = PI,
224: (8)                    **kwargs,
225: (4)                ) -> None:
226: (8)                    self.start_angle = start_angle
227: (8)                    Circle.__init__(
228: (12)                       self, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs
229: (8)                    )
230: (8)                    self.width = length
231: (8)                    self.stretch_to_fit_height(length)
232: (0)            class ArrowCircleFilledTip(ArrowCircleTip):
233: (4)                r"""Circular arrow tip with filled tip."""
234: (4)                def __init__(
235: (8)                    self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs
236: (4)                ) -> None:
237: (8)                    super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)
238: (0)            class ArrowSquareTip(ArrowTip, Square):
239: (4)                r"""Square arrow tip."""
240: (4)                def __init__(
241: (8)                    self,
242: (8)                    fill_opacity: float = 0,
243: (8)                    stroke_width: float = 3,
244: (8)                    length: float = DEFAULT_ARROW_TIP_LENGTH,
245: (8)                    start_angle: float = PI,
246: (8)                    **kwargs,
247: (4)                ) -> None:
248: (8)                    self.start_angle = start_angle
249: (8)                    Square.__init__(
250: (12)                       self,
251: (12)                       fill_opacity=fill_opacity,
252: (12)                       stroke_width=stroke_width,
253: (12)                       side_length=length,
254: (12)                       **kwargs,
255: (8)                    )
256: (8)                    self.width = length
257: (8)                    self.stretch_to_fit_height(length)
258: (0)            class ArrowSquareFilledTip(ArrowSquareTip):
259: (4)                r"""Square arrow tip with filled tip."""
260: (4)                def __init__(
261: (8)                    self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs
262: (4)                ) -> None:
263: (8)                    super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)

----------------------------------------

File 5 - . \frame.py:

1: (0)              """Special rectangles."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "ScreenRectangle",
5: (4)                  "FullScreenRectangle",
6: (0)              ]
7: (0)              from manim.mobject.geometry.polygram import Rectangle
8: (0)              from .. import config
9: (0)              class ScreenRectangle(Rectangle):
10: (4)                 def __init__(self, aspect_ratio=16.0 / 9.0, height=4, **kwargs):
11: (8)                     super().__init__(width=aspect_ratio * height, height=height, **kwargs)
12: (4)                 @property
13: (4)                 def aspect_ratio(self):
14: (8)                     """The aspect ratio.
15: (8)                     When set, the width is stretched to accommodate
16: (8)                     the new aspect ratio.
17: (8)                     """
18: (8)                     return self.width / self.height
19: (4)                 @aspect_ratio.setter
20: (4)                 def aspect_ratio(self, value):
21: (8)                     self.stretch_to_fit_width(value * self.height)
22: (0)             class FullScreenRectangle(ScreenRectangle):
23: (4)                 def __init__(self, **kwargs):
24: (8)                     super().__init__(**kwargs)
25: (8)                     self.height = config["frame_height"]

----------------------------------------

File 6 - . \graph.py:

1: (0)              """Mobjects used to represent mathematical graphs (think graph theory, not plotting)."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "Graph",
5: (4)                  "DiGraph",
6: (0)              ]
7: (0)              import itertools as it
8: (0)              from copy import copy
9: (0)              from typing import TYPE_CHECKING, Any, Hashable, Iterable, Literal, Protocol, cast
10: (0)             import networkx as nx
11: (0)             import numpy as np
12: (0)             if TYPE_CHECKING:
13: (4)                 from typing_extensions import TypeAlias
14: (4)                 from manim.typing import Point3D
15: (4)                 NxGraph: TypeAlias = nx.classes.graph.Graph | nx.classes.digraph.DiGraph
16: (0)             from manim.animation.composition import AnimationGroup
17: (0)             from manim.animation.creation import Create, Uncreate
18: (0)             from manim.mobject.geometry.arc import Dot, LabeledDot
19: (0)             from manim.mobject.geometry.line import Line
20: (0)             from manim.mobject.mobject import Mobject, override_animate
21: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
22: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLMobject
23: (0)             from manim.mobject.text.tex_mobject import MathTex
24: (0)             from manim.mobject.types.vectorized_mobject import VMobject
25: (0)             from manim.utils.color import BLACK
26: (0)             class LayoutFunction(Protocol):
27: (4)                 """A protocol for automatic layout functions that compute a layout for a graph to be used in :meth:`~.Graph.change_layout`.
28: (4)                 .. note:: The layout function must be a pure function, i.e., it must not modify the graph passed to it.
29: (4)                 Examples
30: (4)                 --------
31: (4)                 Here is an example that arranges nodes in an n x m grid in sorted order.
32: (4)                 .. manim:: CustomLayoutExample
33: (8)                     :save_last_frame:
34: (8)                     class CustomLayoutExample(Scene):
35: (12)                        def construct(self):
36: (16)                            import numpy as np
37: (16)                            import networkx as nx
38: (16)                            # create custom layout
39: (16)                            def custom_layout(
40: (20)                                graph: nx.Graph,
41: (20)                                scale: float | tuple[float, float, float] = 2,
42: (20)                                n: int | None = None,
43: (20)                                *args: Any,
44: (20)                                **kwargs: Any,
45: (16)                            ):
46: (20)                                nodes = sorted(list(graph))
47: (20)                                height = len(nodes) // n
48: (20)                                return {
49: (24)                                    node: (scale * np.array([
50: (28)                                        (i % n) - (n-1)/2,
51: (28)                                        -(i // n) + height/2,
52: (28)                                        0
53: (24)                                    ])) for i, node in enumerate(graph)
54: (20)                                }
55: (16)                            # draw graph
56: (16)                            n = 4
57: (16)                            graph = Graph(
58: (20)                                [i for i in range(4 * 2 - 1)],
59: (20)                                [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],
60: (20)                                labels=True,
61: (20)                                layout=custom_layout,
62: (20)                                layout_config={'n': n}
63: (16)                            )
64: (16)                            self.add(graph)
65: (4)                 Several automatic layouts are provided by manim, and can be used by passing their name as the ``layout`` parameter to :meth:`~.Graph.change_layout`.
66: (4)                 Alternatively, a custom layout function can be passed to :meth:`~.Graph.change_layout` as the ``layout`` parameter. Such a function must adhere to the :class:`~.LayoutFunction` protocol.
67: (4)                 The :class:`~.LayoutFunction` s provided by manim are illustrated below:
68: (4)                 - Circular Layout: places the vertices on a circle
69: (4)                 .. manim:: CircularLayout
70: (8)                     :save_last_frame:
71: (8)                     class CircularLayout(Scene):
72: (12)                        def construct(self):
73: (16)                            graph = Graph(
74: (20)                                [1, 2, 3, 4, 5, 6],
75: (20)                                [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
76: (20)                                layout="circular",
77: (20)                                labels=True
78: (16)                            )
79: (16)                            self.add(graph)
80: (4)                 - Kamada Kawai Layout: tries to place the vertices such that the given distances between them are respected
81: (4)                 .. manim:: KamadaKawaiLayout
82: (8)                     :save_last_frame:
83: (8)                     class KamadaKawaiLayout(Scene):
84: (12)                        def construct(self):
85: (16)                            from collections import defaultdict
86: (16)                            distances: dict[int, dict[int, float]] = defaultdict(dict)
87: (16)                            # set desired distances
88: (16)                            distances[1][2] = 1  # distance between vertices 1 and 2 is 1
89: (16)                            distances[2][3] = 1  # distance between vertices 2 and 3 is 1
90: (16)                            distances[3][4] = 2  # etc
91: (16)                            distances[4][5] = 3
92: (16)                            distances[5][6] = 5
93: (16)                            distances[6][1] = 8
94: (16)                            graph = Graph(
95: (20)                                [1, 2, 3, 4, 5, 6],
96: (20)                                [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],
97: (20)                                layout="kamada_kawai",
98: (20)                                layout_config={"dist": distances},
99: (20)                                layout_scale=4,
100: (20)                               labels=True
101: (16)                           )
102: (16)                           self.add(graph)
103: (4)                - Partite Layout: places vertices into distinct partitions
104: (4)                .. manim:: PartiteLayout
105: (8)                    :save_last_frame:
106: (8)                    class PartiteLayout(Scene):
107: (12)                       def construct(self):
108: (16)                           graph = Graph(
109: (20)                               [1, 2, 3, 4, 5, 6],
110: (20)                               [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
111: (20)                               layout="partite",
112: (20)                               layout_config={"partitions": [[1,2],[3,4],[5,6]]},
113: (20)                               labels=True
114: (16)                           )
115: (16)                           self.add(graph)
116: (4)                - Planar Layout: places vertices such that edges do not cross
117: (4)                .. manim:: PlanarLayout
118: (8)                    :save_last_frame:
119: (8)                    class PlanarLayout(Scene):
120: (12)                       def construct(self):
121: (16)                           graph = Graph(
122: (20)                               [1, 2, 3, 4, 5, 6],
123: (20)                               [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
124: (20)                               layout="planar",
125: (20)                               layout_scale=4,
126: (20)                               labels=True
127: (16)                           )
128: (16)                           self.add(graph)
129: (4)                - Random Layout: randomly places vertices
130: (4)                .. manim:: RandomLayout
131: (8)                    :save_last_frame:
132: (8)                    class RandomLayout(Scene):
133: (12)                       def construct(self):
134: (16)                           graph = Graph(
135: (20)                               [1, 2, 3, 4, 5, 6],
136: (20)                               [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
137: (20)                               layout="random",
138: (20)                               labels=True
139: (16)                           )
140: (16)                           self.add(graph)
141: (4)                - Shell Layout: places vertices in concentric circles
142: (4)                .. manim:: ShellLayout
143: (8)                    :save_last_frame:
144: (8)                    class ShellLayout(Scene):
145: (12)                       def construct(self):
146: (16)                           nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]
147: (16)                           graph = Graph(
148: (20)                               [1, 2, 3, 4, 5, 6, 7, 8, 9],
149: (20)                               [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],
150: (20)                               layout="shell",
151: (20)                               layout_config={"nlist": nlist},
152: (20)                               labels=True
153: (16)                           )
154: (16)                           self.add(graph)
155: (4)                - Spectral Layout: places vertices using the eigenvectors of the graph Laplacian (clusters nodes which are an approximation of the ratio cut)
156: (4)                .. manim:: SpectralLayout
157: (8)                    :save_last_frame:
158: (8)                    class SpectralLayout(Scene):
159: (12)                       def construct(self):
160: (16)                           graph = Graph(
161: (20)                               [1, 2, 3, 4, 5, 6],
162: (20)                               [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
163: (20)                               layout="spectral",
164: (20)                               labels=True
165: (16)                           )
166: (16)                           self.add(graph)
167: (4)                - Sprial Layout: places vertices in a spiraling pattern
168: (4)                .. manim:: SpiralLayout
169: (8)                    :save_last_frame:
170: (8)                    class SpiralLayout(Scene):
171: (12)                       def construct(self):
172: (16)                           graph = Graph(
173: (20)                               [1, 2, 3, 4, 5, 6],
174: (20)                               [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
175: (20)                               layout="spiral",
176: (20)                               labels=True
177: (16)                           )
178: (16)                           self.add(graph)
179: (4)                - Spring Layout: places nodes according to the Fruchterman-Reingold force-directed algorithm (attempts to minimize edge length while maximizing node separation)
180: (4)                .. manim:: SpringLayout
181: (8)                    :save_last_frame:
182: (8)                    class SpringLayout(Scene):
183: (12)                       def construct(self):
184: (16)                           graph = Graph(
185: (20)                               [1, 2, 3, 4, 5, 6],
186: (20)                               [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
187: (20)                               layout="spring",
188: (20)                               labels=True
189: (16)                           )
190: (16)                           self.add(graph)
191: (4)                - Tree Layout: places vertices into a tree with a root node and branches (can only be used with legal trees)
192: (4)                .. manim:: TreeLayout
193: (8)                    :save_last_frame:
194: (8)                    class TreeLayout(Scene):
195: (12)                       def construct(self):
196: (16)                           graph = Graph(
197: (20)                               [1, 2, 3, 4, 5, 6, 7],
198: (20)                               [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],
199: (20)                               layout="tree",
200: (20)                               layout_config={"root_vertex": 1},
201: (20)                               labels=True
202: (16)                           )
203: (16)                           self.add(graph)
204: (4)                """
205: (4)                def __call__(
206: (8)                    self,
207: (8)                    graph: NxGraph,
208: (8)                    scale: float | tuple[float, float, float] = 2,
209: (8)                    *args: Any,
210: (8)                    **kwargs: Any,
211: (4)                ) -> dict[Hashable, Point3D]:
212: (8)                    """Given a graph and a scale, return a dictionary of coordinates.
213: (8)                    Parameters
214: (8)                    ----------
215: (8)                    graph : NxGraph
216: (12)                       The underlying NetworkX graph to be laid out. DO NOT MODIFY.
217: (8)                    scale : float | tuple[float, float, float], optional
218: (12)                       Either a single float value, or a tuple of three float values specifying the scale along each axis.
219: (8)                    Returns
220: (8)                    -------
221: (8)                    dict[Hashable, Point3D]
222: (12)                       A dictionary mapping vertices to their positions.
223: (8)                    """
224: (8)                    ...
225: (0)            def _partite_layout(
226: (4)                nx_graph: NxGraph,
227: (4)                scale: float = 2,
228: (4)                partitions: list[list[Hashable]] | None = None,
229: (4)                **kwargs: Any,
230: (0)            ) -> dict[Hashable, Point3D]:
231: (4)                if partitions is None or len(partitions) == 0:
232: (8)                    raise ValueError(
233: (12)                       "The partite layout requires partitions parameter to contain the partition of the vertices",
234: (8)                    )
235: (4)                partition_count = len(partitions)
236: (4)                for i in range(partition_count):
237: (8)                    for v in partitions[i]:
238: (12)                       if nx_graph.nodes[v] is None:
239: (16)                           raise ValueError(
240: (20)                               "The partition must contain arrays of vertices in the graph",
241: (16)                           )
242: (12)                       nx_graph.nodes[v]["subset"] = i
243: (4)                # Add missing vertices to their own side
244: (4)                for v in nx_graph.nodes:
245: (8)                    if "subset" not in nx_graph.nodes[v]:
246: (12)                       nx_graph.nodes[v]["subset"] = partition_count
247: (4)                return nx.layout.multipartite_layout(nx_graph, scale=scale, **kwargs)
248: (0)            def _random_layout(nx_graph: NxGraph, scale: float = 2, **kwargs: Any):
249: (4)                # the random layout places coordinates in [0, 1)
250: (4)                # we need to rescale manually afterwards...
251: (4)                auto_layout = nx.layout.random_layout(nx_graph, **kwargs)
252: (4)                for k, v in auto_layout.items():
253: (8)                    auto_layout[k] = 2 * scale * (v - np.array([0.5, 0.5]))
254: (4)                return {k: np.append(v, [0]) for k, v in auto_layout.items()}
255: (0)            def _tree_layout(
256: (4)                T: NxGraph,
257: (4)                root_vertex: Hashable | None = None,
258: (4)                scale: float | tuple | None = 2,
259: (4)                vertex_spacing: tuple | None = None,
260: (4)                orientation: str = "down",
261: (0)            ):
262: (4)                if root_vertex is None:
263: (8)                    raise ValueError("The tree layout requires the root_vertex parameter")
264: (4)                if not nx.is_tree(T):
265: (8)                    raise ValueError("The tree layout must be used with trees")
266: (4)                children = {root_vertex: list(T.neighbors(root_vertex))}
267: (4)                # The following code is SageMath's tree layout implementation, taken from
268: (4)                # https://github.com/sagemath/sage/blob/cc60cfebc4576fed8b01f0fc487271bdee3cefed/src/sage/graphs/graph_plot.py#L1447
269: (4)                # Always make a copy of the children because they get eaten
270: (4)                stack = [list(children[root_vertex]).copy()]
271: (4)                stick = [root_vertex]
272: (4)                parent = {u: root_vertex for u in children[root_vertex]}
273: (4)                pos = {}
274: (4)                obstruction = [0.0] * len(T)
275: (4)                if orientation == "down":
276: (8)                    o = -1
277: (4)                else:
278: (8)                    o = 1
279: (4)                def slide(v, dx):
280: (8)                    """
281: (8)                    Shift the vertex v and its descendants to the right by dx.
282: (8)                    Precondition: v and its descendents have already had their
283: (8)                    positions computed.
284: (8)                    """
285: (8)                    level = [v]
286: (8)                    while level:
287: (12)                       nextlevel = []
288: (12)                       for u in level:
289: (16)                           x, y = pos[u]
290: (16)                           x += dx
291: (16)                           obstruction[y] = max(x + 1, obstruction[y])
292: (16)                           pos[u] = x, y
293: (16)                           nextlevel += children[u]
294: (12)                       level = nextlevel
295: (4)                while stack:
296: (8)                    C = stack[-1]
297: (8)                    if not C:
298: (12)                       p = stick.pop()
299: (12)                       stack.pop()
300: (12)                       cp = children[p]
301: (12)                       y = o * len(stack)
302: (12)                       if not cp:
303: (16)                           x = obstruction[y]
304: (16)                           pos[p] = x, y
305: (12)                       else:
306: (16)                           x = sum(pos[c][0] for c in cp) / float(len(cp))
307: (16)                           pos[p] = x, y
308: (16)                           ox = obstruction[y]
309: (16)                           if x < ox:
310: (20)                               slide(p, ox - x)
311: (20)                               x = ox
312: (12)                       obstruction[y] = x + 1
313: (12)                       continue
314: (8)                    t = C.pop()
315: (8)                    pt = parent[t]
316: (8)                    ct = [u for u in list(T.neighbors(t)) if u != pt]
317: (8)                    for c in ct:
318: (12)                       parent[c] = t
319: (8)                    children[t] = copy(ct)
320: (8)                    stack.append(ct)
321: (8)                    stick.append(t)
322: (4)                # the resulting layout is then rescaled again to fit on Manim's canvas
323: (4)                x_min = min(pos.values(), key=lambda t: t[0])[0]
324: (4)                x_max = max(pos.values(), key=lambda t: t[0])[0]
325: (4)                y_min = min(pos.values(), key=lambda t: t[1])[1]
326: (4)                y_max = max(pos.values(), key=lambda t: t[1])[1]
327: (4)                center = np.array([x_min + x_max, y_min + y_max, 0]) / 2
328: (4)                height = y_max - y_min
329: (4)                width = x_max - x_min
330: (4)                if vertex_spacing is None:
331: (8)                    if isinstance(scale, (float, int)) and (width > 0 or height > 0):
332: (12)                       sf = 2 * scale / max(width, height)
333: (8)                    elif isinstance(scale, tuple):
334: (12)                       if scale[0] is not None and width > 0:
335: (16)                           sw = 2 * scale[0] / width
336: (12)                       else:
337: (16)                           sw = 1
338: (12)                       if scale[1] is not None and height > 0:
339: (16)                           sh = 2 * scale[1] / height
340: (12)                       else:
341: (16)                           sh = 1
342: (12)                       sf = np.array([sw, sh, 0])
343: (8)                    else:
344: (12)                       sf = 1
345: (4)                else:
346: (8)                    sx, sy = vertex_spacing
347: (8)                    sf = np.array([sx, sy, 0])
348: (4)                return {v: (np.array([x, y, 0]) - center) * sf for v, (x, y) in pos.items()}
349: (0)            LayoutName = Literal[
350: (4)                "circular",
351: (4)                "kamada_kawai",
352: (4)                "partite",
353: (4)                "planar",
354: (4)                "random",
355: (4)                "shell",
356: (4)                "spectral",
357: (4)                "spiral",
358: (4)                "spring",
359: (4)                "tree",
360: (0)            ]
361: (0)            _layouts: dict[LayoutName, LayoutFunction] = {
362: (4)                "circular": cast(LayoutFunction, nx.layout.circular_layout),
363: (4)                "kamada_kawai": cast(LayoutFunction, nx.layout.kamada_kawai_layout),
364: (4)                "partite": cast(LayoutFunction, _partite_layout),
365: (4)                "planar": cast(LayoutFunction, nx.layout.planar_layout),
366: (4)                "random": cast(LayoutFunction, _random_layout),
367: (4)                "shell": cast(LayoutFunction, nx.layout.shell_layout),
368: (4)                "spectral": cast(LayoutFunction, nx.layout.spectral_layout),
369: (4)                "spiral": cast(LayoutFunction, nx.layout.spiral_layout),
370: (4)                "spring": cast(LayoutFunction, nx.layout.spring_layout),
371: (4)                "tree": cast(LayoutFunction, _tree_layout),
372: (0)            }
373: (0)            def _determine_graph_layout(
374: (4)                nx_graph: nx.classes.graph.Graph | nx.classes.digraph.DiGraph,
375: (4)                layout: LayoutName | dict[Hashable, Point3D] | LayoutFunction = "spring",
376: (4)                layout_scale: float | tuple[float, float, float] = 2,
377: (4)                layout_config: dict[str, Any] | None = None,
378: (0)            ) -> dict[Hashable, Point3D]:
379: (4)                if layout_config is None:
380: (8)                    layout_config = {}
381: (4)                if isinstance(layout, dict):
382: (8)                    return layout
383: (4)                elif layout in _layouts:
384: (8)                    auto_layout = _layouts[layout](nx_graph, scale=layout_scale, **layout_config)
385: (8)                    # NetworkX returns a dictionary of 3D points if the dimension
386: (8)                    # is specified to be 3. Otherwise, it returns a dictionary of
387: (8)                    # 2D points, so adjusting is required.
388: (8)                    if (
389: (12)                       layout_config.get("dim") == 3
390: (12)                       or auto_layout[next(auto_layout.__iter__())].shape[0] == 3
391: (8)                    ):
392: (12)                       return auto_layout
393: (8)                    else:
394: (12)                       return {k: np.append(v, [0]) for k, v in auto_layout.items()}
395: (4)                else:
396: (8)                    try:
397: (12)                       return cast(LayoutFunction, layout)(
398: (16)                           nx_graph, scale=layout_scale, **layout_config
399: (12)                       )
400: (8)                    except TypeError as e:
401: (12)                       raise ValueError(
402: (16)                           f"The layout '{layout}' is neither a recognized layout, a layout function,"
403: (16)                           "nor a vertex placement dictionary.",
404: (12)                       )
405: (0)            class GenericGraph(VMobject, metaclass=ConvertToOpenGL):
406: (4)                """Abstract base class for graphs (that is, a collection of vertices
407: (4)                connected with edges).
408: (4)                Graphs can be instantiated by passing both a list of (distinct, hashable)
409: (4)                vertex names, together with list of edges (as tuples of vertex names). See
410: (4)                the examples for concrete implementations of this class for details.
411: (4)                .. note::
412: (8)                    This implementation uses updaters to make the edges move with
413: (8)                    the vertices.
414: (4)                See also
415: (4)                --------
416: (4)                :class:`.Graph`
417: (4)                :class:`.DiGraph`
418: (4)                Parameters
419: (4)                ----------
420: (4)                vertices
421: (8)                    A list of vertices. Must be hashable elements.
422: (4)                edges
423: (8)                    A list of edges, specified as tuples ``(u, v)`` where both ``u``
424: (8)                    and ``v`` are vertices.
425: (4)                labels
426: (8)                    Controls whether or not vertices are labeled. If ``False`` (the default),
427: (8)                    the vertices are not labeled; if ``True`` they are labeled using their
428: (8)                    names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,
429: (8)                    custom labels can be specified by passing a dictionary whose keys are
430: (8)                    the vertices, and whose values are the corresponding vertex labels
431: (8)                    (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).
432: (4)                label_fill_color
433: (8)                    Sets the fill color of the default labels generated when ``labels``
434: (8)                    is set to ``True``. Has no effect for other values of ``labels``.
435: (4)                layout
436: (8)                    Either one of ``"spring"`` (the default), ``"circular"``, ``"kamada_kawai"``,
437: (8)                    ``"planar"``, ``"random"``, ``"shell"``, ``"spectral"``, ``"spiral"``, ``"tree"``, and ``"partite"``
438: (8)                    for automatic vertex positioning primarily using ``networkx``
439: (8)                    (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_
440: (8)                    for more details), a dictionary specifying a coordinate (value)
441: (8)                    for each vertex (key) for manual positioning, or a .:class:`~.LayoutFunction` with a user-defined automatic layout.
442: (4)                layout_config
443: (8)                    Only for automatic layouts. A dictionary whose entries
444: (8)                    are passed as keyword arguments to the named layout or automatic layout function
445: (8)                    specified via ``layout``.
446: (8)                    The ``tree`` layout also accepts a special parameter ``vertex_spacing``
447: (8)                    passed as a keyword argument inside the ``layout_config`` dictionary.
448: (8)                    Passing a tuple ``(space_x, space_y)`` as this argument overrides
449: (8)                    the value of ``layout_scale`` and ensures that vertices are arranged
450: (8)                    in a way such that the centers of siblings in the same layer are
451: (8)                    at least ``space_x`` units apart horizontally, and neighboring layers
452: (8)                    are spaced ``space_y`` units vertically.
453: (4)                layout_scale
454: (8)                    The scale of automatically generated layouts: the vertices will
455: (8)                    be arranged such that the coordinates are located within the
456: (8)                    interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``
457: (8)                    causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,
458: (8)                    and the second in ``[-scale_y, scale_y]``. Default: 2.
459: (4)                vertex_type
460: (8)                    The mobject class used for displaying vertices in the scene.
461: (4)                vertex_config
462: (8)                    Either a dictionary containing keyword arguments to be passed to
463: (8)                    the class specified via ``vertex_type``, or a dictionary whose keys
464: (8)                    are the vertices, and whose values are dictionaries containing keyword
465: (8)                    arguments for the mobject related to the corresponding vertex.
466: (4)                vertex_mobjects
467: (8)                    A dictionary whose keys are the vertices, and whose values are
468: (8)                    mobjects to be used as vertices. Passing vertices here overrides
469: (8)                    all other configuration options for a vertex.
470: (4)                edge_type
471: (8)                    The mobject class used for displaying edges in the scene.
472: (4)                edge_config
473: (8)                    Either a dictionary containing keyword arguments to be passed
474: (8)                    to the class specified via ``edge_type``, or a dictionary whose
475: (8)                    keys are the edges, and whose values are dictionaries containing
476: (8)                    keyword arguments for the mobject related to the corresponding edge.
477: (4)                """
478: (4)                def __init__(
479: (8)                    self,
480: (8)                    vertices: list[Hashable],
481: (8)                    edges: list[tuple[Hashable, Hashable]],
482: (8)                    labels: bool | dict = False,
483: (8)                    label_fill_color: str = BLACK,
484: (8)                    layout: LayoutName | dict[Hashable, Point3D] | LayoutFunction = "spring",
485: (8)                    layout_scale: float | tuple[float, float, float] = 2,
486: (8)                    layout_config: dict | None = None,
487: (8)                    vertex_type: type[Mobject] = Dot,
488: (8)                    vertex_config: dict | None = None,
489: (8)                    vertex_mobjects: dict | None = None,
490: (8)                    edge_type: type[Mobject] = Line,
491: (8)                    partitions: list[list[Hashable]] | None = None,
492: (8)                    root_vertex: Hashable | None = None,
493: (8)                    edge_config: dict | None = None,
494: (4)                ) -> None:
495: (8)                    super().__init__()
496: (8)                    nx_graph = self._empty_networkx_graph()
497: (8)                    nx_graph.add_nodes_from(vertices)
498: (8)                    nx_graph.add_edges_from(edges)
499: (8)                    self._graph = nx_graph
500: (8)                    if isinstance(labels, dict):
501: (12)                       self._labels = labels
502: (8)                    elif isinstance(labels, bool):
503: (12)                       if labels:
504: (16)                           self._labels = {
505: (20)                               v: MathTex(v, fill_color=label_fill_color) for v in vertices
506: (16)                           }
507: (12)                       else:
508: (16)                           self._labels = {}
509: (8)                    if self._labels and vertex_type is Dot:
510: (12)                       vertex_type = LabeledDot
511: (8)                    if vertex_mobjects is None:
512: (12)                       vertex_mobjects = {}
513: (8)                    # build vertex_config
514: (8)                    if vertex_config is None:
515: (12)                       vertex_config = {}
516: (8)                    default_vertex_config = {}
517: (8)                    if vertex_config:
518: (12)                       default_vertex_config = {
519: (16)                           k: v for k, v in vertex_config.items() if k not in vertices
520: (12)                       }
521: (8)                    self._vertex_config = {
522: (12)                       v: vertex_config.get(v, copy(default_vertex_config)) for v in vertices
523: (8)                    }
524: (8)                    self.default_vertex_config = default_vertex_config
525: (8)                    for v, label in self._labels.items():
526: (12)                       self._vertex_config[v]["label"] = label
527: (8)                    self.vertices = {v: vertex_type(**self._vertex_config[v]) for v in vertices}
528: (8)                    self.vertices.update(vertex_mobjects)
529: (8)                    self.change_layout(
530: (12)                       layout=layout,
531: (12)                       layout_scale=layout_scale,
532: (12)                       layout_config=layout_config,
533: (12)                       partitions=partitions,
534: (12)                       root_vertex=root_vertex,
535: (8)                    )
536: (8)                    # build edge_config
537: (8)                    if edge_config is None:
538: (12)                       edge_config = {}
539: (8)                    default_tip_config = {}
540: (8)                    default_edge_config = {}
541: (8)                    if edge_config:
542: (12)                       default_tip_config = edge_config.pop("tip_config", {})
543: (12)                       default_edge_config = {
544: (16)                           k: v
545: (16)                           for k, v in edge_config.items()
546: (16)                           if not isinstance(
547: (20)                               k, tuple
548: (16)                           )  # everything that is not an edge is an option
549: (12)                       }
550: (8)                    self._edge_config = {}
551: (8)                    self._tip_config = {}
552: (8)                    for e in edges:
553: (12)                       if e in edge_config:
554: (16)                           self._tip_config[e] = edge_config[e].pop(
555: (20)                               "tip_config", copy(default_tip_config)
556: (16)                           )
557: (16)                           self._edge_config[e] = edge_config[e]
558: (12)                       else:
559: (16)                           self._tip_config[e] = copy(default_tip_config)
560: (16)                           self._edge_config[e] = copy(default_edge_config)
561: (8)                    self.default_edge_config = default_edge_config
562: (8)                    self._populate_edge_dict(edges, edge_type)
563: (8)                    self.add(*self.vertices.values())
564: (8)                    self.add(*self.edges.values())
565: (8)                    self.add_updater(self.update_edges)
566: (4)                @staticmethod
567: (4)                def _empty_networkx_graph() -> nx.classes.graph.Graph:
568: (8)                    """Return an empty networkx graph for the given graph type."""
569: (8)                    raise NotImplementedError("To be implemented in concrete subclasses")
570: (4)                def _populate_edge_dict(
571: (8)                    self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]
572: (4)                ):
573: (8)                    """Helper method for populating the edges of the graph."""
574: (8)                    raise NotImplementedError("To be implemented in concrete subclasses")
575: (4)                def __getitem__(self: Graph, v: Hashable) -> Mobject:
576: (8)                    return self.vertices[v]
577: (4)                def _create_vertex(
578: (8)                    self,
579: (8)                    vertex: Hashable,
580: (8)                    position: Point3D | None = None,
581: (8)                    label: bool = False,
582: (8)                    label_fill_color: str = BLACK,
583: (8)                    vertex_type: type[Mobject] = Dot,
584: (8)                    vertex_config: dict | None = None,
585: (8)                    vertex_mobject: dict | None = None,
586: (4)                ) -> tuple[Hashable, Point3D, dict, Mobject]:
587: (8)                    if position is None:
588: (12)                       position = self.get_center()
589: (8)                    if vertex_config is None:
590: (12)                       vertex_config = {}
591: (8)                    if vertex in self.vertices:
592: (12)                       raise ValueError(
593: (16)                           f"Vertex identifier '{vertex}' is already used for a vertex in this graph.",
594: (12)                       )
595: (8)                    if label is True:
596: (12)                       label = MathTex(vertex, fill_color=label_fill_color)
597: (8)                    elif vertex in self._labels:
598: (12)                       label = self._labels[vertex]
599: (8)                    elif not isinstance(label, (Mobject, OpenGLMobject)):
600: (12)                       label = None
601: (8)                    base_vertex_config = copy(self.default_vertex_config)
602: (8)                    base_vertex_config.update(vertex_config)
603: (8)                    vertex_config = base_vertex_config
604: (8)                    if label is not None:
605: (12)                       vertex_config["label"] = label
606: (12)                       if vertex_type is Dot:
607: (16)                           vertex_type = LabeledDot
608: (8)                    if vertex_mobject is None:
609: (12)                       vertex_mobject = vertex_type(**vertex_config)
610: (8)                    vertex_mobject.move_to(position)
611: (8)                    return (vertex, position, vertex_config, vertex_mobject)
612: (4)                def _add_created_vertex(
613: (8)                    self,
614: (8)                    vertex: Hashable,
615: (8)                    position: Point3D,
616: (8)                    vertex_config: dict,
617: (8)                    vertex_mobject: Mobject,
618: (4)                ) -> Mobject:
619: (8)                    if vertex in self.vertices:
620: (12)                       raise ValueError(
621: (16)                           f"Vertex identifier '{vertex}' is already used for a vertex in this graph.",
622: (12)                       )
623: (8)                    self._graph.add_node(vertex)
624: (8)                    self._layout[vertex] = position
625: (8)                    if "label" in vertex_config:
626: (12)                       self._labels[vertex] = vertex_config["label"]
627: (8)                    self._vertex_config[vertex] = vertex_config
628: (8)                    self.vertices[vertex] = vertex_mobject
629: (8)                    self.vertices[vertex].move_to(position)
630: (8)                    self.add(self.vertices[vertex])
631: (8)                    return self.vertices[vertex]
632: (4)                def _add_vertex(
633: (8)                    self,
634: (8)                    vertex: Hashable,
635: (8)                    position: Point3D | None = None,
636: (8)                    label: bool = False,
637: (8)                    label_fill_color: str = BLACK,
638: (8)                    vertex_type: type[Mobject] = Dot,
639: (8)                    vertex_config: dict | None = None,
640: (8)                    vertex_mobject: dict | None = None,
641: (4)                ) -> Mobject:
642: (8)                    """Add a vertex to the graph.
643: (8)                    Parameters
644: (8)                    ----------
645: (8)                    vertex
646: (12)                       A hashable vertex identifier.
647: (8)                    position
648: (12)                       The coordinates where the new vertex should be added. If ``None``, the center
649: (12)                       of the graph is used.
650: (8)                    label
651: (12)                       Controls whether or not the vertex is labeled. If ``False`` (the default),
652: (12)                       the vertex is not labeled; if ``True`` it is labeled using its
653: (12)                       names (as specified in ``vertex``) via :class:`~.MathTex`. Alternatively,
654: (12)                       any :class:`~.Mobject` can be passed to be used as the label.
655: (8)                    label_fill_color
656: (12)                       Sets the fill color of the default labels generated when ``labels``
657: (12)                       is set to ``True``. Has no effect for other values of ``label``.
658: (8)                    vertex_type
659: (12)                       The mobject class used for displaying vertices in the scene.
660: (8)                    vertex_config
661: (12)                       A dictionary containing keyword arguments to be passed to
662: (12)                       the class specified via ``vertex_type``.
663: (8)                    vertex_mobject
664: (12)                       The mobject to be used as the vertex. Overrides all other
665: (12)                       vertex customization options.
666: (8)                    """
667: (8)                    return self._add_created_vertex(
668: (12)                       *self._create_vertex(
669: (16)                           vertex=vertex,
670: (16)                           position=position,
671: (16)                           label=label,
672: (16)                           label_fill_color=label_fill_color,
673: (16)                           vertex_type=vertex_type,
674: (16)                           vertex_config=vertex_config,
675: (16)                           vertex_mobject=vertex_mobject,
676: (12)                       )
677: (8)                    )
678: (4)                def _create_vertices(
679: (8)                    self: Graph,
680: (8)                    *vertices: Hashable,
681: (8)                    positions: dict | None = None,
682: (8)                    labels: bool = False,
683: (8)                    label_fill_color: str = BLACK,
684: (8)                    vertex_type: type[Mobject] = Dot,
685: (8)                    vertex_config: dict | None = None,
686: (8)                    vertex_mobjects: dict | None = None,
687: (4)                ) -> Iterable[tuple[Hashable, Point3D, dict, Mobject]]:
688: (8)                    if positions is None:
689: (12)                       positions = {}
690: (8)                    if vertex_mobjects is None:
691: (12)                       vertex_mobjects = {}
692: (8)                    graph_center = self.get_center()
693: (8)                    base_positions = {v: graph_center for v in vertices}
694: (8)                    base_positions.update(positions)
695: (8)                    positions = base_positions
696: (8)                    if isinstance(labels, bool):
697: (12)                       labels = {v: labels for v in vertices}
698: (8)                    else:
699: (12)                       assert isinstance(labels, dict)
700: (12)                       base_labels = {v: False for v in vertices}
701: (12)                       base_labels.update(labels)
702: (12)                       labels = base_labels
703: (8)                    if vertex_config is None:
704: (12)                       vertex_config = copy(self.default_vertex_config)
705: (8)                    assert isinstance(vertex_config, dict)
706: (8)                    base_vertex_config = copy(self.default_vertex_config)
707: (8)                    base_vertex_config.update(
708: (12)                       {key: val for key, val in vertex_config.items() if key not in vertices},
709: (8)                    )
710: (8)                    vertex_config = {
711: (12)                       v: (vertex_config[v] if v in vertex_config else copy(base_vertex_config))
712: (12)                       for v in vertices
713: (8)                    }
714: (8)                    return [
715: (12)                       self._create_vertex(
716: (16)                           v,
717: (16)                           position=positions[v],
718: (16)                           label=labels[v],
719: (16)                           label_fill_color=label_fill_color,
720: (16)                           vertex_type=vertex_type,
721: (16)                           vertex_config=vertex_config[v],
722: (16)                           vertex_mobject=vertex_mobjects[v] if v in vertex_mobjects else None,
723: (12)                       )
724: (12)                       for v in vertices
725: (8)                    ]
726: (4)                def add_vertices(
727: (8)                    self: Graph,
728: (8)                    *vertices: Hashable,
729: (8)                    positions: dict | None = None,
730: (8)                    labels: bool = False,
731: (8)                    label_fill_color: str = BLACK,
732: (8)                    vertex_type: type[Mobject] = Dot,
733: (8)                    vertex_config: dict | None = None,
734: (8)                    vertex_mobjects: dict | None = None,
735: (4)                ):
736: (8)                    """Add a list of vertices to the graph.
737: (8)                    Parameters
738: (8)                    ----------
739: (8)                    vertices
740: (12)                       Hashable vertex identifiers.
741: (8)                    positions
742: (12)                       A dictionary specifying the coordinates where the new vertices should be added.
743: (12)                       If ``None``, all vertices are created at the center of the graph.
744: (8)                    labels
745: (12)                       Controls whether or not the vertex is labeled. If ``False`` (the default),
746: (12)                       the vertex is not labeled; if ``True`` it is labeled using its
747: (12)                       names (as specified in ``vertex``) via :class:`~.MathTex`. Alternatively,
748: (12)                       any :class:`~.Mobject` can be passed to be used as the label.
749: (8)                    label_fill_color
750: (12)                       Sets the fill color of the default labels generated when ``labels``
751: (12)                       is set to ``True``. Has no effect for other values of ``labels``.
752: (8)                    vertex_type
753: (12)                       The mobject class used for displaying vertices in the scene.
754: (8)                    vertex_config
755: (12)                       A dictionary containing keyword arguments to be passed to
756: (12)                       the class specified via ``vertex_type``.
757: (8)                    vertex_mobjects
758: (12)                       A dictionary whose keys are the vertex identifiers, and whose
759: (12)                       values are mobjects that should be used as vertices. Overrides
760: (12)                       all other vertex customization options.
761: (8)                    """
762: (8)                    return [
763: (12)                       self._add_created_vertex(*v)
764: (12)                       for v in self._create_vertices(
765: (16)                           *vertices,
766: (16)                           positions=positions,
767: (16)                           labels=labels,
768: (16)                           label_fill_color=label_fill_color,
769: (16)                           vertex_type=vertex_type,
770: (16)                           vertex_config=vertex_config,
771: (16)                           vertex_mobjects=vertex_mobjects,
772: (12)                       )
773: (8)                    ]
774: (4)                @override_animate(add_vertices)
775: (4)                def _add_vertices_animation(self, *args, anim_args=None, **kwargs):
776: (8)                    if anim_args is None:
777: (12)                       anim_args = {}
778: (8)                    animation = anim_args.pop("animation", Create)
779: (8)                    vertex_mobjects = self._create_vertices(*args, **kwargs)
780: (8)                    def on_finish(scene: Scene):
781: (12)                       for v in vertex_mobjects:
782: (16)                           scene.remove(v[-1])
783: (16)                           self._add_created_vertex(*v)
784: (8)                    return AnimationGroup(
785: (12)                       *(animation(v[-1], **anim_args) for v in vertex_mobjects),
786: (12)                       group=self,
787: (12)                       _on_finish=on_finish,
788: (8)                    )
789: (4)                def _remove_vertex(self, vertex):
790: (8)                    """Remove a vertex (as well as all incident edges) from the graph.
791: (8)                    Parameters
792: (8)                    ----------
793: (8)                    vertex
794: (12)                       The identifier of a vertex to be removed.
795: (8)                    Returns
796: (8)                    -------
797: (8)                    Group
798: (12)                       A mobject containing all removed objects.
799: (8)                    """
800: (8)                    if vertex not in self.vertices:
801: (12)                       raise ValueError(
802: (16)                           f"The graph does not contain a vertex with identifier '{vertex}'",
803: (12)                       )
804: (8)                    self._graph.remove_node(vertex)
805: (8)                    self._layout.pop(vertex)
806: (8)                    if vertex in self._labels:
807: (12)                       self._labels.pop(vertex)
808: (8)                    self._vertex_config.pop(vertex)
809: (8)                    edge_tuples = [e for e in self.edges if vertex in e]
810: (8)                    for e in edge_tuples:
811: (12)                       self._edge_config.pop(e)
812: (8)                    to_remove = [self.edges.pop(e) for e in edge_tuples]
813: (8)                    to_remove.append(self.vertices.pop(vertex))
814: (8)                    self.remove(*to_remove)
815: (8)                    return self.get_group_class()(*to_remove)
816: (4)                def remove_vertices(self, *vertices):
817: (8)                    """Remove several vertices from the graph.
818: (8)                    Parameters
819: (8)                    ----------
820: (8)                    vertices
821: (12)                       Vertices to be removed from the graph.
822: (8)                    Examples
823: (8)                    --------
824: (8)                    ::
825: (12)                       >>> G = Graph([1, 2, 3], [(1, 2), (2, 3)])
826: (12)                       >>> removed = G.remove_vertices(2, 3); removed
827: (12)                       VGroup(Line, Line, Dot, Dot)
828: (12)                       >>> G
829: (12)                       Undirected graph on 1 vertices and 0 edges
830: (8)                    """
831: (8)                    mobjects = []
832: (8)                    for v in vertices:
833: (12)                       mobjects.extend(self._remove_vertex(v).submobjects)
834: (8)                    return self.get_group_class()(*mobjects)
835: (4)                @override_animate(remove_vertices)
836: (4)                def _remove_vertices_animation(self, *vertices, anim_args=None):
837: (8)                    if anim_args is None:
838: (12)                       anim_args = {}
839: (8)                    animation = anim_args.pop("animation", Uncreate)
840: (8)                    mobjects = self.remove_vertices(*vertices)
841: (8)                    return AnimationGroup(
842: (12)                       *(animation(mobj, **anim_args) for mobj in mobjects), group=self
843: (8)                    )
844: (4)                def _add_edge(
845: (8)                    self,
846: (8)                    edge: tuple[Hashable, Hashable],
847: (8)                    edge_type: type[Mobject] = Line,
848: (8)                    edge_config: dict | None = None,
849: (4)                ):
850: (8)                    """Add a new edge to the graph.
851: (8)                    Parameters
852: (8)                    ----------
853: (8)                    edge
854: (12)                       The edge (as a tuple of vertex identifiers) to be added. If a non-existing
855: (12)                       vertex is passed, a new vertex with default settings will be created. Create
856: (12)                       new vertices yourself beforehand to customize them.
857: (8)                    edge_type
858: (12)                       The mobject class used for displaying edges in the scene.
859: (8)                    edge_config
860: (12)                       A dictionary containing keyword arguments to be passed
861: (12)                       to the class specified via ``edge_type``.
862: (8)                    Returns
863: (8)                    -------
864: (8)                    Group
865: (12)                       A group containing all newly added vertices and edges.
866: (8)                    """
867: (8)                    if edge_config is None:
868: (12)                       edge_config = self.default_edge_config.copy()
869: (8)                    added_mobjects = []
870: (8)                    for v in edge:
871: (12)                       if v not in self.vertices:
872: (16)                           added_mobjects.append(self._add_vertex(v))
873: (8)                    u, v = edge
874: (8)                    self._graph.add_edge(u, v)
875: (8)                    base_edge_config = self.default_edge_config.copy()
876: (8)                    base_edge_config.update(edge_config)
877: (8)                    edge_config = base_edge_config
878: (8)                    self._edge_config[(u, v)] = edge_config
879: (8)                    edge_mobject = edge_type(
880: (12)                       self[u].get_center(), self[v].get_center(), z_index=-1, **edge_config
881: (8)                    )
882: (8)                    self.edges[(u, v)] = edge_mobject
883: (8)                    self.add(edge_mobject)
884: (8)                    added_mobjects.append(edge_mobject)
885: (8)                    return self.get_group_class()(*added_mobjects)
886: (4)                def add_edges(
887: (8)                    self,
888: (8)                    *edges: tuple[Hashable, Hashable],
889: (8)                    edge_type: type[Mobject] = Line,
890: (8)                    edge_config: dict | None = None,
891: (8)                    **kwargs,
892: (4)                ):
893: (8)                    """Add new edges to the graph.
894: (8)                    Parameters
895: (8)                    ----------
896: (8)                    edges
897: (12)                       Edges (as tuples of vertex identifiers) to be added. If a non-existing
898: (12)                       vertex is passed, a new vertex with default settings will be created. Create
899: (12)                       new vertices yourself beforehand to customize them.
900: (8)                    edge_type
901: (12)                       The mobject class used for displaying edges in the scene.
902: (8)                    edge_config
903: (12)                       A dictionary either containing keyword arguments to be passed
904: (12)                       to the class specified via ``edge_type``, or a dictionary
905: (12)                       whose keys are the edge tuples, and whose values are dictionaries
906: (12)                       containing keyword arguments to be passed for the construction
907: (12)                       of the corresponding edge.
908: (8)                    kwargs
909: (12)                       Any further keyword arguments are passed to :meth:`.add_vertices`
910: (12)                       which is used to create new vertices in the passed edges.
911: (8)                    Returns
912: (8)                    -------
913: (8)                    Group
914: (12)                       A group containing all newly added vertices and edges.
915: (8)                    """
916: (8)                    if edge_config is None:
917: (12)                       edge_config = {}
918: (8)                    non_edge_settings = {k: v for (k, v) in edge_config.items() if k not in edges}
919: (8)                    base_edge_config = self.default_edge_config.copy()
920: (8)                    base_edge_config.update(non_edge_settings)
921: (8)                    base_edge_config = {e: base_edge_config.copy() for e in edges}
922: (8)                    for e in edges:
923: (12)                       base_edge_config[e].update(edge_config.get(e, {}))
924: (8)                    edge_config = base_edge_config
925: (8)                    edge_vertices = set(it.chain(*edges))
926: (8)                    new_vertices = [v for v in edge_vertices if v not in self.vertices]
927: (8)                    added_vertices = self.add_vertices(*new_vertices, **kwargs)
928: (8)                    added_mobjects = sum(
929: (12)                       (
930: (16)                           self._add_edge(
931: (20)                               edge,
932: (20)                               edge_type=edge_type,
933: (20)                               edge_config=edge_config[edge],
934: (16)                           ).submobjects
935: (16)                           for edge in edges
936: (12)                       ),
937: (12)                       added_vertices,
938: (8)                    )
939: (8)                    return self.get_group_class()(*added_mobjects)
940: (4)                @override_animate(add_edges)
941: (4)                def _add_edges_animation(self, *args, anim_args=None, **kwargs):
942: (8)                    if anim_args is None:
943: (12)                       anim_args = {}
944: (8)                    animation = anim_args.pop("animation", Create)
945: (8)                    mobjects = self.add_edges(*args, **kwargs)
946: (8)                    return AnimationGroup(
947: (12)                       *(animation(mobj, **anim_args) for mobj in mobjects), group=self
948: (8)                    )
949: (4)                def _remove_edge(self, edge: tuple[Hashable]):
950: (8)                    """Remove an edge from the graph.
951: (8)                    Parameters
952: (8)                    ----------
953: (8)                    edge
954: (12)                       The edge (i.e., a tuple of vertex identifiers) to be removed from the graph.
955: (8)                    Returns
956: (8)                    -------
957: (8)                    Mobject
958: (12)                       The removed edge.
959: (8)                    """
960: (8)                    if edge not in self.edges:
961: (12)                       raise ValueError(f"The graph does not contain a edge '{edge}'")
962: (8)                    edge_mobject = self.edges.pop(edge)
963: (8)                    self._graph.remove_edge(*edge)
964: (8)                    self._edge_config.pop(edge, None)
965: (8)                    self.remove(edge_mobject)
966: (8)                    return edge_mobject
967: (4)                def remove_edges(self, *edges: tuple[Hashable]):
968: (8)                    """Remove several edges from the graph.
969: (8)                    Parameters
970: (8)                    ----------
971: (8)                    edges
972: (12)                       Edges to be removed from the graph.
973: (8)                    Returns
974: (8)                    -------
975: (8)                    Group
976: (12)                       A group containing all removed edges.
977: (8)                    """
978: (8)                    edge_mobjects = [self._remove_edge(edge) for edge in edges]
979: (8)                    return self.get_group_class()(*edge_mobjects)
980: (4)                @override_animate(remove_edges)
981: (4)                def _remove_edges_animation(self, *edges, anim_args=None):
982: (8)                    if anim_args is None:
983: (12)                       anim_args = {}
984: (8)                    animation = anim_args.pop("animation", Uncreate)
985: (8)                    mobjects = self.remove_edges(*edges)
986: (8)                    return AnimationGroup(*(animation(mobj, **anim_args) for mobj in mobjects))
987: (4)                @classmethod
988: (4)                def from_networkx(
989: (8)                    cls, nxgraph: nx.classes.graph.Graph | nx.classes.digraph.DiGraph, **kwargs
990: (4)                ):
991: (8)                    """Build a :class:`~.Graph` or :class:`~.DiGraph` from a
992: (8)                    given ``networkx`` graph.
993: (8)                    Parameters
994: (8)                    ----------
995: (8)                    nxgraph
996: (12)                       A ``networkx`` graph or digraph.
997: (8)                    **kwargs
998: (12)                       Keywords to be passed to the constructor of :class:`~.Graph`.
999: (8)                    Examples
1000: (8)                   --------
1001: (8)                   .. manim:: ImportNetworkxGraph
1002: (12)                      import networkx as nx
1003: (12)                      nxgraph = nx.erdos_renyi_graph(14, 0.5)
1004: (12)                      class ImportNetworkxGraph(Scene):
1005: (16)                          def construct(self):
1006: (20)                              G = Graph.from_networkx(nxgraph, layout="spring", layout_scale=3.5)
1007: (20)                              self.play(Create(G))
1008: (20)                              self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +
1009: (53)                                                               3*UP*np.sin(ind/7 * PI))
1010: (32)                                          for ind, v in enumerate(G.vertices)])
1011: (20)                              self.play(Uncreate(G))
1012: (8)                   """
1013: (8)                   return cls(list(nxgraph.nodes), list(nxgraph.edges), **kwargs)
1014: (4)               def change_layout(
1015: (8)                   self,
1016: (8)                   layout: LayoutName | dict[Hashable, Point3D] | LayoutFunction = "spring",
1017: (8)                   layout_scale: float | tuple[float, float, float] = 2,
1018: (8)                   layout_config: dict[str, Any] | None = None,
1019: (8)                   partitions: list[list[Hashable]] | None = None,
1020: (8)                   root_vertex: Hashable | None = None,
1021: (4)               ) -> Graph:
1022: (8)                   """Change the layout of this graph.
1023: (8)                   See the documentation of :class:`~.Graph` for details about the
1024: (8)                   keyword arguments.
1025: (8)                   Examples
1026: (8)                   --------
1027: (8)                   .. manim:: ChangeGraphLayout
1028: (12)                      class ChangeGraphLayout(Scene):
1029: (16)                          def construct(self):
1030: (20)                              G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],
1031: (30)                                        layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],
1032: (38)                                                4: [1, 0, 0], 5: [2, 0, 0]}
1033: (30)                                        )
1034: (20)                              self.play(Create(G))
1035: (20)                              self.play(G.animate.change_layout("circular"))
1036: (20)                              self.wait()
1037: (8)                   """
1038: (8)                   layout_config = {} if layout_config is None else layout_config
1039: (8)                   if partitions is not None and "partitions" not in layout_config:
1040: (12)                      layout_config["partitions"] = partitions
1041: (8)                   if root_vertex is not None and "root_vertex" not in layout_config:
1042: (12)                      layout_config["root_vertex"] = root_vertex
1043: (8)                   self._layout = _determine_graph_layout(
1044: (12)                      self._graph,
1045: (12)                      layout=layout,
1046: (12)                      layout_scale=layout_scale,
1047: (12)                      layout_config=layout_config,
1048: (8)                   )
1049: (8)                   for v in self.vertices:
1050: (12)                      self[v].move_to(self._layout[v])
1051: (8)                   return self
1052: (0)           class Graph(GenericGraph):
1053: (4)               """An undirected graph (vertices connected with edges).
1054: (4)               The graph comes with an updater which makes the edges stick to
1055: (4)               the vertices when moved around. See :class:`.DiGraph` for
1056: (4)               a version with directed edges.
1057: (4)               See also
1058: (4)               --------
1059: (4)               :class:`.GenericGraph`
1060: (4)               Parameters
1061: (4)               ----------
1062: (4)               vertices
1063: (8)                   A list of vertices. Must be hashable elements.
1064: (4)               edges
1065: (8)                   A list of edges, specified as tuples ``(u, v)`` where both ``u``
1066: (8)                   and ``v`` are vertices. The vertex order is irrelevant.
1067: (4)               labels
1068: (8)                   Controls whether or not vertices are labeled. If ``False`` (the default),
1069: (8)                   the vertices are not labeled; if ``True`` they are labeled using their
1070: (8)                   names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,
1071: (8)                   custom labels can be specified by passing a dictionary whose keys are
1072: (8)                   the vertices, and whose values are the corresponding vertex labels
1073: (8)                   (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).
1074: (4)               label_fill_color
1075: (8)                   Sets the fill color of the default labels generated when ``labels``
1076: (8)                   is set to ``True``. Has no effect for other values of ``labels``.
1077: (4)               layout
1078: (8)                   Either one of ``"spring"`` (the default), ``"circular"``, ``"kamada_kawai"``,
1079: (8)                   ``"planar"``, ``"random"``, ``"shell"``, ``"spectral"``, ``"spiral"``, ``"tree"``, and ``"partite"``
1080: (8)                   for automatic vertex positioning using ``networkx``
1081: (8)                   (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_
1082: (8)                   for more details), or a dictionary specifying a coordinate (value)
1083: (8)                   for each vertex (key) for manual positioning.
1084: (4)               layout_config
1085: (8)                   Only for automatically generated layouts. A dictionary whose entries
1086: (8)                   are passed as keyword arguments to the automatic layout algorithm
1087: (8)                   specified via ``layout`` of ``networkx``.
1088: (8)                   The ``tree`` layout also accepts a special parameter ``vertex_spacing``
1089: (8)                   passed as a keyword argument inside the ``layout_config`` dictionary.
1090: (8)                   Passing a tuple ``(space_x, space_y)`` as this argument overrides
1091: (8)                   the value of ``layout_scale`` and ensures that vertices are arranged
1092: (8)                   in a way such that the centers of siblings in the same layer are
1093: (8)                   at least ``space_x`` units apart horizontally, and neighboring layers
1094: (8)                   are spaced ``space_y`` units vertically.
1095: (4)               layout_scale
1096: (8)                   The scale of automatically generated layouts: the vertices will
1097: (8)                   be arranged such that the coordinates are located within the
1098: (8)                   interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``
1099: (8)                   causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,
1100: (8)                   and the second in ``[-scale_y, scale_y]``. Default: 2.
1101: (4)               vertex_type
1102: (8)                   The mobject class used for displaying vertices in the scene.
1103: (4)               vertex_config
1104: (8)                   Either a dictionary containing keyword arguments to be passed to
1105: (8)                   the class specified via ``vertex_type``, or a dictionary whose keys
1106: (8)                   are the vertices, and whose values are dictionaries containing keyword
1107: (8)                   arguments for the mobject related to the corresponding vertex.
1108: (4)               vertex_mobjects
1109: (8)                   A dictionary whose keys are the vertices, and whose values are
1110: (8)                   mobjects to be used as vertices. Passing vertices here overrides
1111: (8)                   all other configuration options for a vertex.
1112: (4)               edge_type
1113: (8)                   The mobject class used for displaying edges in the scene.
1114: (4)               edge_config
1115: (8)                   Either a dictionary containing keyword arguments to be passed
1116: (8)                   to the class specified via ``edge_type``, or a dictionary whose
1117: (8)                   keys are the edges, and whose values are dictionaries containing
1118: (8)                   keyword arguments for the mobject related to the corresponding edge.
1119: (4)               Examples
1120: (4)               --------
1121: (4)               First, we create a small graph and demonstrate that the edges move
1122: (4)               together with the vertices.
1123: (4)               .. manim:: MovingVertices
1124: (8)                   class MovingVertices(Scene):
1125: (12)                      def construct(self):
1126: (16)                          vertices = [1, 2, 3, 4]
1127: (16)                          edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]
1128: (16)                          g = Graph(vertices, edges)
1129: (16)                          self.play(Create(g))
1130: (16)                          self.wait()
1131: (16)                          self.play(g[1].animate.move_to([1, 1, 0]),
1132: (26)                                    g[2].animate.move_to([-1, 1, 0]),
1133: (26)                                    g[3].animate.move_to([1, -1, 0]),
1134: (26)                                    g[4].animate.move_to([-1, -1, 0]))
1135: (16)                          self.wait()
1136: (4)               There are several automatic positioning algorithms to choose from:
1137: (4)               .. manim:: GraphAutoPosition
1138: (8)                   :save_last_frame:
1139: (8)                   class GraphAutoPosition(Scene):
1140: (12)                      def construct(self):
1141: (16)                          vertices = [1, 2, 3, 4, 5, 6, 7, 8]
1142: (16)                          edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
1143: (25)                                   (2, 8), (3, 4), (6, 1), (6, 2),
1144: (25)                                   (6, 3), (7, 2), (7, 4)]
1145: (16)                          autolayouts = ["spring", "circular", "kamada_kawai",
1146: (31)                                         "planar", "random", "shell",
1147: (31)                                         "spectral", "spiral"]
1148: (16)                          graphs = [Graph(vertices, edges, layout=lt).scale(0.5)
1149: (26)                                    for lt in autolayouts]
1150: (16)                          r1 = VGroup(*graphs[:3]).arrange()
1151: (16)                          r2 = VGroup(*graphs[3:6]).arrange()
1152: (16)                          r3 = VGroup(*graphs[6:]).arrange()
1153: (16)                          self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))
1154: (4)               Vertices can also be positioned manually:
1155: (4)               .. manim:: GraphManualPosition
1156: (8)                   :save_last_frame:
1157: (8)                   class GraphManualPosition(Scene):
1158: (12)                      def construct(self):
1159: (16)                          vertices = [1, 2, 3, 4]
1160: (16)                          edges = [(1, 2), (2, 3), (3, 4), (4, 1)]
1161: (16)                          lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}
1162: (16)                          G = Graph(vertices, edges, layout=lt)
1163: (16)                          self.add(G)
1164: (4)               The vertices in graphs can be labeled, and configurations for vertices
1165: (4)               and edges can be modified both by default and for specific vertices and
1166: (4)               edges.
1167: (4)               .. note::
1168: (8)                   In ``edge_config``, edges can be passed in both directions: if
1169: (8)                   ``(u, v)`` is an edge in the graph, both ``(u, v)`` as well
1170: (8)                   as ``(v, u)`` can be used as keys in the dictionary.
1171: (4)               .. manim:: LabeledModifiedGraph
1172: (8)                   :save_last_frame:
1173: (8)                   class LabeledModifiedGraph(Scene):
1174: (12)                      def construct(self):
1175: (16)                          vertices = [1, 2, 3, 4, 5, 6, 7, 8]
1176: (16)                          edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
1177: (25)                                   (2, 8), (3, 4), (6, 1), (6, 2),
1178: (25)                                   (6, 3), (7, 2), (7, 4)]
1179: (16)                          g = Graph(vertices, edges, layout="circular", layout_scale=3,
1180: (26)                                    labels=True, vertex_config={7: {"fill_color": RED}},
1181: (26)                                    edge_config={(1, 7): {"stroke_color": RED},
1182: (39)                                                 (2, 7): {"stroke_color": RED},
1183: (39)                                                 (4, 7): {"stroke_color": RED}})
1184: (16)                          self.add(g)
1185: (4)               You can also lay out a partite graph on columns by specifying
1186: (4)               a list of the vertices on each side and choosing the partite layout.
1187: (4)               .. note::
1188: (8)                   All vertices in your graph which are not listed in any of the partitions
1189: (8)                   are collected in their own partition and rendered in the rightmost column.
1190: (4)               .. manim:: PartiteGraph
1191: (8)                   :save_last_frame:
1192: (8)                   import networkx as nx
1193: (8)                   class PartiteGraph(Scene):
1194: (12)                      def construct(self):
1195: (16)                          G = nx.Graph()
1196: (16)                          G.add_nodes_from([0, 1, 2, 3])
1197: (16)                          G.add_edges_from([(0, 2), (0,3), (1, 2)])
1198: (16)                          graph = Graph(list(G.nodes), list(G.edges), layout="partite", partitions=[[0, 1]])
1199: (16)                          self.play(Create(graph))
1200: (4)               The representation of a linear artificial neural network is facilitated
1201: (4)               by the use of the partite layout and defining partitions for each layer.
1202: (4)               .. manim:: LinearNN
1203: (8)                   :save_last_frame:
1204: (8)                   class LinearNN(Scene):
1205: (12)                      def construct(self):
1206: (16)                          edges = []
1207: (16)                          partitions = []
1208: (16)                          c = 0
1209: (16)                          layers = [2, 3, 3, 2]  # the number of neurons in each layer
1210: (16)                          for i in layers:
1211: (20)                              partitions.append(list(range(c + 1, c + i + 1)))
1212: (20)                              c += i
1213: (16)                          for i, v in enumerate(layers[1:]):
1214: (24)                                  last = sum(layers[:i+1])
1215: (24)                                  for j in range(v):
1216: (28)                                      for k in range(last - layers[i], last):
1217: (32)                                          edges.append((k + 1, j + last + 1))
1218: (16)                          vertices = np.arange(1, sum(layers) + 1)
1219: (16)                          graph = Graph(
1220: (20)                              vertices,
1221: (20)                              edges,
1222: (20)                              layout='partite',
1223: (20)                              partitions=partitions,
1224: (20)                              layout_scale=3,
1225: (20)                              vertex_config={'radius': 0.20},
1226: (16)                          )
1227: (16)                          self.add(graph)
1228: (4)               The custom tree layout can be used to show the graph
1229: (4)               by distance from the root vertex. You must pass the root vertex
1230: (4)               of the tree.
1231: (4)               .. manim:: Tree
1232: (8)                   import networkx as nx
1233: (8)                   class Tree(Scene):
1234: (12)                      def construct(self):
1235: (16)                          G = nx.Graph()
1236: (16)                          G.add_node("ROOT")
1237: (16)                          for i in range(5):
1238: (20)                              G.add_node("Child_%i" % i)
1239: (20)                              G.add_node("Grandchild_%i" % i)
1240: (20)                              G.add_node("Greatgrandchild_%i" % i)
1241: (20)                              G.add_edge("ROOT", "Child_%i" % i)
1242: (20)                              G.add_edge("Child_%i" % i, "Grandchild_%i" % i)
1243: (20)                              G.add_edge("Grandchild_%i" % i, "Greatgrandchild_%i" % i)
1244: (16)                          self.play(Create(
1245: (20)                              Graph(list(G.nodes), list(G.edges), layout="tree", root_vertex="ROOT")))
1246: (4)               The following code sample illustrates the use of the ``vertex_spacing``
1247: (4)               layout parameter specific to the ``"tree"`` layout. As mentioned
1248: (4)               above, setting ``vertex_spacing`` overrides the specified value
1249: (4)               for ``layout_scale``, and as such it is harder to control the size
1250: (4)               of the mobject. However, we can adjust the captured frame and
1251: (4)               zoom out by using a :class:`.MovingCameraScene`::
1252: (8)                   class LargeTreeGeneration(MovingCameraScene):
1253: (12)                      DEPTH = 4
1254: (12)                      CHILDREN_PER_VERTEX = 3
1255: (12)                      LAYOUT_CONFIG = {"vertex_spacing": (0.5, 1)}
1256: (12)                      VERTEX_CONF = {"radius": 0.25, "color": BLUE_B, "fill_opacity": 1}
1257: (12)                      def expand_vertex(self, g, vertex_id: str, depth: int):
1258: (16)                          new_vertices = [f"{vertex_id}/{i}" for i in range(self.CHILDREN_PER_VERTEX)]
1259: (16)                          new_edges = [(vertex_id, child_id) for child_id in new_vertices]
1260: (16)                          g.add_edges(
1261: (20)                              *new_edges,
1262: (20)                              vertex_config=self.VERTEX_CONF,
1263: (20)                              positions={
1264: (24)                                  k: g.vertices[vertex_id].get_center() + 0.1 * DOWN for k in new_vertices
1265: (20)                              },
1266: (16)                          )
1267: (16)                          if depth < self.DEPTH:
1268: (20)                              for child_id in new_vertices:
1269: (24)                                  self.expand_vertex(g, child_id, depth + 1)
1270: (16)                          return g
1271: (12)                      def construct(self):
1272: (16)                          g = Graph(["ROOT"], [], vertex_config=self.VERTEX_CONF)
1273: (16)                          g = self.expand_vertex(g, "ROOT", 1)
1274: (16)                          self.add(g)
1275: (16)                          self.play(
1276: (20)                              g.animate.change_layout(
1277: (24)                                  "tree",
1278: (24)                                  root_vertex="ROOT",
1279: (24)                                  layout_config=self.LAYOUT_CONFIG,
1280: (20)                              )
1281: (16)                          )
1282: (16)                          self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)
1283: (4)               """
1284: (4)               @staticmethod
1285: (4)               def _empty_networkx_graph() -> nx.Graph:
1286: (8)                   return nx.Graph()
1287: (4)               def _populate_edge_dict(
1288: (8)                   self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]
1289: (4)               ):
1290: (8)                   self.edges = {
1291: (12)                      (u, v): edge_type(
1292: (16)                          self[u].get_center(),
1293: (16)                          self[v].get_center(),
1294: (16)                          z_index=-1,
1295: (16)                          **self._edge_config[(u, v)],
1296: (12)                      )
1297: (12)                      for (u, v) in edges
1298: (8)                   }
1299: (4)               def update_edges(self, graph):
1300: (8)                   for (u, v), edge in graph.edges.items():
1301: (12)                      # Undirected graph has a Line edge
1302: (12)                      edge.put_start_and_end_on(graph[u].get_center(), graph[v].get_center())
1303: (4)               def __repr__(self: Graph) -> str:
1304: (8)                   return f"Undirected graph on {len(self.vertices)} vertices and {len(self.edges)} edges"
1305: (0)           class DiGraph(GenericGraph):
1306: (4)               """A directed graph.
1307: (4)               .. note::
1308: (8)                   In contrast to undirected graphs, the order in which vertices in a given
1309: (8)                   edge are specified is relevant here.
1310: (4)               See also
1311: (4)               --------
1312: (4)               :class:`.GenericGraph`
1313: (4)               Parameters
1314: (4)               ----------
1315: (4)               vertices
1316: (8)                   A list of vertices. Must be hashable elements.
1317: (4)               edges
1318: (8)                   A list of edges, specified as tuples ``(u, v)`` where both ``u``
1319: (8)                   and ``v`` are vertices. The edge is directed from ``u`` to ``v``.
1320: (4)               labels
1321: (8)                   Controls whether or not vertices are labeled. If ``False`` (the default),
1322: (8)                   the vertices are not labeled; if ``True`` they are labeled using their
1323: (8)                   names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,
1324: (8)                   custom labels can be specified by passing a dictionary whose keys are
1325: (8)                   the vertices, and whose values are the corresponding vertex labels
1326: (8)                   (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).
1327: (4)               label_fill_color
1328: (8)                   Sets the fill color of the default labels generated when ``labels``
1329: (8)                   is set to ``True``. Has no effect for other values of ``labels``.
1330: (4)               layout
1331: (8)                   Either one of ``"spring"`` (the default), ``"circular"``, ``"kamada_kawai"``,
1332: (8)                   ``"planar"``, ``"random"``, ``"shell"``, ``"spectral"``, ``"spiral"``, ``"tree"``, and ``"partite"``
1333: (8)                   for automatic vertex positioning using ``networkx``
1334: (8)                   (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_
1335: (8)                   for more details), or a dictionary specifying a coordinate (value)
1336: (8)                   for each vertex (key) for manual positioning.
1337: (4)               layout_config
1338: (8)                   Only for automatically generated layouts. A dictionary whose entries
1339: (8)                   are passed as keyword arguments to the automatic layout algorithm
1340: (8)                   specified via ``layout`` of ``networkx``.
1341: (8)                   The ``tree`` layout also accepts a special parameter ``vertex_spacing``
1342: (8)                   passed as a keyword argument inside the ``layout_config`` dictionary.
1343: (8)                   Passing a tuple ``(space_x, space_y)`` as this argument overrides
1344: (8)                   the value of ``layout_scale`` and ensures that vertices are arranged
1345: (8)                   in a way such that the centers of siblings in the same layer are
1346: (8)                   at least ``space_x`` units apart horizontally, and neighboring layers
1347: (8)                   are spaced ``space_y`` units vertically.
1348: (4)               layout_scale
1349: (8)                   The scale of automatically generated layouts: the vertices will
1350: (8)                   be arranged such that the coordinates are located within the
1351: (8)                   interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``
1352: (8)                   causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,
1353: (8)                   and the second in ``[-scale_y, scale_y]``. Default: 2.
1354: (4)               vertex_type
1355: (8)                   The mobject class used for displaying vertices in the scene.
1356: (4)               vertex_config
1357: (8)                   Either a dictionary containing keyword arguments to be passed to
1358: (8)                   the class specified via ``vertex_type``, or a dictionary whose keys
1359: (8)                   are the vertices, and whose values are dictionaries containing keyword
1360: (8)                   arguments for the mobject related to the corresponding vertex.
1361: (4)               vertex_mobjects
1362: (8)                   A dictionary whose keys are the vertices, and whose values are
1363: (8)                   mobjects to be used as vertices. Passing vertices here overrides
1364: (8)                   all other configuration options for a vertex.
1365: (4)               edge_type
1366: (8)                   The mobject class used for displaying edges in the scene.
1367: (4)               edge_config
1368: (8)                   Either a dictionary containing keyword arguments to be passed
1369: (8)                   to the class specified via ``edge_type``, or a dictionary whose
1370: (8)                   keys are the edges, and whose values are dictionaries containing
1371: (8)                   keyword arguments for the mobject related to the corresponding edge.
1372: (8)                   You can further customize the tip by adding a ``tip_config`` dictionary
1373: (8)                   for global styling, or by adding the dict to a specific ``edge_config``.
1374: (4)               Examples
1375: (4)               --------
1376: (4)               .. manim:: MovingDiGraph
1377: (8)                   class MovingDiGraph(Scene):
1378: (12)                      def construct(self):
1379: (16)                          vertices = [1, 2, 3, 4]
1380: (16)                          edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]
1381: (16)                          g = DiGraph(vertices, edges)
1382: (16)                          self.add(g)
1383: (16)                          self.play(
1384: (20)                              g[1].animate.move_to([1, 1, 1]),
1385: (20)                              g[2].animate.move_to([-1, 1, 2]),
1386: (20)                              g[3].animate.move_to([1, -1, -1]),
1387: (20)                              g[4].animate.move_to([-1, -1, 0]),
1388: (16)                          )
1389: (16)                          self.wait()
1390: (4)               You can customize the edges and arrow tips globally or locally.
1391: (4)               .. manim:: CustomDiGraph
1392: (8)                   class CustomDiGraph(Scene):
1393: (12)                      def construct(self):
1394: (16)                          vertices = [i for i in range(5)]
1395: (16)                          edges = [
1396: (20)                              (0, 1),
1397: (20)                              (1, 2),
1398: (20)                              (3, 2),
1399: (20)                              (3, 4),
1400: (16)                          ]
1401: (16)                          edge_config = {
1402: (20)                              "stroke_width": 2,
1403: (20)                              "tip_config": {
1404: (24)                                  "tip_shape": ArrowSquareTip,
1405: (24)                                  "tip_length": 0.15,
1406: (20)                              },
1407: (20)                              (3, 4): {
1408: (24)                                  "color": RED,
1409: (24)                                  "tip_config": {"tip_length": 0.25, "tip_width": 0.25}
1410: (20)                              },
1411: (16)                          }
1412: (16)                          g = DiGraph(
1413: (20)                              vertices,
1414: (20)                              edges,
1415: (20)                              labels=True,
1416: (20)                              layout="circular",
1417: (20)                              edge_config=edge_config,
1418: (16)                          ).scale(1.4)
1419: (16)                          self.play(Create(g))
1420: (16)                          self.wait()
1421: (4)               Since this implementation respects the labels boundary you can also use
1422: (4)               it for an undirected moving graph with labels.
1423: (4)               .. manim:: UndirectedMovingDiGraph
1424: (8)                   class UndirectedMovingDiGraph(Scene):
1425: (12)                      def construct(self):
1426: (16)                          vertices = [i for i in range(5)]
1427: (16)                          edges = [
1428: (20)                              (0, 1),
1429: (20)                              (1, 2),
1430: (20)                              (3, 2),
1431: (20)                              (3, 4),
1432: (16)                          ]
1433: (16)                          edge_config = {
1434: (20)                              "stroke_width": 2,
1435: (20)                              "tip_config": {"tip_length": 0, "tip_width": 0},
1436: (20)                              (3, 4): {"color": RED},
1437: (16)                          }
1438: (16)                          g = DiGraph(
1439: (20)                              vertices,
1440: (20)                              edges,
1441: (20)                              labels=True,
1442: (20)                              layout="circular",
1443: (20)                              edge_config=edge_config,
1444: (16)                          ).scale(1.4)
1445: (16)                          self.play(Create(g))
1446: (16)                          self.wait()
1447: (16)                          self.play(
1448: (20)                              g[1].animate.move_to([1, 1, 1]),
1449: (20)                              g[2].animate.move_to([-1, 1, 2]),
1450: (20)                              g[3].animate.move_to([-1.5, -1.5, -1]),
1451: (20)                              g[4].animate.move_to([1, -2, -1]),
1452: (16)                          )
1453: (16)                          self.wait()
1454: (4)               """
1455: (4)               @staticmethod
1456: (4)               def _empty_networkx_graph() -> nx.DiGraph:
1457: (8)                   return nx.DiGraph()
1458: (4)               def _populate_edge_dict(
1459: (8)                   self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]
1460: (4)               ):
1461: (8)                   self.edges = {
1462: (12)                      (u, v): edge_type(
1463: (16)                          self[u],
1464: (16)                          self[v],
1465: (16)                          z_index=-1,
1466: (16)                          **self._edge_config[(u, v)],
1467: (12)                      )
1468: (12)                      for (u, v) in edges
1469: (8)                   }
1470: (8)                   for (u, v), edge in self.edges.items():
1471: (12)                      edge.add_tip(**self._tip_config[(u, v)])
1472: (4)               def update_edges(self, graph):
1473: (8)                   """Updates the edges to stick at their corresponding vertices.
1474: (8)                   Arrow tips need to be repositioned since otherwise they can be
1475: (8)                   deformed.
1476: (8)                   """
1477: (8)                   for (u, v), edge in graph.edges.items():
1478: (12)                      edge_type = type(edge)
1479: (12)                      tip = edge.pop_tips()[0]
1480: (12)                      new_edge = edge_type(self[u], self[v], **self._edge_config[(u, v)])
1481: (12)                      edge.become(new_edge)
1482: (12)                      edge.add_tip(tip)
1483: (4)               def __repr__(self: DiGraph) -> str:
1484: (8)                   return f"Directed graph on {len(self.vertices)} vertices and {len(self.edges)} edges"

----------------------------------------

File 7 - .\graphing \scale.py:

1: (0)              from __future__ import annotations
2: (0)              import math
3: (0)              from typing import TYPE_CHECKING, Any, Iterable
4: (0)              import numpy as np
5: (0)              __all__ = ["LogBase", "LinearBase"]
6: (0)              from manim.mobject.text.numbers import Integer
7: (0)              if TYPE_CHECKING:
8: (4)                  from manim.mobject.mobject import Mobject
9: (0)              class _ScaleBase:
10: (4)                 """Scale baseclass for graphing/functions.
11: (4)                 Parameters
12: (4)                 ----------
13: (4)                 custom_labels
14: (8)                     Whether to create custom labels when plotted on a :class:`~.NumberLine`.
15: (4)                 """
16: (4)                 def __init__(self, custom_labels: bool = False):
17: (8)                     self.custom_labels = custom_labels
18: (4)                 def function(self, value: float) -> float:
19: (8)                     """The function that will be used to scale the values.
20: (8)                     Parameters
21: (8)                     ----------
22: (8)                     value
23: (12)                        The number/``np.ndarray`` to be scaled.
24: (8)                     Returns
25: (8)                     -------
26: (8)                     float
27: (12)                        The value after it has undergone the scaling.
28: (8)                     Raises
29: (8)                     ------
30: (8)                     NotImplementedError
31: (12)                        Must be subclassed.
32: (8)                     """
33: (8)                     raise NotImplementedError
34: (4)                 def inverse_function(self, value: float) -> float:
35: (8)                     """The inverse of ``function``. Used for plotting on a particular axis.
36: (8)                     Raises
37: (8)                     ------
38: (8)                     NotImplementedError
39: (12)                        Must be subclassed.
40: (8)                     """
41: (8)                     raise NotImplementedError
42: (4)                 def get_custom_labels(
43: (8)                     self,
44: (8)                     val_range: Iterable[float],
45: (4)                 ) -> Iterable[Mobject]:
46: (8)                     """Custom instructions for generating labels along an axis.
47: (8)                     Parameters
48: (8)                     ----------
49: (8)                     val_range
50: (12)                        The position of labels. Also used for defining the content of the labels.
51: (8)                     Returns
52: (8)                     -------
53: (8)                     Dict
54: (12)                        A list consisting of the labels.
55: (12)                        Can be passed to :meth:`~.NumberLine.add_labels() along with ``val_range``.
56: (8)                     Raises
57: (8)                     ------
58: (8)                     NotImplementedError
59: (12)                        Can be subclassed, optional.
60: (8)                     """
61: (8)                     raise NotImplementedError
62: (0)             class LinearBase(_ScaleBase):
63: (4)                 def __init__(self, scale_factor: float = 1.0):
64: (8)                     """The default scaling class.
65: (8)                     Parameters
66: (8)                     ----------
67: (8)                     scale_factor
68: (12)                        The slope of the linear function, by default 1.0
69: (8)                     """
70: (8)                     super().__init__()
71: (8)                     self.scale_factor = scale_factor
72: (4)                 def function(self, value: float) -> float:
73: (8)                     """Multiplies the value by the scale factor.
74: (8)                     Parameters
75: (8)                     ----------
76: (8)                     value
77: (12)                        Value to be multiplied by the scale factor.
78: (8)                     """
79: (8)                     return self.scale_factor * value
80: (4)                 def inverse_function(self, value: float) -> float:
81: (8)                     """Inverse of function. Divides the value by the scale factor.
82: (8)                     Parameters
83: (8)                     ----------
84: (8)                     value
85: (12)                        value to be divided by the scale factor.
86: (8)                     """
87: (8)                     return value / self.scale_factor
88: (0)             class LogBase(_ScaleBase):
89: (4)                 def __init__(self, base: float = 10, custom_labels: bool = True):
90: (8)                     """Scale for logarithmic graphs/functions.
91: (8)                     Parameters
92: (8)                     ----------
93: (8)                     base
94: (12)                        The base of the log, by default 10.
95: (8)                     custom_labels
96: (12)                        For use with :class:`~.Axes`:
97: (12)                        Whether or not to include ``LaTeX`` axis labels, by default True.
98: (8)                     Examples
99: (8)                     --------
100: (8)                    .. code-block:: python
101: (12)                       func = ParametricFunction(lambda x: x, scaling=LogBase(base=2))
102: (8)                    """
103: (8)                    super().__init__()
104: (8)                    self.base = base
105: (8)                    self.custom_labels = custom_labels
106: (4)                def function(self, value: float) -> float:
107: (8)                    """Scales the value to fit it to a logarithmic scale.``self.function(5)==10**5``"""
108: (8)                    return self.base**value
109: (4)                def inverse_function(self, value: float) -> float:
110: (8)                    """Inverse of ``function``. The value must be greater than 0"""
111: (8)                    if isinstance(value, np.ndarray):
112: (12)                       condition = value.any() <= 0
113: (12)                       func = lambda value, base: np.log(value) / np.log(base)
114: (8)                    else:
115: (12)                       condition = value <= 0
116: (12)                       func = math.log
117: (8)                    if condition:
118: (12)                       raise ValueError(
119: (16)                           "log(0) is undefined. Make sure the value is in the domain of the function"
120: (12)                       )
121: (8)                    value = func(value, self.base)
122: (8)                    return value
123: (4)                def get_custom_labels(
124: (8)                    self,
125: (8)                    val_range: Iterable[float],
126: (8)                    unit_decimal_places: int = 0,
127: (8)                    **base_config: dict[str, Any],
128: (4)                ) -> list[Mobject]:
129: (8)                    """Produces custom :class:`~.Integer` labels in the form of ``10^2``.
130: (8)                    Parameters
131: (8)                    ----------
132: (8)                    val_range
133: (12)                       The iterable of values used to create the labels. Determines the exponent.
134: (8)                    unit_decimal_places
135: (12)                       The number of decimal places to include in the exponent
136: (8)                    base_config
137: (12)                       Additional arguments to be passed to :class:`~.Integer`.
138: (8)                    """
139: (8)                    # uses `format` syntax to control the number of decimal places.
140: (8)                    tex_labels = [
141: (12)                       Integer(
142: (16)                           self.base,
143: (16)                           unit="^{%s}" % (f"{self.inverse_function(i):.{unit_decimal_places}f}"),
144: (16)                           **base_config,
145: (12)                       )
146: (12)                       for i in val_range
147: (8)                    ]
148: (8)                    return tex_labels

----------------------------------------

File 8 - . \matrix.py:

1: (0)              r"""Mobjects representing matrices.
2: (0)              Examples
3: (0)              --------
4: (0)              .. manim:: MatrixExamples
5: (4)                  :save_last_frame:
6: (4)                  class MatrixExamples(Scene):
7: (8)                      def construct(self):
8: (12)                         m0 = Matrix([["\\pi", 0], [-1, 1]])
9: (12)                         m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],
10: (16)                            left_bracket="(",
11: (16)                            right_bracket=")")
12: (12)                        m2 = DecimalMatrix(
13: (16)                            [[3.456, 2.122], [33.2244, 12.33]],
14: (16)                            element_to_mobject_config={"num_decimal_places": 2},
15: (16)                            left_bracket="\\{",
16: (16)                            right_bracket="\\}")
17: (12)                        m3 = MobjectMatrix(
18: (16)                            [[Circle().scale(0.3), Square().scale(0.3)],
19: (16)                            [MathTex("\\pi").scale(2), Star().scale(0.3)]],
20: (16)                            left_bracket="\\langle",
21: (16)                            right_bracket="\\rangle")
22: (12)                        g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)
23: (12)                        self.add(g)
24: (0)             """
25: (0)             from __future__ import annotations
26: (0)             __all__ = [
27: (4)                 "Matrix",
28: (4)                 "DecimalMatrix",
29: (4)                 "IntegerMatrix",
30: (4)                 "MobjectMatrix",
31: (4)                 "matrix_to_tex_string",
32: (4)                 "matrix_to_mobject",
33: (4)                 "get_det_text",
34: (0)             ]
35: (0)             import itertools as it
36: (0)             from typing import Iterable, Sequence
37: (0)             import numpy as np
38: (0)             from manim.mobject.mobject import Mobject
39: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
40: (0)             from manim.mobject.text.numbers import DecimalNumber, Integer
41: (0)             from manim.mobject.text.tex_mobject import MathTex, Tex
42: (0)             from ..constants import *
43: (0)             from ..mobject.types.vectorized_mobject import VGroup, VMobject
44: (0)             # TO DO : The following two functions are not used in this file.
45: (0)             #         Not sure if we should keep it or not.
46: (0)             def matrix_to_tex_string(matrix):
47: (4)                 matrix = np.array(matrix).astype("str")
48: (4)                 if matrix.ndim == 1:
49: (8)                     matrix = matrix.reshape((matrix.size, 1))
50: (4)                 n_rows, n_cols = matrix.shape
51: (4)                 prefix = "\\left[ \\begin{array}{%s}" % ("c" * n_cols)
52: (4)                 suffix = "\\end{array} \\right]"
53: (4)                 rows = [" & ".join(row) for row in matrix]
54: (4)                 return prefix + " \\\\ ".join(rows) + suffix
55: (0)             def matrix_to_mobject(matrix):
56: (4)                 return MathTex(matrix_to_tex_string(matrix))
57: (0)             class Matrix(VMobject, metaclass=ConvertToOpenGL):
58: (4)                 """A mobject that displays a matrix on the screen.
59: (4)                 Parameters
60: (4)                 ----------
61: (4)                 matrix
62: (8)                     A numpy 2d array or list of lists.
63: (4)                 v_buff
64: (8)                     Vertical distance between elements, by default 0.8.
65: (4)                 h_buff
66: (8)                     Horizontal distance between elements, by default 1.3.
67: (4)                 bracket_h_buff
68: (8)                     Distance of the brackets from the matrix, by default ``MED_SMALL_BUFF``.
69: (4)                 bracket_v_buff
70: (8)                     Height of the brackets, by default ``MED_SMALL_BUFF``.
71: (4)                 add_background_rectangles_to_entries
72: (8)                     ``True`` if should add backgraound rectangles to entries, by default ``False``.
73: (4)                 include_background_rectangle
74: (8)                     ``True`` if should include background rectangle, by default ``False``.
75: (4)                 element_to_mobject
76: (8)                     The mobject class used to construct the elements, by default :class:`~.MathTex`.
77: (4)                 element_to_mobject_config
78: (8)                     Additional arguments to be passed to the constructor in ``element_to_mobject``,
79: (8)                     by default ``{}``.
80: (4)                 element_alignment_corner
81: (8)                     The corner to which elements are aligned, by default ``DR``.
82: (4)                 left_bracket
83: (8)                     The left bracket type, by default ``"["``.
84: (4)                 right_bracket
85: (8)                     The right bracket type, by default ``"]"``.
86: (4)                 stretch_brackets
87: (8)                     ``True`` if should stretch the brackets to fit the height of matrix contents, by default ``True``.
88: (4)                 bracket_config
89: (8)                     Additional arguments to be passed to :class:`~.MathTex` when constructing
90: (8)                     the brackets.
91: (4)                 Examples
92: (4)                 --------
93: (4)                 The first example shows a variety of uses of this module while the second example
94: (4)                 exlpains the use of the options `add_background_rectangles_to_entries` and
95: (4)                 `include_background_rectangle`.
96: (4)                 .. manim:: MatrixExamples
97: (8)                     :save_last_frame:
98: (8)                     class MatrixExamples(Scene):
99: (12)                        def construct(self):
100: (16)                           m0 = Matrix([[2, "\\pi"], [-1, 1]])
101: (16)                           m1 = Matrix([[2, 0, 4], [-1, 1, 5]],
102: (20)                               v_buff=1.3,
103: (20)                               h_buff=0.8,
104: (20)                               bracket_h_buff=SMALL_BUFF,
105: (20)                               bracket_v_buff=SMALL_BUFF,
106: (20)                               left_bracket="\\{",
107: (20)                               right_bracket="\\}")
108: (16)                           m1.add(SurroundingRectangle(m1.get_columns()[1]))
109: (16)                           m2 = Matrix([[2, 1], [-1, 3]],
110: (20)                               element_alignment_corner=UL,
111: (20)                               left_bracket="(",
112: (20)                               right_bracket=")")
113: (16)                           m3 = Matrix([[2, 1], [-1, 3]],
114: (20)                               left_bracket="\\\\langle",
115: (20)                               right_bracket="\\\\rangle")
116: (16)                           m4 = Matrix([[2, 1], [-1, 3]],
117: (16)                           ).set_column_colors(RED, GREEN)
118: (16)                           m5 = Matrix([[2, 1], [-1, 3]],
119: (16)                           ).set_row_colors(RED, GREEN)
120: (16)                           g = Group(
121: (20)                               m0,m1,m2,m3,m4,m5
122: (16)                           ).arrange_in_grid(buff=2)
123: (16)                           self.add(g)
124: (4)                .. manim:: BackgroundRectanglesExample
125: (8)                    :save_last_frame:
126: (8)                    class BackgroundRectanglesExample(Scene):
127: (12)                       def construct(self):
128: (16)                           background= Rectangle().scale(3.2)
129: (16)                           background.set_fill(opacity=.5)
130: (16)                           background.set_color([TEAL, RED, YELLOW])
131: (16)                           self.add(background)
132: (16)                           m0 = Matrix([[12, -30], [-1, 15]],
133: (20)                               add_background_rectangles_to_entries=True)
134: (16)                           m1 = Matrix([[2, 0], [-1, 1]],
135: (20)                               include_background_rectangle=True)
136: (16)                           m2 = Matrix([[12, -30], [-1, 15]])
137: (16)                           g = Group(m0, m1, m2).arrange(buff=2)
138: (16)                           self.add(g)
139: (4)                """
140: (4)                def __init__(
141: (8)                    self,
142: (8)                    matrix: Iterable,
143: (8)                    v_buff: float = 0.8,
144: (8)                    h_buff: float = 1.3,
145: (8)                    bracket_h_buff: float = MED_SMALL_BUFF,
146: (8)                    bracket_v_buff: float = MED_SMALL_BUFF,
147: (8)                    add_background_rectangles_to_entries: bool = False,
148: (8)                    include_background_rectangle: bool = False,
149: (8)                    element_to_mobject: type[MathTex] = MathTex,
150: (8)                    element_to_mobject_config: dict = {},
151: (8)                    element_alignment_corner: Sequence[float] = DR,
152: (8)                    left_bracket: str = "[",
153: (8)                    right_bracket: str = "]",
154: (8)                    stretch_brackets: bool = True,
155: (8)                    bracket_config: dict = {},
156: (8)                    **kwargs,
157: (4)                ):
158: (8)                    self.v_buff = v_buff
159: (8)                    self.h_buff = h_buff
160: (8)                    self.bracket_h_buff = bracket_h_buff
161: (8)                    self.bracket_v_buff = bracket_v_buff
162: (8)                    self.add_background_rectangles_to_entries = add_background_rectangles_to_entries
163: (8)                    self.include_background_rectangle = include_background_rectangle
164: (8)                    self.element_to_mobject = element_to_mobject
165: (8)                    self.element_to_mobject_config = element_to_mobject_config
166: (8)                    self.element_alignment_corner = element_alignment_corner
167: (8)                    self.left_bracket = left_bracket
168: (8)                    self.right_bracket = right_bracket
169: (8)                    self.stretch_brackets = stretch_brackets
170: (8)                    super().__init__(**kwargs)
171: (8)                    mob_matrix = self._matrix_to_mob_matrix(matrix)
172: (8)                    self._organize_mob_matrix(mob_matrix)
173: (8)                    self.elements = VGroup(*it.chain(*mob_matrix))
174: (8)                    self.add(self.elements)
175: (8)                    self._add_brackets(self.left_bracket, self.right_bracket, **bracket_config)
176: (8)                    self.center()
177: (8)                    self.mob_matrix = mob_matrix
178: (8)                    if self.add_background_rectangles_to_entries:
179: (12)                       for mob in self.elements:
180: (16)                           mob.add_background_rectangle()
181: (8)                    if self.include_background_rectangle:
182: (12)                       self.add_background_rectangle()
183: (4)                def _matrix_to_mob_matrix(self, matrix):
184: (8)                    return [
185: (12)                       [
186: (16)                           self.element_to_mobject(item, **self.element_to_mobject_config)
187: (16)                           for item in row
188: (12)                       ]
189: (12)                       for row in matrix
190: (8)                    ]
191: (4)                def _organize_mob_matrix(self, matrix):
192: (8)                    for i, row in enumerate(matrix):
193: (12)                       for j, _ in enumerate(row):
194: (16)                           mob = matrix[i][j]
195: (16)                           mob.move_to(
196: (20)                               i * self.v_buff * DOWN + j * self.h_buff * RIGHT,
197: (20)                               self.element_alignment_corner,
198: (16)                           )
199: (8)                    return self
200: (4)                def _add_brackets(self, left: str = "[", right: str = "]", **kwargs):
201: (8)                    """Adds the brackets to the Matrix mobject.
202: (8)                    See Latex document for various bracket types.
203: (8)                    Parameters
204: (8)                    ----------
205: (8)                    left
206: (12)                       the left bracket, by default "["
207: (8)                    right
208: (12)                       the right bracket, by default "]"
209: (8)                    Returns
210: (8)                    -------
211: (8)                    :class:`Matrix`
212: (12)                       The current matrix object (self).
213: (8)                    """
214: (8)                    # Height per row of LaTeX array with default settings
215: (8)                    BRACKET_HEIGHT = 0.5977
216: (8)                    n = int((self.height) / BRACKET_HEIGHT) + 1
217: (8)                    empty_tex_array = "".join(
218: (12)                       [
219: (16)                           r"\begin{array}{c}",
220: (16)                           *n * [r"\quad \\"],
221: (16)                           r"\end{array}",
222: (12)                       ]
223: (8)                    )
224: (8)                    tex_left = "".join(
225: (12)                       [
226: (16)                           r"\left" + left,
227: (16)                           empty_tex_array,
228: (16)                           r"\right.",
229: (12)                       ]
230: (8)                    )
231: (8)                    tex_right = "".join(
232: (12)                       [
233: (16)                           r"\left.",
234: (16)                           empty_tex_array,
235: (16)                           r"\right" + right,
236: (12)                       ]
237: (8)                    )
238: (8)                    l_bracket = MathTex(tex_left, **kwargs)
239: (8)                    r_bracket = MathTex(tex_right, **kwargs)
240: (8)                    bracket_pair = VGroup(l_bracket, r_bracket)
241: (8)                    if self.stretch_brackets:
242: (12)                       bracket_pair.stretch_to_fit_height(self.height + 2 * self.bracket_v_buff)
243: (8)                    l_bracket.next_to(self, LEFT, self.bracket_h_buff)
244: (8)                    r_bracket.next_to(self, RIGHT, self.bracket_h_buff)
245: (8)                    self.brackets = bracket_pair
246: (8)                    self.add(l_bracket, r_bracket)
247: (8)                    return self
248: (4)                def get_columns(self):
249: (8)                    """Return columns of the matrix as VGroups.
250: (8)                    Returns
251: (8)                    --------
252: (8)                    List[:class:`~.VGroup`]
253: (12)                       Each VGroup contains a column of the matrix.
254: (8)                    Examples
255: (8)                    --------
256: (8)                    .. manim:: GetColumnsExample
257: (12)                       :save_last_frame:
258: (12)                       class GetColumnsExample(Scene):
259: (16)                           def construct(self):
260: (20)                               m0 = Matrix([["\\pi", 3], [1, 5]])
261: (20)                               m0.add(SurroundingRectangle(m0.get_columns()[1]))
262: (20)                               self.add(m0)
263: (8)                    """
264: (8)                    return VGroup(
265: (12)                       *(
266: (16)                           VGroup(*(row[i] for row in self.mob_matrix))
267: (16)                           for i in range(len(self.mob_matrix[0]))
268: (12)                       )
269: (8)                    )
270: (4)                def set_column_colors(self, *colors: str):
271: (8)                    """Set individual colors for each columns of the matrix.
272: (8)                    Parameters
273: (8)                    ----------
274: (8)                    colors
275: (12)                       The list of colors; each color specified corresponds to a column.
276: (8)                    Returns
277: (8)                    -------
278: (8)                    :class:`Matrix`
279: (12)                       The current matrix object (self).
280: (8)                    Examples
281: (8)                    --------
282: (8)                    .. manim:: SetColumnColorsExample
283: (12)                       :save_last_frame:
284: (12)                       class SetColumnColorsExample(Scene):
285: (16)                           def construct(self):
286: (20)                               m0 = Matrix([["\\pi", 1], [-1, 3]],
287: (20)                               ).set_column_colors([RED,BLUE], GREEN)
288: (20)                               self.add(m0)
289: (8)                    """
290: (8)                    columns = self.get_columns()
291: (8)                    for color, column in zip(colors, columns):
292: (12)                       column.set_color(color)
293: (8)                    return self
294: (4)                def get_rows(self):
295: (8)                    """Return rows of the matrix as VGroups.
296: (8)                    Returns
297: (8)                    --------
298: (8)                    List[:class:`~.VGroup`]
299: (12)                       Each VGroup contains a row of the matrix.
300: (8)                    Examples
301: (8)                    --------
302: (8)                    .. manim:: GetRowsExample
303: (12)                       :save_last_frame:
304: (12)                       class GetRowsExample(Scene):
305: (16)                           def construct(self):
306: (20)                               m0 = Matrix([["\\pi", 3], [1, 5]])
307: (20)                               m0.add(SurroundingRectangle(m0.get_rows()[1]))
308: (20)                               self.add(m0)
309: (8)                    """
310: (8)                    return VGroup(*(VGroup(*row) for row in self.mob_matrix))
311: (4)                def set_row_colors(self, *colors: str):
312: (8)                    """Set individual colors for each row of the matrix.
313: (8)                    Parameters
314: (8)                    ----------
315: (8)                    colors
316: (12)                       The list of colors; each color specified corresponds to a row.
317: (8)                    Returns
318: (8)                    -------
319: (8)                    :class:`Matrix`
320: (12)                       The current matrix object (self).
321: (8)                    Examples
322: (8)                    --------
323: (8)                    .. manim:: SetRowColorsExample
324: (12)                       :save_last_frame:
325: (12)                       class SetRowColorsExample(Scene):
326: (16)                           def construct(self):
327: (20)                               m0 = Matrix([["\\pi", 1], [-1, 3]],
328: (20)                               ).set_row_colors([RED,BLUE], GREEN)
329: (20)                               self.add(m0)
330: (8)                    """
331: (8)                    rows = self.get_rows()
332: (8)                    for color, row in zip(colors, rows):
333: (12)                       row.set_color(color)
334: (8)                    return self
335: (4)                def add_background_to_entries(self):
336: (8)                    """Add a black background rectangle to the matrix,
337: (8)                    see above for an example.
338: (8)                    Returns
339: (8)                    -------
340: (8)                    :class:`Matrix`
341: (12)                       The current matrix object (self).
342: (8)                    """
343: (8)                    for mob in self.get_entries():
344: (12)                       mob.add_background_rectangle()
345: (8)                    return self
346: (4)                def get_mob_matrix(self):
347: (8)                    """Return the underlying mob matrix mobjects.
348: (8)                    Returns
349: (8)                    --------
350: (8)                    List[:class:`~.VGroup`]
351: (12)                       Each VGroup contains a row of the matrix.
352: (8)                    """
353: (8)                    return self.mob_matrix
354: (4)                def get_entries(self):
355: (8)                    """Return the individual entries of the matrix.
356: (8)                    Returns
357: (8)                    --------
358: (8)                    :class:`~.VGroup`
359: (12)                       VGroup containing entries of the matrix.
360: (8)                    Examples
361: (8)                    --------
362: (8)                    .. manim:: GetEntriesExample
363: (12)                       :save_last_frame:
364: (12)                       class GetEntriesExample(Scene):
365: (16)                           def construct(self):
366: (20)                               m0 = Matrix([[2, 3], [1, 5]])
367: (20)                               ent = m0.get_entries()
368: (20)                               colors = [BLUE, GREEN, YELLOW, RED]
369: (20)                               for k in range(len(colors)):
370: (24)                                   ent[k].set_color(colors[k])
371: (20)                               self.add(m0)
372: (8)                    """
373: (8)                    return self.elements
374: (4)                def get_brackets(self):
375: (8)                    """Return the bracket mobjects.
376: (8)                    Returns
377: (8)                    --------
378: (8)                    List[:class:`~.VGroup`]
379: (12)                       Each VGroup contains a bracket
380: (8)                    Examples
381: (8)                    --------
382: (8)                    .. manim:: GetBracketsExample
383: (12)                       :save_last_frame:
384: (12)                       class GetBracketsExample(Scene):
385: (16)                           def construct(self):
386: (20)                               m0 = Matrix([["\\pi", 3], [1, 5]])
387: (20)                               bra = m0.get_brackets()
388: (20)                               colors = [BLUE, GREEN]
389: (20)                               for k in range(len(colors)):
390: (24)                                   bra[k].set_color(colors[k])
391: (20)                               self.add(m0)
392: (8)                    """
393: (8)                    return self.brackets
394: (0)            class DecimalMatrix(Matrix):
395: (4)                """A mobject that displays a matrix with decimal entries on the screen.
396: (4)                Examples
397: (4)                --------
398: (4)                .. manim:: DecimalMatrixExample
399: (8)                    :save_last_frame:
400: (8)                    class DecimalMatrixExample(Scene):
401: (12)                       def construct(self):
402: (16)                           m0 = DecimalMatrix(
403: (20)                               [[3.456, 2.122], [33.2244, 12]],
404: (20)                               element_to_mobject_config={"num_decimal_places": 2},
405: (20)                               left_bracket="\\{",
406: (20)                               right_bracket="\\}")
407: (16)                           self.add(m0)
408: (4)                """
409: (4)                def __init__(
410: (8)                    self,
411: (8)                    matrix: Iterable,
412: (8)                    element_to_mobject: Mobject = DecimalNumber,
413: (8)                    element_to_mobject_config: dict[str, Mobject] = {"num_decimal_places": 1},
414: (8)                    **kwargs,
415: (4)                ):
416: (8)                    """
417: (8)                    Will round/truncate the decimal places as per the provided config.
418: (8)                    Parameters
419: (8)                    ----------
420: (8)                    matrix
421: (12)                       A numpy 2d array or list of lists
422: (8)                    element_to_mobject
423: (12)                       Mobject to use, by default DecimalNumber
424: (8)                    element_to_mobject_config
425: (12)                       Config for the desired mobject, by default {"num_decimal_places": 1}
426: (8)                    """
427: (8)                    super().__init__(
428: (12)                       matrix,
429: (12)                       element_to_mobject=element_to_mobject,
430: (12)                       element_to_mobject_config=element_to_mobject_config,
431: (12)                       **kwargs,
432: (8)                    )
433: (0)            class IntegerMatrix(Matrix):
434: (4)                """A mobject that displays a matrix with integer entries on the screen.
435: (4)                Examples
436: (4)                --------
437: (4)                .. manim:: IntegerMatrixExample
438: (8)                    :save_last_frame:
439: (8)                    class IntegerMatrixExample(Scene):
440: (12)                       def construct(self):
441: (16)                           m0 = IntegerMatrix(
442: (20)                               [[3.7, 2], [42.2, 12]],
443: (20)                               left_bracket="(",
444: (20)                               right_bracket=")")
445: (16)                           self.add(m0)
446: (4)                """
447: (4)                def __init__(
448: (8)                    self, matrix: Iterable, element_to_mobject: Mobject = Integer, **kwargs
449: (4)                ):
450: (8)                    """
451: (8)                    Will round if there are decimal entries in the matrix.
452: (8)                    Parameters
453: (8)                    ----------
454: (8)                    matrix
455: (12)                       A numpy 2d array or list of lists
456: (8)                    element_to_mobject
457: (12)                       Mobject to use, by default Integer
458: (8)                    """
459: (8)                    super().__init__(matrix, element_to_mobject=element_to_mobject, **kwargs)
460: (0)            class MobjectMatrix(Matrix):
461: (4)                """A mobject that displays a matrix of mobject entries on the screen.
462: (4)                Examples
463: (4)                --------
464: (4)                .. manim:: MobjectMatrixExample
465: (8)                    :save_last_frame:
466: (8)                    class MobjectMatrixExample(Scene):
467: (12)                       def construct(self):
468: (16)                           a = Circle().scale(0.3)
469: (16)                           b = Square().scale(0.3)
470: (16)                           c = MathTex("\\pi").scale(2)
471: (16)                           d = Star().scale(0.3)
472: (16)                           m0 = MobjectMatrix([[a, b], [c, d]])
473: (16)                           self.add(m0)
474: (4)                """
475: (4)                def __init__(self, matrix, element_to_mobject=lambda m: m, **kwargs):
476: (8)                    super().__init__(matrix, element_to_mobject=element_to_mobject, **kwargs)
477: (0)            def get_det_text(
478: (4)                matrix: Matrix,
479: (4)                determinant: int | str | None = None,
480: (4)                background_rect: bool = False,
481: (4)                initial_scale_factor: float = 2,
482: (0)            ):
483: (4)                r"""Helper function to create determinant.
484: (4)                Parameters
485: (4)                ----------
486: (4)                matrix
487: (8)                    The matrix whose determinant is to be created
488: (4)                determinant
489: (8)                    The value of the determinant of the matrix
490: (4)                background_rect
491: (8)                    The background rectangle
492: (4)                initial_scale_factor
493: (8)                    The scale of the text `det` w.r.t the matrix
494: (4)                Returns
495: (4)                --------
496: (4)                :class:`~.VGroup`
497: (8)                    A VGroup containing the determinant
498: (4)                Examples
499: (4)                --------
500: (4)                .. manim:: DeterminantOfAMatrix
501: (8)                    :save_last_frame:
502: (8)                    class DeterminantOfAMatrix(Scene):
503: (12)                       def construct(self):
504: (16)                           matrix = Matrix([
505: (20)                               [2, 0],
506: (20)                               [-1, 1]
507: (16)                           ])
508: (16)                           # scaling down the `det` string
509: (16)                           det = get_det_text(matrix,
510: (28)                                       determinant=3,
511: (28)                                       initial_scale_factor=1)
512: (16)                           # must add the matrix
513: (16)                           self.add(matrix)
514: (16)                           self.add(det)
515: (4)                """
516: (4)                parens = MathTex("(", ")")
517: (4)                parens.scale(initial_scale_factor)
518: (4)                parens.stretch_to_fit_height(matrix.height)
519: (4)                l_paren, r_paren = parens.split()
520: (4)                l_paren.next_to(matrix, LEFT, buff=0.1)
521: (4)                r_paren.next_to(matrix, RIGHT, buff=0.1)
522: (4)                det = Tex("det")
523: (4)                det.scale(initial_scale_factor)
524: (4)                det.next_to(l_paren, LEFT, buff=0.1)
525: (4)                if background_rect:
526: (8)                    det.add_background_rectangle()
527: (4)                det_text = VGroup(det, l_paren, r_paren)
528: (4)                if determinant is not None:
529: (8)                    eq = MathTex("=")
530: (8)                    eq.next_to(r_paren, RIGHT, buff=0.1)
531: (8)                    result = MathTex(str(determinant))
532: (8)                    result.next_to(eq, RIGHT, buff=0.2)
533: (8)                    det_text.add(eq, result)
534: (4)                return det_text

----------------------------------------

File 9 - . \mobject.py:

1: (0)              """Base classes for objects that can be displayed."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["Mobject", "Group", "override_animate"]
4: (0)              import copy
5: (0)              import inspect
6: (0)              import itertools as it
7: (0)              import math
8: (0)              import operator as op
9: (0)              import random
10: (0)             import sys
11: (0)             import types
12: (0)             import warnings
13: (0)             from functools import partialmethod, reduce
14: (0)             from pathlib import Path
15: (0)             from typing import TYPE_CHECKING, Callable, Iterable, Literal
16: (0)             import numpy as np
17: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
18: (0)             from .. import config, logger
19: (0)             from ..constants import *
20: (0)             from ..utils.color import (
21: (4)                 BLACK,
22: (4)                 WHITE,
23: (4)                 YELLOW_C,
24: (4)                 ManimColor,
25: (4)                 ParsableManimColor,
26: (4)                 color_gradient,
27: (4)                 interpolate_color,
28: (0)             )
29: (0)             from ..utils.exceptions import MultiAnimationOverrideException
30: (0)             from ..utils.iterables import list_update, remove_list_redundancies
31: (0)             from ..utils.paths import straight_path
32: (0)             from ..utils.space_ops import angle_between_vectors, normalize, rotation_matrix
33: (0)             if TYPE_CHECKING:
34: (4)                 from typing_extensions import Self, TypeAlias
35: (4)                 from manim.typing import (
36: (8)                     FunctionOverride,
37: (8)                     Image,
38: (8)                     ManimFloat,
39: (8)                     ManimInt,
40: (8)                     MappingFunction,
41: (8)                     PathFuncType,
42: (8)                     Point3D,
43: (8)                     Point3D_Array,
44: (8)                     Vector3D,
45: (4)                 )
46: (4)                 from ..animation.animation import Animation
47: (4)                 TimeBasedUpdater: TypeAlias = Callable[["Mobject", float], object]
48: (4)                 NonTimeBasedUpdater: TypeAlias = Callable[["Mobject"], object]
49: (4)                 Updater: TypeAlias = NonTimeBasedUpdater | TimeBasedUpdater
50: (0)             class Mobject:
51: (4)                 """Mathematical Object: base class for objects that can be displayed on screen.
52: (4)                 There is a compatibility layer that allows for
53: (4)                 getting and setting generic attributes with ``get_*``
54: (4)                 and ``set_*`` methods. See :meth:`set` for more details.
55: (4)                 Attributes
56: (4)                 ----------
57: (4)                 submobjects : List[:class:`Mobject`]
58: (8)                     The contained objects.
59: (4)                 points : :class:`numpy.ndarray`
60: (8)                     The points of the objects.
61: (8)                     .. seealso::
62: (12)                        :class:`~.VMobject`
63: (4)                 """
64: (4)                 animation_overrides = {}
65: (4)                 @classmethod
66: (4)                 def __init_subclass__(cls, **kwargs) -> None:
67: (8)                     super().__init_subclass__(**kwargs)
68: (8)                     cls.animation_overrides: dict[
69: (12)                        type[Animation],
70: (12)                        FunctionOverride,
71: (8)                     ] = {}
72: (8)                     cls._add_intrinsic_animation_overrides()
73: (8)                     cls._original__init__ = cls.__init__
74: (4)                 def __init__(
75: (8)                     self,
76: (8)                     color: ParsableManimColor | list[ParsableManimColor] = WHITE,
77: (8)                     name: str | None = None,
78: (8)                     dim: int = 3,
79: (8)                     target=None,
80: (8)                     z_index: float = 0,
81: (4)                 ) -> None:
82: (8)                     self.name = self.__class__.__name__ if name is None else name
83: (8)                     self.dim = dim
84: (8)                     self.target = target
85: (8)                     self.z_index = z_index
86: (8)                     self.point_hash = None
87: (8)                     self.submobjects = []
88: (8)                     self.updaters: list[Updater] = []
89: (8)                     self.updating_suspended = False
90: (8)                     self.color = ManimColor.parse(color)
91: (8)                     self.reset_points()
92: (8)                     self.generate_points()
93: (8)                     self.init_colors()
94: (4)                 @classmethod
95: (4)                 def animation_override_for(
96: (8)                     cls,
97: (8)                     animation_class: type[Animation],
98: (4)                 ) -> FunctionOverride | None:
99: (8)                     """Returns the function defining a specific animation override for this class.
100: (8)                    Parameters
101: (8)                    ----------
102: (8)                    animation_class
103: (12)                       The animation class for which the override function should be returned.
104: (8)                    Returns
105: (8)                    -------
106: (8)                    Optional[Callable[[Mobject, ...], Animation]]
107: (12)                       The function returning the override animation or ``None`` if no such animation
108: (12)                       override is defined.
109: (8)                    """
110: (8)                    if animation_class in cls.animation_overrides:
111: (12)                       return cls.animation_overrides[animation_class]
112: (8)                    return None
113: (4)                @classmethod
114: (4)                def _add_intrinsic_animation_overrides(cls) -> None:
115: (8)                    """Initializes animation overrides marked with the :func:`~.override_animation`
116: (8)                    decorator.
117: (8)                    """
118: (8)                    for method_name in dir(cls):
119: (12)                       # Ignore dunder methods
120: (12)                       if method_name.startswith("__"):
121: (16)                           continue
122: (12)                       method = getattr(cls, method_name)
123: (12)                       if hasattr(method, "_override_animation"):
124: (16)                           animation_class = method._override_animation
125: (16)                           cls.add_animation_override(animation_class, method)
126: (4)                @classmethod
127: (4)                def add_animation_override(
128: (8)                    cls,
129: (8)                    animation_class: type[Animation],
130: (8)                    override_func: FunctionOverride,
131: (4)                ) -> None:
132: (8)                    """Add an animation override.
133: (8)                    This does not apply to subclasses.
134: (8)                    Parameters
135: (8)                    ----------
136: (8)                    animation_class
137: (12)                       The animation type to be overridden
138: (8)                    override_func
139: (12)                       The function returning an animation replacing the default animation. It gets
140: (12)                       passed the parameters given to the animation constructor.
141: (8)                    Raises
142: (8)                    ------
143: (8)                    MultiAnimationOverrideException
144: (12)                       If the overridden animation was already overridden.
145: (8)                    """
146: (8)                    if animation_class not in cls.animation_overrides:
147: (12)                       cls.animation_overrides[animation_class] = override_func
148: (8)                    else:
149: (12)                       raise MultiAnimationOverrideException(
150: (16)                           f"The animation {animation_class.__name__} for "
151: (16)                           f"{cls.__name__} is overridden by more than one method: "
152: (16)                           f"{cls.animation_overrides[animation_class].__qualname__} and "
153: (16)                           f"{override_func.__qualname__}.",
154: (12)                       )
155: (4)                @classmethod
156: (4)                def set_default(cls, **kwargs) -> None:
157: (8)                    """Sets the default values of keyword arguments.
158: (8)                    If this method is called without any additional keyword
159: (8)                    arguments, the original default values of the initialization
160: (8)                    method of this class are restored.
161: (8)                    Parameters
162: (8)                    ----------
163: (8)                    kwargs
164: (12)                       Passing any keyword argument will update the default
165: (12)                       values of the keyword arguments of the initialization
166: (12)                       function of this class.
167: (8)                    Examples
168: (8)                    --------
169: (8)                    ::
170: (12)                       >>> from manim import Square, GREEN
171: (12)                       >>> Square.set_default(color=GREEN, fill_opacity=0.25)
172: (12)                       >>> s = Square(); s.color, s.fill_opacity
173: (12)                       (ManimColor('#83C167'), 0.25)
174: (12)                       >>> Square.set_default()
175: (12)                       >>> s = Square(); s.color, s.fill_opacity
176: (12)                       (ManimColor('#FFFFFF'), 0.0)
177: (8)                    .. manim:: ChangedDefaultTextcolor
178: (12)                       :save_last_frame:
179: (12)                       config.background_color = WHITE
180: (12)                       class ChangedDefaultTextcolor(Scene):
181: (16)                           def construct(self):
182: (20)                               Text.set_default(color=BLACK)
183: (20)                               self.add(Text("Changing default values is easy!"))
184: (20)                               # we revert the colour back to the default to prevent a bug in the docs.
185: (20)                               Text.set_default(color=WHITE)
186: (8)                    """
187: (8)                    if kwargs:
188: (12)                       cls.__init__ = partialmethod(cls.__init__, **kwargs)
189: (8)                    else:
190: (12)                       cls.__init__ = cls._original__init__
191: (4)                @property
192: (4)                def animate(self) -> _AnimationBuilder | Self:
193: (8)                    """Used to animate the application of any method of :code:`self`.
194: (8)                    Any method called on :code:`animate` is converted to an animation of applying
195: (8)                    that method on the mobject itself.
196: (8)                    For example, :code:`square.set_fill(WHITE)` sets the fill color of a square,
197: (8)                    while :code:`square.animate.set_fill(WHITE)` animates this action.
198: (8)                    Multiple methods can be put in a single animation once via chaining:
199: (8)                    ::
200: (12)                       self.play(my_mobject.animate.shift(RIGHT).rotate(PI))
201: (8)                    .. warning::
202: (12)                       Passing multiple animations for the same :class:`Mobject` in one
203: (12)                       call to :meth:`~.Scene.play` is discouraged and will most likely
204: (12)                       not work properly. Instead of writing an animation like
205: (12)                       ::
206: (16)                           self.play(my_mobject.animate.shift(RIGHT), my_mobject.animate.rotate(PI))
207: (12)                       make use of method chaining.
208: (8)                    Keyword arguments that can be passed to :meth:`.Scene.play` can be passed
209: (8)                    directly after accessing ``.animate``, like so::
210: (12)                       self.play(my_mobject.animate(rate_func=linear).shift(RIGHT))
211: (8)                    This is especially useful when animating simultaneous ``.animate`` calls that
212: (8)                    you want to behave differently::
213: (12)                       self.play(
214: (16)                           mobject1.animate(run_time=2).rotate(PI),
215: (16)                           mobject2.animate(rate_func=there_and_back).shift(RIGHT),
216: (12)                       )
217: (8)                    .. seealso::
218: (12)                       :func:`override_animate`
219: (8)                    Examples
220: (8)                    --------
221: (8)                    .. manim:: AnimateExample
222: (12)                       class AnimateExample(Scene):
223: (16)                           def construct(self):
224: (20)                               s = Square()
225: (20)                               self.play(Create(s))
226: (20)                               self.play(s.animate.shift(RIGHT))
227: (20)                               self.play(s.animate.scale(2))
228: (20)                               self.play(s.animate.rotate(PI / 2))
229: (20)                               self.play(Uncreate(s))
230: (8)                    .. manim:: AnimateChainExample
231: (12)                       class AnimateChainExample(Scene):
232: (16)                           def construct(self):
233: (20)                               s = Square()
234: (20)                               self.play(Create(s))
235: (20)                               self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))
236: (20)                               self.play(Uncreate(s))
237: (8)                    .. manim:: AnimateWithArgsExample
238: (12)                       class AnimateWithArgsExample(Scene):
239: (16)                           def construct(self):
240: (20)                               s = Square()
241: (20)                               c = Circle()
242: (20)                               VGroup(s, c).arrange(RIGHT, buff=2)
243: (20)                               self.add(s, c)
244: (20)                               self.play(
245: (24)                                   s.animate(run_time=2).rotate(PI / 2),
246: (24)                                   c.animate(rate_func=there_and_back).shift(RIGHT),
247: (20)                               )
248: (8)                    .. warning::
249: (12)                       ``.animate``
250: (13)                        will interpolate the :class:`~.Mobject` between its points prior to
251: (13)                        ``.animate`` and its points after applying ``.animate`` to it. This may
252: (13)                        result in unexpected behavior when attempting to interpolate along paths,
253: (13)                        or rotations.
254: (13)                        If you want animations to consider the points between, consider using
255: (13)                        :class:`~.ValueTracker` with updaters instead.
256: (8)                    """
257: (8)                    return _AnimationBuilder(self)
258: (4)                def __deepcopy__(self, clone_from_id) -> Self:
259: (8)                    cls = self.__class__
260: (8)                    result = cls.__new__(cls)
261: (8)                    clone_from_id[id(self)] = result
262: (8)                    for k, v in self.__dict__.items():
263: (12)                       setattr(result, k, copy.deepcopy(v, clone_from_id))
264: (8)                    result.original_id = str(id(self))
265: (8)                    return result
266: (4)                def __repr__(self) -> str:
267: (8)                    return str(self.name)
268: (4)                def reset_points(self) -> None:
269: (8)                    """Sets :attr:`points` to be an empty array."""
270: (8)                    self.points = np.zeros((0, self.dim))
271: (4)                def init_colors(self) -> None:
272: (8)                    """Initializes the colors.
273: (8)                    Gets called upon creation. This is an empty method that can be implemented by
274: (8)                    subclasses.
275: (8)                    """
276: (4)                def generate_points(self) -> None:
277: (8)                    """Initializes :attr:`points` and therefore the shape.
278: (8)                    Gets called upon creation. This is an empty method that can be implemented by
279: (8)                    subclasses.
280: (8)                    """
281: (4)                def add(self, *mobjects: Mobject) -> Self:
282: (8)                    """Add mobjects as submobjects.
283: (8)                    The mobjects are added to :attr:`submobjects`.
284: (8)                    Subclasses of mobject may implement ``+`` and ``+=`` dunder methods.
285: (8)                    Parameters
286: (8)                    ----------
287: (8)                    mobjects
288: (12)                       The mobjects to add.
289: (8)                    Returns
290: (8)                    -------
291: (8)                    :class:`Mobject`
292: (12)                       ``self``
293: (8)                    Raises
294: (8)                    ------
295: (8)                    :class:`ValueError`
296: (12)                       When a mobject tries to add itself.
297: (8)                    :class:`TypeError`
298: (12)                       When trying to add an object that is not an instance of :class:`Mobject`.
299: (8)                    Notes
300: (8)                    -----
301: (8)                    A mobject cannot contain itself, and it cannot contain a submobject
302: (8)                    more than once.  If the parent mobject is displayed, the newly-added
303: (8)                    submobjects will also be displayed (i.e. they are automatically added
304: (8)                    to the parent Scene).
305: (8)                    See Also
306: (8)                    --------
307: (8)                    :meth:`remove`
308: (8)                    :meth:`add_to_back`
309: (8)                    Examples
310: (8)                    --------
311: (8)                    ::
312: (12)                       >>> outer = Mobject()
313: (12)                       >>> inner = Mobject()
314: (12)                       >>> outer = outer.add(inner)
315: (8)                    Duplicates are not added again::
316: (12)                       >>> outer = outer.add(inner)
317: (12)                       >>> len(outer.submobjects)
318: (12)                       1
319: (8)                    Adding an object to itself raises an error::
320: (12)                       >>> outer.add(outer)
321: (12)                       Traceback (most recent call last):
322: (12)                       ...
323: (12)                       ValueError: Mobject cannot contain self
324: (8)                    A given mobject cannot be added as a submobject
325: (8)                    twice to some parent::
326: (12)                       >>> parent = Mobject(name="parent")
327: (12)                       >>> child = Mobject(name="child")
328: (12)                       >>> parent.add(child, child)
329: (12)                       [...] WARNING  ...
330: (12)                       parent
331: (12)                       >>> parent.submobjects
332: (12)                       [child]
333: (8)                    """
334: (8)                    for m in mobjects:
335: (12)                       if not isinstance(m, Mobject):
336: (16)                           raise TypeError("All submobjects must be of type Mobject")
337: (12)                       if m is self:
338: (16)                           raise ValueError("Mobject cannot contain self")
339: (8)                    unique_mobjects = remove_list_redundancies(mobjects)
340: (8)                    if len(mobjects) != len(unique_mobjects):
341: (12)                       logger.warning(
342: (16)                           "Attempted adding some Mobject as a child more than once, "
343: (16)                           "this is not possible. Repetitions are ignored.",
344: (12)                       )
345: (8)                    self.submobjects = list_update(self.submobjects, unique_mobjects)
346: (8)                    return self
347: (4)                def insert(self, index: int, mobject: Mobject) -> None:
348: (8)                    """Inserts a mobject at a specific position into self.submobjects
349: (8)                    Effectively just calls  ``self.submobjects.insert(index, mobject)``,
350: (8)                    where ``self.submobjects`` is a list.
351: (8)                    Highly adapted from ``Mobject.add``.
352: (8)                    Parameters
353: (8)                    ----------
354: (8)                    index
355: (12)                       The index at which
356: (8)                    mobject
357: (12)                       The mobject to be inserted.
358: (8)                    """
359: (8)                    if not isinstance(mobject, Mobject):
360: (12)                       raise TypeError("All submobjects must be of type Mobject")
361: (8)                    if mobject is self:
362: (12)                       raise ValueError("Mobject cannot contain self")
363: (8)                    self.submobjects.insert(index, mobject)
364: (4)                def __add__(self, mobject: Mobject):
365: (8)                    raise NotImplementedError
366: (4)                def __iadd__(self, mobject: Mobject):
367: (8)                    raise NotImplementedError
368: (4)                def add_to_back(self, *mobjects: Mobject) -> Self:
369: (8)                    """Add all passed mobjects to the back of the submobjects.
370: (8)                    If :attr:`submobjects` already contains the given mobjects, they just get moved
371: (8)                    to the back instead.
372: (8)                    Parameters
373: (8)                    ----------
374: (8)                    mobjects
375: (12)                       The mobjects to add.
376: (8)                    Returns
377: (8)                    -------
378: (8)                    :class:`Mobject`
379: (12)                       ``self``
380: (8)                    .. note::
381: (12)                       Technically, this is done by adding (or moving) the mobjects to
382: (12)                       the head of :attr:`submobjects`. The head of this list is rendered
383: (12)                       first, which places the corresponding mobjects behind the
384: (12)                       subsequent list members.
385: (8)                    Raises
386: (8)                    ------
387: (8)                    :class:`ValueError`
388: (12)                       When a mobject tries to add itself.
389: (8)                    :class:`TypeError`
390: (12)                       When trying to add an object that is not an instance of :class:`Mobject`.
391: (8)                    Notes
392: (8)                    -----
393: (8)                    A mobject cannot contain itself, and it cannot contain a submobject
394: (8)                    more than once.  If the parent mobject is displayed, the newly-added
395: (8)                    submobjects will also be displayed (i.e. they are automatically added
396: (8)                    to the parent Scene).
397: (8)                    See Also
398: (8)                    --------
399: (8)                    :meth:`remove`
400: (8)                    :meth:`add`
401: (8)                    """
402: (8)                    if self in mobjects:
403: (12)                       raise ValueError("A mobject shouldn't contain itself")
404: (8)                    for mobject in mobjects:
405: (12)                       if not isinstance(mobject, Mobject):
406: (16)                           raise TypeError("All submobjects must be of type Mobject")
407: (8)                    self.remove(*mobjects)
408: (8)                    # dict.fromkeys() removes duplicates while maintaining order
409: (8)                    self.submobjects = list(dict.fromkeys(mobjects)) + self.submobjects
410: (8)                    return self
411: (4)                def remove(self, *mobjects: Mobject) -> Self:
412: (8)                    """Remove :attr:`submobjects`.
413: (8)                    The mobjects are removed from :attr:`submobjects`, if they exist.
414: (8)                    Subclasses of mobject may implement ``-`` and ``-=`` dunder methods.
415: (8)                    Parameters
416: (8)                    ----------
417: (8)                    mobjects
418: (12)                       The mobjects to remove.
419: (8)                    Returns
420: (8)                    -------
421: (8)                    :class:`Mobject`
422: (12)                       ``self``
423: (8)                    See Also
424: (8)                    --------
425: (8)                    :meth:`add`
426: (8)                    """
427: (8)                    for mobject in mobjects:
428: (12)                       if mobject in self.submobjects:
429: (16)                           self.submobjects.remove(mobject)
430: (8)                    return self
431: (4)                def __sub__(self, other):
432: (8)                    raise NotImplementedError
433: (4)                def __isub__(self, other):
434: (8)                    raise NotImplementedError
435: (4)                def set(self, **kwargs) -> Self:
436: (8)                    """Sets attributes.
437: (8)                    I.e. ``my_mobject.set(foo=1)`` applies ``my_mobject.foo = 1``.
438: (8)                    This is a convenience to be used along with :attr:`animate` to
439: (8)                    animate setting attributes.
440: (8)                    In addition to this method, there is a compatibility
441: (8)                    layer that allows ``get_*`` and ``set_*`` methods to
442: (8)                    get and set generic attributes. For instance::
443: (12)                       >>> mob = Mobject()
444: (12)                       >>> mob.set_foo(0)
445: (12)                       Mobject
446: (12)                       >>> mob.get_foo()
447: (12)                       0
448: (12)                       >>> mob.foo
449: (12)                       0
450: (8)                    This compatibility layer does not interfere with any
451: (8)                    ``get_*`` or ``set_*`` methods that are explicitly
452: (8)                    defined.
453: (8)                    .. warning::
454: (12)                       This compatibility layer is for backwards compatibility
455: (12)                       and is not guaranteed to stay around. Where applicable,
456: (12)                       please prefer getting/setting attributes normally or with
457: (12)                       the :meth:`set` method.
458: (8)                    Parameters
459: (8)                    ----------
460: (8)                    **kwargs
461: (12)                       The attributes and corresponding values to set.
462: (8)                    Returns
463: (8)                    -------
464: (8)                    :class:`Mobject`
465: (12)                       ``self``
466: (8)                    Examples
467: (8)                    --------
468: (8)                    ::
469: (12)                       >>> mob = Mobject()
470: (12)                       >>> mob.set(foo=0)
471: (12)                       Mobject
472: (12)                       >>> mob.foo
473: (12)                       0
474: (8)                    """
475: (8)                    for attr, value in kwargs.items():
476: (12)                       setattr(self, attr, value)
477: (8)                    return self
478: (4)                def __getattr__(self, attr: str) -> types.MethodType:
479: (8)                    # Add automatic compatibility layer
480: (8)                    # between properties and get_* and set_*
481: (8)                    # methods.
482: (8)                    #
483: (8)                    # In python 3.9+ we could change this
484: (8)                    # logic to use str.remove_prefix instead.
485: (8)                    if attr.startswith("get_"):
486: (12)                       # Remove the "get_" prefix
487: (12)                       to_get = attr[4:]
488: (12)                       def getter(self):
489: (16)                           warnings.warn(
490: (20)                               "This method is not guaranteed to stay around. Please prefer "
491: (20)                               "getting the attribute normally.",
492: (20)                               DeprecationWarning,
493: (20)                               stacklevel=2,
494: (16)                           )
495: (16)                           return getattr(self, to_get)
496: (12)                       # Return a bound method
497: (12)                       return types.MethodType(getter, self)
498: (8)                    if attr.startswith("set_"):
499: (12)                       # Remove the "set_" prefix
500: (12)                       to_set = attr[4:]
501: (12)                       def setter(self, value):
502: (16)                           warnings.warn(
503: (20)                               "This method is not guaranteed to stay around. Please prefer "
504: (20)                               "setting the attribute normally or with Mobject.set().",
505: (20)                               DeprecationWarning,
506: (20)                               stacklevel=2,
507: (16)                           )
508: (16)                           setattr(self, to_set, value)
509: (16)                           return self
510: (12)                       # Return a bound method
511: (12)                       return types.MethodType(setter, self)
512: (8)                    # Unhandled attribute, therefore error
513: (8)                    raise AttributeError(f"{type(self).__name__} object has no attribute '{attr}'")
514: (4)                @property
515: (4)                def width(self) -> float:
516: (8)                    """The width of the mobject.
517: (8)                    Returns
518: (8)                    -------
519: (8)                    :class:`float`
520: (8)                    Examples
521: (8)                    --------
522: (8)                    .. manim:: WidthExample
523: (12)                       class WidthExample(Scene):
524: (16)                           def construct(self):
525: (20)                               decimal = DecimalNumber().to_edge(UP)
526: (20)                               rect = Rectangle(color=BLUE)
527: (20)                               rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)
528: (20)                               decimal.add_updater(lambda d: d.set_value(rect.width))
529: (20)                               self.add(rect_copy, rect, decimal)
530: (20)                               self.play(rect.animate.set(width=7))
531: (20)                               self.wait()
532: (8)                    See also
533: (8)                    --------
534: (8)                    :meth:`length_over_dim`
535: (8)                    """
536: (8)                    # Get the length across the X dimension
537: (8)                    return self.length_over_dim(0)
538: (4)                @width.setter
539: (4)                def width(self, value: float):
540: (8)                    self.scale_to_fit_width(value)
541: (4)                @property
542: (4)                def height(self) -> float:
543: (8)                    """The height of the mobject.
544: (8)                    Returns
545: (8)                    -------
546: (8)                    :class:`float`
547: (8)                    Examples
548: (8)                    --------
549: (8)                    .. manim:: HeightExample
550: (12)                       class HeightExample(Scene):
551: (16)                           def construct(self):
552: (20)                               decimal = DecimalNumber().to_edge(UP)
553: (20)                               rect = Rectangle(color=BLUE)
554: (20)                               rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)
555: (20)                               decimal.add_updater(lambda d: d.set_value(rect.height))
556: (20)                               self.add(rect_copy, rect, decimal)
557: (20)                               self.play(rect.animate.set(height=5))
558: (20)                               self.wait()
559: (8)                    See also
560: (8)                    --------
561: (8)                    :meth:`length_over_dim`
562: (8)                    """
563: (8)                    # Get the length across the Y dimension
564: (8)                    return self.length_over_dim(1)
565: (4)                @height.setter
566: (4)                def height(self, value: float):
567: (8)                    self.scale_to_fit_height(value)
568: (4)                @property
569: (4)                def depth(self) -> float:
570: (8)                    """The depth of the mobject.
571: (8)                    Returns
572: (8)                    -------
573: (8)                    :class:`float`
574: (8)                    See also
575: (8)                    --------
576: (8)                    :meth:`length_over_dim`
577: (8)                    """
578: (8)                    # Get the length across the Z dimension
579: (8)                    return self.length_over_dim(2)
580: (4)                @depth.setter
581: (4)                def depth(self, value: float):
582: (8)                    self.scale_to_fit_depth(value)
583: (4)                # Can't be staticmethod because of point_cloud_mobject.py
584: (4)                def get_array_attrs(self) -> list[Literal["points"]]:
585: (8)                    return ["points"]
586: (4)                def apply_over_attr_arrays(self, func: MappingFunction) -> Self:
587: (8)                    for attr in self.get_array_attrs():
588: (12)                       setattr(self, attr, func(getattr(self, attr)))
589: (8)                    return self
590: (4)                # Displaying
591: (4)                def get_image(self, camera=None) -> Image:
592: (8)                    if camera is None:
593: (12)                       from ..camera.camera import Camera
594: (12)                       camera = Camera()
595: (8)                    camera.capture_mobject(self)
596: (8)                    return camera.get_image()
597: (4)                def show(self, camera=None) -> None:
598: (8)                    self.get_image(camera=camera).show()
599: (4)                def save_image(self, name: str | None = None) -> None:
600: (8)                    """Saves an image of only this :class:`Mobject` at its position to a png
601: (8)                    file."""
602: (8)                    self.get_image().save(
603: (12)                       Path(config.get_dir("video_dir")).joinpath((name or str(self)) + ".png"),
604: (8)                    )
605: (4)                def copy(self) -> Self:
606: (8)                    """Create and return an identical copy of the :class:`Mobject` including all
607: (8)                    :attr:`submobjects`.
608: (8)                    Returns
609: (8)                    -------
610: (8)                    :class:`Mobject`
611: (12)                       The copy.
612: (8)                    Note
613: (8)                    ----
614: (8)                    The clone is initially not visible in the Scene, even if the original was.
615: (8)                    """
616: (8)                    return copy.deepcopy(self)
617: (4)                def generate_target(self, use_deepcopy: bool = False) -> Self:
618: (8)                    self.target = None  # Prevent unbounded linear recursion
619: (8)                    if use_deepcopy:
620: (12)                       self.target = copy.deepcopy(self)
621: (8)                    else:
622: (12)                       self.target = self.copy()
623: (8)                    return self.target
624: (4)                # Updating
625: (4)                def update(self, dt: float = 0, recursive: bool = True) -> Self:
626: (8)                    """Apply all updaters.
627: (8)                    Does nothing if updating is suspended.
628: (8)                    Parameters
629: (8)                    ----------
630: (8)                    dt
631: (12)                       The parameter ``dt`` to pass to the update functions. Usually this is the
632: (12)                       time in seconds since the last call of ``update``.
633: (8)                    recursive
634: (12)                       Whether to recursively update all submobjects.
635: (8)                    Returns
636: (8)                    -------
637: (8)                    :class:`Mobject`
638: (12)                       ``self``
639: (8)                    See Also
640: (8)                    --------
641: (8)                    :meth:`add_updater`
642: (8)                    :meth:`get_updaters`
643: (8)                    """
644: (8)                    if self.updating_suspended:
645: (12)                       return self
646: (8)                    for updater in self.updaters:
647: (12)                       if "dt" in inspect.signature(updater).parameters:
648: (16)                           updater(self, dt)
649: (12)                       else:
650: (16)                           updater(self)
651: (8)                    if recursive:
652: (12)                       for submob in self.submobjects:
653: (16)                           submob.update(dt, recursive)
654: (8)                    return self
655: (4)                def get_time_based_updaters(self) -> list[TimeBasedUpdater]:
656: (8)                    """Return all updaters using the ``dt`` parameter.
657: (8)                    The updaters use this parameter as the input for difference in time.
658: (8)                    Returns
659: (8)                    -------
660: (8)                    List[:class:`Callable`]
661: (12)                       The list of time based updaters.
662: (8)                    See Also
663: (8)                    --------
664: (8)                    :meth:`get_updaters`
665: (8)                    :meth:`has_time_based_updater`
666: (8)                    """
667: (8)                    return [
668: (12)                       updater
669: (12)                       for updater in self.updaters
670: (12)                       if "dt" in inspect.signature(updater).parameters
671: (8)                    ]
672: (4)                def has_time_based_updater(self) -> bool:
673: (8)                    """Test if ``self`` has a time based updater.
674: (8)                    Returns
675: (8)                    -------
676: (8)                    :class:`bool`
677: (12)                       ``True`` if at least one updater uses the ``dt`` parameter, ``False``
678: (12)                       otherwise.
679: (8)                    See Also
680: (8)                    --------
681: (8)                    :meth:`get_time_based_updaters`
682: (8)                    """
683: (8)                    return any(
684: (12)                       "dt" in inspect.signature(updater).parameters for updater in self.updaters
685: (8)                    )
686: (4)                def get_updaters(self) -> list[Updater]:
687: (8)                    """Return all updaters.
688: (8)                    Returns
689: (8)                    -------
690: (8)                    List[:class:`Callable`]
691: (12)                       The list of updaters.
692: (8)                    See Also
693: (8)                    --------
694: (8)                    :meth:`add_updater`
695: (8)                    :meth:`get_time_based_updaters`
696: (8)                    """
697: (8)                    return self.updaters
698: (4)                def get_family_updaters(self) -> list[Updater]:
699: (8)                    return list(it.chain(*(sm.get_updaters() for sm in self.get_family())))
700: (4)                def add_updater(
701: (8)                    self,
702: (8)                    update_function: Updater,
703: (8)                    index: int | None = None,
704: (8)                    call_updater: bool = False,
705: (4)                ) -> Self:
706: (8)                    """Add an update function to this mobject.
707: (8)                    Update functions, or updaters in short, are functions that are applied to the
708: (8)                    Mobject in every frame.
709: (8)                    Parameters
710: (8)                    ----------
711: (8)                    update_function
712: (12)                       The update function to be added.
713: (12)                       Whenever :meth:`update` is called, this update function gets called using
714: (12)                       ``self`` as the first parameter.
715: (12)                       The updater can have a second parameter ``dt``. If it uses this parameter,
716: (12)                       it gets called using a second value ``dt``, usually representing the time
717: (12)                       in seconds since the last call of :meth:`update`.
718: (8)                    index
719: (12)                       The index at which the new updater should be added in ``self.updaters``.
720: (12)                       In case ``index`` is ``None`` the updater will be added at the end.
721: (8)                    call_updater
722: (12)                       Whether or not to call the updater initially. If ``True``, the updater will
723: (12)                       be called using ``dt=0``.
724: (8)                    Returns
725: (8)                    -------
726: (8)                    :class:`Mobject`
727: (12)                       ``self``
728: (8)                    Examples
729: (8)                    --------
730: (8)                    .. manim:: NextToUpdater
731: (12)                       class NextToUpdater(Scene):
732: (16)                           def construct(self):
733: (20)                               def dot_position(mobject):
734: (24)                                   mobject.set_value(dot.get_center()[0])
735: (24)                                   mobject.next_to(dot)
736: (20)                               dot = Dot(RIGHT*3)
737: (20)                               label = DecimalNumber()
738: (20)                               label.add_updater(dot_position)
739: (20)                               self.add(dot, label)
740: (20)                               self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))
741: (8)                    .. manim:: DtUpdater
742: (12)                       class DtUpdater(Scene):
743: (16)                           def construct(self):
744: (20)                               square = Square()
745: (20)                               #Let the square rotate 90° per second
746: (20)                               square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))
747: (20)                               self.add(square)
748: (20)                               self.wait(2)
749: (8)                    See also
750: (8)                    --------
751: (8)                    :meth:`get_updaters`
752: (8)                    :meth:`remove_updater`
753: (8)                    :class:`~.UpdateFromFunc`
754: (8)                    """
755: (8)                    if index is None:
756: (12)                       self.updaters.append(update_function)
757: (8)                    else:
758: (12)                       self.updaters.insert(index, update_function)
759: (8)                    if call_updater:
760: (12)                       parameters = inspect.signature(update_function).parameters
761: (12)                       if "dt" in parameters:
762: (16)                           update_function(self, 0)
763: (12)                       else:
764: (16)                           update_function(self)
765: (8)                    return self
766: (4)                def remove_updater(self, update_function: Updater) -> Self:
767: (8)                    """Remove an updater.
768: (8)                    If the same updater is applied multiple times, every instance gets removed.
769: (8)                    Parameters
770: (8)                    ----------
771: (8)                    update_function
772: (12)                       The update function to be removed.
773: (8)                    Returns
774: (8)                    -------
775: (8)                    :class:`Mobject`
776: (12)                       ``self``
777: (8)                    See also
778: (8)                    --------
779: (8)                    :meth:`clear_updaters`
780: (8)                    :meth:`add_updater`
781: (8)                    :meth:`get_updaters`
782: (8)                    """
783: (8)                    while update_function in self.updaters:
784: (12)                       self.updaters.remove(update_function)
785: (8)                    return self
786: (4)                def clear_updaters(self, recursive: bool = True) -> Self:
787: (8)                    """Remove every updater.
788: (8)                    Parameters
789: (8)                    ----------
790: (8)                    recursive
791: (12)                       Whether to recursively call ``clear_updaters`` on all submobjects.
792: (8)                    Returns
793: (8)                    -------
794: (8)                    :class:`Mobject`
795: (12)                       ``self``
796: (8)                    See also
797: (8)                    --------
798: (8)                    :meth:`remove_updater`
799: (8)                    :meth:`add_updater`
800: (8)                    :meth:`get_updaters`
801: (8)                    """
802: (8)                    self.updaters = []
803: (8)                    if recursive:
804: (12)                       for submob in self.submobjects:
805: (16)                           submob.clear_updaters()
806: (8)                    return self
807: (4)                def match_updaters(self, mobject: Mobject) -> Self:
808: (8)                    """Match the updaters of the given mobject.
809: (8)                    Parameters
810: (8)                    ----------
811: (8)                    mobject
812: (12)                       The mobject whose updaters get matched.
813: (8)                    Returns
814: (8)                    -------
815: (8)                    :class:`Mobject`
816: (12)                       ``self``
817: (8)                    Note
818: (8)                    ----
819: (8)                    All updaters from submobjects are removed, but only updaters of the given
820: (8)                    mobject are matched, not those of it's submobjects.
821: (8)                    See also
822: (8)                    --------
823: (8)                    :meth:`add_updater`
824: (8)                    :meth:`clear_updaters`
825: (8)                    """
826: (8)                    self.clear_updaters()
827: (8)                    for updater in mobject.get_updaters():
828: (12)                       self.add_updater(updater)
829: (8)                    return self
830: (4)                def suspend_updating(self, recursive: bool = True) -> Self:
831: (8)                    """Disable updating from updaters and animations.
832: (8)                    Parameters
833: (8)                    ----------
834: (8)                    recursive
835: (12)                       Whether to recursively suspend updating on all submobjects.
836: (8)                    Returns
837: (8)                    -------
838: (8)                    :class:`Mobject`
839: (12)                       ``self``
840: (8)                    See also
841: (8)                    --------
842: (8)                    :meth:`resume_updating`
843: (8)                    :meth:`add_updater`
844: (8)                    """
845: (8)                    self.updating_suspended = True
846: (8)                    if recursive:
847: (12)                       for submob in self.submobjects:
848: (16)                           submob.suspend_updating(recursive)
849: (8)                    return self
850: (4)                def resume_updating(self, recursive: bool = True) -> Self:
851: (8)                    """Enable updating from updaters and animations.
852: (8)                    Parameters
853: (8)                    ----------
854: (8)                    recursive
855: (12)                       Whether to recursively enable updating on all submobjects.
856: (8)                    Returns
857: (8)                    -------
858: (8)                    :class:`Mobject`
859: (12)                       ``self``
860: (8)                    See also
861: (8)                    --------
862: (8)                    :meth:`suspend_updating`
863: (8)                    :meth:`add_updater`
864: (8)                    """
865: (8)                    self.updating_suspended = False
866: (8)                    if recursive:
867: (12)                       for submob in self.submobjects:
868: (16)                           submob.resume_updating(recursive)
869: (8)                    self.update(dt=0, recursive=recursive)
870: (8)                    return self
871: (4)                # Transforming operations
872: (4)                def apply_to_family(self, func: Callable[[Mobject], None]) -> None:
873: (8)                    """Apply a function to ``self`` and every submobject with points recursively.
874: (8)                    Parameters
875: (8)                    ----------
876: (8)                    func
877: (12)                       The function to apply to each mobject. ``func`` gets passed the respective
878: (12)                       (sub)mobject as parameter.
879: (8)                    Returns
880: (8)                    -------
881: (8)                    :class:`Mobject`
882: (12)                       ``self``
883: (8)                    See also
884: (8)                    --------
885: (8)                    :meth:`family_members_with_points`
886: (8)                    """
887: (8)                    for mob in self.family_members_with_points():
888: (12)                       func(mob)
889: (4)                def shift(self, *vectors: Vector3D) -> Self:
890: (8)                    """Shift by the given vectors.
891: (8)                    Parameters
892: (8)                    ----------
893: (8)                    vectors
894: (12)                       Vectors to shift by. If multiple vectors are given, they are added
895: (12)                       together.
896: (8)                    Returns
897: (8)                    -------
898: (8)                    :class:`Mobject`
899: (12)                       ``self``
900: (8)                    See also
901: (8)                    --------
902: (8)                    :meth:`move_to`
903: (8)                    """
904: (8)                    total_vector = reduce(op.add, vectors)
905: (8)                    for mob in self.family_members_with_points():
906: (12)                       mob.points = mob.points.astype("float")
907: (12)                       mob.points += total_vector
908: (8)                    return self
909: (4)                def scale(self, scale_factor: float, **kwargs) -> Self:
910: (8)                    r"""Scale the size by a factor.
911: (8)                    Default behavior is to scale about the center of the mobject.
912: (8)                    Parameters
913: (8)                    ----------
914: (8)                    scale_factor
915: (12)                       The scaling factor :math:`\alpha`. If :math:`0 < |\alpha| < 1`, the mobject
916: (12)                       will shrink, and for :math:`|\alpha| > 1` it will grow. Furthermore,
917: (12)                       if :math:`\alpha < 0`, the mobject is also flipped.
918: (8)                    kwargs
919: (12)                       Additional keyword arguments passed to
920: (12)                       :meth:`apply_points_function_about_point`.
921: (8)                    Returns
922: (8)                    -------
923: (8)                    :class:`Mobject`
924: (12)                       ``self``
925: (8)                    Examples
926: (8)                    --------
927: (8)                    .. manim:: MobjectScaleExample
928: (12)                       :save_last_frame:
929: (12)                       class MobjectScaleExample(Scene):
930: (16)                           def construct(self):
931: (20)                               f1 = Text("F")
932: (20)                               f2 = Text("F").scale(2)
933: (20)                               f3 = Text("F").scale(0.5)
934: (20)                               f4 = Text("F").scale(-1)
935: (20)                               vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)
936: (20)                               self.add(vgroup)
937: (8)                    See also
938: (8)                    --------
939: (8)                    :meth:`move_to`
940: (8)                    """
941: (8)                    self.apply_points_function_about_point(
942: (12)                       lambda points: scale_factor * points, **kwargs
943: (8)                    )
944: (8)                    return self
945: (4)                def rotate_about_origin(self, angle: float, axis: Vector3D = OUT, axes=[]) -> Self:
946: (8)                    """Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0]."""
947: (8)                    return self.rotate(angle, axis, about_point=ORIGIN)
948: (4)                def rotate(
949: (8)                    self,
950: (8)                    angle: float,
951: (8)                    axis: Vector3D = OUT,
952: (8)                    about_point: Point3D | None = None,
953: (8)                    **kwargs,
954: (4)                ) -> Self:
955: (8)                    """Rotates the :class:`~.Mobject` about a certain point."""
956: (8)                    rot_matrix = rotation_matrix(angle, axis)
957: (8)                    self.apply_points_function_about_point(
958: (12)                       lambda points: np.dot(points, rot_matrix.T), about_point, **kwargs
959: (8)                    )
960: (8)                    return self
961: (4)                def flip(self, axis: Vector3D = UP, **kwargs) -> Self:
962: (8)                    """Flips/Mirrors an mobject about its center.
963: (8)                    Examples
964: (8)                    --------
965: (8)                    .. manim:: FlipExample
966: (12)                       :save_last_frame:
967: (12)                       class FlipExample(Scene):
968: (16)                           def construct(self):
969: (20)                               s= Line(LEFT, RIGHT+UP).shift(4*LEFT)
970: (20)                               self.add(s)
971: (20)                               s2= s.copy().flip()
972: (20)                               self.add(s2)
973: (8)                    """
974: (8)                    return self.rotate(TAU / 2, axis, **kwargs)
975: (4)                def stretch(self, factor: float, dim: int, **kwargs) -> Self:
976: (8)                    def func(points):
977: (12)                       points[:, dim] *= factor
978: (12)                       return points
979: (8)                    self.apply_points_function_about_point(func, **kwargs)
980: (8)                    return self
981: (4)                def apply_function(self, function: MappingFunction, **kwargs) -> Self:
982: (8)                    # Default to applying matrix about the origin, not mobjects center
983: (8)                    if len(kwargs) == 0:
984: (12)                       kwargs["about_point"] = ORIGIN
985: (8)                    self.apply_points_function_about_point(
986: (12)                       lambda points: np.apply_along_axis(function, 1, points), **kwargs
987: (8)                    )
988: (8)                    return self
989: (4)                def apply_function_to_position(self, function: MappingFunction) -> Self:
990: (8)                    self.move_to(function(self.get_center()))
991: (8)                    return self
992: (4)                def apply_function_to_submobject_positions(self, function: MappingFunction) -> Self:
993: (8)                    for submob in self.submobjects:
994: (12)                       submob.apply_function_to_position(function)
995: (8)                    return self
996: (4)                def apply_matrix(self, matrix, **kwargs) -> Self:
997: (8)                    # Default to applying matrix about the origin, not mobjects center
998: (8)                    if ("about_point" not in kwargs) and ("about_edge" not in kwargs):
999: (12)                       kwargs["about_point"] = ORIGIN
1000: (8)                   full_matrix = np.identity(self.dim)
1001: (8)                   matrix = np.array(matrix)
1002: (8)                   full_matrix[: matrix.shape[0], : matrix.shape[1]] = matrix
1003: (8)                   self.apply_points_function_about_point(
1004: (12)                      lambda points: np.dot(points, full_matrix.T), **kwargs
1005: (8)                   )
1006: (8)                   return self
1007: (4)               def apply_complex_function(
1008: (8)                   self, function: Callable[[complex], complex], **kwargs
1009: (4)               ) -> Self:
1010: (8)                   """Applies a complex function to a :class:`Mobject`.
1011: (8)                   The x and y Point3Ds correspond to the real and imaginary parts respectively.
1012: (8)                   Example
1013: (8)                   -------
1014: (8)                   .. manim:: ApplyFuncExample
1015: (12)                      class ApplyFuncExample(Scene):
1016: (16)                          def construct(self):
1017: (20)                              circ = Circle().scale(1.5)
1018: (20)                              circ_ref = circ.copy()
1019: (20)                              circ.apply_complex_function(
1020: (24)                                  lambda x: np.exp(x*1j)
1021: (20)                              )
1022: (20)                              t = ValueTracker(0)
1023: (20)                              circ.add_updater(
1024: (24)                                  lambda x: x.become(circ_ref.copy().apply_complex_function(
1025: (28)                                      lambda x: np.exp(x+t.get_value()*1j)
1026: (24)                                  )).set_color(BLUE)
1027: (20)                              )
1028: (20)                              self.add(circ_ref)
1029: (20)                              self.play(TransformFromCopy(circ_ref, circ))
1030: (20)                              self.play(t.animate.set_value(TAU), run_time=3)
1031: (8)                   """
1032: (8)                   def R3_func(point):
1033: (12)                      x, y, z = point
1034: (12)                      xy_complex = function(complex(x, y))
1035: (12)                      return [xy_complex.real, xy_complex.imag, z]
1036: (8)                   return self.apply_function(R3_func)
1037: (4)               def reverse_points(self) -> Self:
1038: (8)                   for mob in self.family_members_with_points():
1039: (12)                      mob.apply_over_attr_arrays(lambda arr: np.array(list(reversed(arr))))
1040: (8)                   return self
1041: (4)               def repeat(self, count: int) -> Self:
1042: (8)                   """This can make transition animations nicer"""
1043: (8)                   def repeat_array(array):
1044: (12)                      return reduce(lambda a1, a2: np.append(a1, a2, axis=0), [array] * count)
1045: (8)                   for mob in self.family_members_with_points():
1046: (12)                      mob.apply_over_attr_arrays(repeat_array)
1047: (8)                   return self
1048: (4)               # In place operations.
1049: (4)               # Note, much of these are now redundant with default behavior of
1050: (4)               # above methods
1051: (4)               def apply_points_function_about_point(
1052: (8)                   self,
1053: (8)                   func: MappingFunction,
1054: (8)                   about_point: Point3D = None,
1055: (8)                   about_edge=None,
1056: (4)               ) -> Self:
1057: (8)                   if about_point is None:
1058: (12)                      if about_edge is None:
1059: (16)                          about_edge = ORIGIN
1060: (12)                      about_point = self.get_critical_point(about_edge)
1061: (8)                   for mob in self.family_members_with_points():
1062: (12)                      mob.points -= about_point
1063: (12)                      mob.points = func(mob.points)
1064: (12)                      mob.points += about_point
1065: (8)                   return self
1066: (4)               def pose_at_angle(self, **kwargs):
1067: (8)                   self.rotate(TAU / 14, RIGHT + UP, **kwargs)
1068: (8)                   return self
1069: (4)               # Positioning methods
1070: (4)               def center(self) -> Self:
1071: (8)                   """Moves the center of the mobject to the center of the scene.
1072: (8)                   Returns
1073: (8)                   -------
1074: (8)                   :class:`.Mobject`
1075: (12)                      The centered mobject.
1076: (8)                   """
1077: (8)                   self.shift(-self.get_center())
1078: (8)                   return self
1079: (4)               def align_on_border(
1080: (8)                   self, direction: Vector3D, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER
1081: (4)               ) -> Self:
1082: (8)                   """Direction just needs to be a vector pointing towards side or
1083: (8)                   corner in the 2d plane.
1084: (8)                   """
1085: (8)                   target_point = np.sign(direction) * (
1086: (12)                      config["frame_x_radius"],
1087: (12)                      config["frame_y_radius"],
1088: (12)                      0,
1089: (8)                   )
1090: (8)                   point_to_align = self.get_critical_point(direction)
1091: (8)                   shift_val = target_point - point_to_align - buff * np.array(direction)
1092: (8)                   shift_val = shift_val * abs(np.sign(direction))
1093: (8)                   self.shift(shift_val)
1094: (8)                   return self
1095: (4)               def to_corner(
1096: (8)                   self, corner: Vector3D = DL, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER
1097: (4)               ) -> Self:
1098: (8)                   """Moves this :class:`~.Mobject` to the given corner of the screen.
1099: (8)                   Returns
1100: (8)                   -------
1101: (8)                   :class:`.Mobject`
1102: (12)                      The newly positioned mobject.
1103: (8)                   Examples
1104: (8)                   --------
1105: (8)                   .. manim:: ToCornerExample
1106: (12)                      :save_last_frame:
1107: (12)                      class ToCornerExample(Scene):
1108: (16)                          def construct(self):
1109: (20)                              c = Circle()
1110: (20)                              c.to_corner(UR)
1111: (20)                              t = Tex("To the corner!")
1112: (20)                              t2 = MathTex("x^3").shift(DOWN)
1113: (20)                              self.add(c,t,t2)
1114: (20)                              t.to_corner(DL, buff=0)
1115: (20)                              t2.to_corner(UL, buff=1.5)
1116: (8)                   """
1117: (8)                   return self.align_on_border(corner, buff)
1118: (4)               def to_edge(
1119: (8)                   self, edge: Vector3D = LEFT, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER
1120: (4)               ) -> Self:
1121: (8)                   """Moves this :class:`~.Mobject` to the given edge of the screen,
1122: (8)                   without affecting its position in the other dimension.
1123: (8)                   Returns
1124: (8)                   -------
1125: (8)                   :class:`.Mobject`
1126: (12)                      The newly positioned mobject.
1127: (8)                   Examples
1128: (8)                   --------
1129: (8)                   .. manim:: ToEdgeExample
1130: (12)                      :save_last_frame:
1131: (12)                      class ToEdgeExample(Scene):
1132: (16)                          def construct(self):
1133: (20)                              tex_top = Tex("I am at the top!")
1134: (20)                              tex_top.to_edge(UP)
1135: (20)                              tex_side = Tex("I am moving to the side!")
1136: (20)                              c = Circle().shift(2*DOWN)
1137: (20)                              self.add(tex_top, tex_side)
1138: (20)                              tex_side.to_edge(LEFT)
1139: (20)                              c.to_edge(RIGHT, buff=0)
1140: (8)                   """
1141: (8)                   return self.align_on_border(edge, buff)
1142: (4)               def next_to(
1143: (8)                   self,
1144: (8)                   mobject_or_point: Mobject | Point3D,
1145: (8)                   direction: Vector3D = RIGHT,
1146: (8)                   buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,
1147: (8)                   aligned_edge: Vector3D = ORIGIN,
1148: (8)                   submobject_to_align: Mobject | None = None,
1149: (8)                   index_of_submobject_to_align: int | None = None,
1150: (8)                   coor_mask: Vector3D = np.array([1, 1, 1]),
1151: (4)               ) -> Self:
1152: (8)                   """Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.
1153: (8)                   Examples
1154: (8)                   --------
1155: (8)                   .. manim:: GeometricShapes
1156: (12)                      :save_last_frame:
1157: (12)                      class GeometricShapes(Scene):
1158: (16)                          def construct(self):
1159: (20)                              d = Dot()
1160: (20)                              c = Circle()
1161: (20)                              s = Square()
1162: (20)                              t = Triangle()
1163: (20)                              d.next_to(c, RIGHT)
1164: (20)                              s.next_to(c, LEFT)
1165: (20)                              t.next_to(c, DOWN)
1166: (20)                              self.add(d, c, s, t)
1167: (8)                   """
1168: (8)                   if isinstance(mobject_or_point, Mobject):
1169: (12)                      mob = mobject_or_point
1170: (12)                      if index_of_submobject_to_align is not None:
1171: (16)                          target_aligner = mob[index_of_submobject_to_align]
1172: (12)                      else:
1173: (16)                          target_aligner = mob
1174: (12)                      target_point = target_aligner.get_critical_point(aligned_edge + direction)
1175: (8)                   else:
1176: (12)                      target_point = mobject_or_point
1177: (8)                   if submobject_to_align is not None:
1178: (12)                      aligner = submobject_to_align
1179: (8)                   elif index_of_submobject_to_align is not None:
1180: (12)                      aligner = self[index_of_submobject_to_align]
1181: (8)                   else:
1182: (12)                      aligner = self
1183: (8)                   point_to_align = aligner.get_critical_point(aligned_edge - direction)
1184: (8)                   self.shift((target_point - point_to_align + buff * direction) * coor_mask)
1185: (8)                   return self
1186: (4)               def shift_onto_screen(self, **kwargs) -> Self:
1187: (8)                   space_lengths = [config["frame_x_radius"], config["frame_y_radius"]]
1188: (8)                   for vect in UP, DOWN, LEFT, RIGHT:
1189: (12)                      dim = np.argmax(np.abs(vect))
1190: (12)                      buff = kwargs.get("buff", DEFAULT_MOBJECT_TO_EDGE_BUFFER)
1191: (12)                      max_val = space_lengths[dim] - buff
1192: (12)                      edge_center = self.get_edge_center(vect)
1193: (12)                      if np.dot(edge_center, vect) > max_val:
1194: (16)                          self.to_edge(vect, **kwargs)
1195: (8)                   return self
1196: (4)               def is_off_screen(self):
1197: (8)                   if self.get_left()[0] > config["frame_x_radius"]:
1198: (12)                      return True
1199: (8)                   if self.get_right()[0] < -config["frame_x_radius"]:
1200: (12)                      return True
1201: (8)                   if self.get_bottom()[1] > config["frame_y_radius"]:
1202: (12)                      return True
1203: (8)                   if self.get_top()[1] < -config["frame_y_radius"]:
1204: (12)                      return True
1205: (8)                   return False
1206: (4)               def stretch_about_point(self, factor: float, dim: int, point: Point3D) -> Self:
1207: (8)                   return self.stretch(factor, dim, about_point=point)
1208: (4)               def rescale_to_fit(
1209: (8)                   self, length: float, dim: int, stretch: bool = False, **kwargs
1210: (4)               ) -> Self:
1211: (8)                   old_length = self.length_over_dim(dim)
1212: (8)                   if old_length == 0:
1213: (12)                      return self
1214: (8)                   if stretch:
1215: (12)                      self.stretch(length / old_length, dim, **kwargs)
1216: (8)                   else:
1217: (12)                      self.scale(length / old_length, **kwargs)
1218: (8)                   return self
1219: (4)               def scale_to_fit_width(self, width: float, **kwargs) -> Self:
1220: (8)                   """Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.
1221: (8)                   Returns
1222: (8)                   -------
1223: (8)                   :class:`Mobject`
1224: (12)                      ``self``
1225: (8)                   Examples
1226: (8)                   --------
1227: (8)                   ::
1228: (12)                      >>> from manim import *
1229: (12)                      >>> sq = Square()
1230: (12)                      >>> sq.height
1231: (12)                      2.0
1232: (12)                      >>> sq.scale_to_fit_width(5)
1233: (12)                      Square
1234: (12)                      >>> sq.width
1235: (12)                      5.0
1236: (12)                      >>> sq.height
1237: (12)                      5.0
1238: (8)                   """
1239: (8)                   return self.rescale_to_fit(width, 0, stretch=False, **kwargs)
1240: (4)               def stretch_to_fit_width(self, width: float, **kwargs) -> Self:
1241: (8)                   """Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.
1242: (8)                   Returns
1243: (8)                   -------
1244: (8)                   :class:`Mobject`
1245: (12)                      ``self``
1246: (8)                   Examples
1247: (8)                   --------
1248: (8)                   ::
1249: (12)                      >>> from manim import *
1250: (12)                      >>> sq = Square()
1251: (12)                      >>> sq.height
1252: (12)                      2.0
1253: (12)                      >>> sq.stretch_to_fit_width(5)
1254: (12)                      Square
1255: (12)                      >>> sq.width
1256: (12)                      5.0
1257: (12)                      >>> sq.height
1258: (12)                      2.0
1259: (8)                   """
1260: (8)                   return self.rescale_to_fit(width, 0, stretch=True, **kwargs)
1261: (4)               def scale_to_fit_height(self, height: float, **kwargs) -> Self:
1262: (8)                   """Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.
1263: (8)                   Returns
1264: (8)                   -------
1265: (8)                   :class:`Mobject`
1266: (12)                      ``self``
1267: (8)                   Examples
1268: (8)                   --------
1269: (8)                   ::
1270: (12)                      >>> from manim import *
1271: (12)                      >>> sq = Square()
1272: (12)                      >>> sq.width
1273: (12)                      2.0
1274: (12)                      >>> sq.scale_to_fit_height(5)
1275: (12)                      Square
1276: (12)                      >>> sq.height
1277: (12)                      5.0
1278: (12)                      >>> sq.width
1279: (12)                      5.0
1280: (8)                   """
1281: (8)                   return self.rescale_to_fit(height, 1, stretch=False, **kwargs)
1282: (4)               def stretch_to_fit_height(self, height: float, **kwargs) -> Self:
1283: (8)                   """Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.
1284: (8)                   Returns
1285: (8)                   -------
1286: (8)                   :class:`Mobject`
1287: (12)                      ``self``
1288: (8)                   Examples
1289: (8)                   --------
1290: (8)                   ::
1291: (12)                      >>> from manim import *
1292: (12)                      >>> sq = Square()
1293: (12)                      >>> sq.width
1294: (12)                      2.0
1295: (12)                      >>> sq.stretch_to_fit_height(5)
1296: (12)                      Square
1297: (12)                      >>> sq.height
1298: (12)                      5.0
1299: (12)                      >>> sq.width
1300: (12)                      2.0
1301: (8)                   """
1302: (8)                   return self.rescale_to_fit(height, 1, stretch=True, **kwargs)
1303: (4)               def scale_to_fit_depth(self, depth: float, **kwargs) -> Self:
1304: (8)                   """Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional."""
1305: (8)                   return self.rescale_to_fit(depth, 2, stretch=False, **kwargs)
1306: (4)               def stretch_to_fit_depth(self, depth: float, **kwargs) -> Self:
1307: (8)                   """Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional."""
1308: (8)                   return self.rescale_to_fit(depth, 2, stretch=True, **kwargs)
1309: (4)               def set_coord(self, value, dim: int, direction: Vector3D = ORIGIN) -> Self:
1310: (8)                   curr = self.get_coord(dim, direction)
1311: (8)                   shift_vect = np.zeros(self.dim)
1312: (8)                   shift_vect[dim] = value - curr
1313: (8)                   self.shift(shift_vect)
1314: (8)                   return self
1315: (4)               def set_x(self, x: float, direction: Vector3D = ORIGIN) -> Self:
1316: (8)                   """Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)"""
1317: (8)                   return self.set_coord(x, 0, direction)
1318: (4)               def set_y(self, y: float, direction: Vector3D = ORIGIN) -> Self:
1319: (8)                   """Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)"""
1320: (8)                   return self.set_coord(y, 1, direction)
1321: (4)               def set_z(self, z: float, direction: Vector3D = ORIGIN) -> Self:
1322: (8)                   """Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)"""
1323: (8)                   return self.set_coord(z, 2, direction)
1324: (4)               def space_out_submobjects(self, factor: float = 1.5, **kwargs) -> Self:
1325: (8)                   self.scale(factor, **kwargs)
1326: (8)                   for submob in self.submobjects:
1327: (12)                      submob.scale(1.0 / factor)
1328: (8)                   return self
1329: (4)               def move_to(
1330: (8)                   self,
1331: (8)                   point_or_mobject: Point3D | Mobject,
1332: (8)                   aligned_edge: Vector3D = ORIGIN,
1333: (8)                   coor_mask: Vector3D = np.array([1, 1, 1]),
1334: (4)               ) -> Self:
1335: (8)                   """Move center of the :class:`~.Mobject` to certain Point3D."""
1336: (8)                   if isinstance(point_or_mobject, Mobject):
1337: (12)                      target = point_or_mobject.get_critical_point(aligned_edge)
1338: (8)                   else:
1339: (12)                      target = point_or_mobject
1340: (8)                   point_to_align = self.get_critical_point(aligned_edge)
1341: (8)                   self.shift((target - point_to_align) * coor_mask)
1342: (8)                   return self
1343: (4)               def replace(
1344: (8)                   self, mobject: Mobject, dim_to_match: int = 0, stretch: bool = False
1345: (4)               ) -> Self:
1346: (8)                   if not mobject.get_num_points() and not mobject.submobjects:
1347: (12)                      raise Warning("Attempting to replace mobject with no points")
1348: (8)                   if stretch:
1349: (12)                      self.stretch_to_fit_width(mobject.width)
1350: (12)                      self.stretch_to_fit_height(mobject.height)
1351: (8)                   else:
1352: (12)                      self.rescale_to_fit(
1353: (16)                          mobject.length_over_dim(dim_to_match),
1354: (16)                          dim_to_match,
1355: (16)                          stretch=False,
1356: (12)                      )
1357: (8)                   self.shift(mobject.get_center() - self.get_center())
1358: (8)                   return self
1359: (4)               def surround(
1360: (8)                   self,
1361: (8)                   mobject: Mobject,
1362: (8)                   dim_to_match: int = 0,
1363: (8)                   stretch: bool = False,
1364: (8)                   buff: float = MED_SMALL_BUFF,
1365: (4)               ) -> Self:
1366: (8)                   self.replace(mobject, dim_to_match, stretch)
1367: (8)                   length = mobject.length_over_dim(dim_to_match)
1368: (8)                   self.scale((length + buff) / length)
1369: (8)                   return self
1370: (4)               def put_start_and_end_on(self, start: Point3D, end: Point3D) -> Self:
1371: (8)                   curr_start, curr_end = self.get_start_and_end()
1372: (8)                   curr_vect = curr_end - curr_start
1373: (8)                   if np.all(curr_vect == 0):
1374: (12)                      self.points = start
1375: (12)                      return self
1376: (8)                   target_vect = np.array(end) - np.array(start)
1377: (8)                   axis = (
1378: (12)                      normalize(np.cross(curr_vect, target_vect))
1379: (12)                      if np.linalg.norm(np.cross(curr_vect, target_vect)) != 0
1380: (12)                      else OUT
1381: (8)                   )
1382: (8)                   self.scale(
1383: (12)                      np.linalg.norm(target_vect) / np.linalg.norm(curr_vect),
1384: (12)                      about_point=curr_start,
1385: (8)                   )
1386: (8)                   self.rotate(
1387: (12)                      angle_between_vectors(curr_vect, target_vect),
1388: (12)                      about_point=curr_start,
1389: (12)                      axis=axis,
1390: (8)                   )
1391: (8)                   self.shift(start - curr_start)
1392: (8)                   return self
1393: (4)               # Background rectangle
1394: (4)               def add_background_rectangle(
1395: (8)                   self, color: ParsableManimColor | None = None, opacity: float = 0.75, **kwargs
1396: (4)               ) -> Self:
1397: (8)                   """Add a BackgroundRectangle as submobject.
1398: (8)                   The BackgroundRectangle is added behind other submobjects.
1399: (8)                   This can be used to increase the mobjects visibility in front of a noisy background.
1400: (8)                   Parameters
1401: (8)                   ----------
1402: (8)                   color
1403: (12)                      The color of the BackgroundRectangle
1404: (8)                   opacity
1405: (12)                      The opacity of the BackgroundRectangle
1406: (8)                   kwargs
1407: (12)                      Additional keyword arguments passed to the BackgroundRectangle constructor
1408: (8)                   Returns
1409: (8)                   -------
1410: (8)                   :class:`Mobject`
1411: (12)                      ``self``
1412: (8)                   See Also
1413: (8)                   --------
1414: (8)                   :meth:`add_to_back`
1415: (8)                   :class:`~.BackgroundRectangle`
1416: (8)                   """
1417: (8)                   # TODO, this does not behave well when the mobject has points,
1418: (8)                   # since it gets displayed on top
1419: (8)                   from manim.mobject.geometry.shape_matchers import BackgroundRectangle
1420: (8)                   self.background_rectangle = BackgroundRectangle(
1421: (12)                      self, color=color, fill_opacity=opacity, **kwargs
1422: (8)                   )
1423: (8)                   self.add_to_back(self.background_rectangle)
1424: (8)                   return self
1425: (4)               def add_background_rectangle_to_submobjects(self, **kwargs) -> Self:
1426: (8)                   for submobject in self.submobjects:
1427: (12)                      submobject.add_background_rectangle(**kwargs)
1428: (8)                   return self
1429: (4)               def add_background_rectangle_to_family_members_with_points(self, **kwargs) -> Self:
1430: (8)                   for mob in self.family_members_with_points():
1431: (12)                      mob.add_background_rectangle(**kwargs)
1432: (8)                   return self
1433: (4)               # Color functions
1434: (4)               def set_color(
1435: (8)                   self, color: ParsableManimColor = YELLOW_C, family: bool = True
1436: (4)               ) -> Self:
1437: (8)                   """Condition is function which takes in one arguments, (x, y, z).
1438: (8)                   Here it just recurses to submobjects, but in subclasses this
1439: (8)                   should be further implemented based on the the inner workings
1440: (8)                   of color
1441: (8)                   """
1442: (8)                   if family:
1443: (12)                      for submob in self.submobjects:
1444: (16)                          submob.set_color(color, family=family)
1445: (8)                   self.color = ManimColor.parse(color)
1446: (8)                   return self
1447: (4)               def set_color_by_gradient(self, *colors: ParsableManimColor) -> Self:
1448: (8)                   """
1449: (8)                   Parameters
1450: (8)                   ----------
1451: (8)                   colors
1452: (12)                      The colors to use for the gradient. Use like `set_color_by_gradient(RED, BLUE, GREEN)`.
1453: (8)                   self.color = ManimColor.parse(color)
1454: (8)                   return self
1455: (8)                   """
1456: (8)                   self.set_submobject_colors_by_gradient(*colors)
1457: (8)                   return self
1458: (4)               def set_colors_by_radial_gradient(
1459: (8)                   self,
1460: (8)                   center: Point3D | None = None,
1461: (8)                   radius: float = 1,
1462: (8)                   inner_color: ParsableManimColor = WHITE,
1463: (8)                   outer_color: ParsableManimColor = BLACK,
1464: (4)               ) -> Self:
1465: (8)                   self.set_submobject_colors_by_radial_gradient(
1466: (12)                      center,
1467: (12)                      radius,
1468: (12)                      inner_color,
1469: (12)                      outer_color,
1470: (8)                   )
1471: (8)                   return self
1472: (4)               def set_submobject_colors_by_gradient(self, *colors: Iterable[ParsableManimColor]):
1473: (8)                   if len(colors) == 0:
1474: (12)                      raise ValueError("Need at least one color")
1475: (8)                   elif len(colors) == 1:
1476: (12)                      return self.set_color(*colors)
1477: (8)                   mobs = self.family_members_with_points()
1478: (8)                   new_colors = color_gradient(colors, len(mobs))
1479: (8)                   for mob, color in zip(mobs, new_colors):
1480: (12)                      mob.set_color(color, family=False)
1481: (8)                   return self
1482: (4)               def set_submobject_colors_by_radial_gradient(
1483: (8)                   self,
1484: (8)                   center: Point3D | None = None,
1485: (8)                   radius: float = 1,
1486: (8)                   inner_color: ParsableManimColor = WHITE,
1487: (8)                   outer_color: ParsableManimColor = BLACK,
1488: (4)               ) -> Self:
1489: (8)                   if center is None:
1490: (12)                      center = self.get_center()
1491: (8)                   for mob in self.family_members_with_points():
1492: (12)                      t = np.linalg.norm(mob.get_center() - center) / radius
1493: (12)                      t = min(t, 1)
1494: (12)                      mob_color = interpolate_color(inner_color, outer_color, t)
1495: (12)                      mob.set_color(mob_color, family=False)
1496: (8)                   return self
1497: (4)               def to_original_color(self) -> Self:
1498: (8)                   self.set_color(self.color)
1499: (8)                   return self
1500: (4)               def fade_to(
1501: (8)                   self, color: ParsableManimColor, alpha: float, family: bool = True
1502: (4)               ) -> Self:
1503: (8)                   if self.get_num_points() > 0:
1504: (12)                      new_color = interpolate_color(self.get_color(), color, alpha)
1505: (12)                      self.set_color(new_color, family=False)
1506: (8)                   if family:
1507: (12)                      for submob in self.submobjects:
1508: (16)                          submob.fade_to(color, alpha)
1509: (8)                   return self
1510: (4)               def fade(self, darkness: float = 0.5, family: bool = True) -> Self:
1511: (8)                   if family:
1512: (12)                      for submob in self.submobjects:
1513: (16)                          submob.fade(darkness, family)
1514: (8)                   return self
1515: (4)               def get_color(self) -> ManimColor:
1516: (8)                   """Returns the color of the :class:`~.Mobject`
1517: (8)                   Examples
1518: (8)                   --------
1519: (8)                   ::
1520: (12)                      >>> from manim import Square, RED
1521: (12)                      >>> Square(color=RED).get_color() == RED
1522: (12)                      True
1523: (8)                   """
1524: (8)                   return self.color
1525: (4)               ##
1526: (4)               def save_state(self) -> Self:
1527: (8)                   """Save the current state (position, color & size). Can be restored with :meth:`~.Mobject.restore`."""
1528: (8)                   if hasattr(self, "saved_state"):
1529: (12)                      # Prevent exponential growth of data
1530: (12)                      self.saved_state = None
1531: (8)                   self.saved_state = self.copy()
1532: (8)                   return self
1533: (4)               def restore(self) -> Self:
1534: (8)                   """Restores the state that was previously saved with :meth:`~.Mobject.save_state`."""
1535: (8)                   if not hasattr(self, "saved_state") or self.save_state is None:
1536: (12)                      raise Exception("Trying to restore without having saved")
1537: (8)                   self.become(self.saved_state)
1538: (8)                   return self
1539: (4)               def reduce_across_dimension(self, reduce_func: Callable, dim: int):
1540: (8)                   """Find the min or max value from a dimension across all points in this and submobjects."""
1541: (8)                   assert dim >= 0 and dim <= 2
1542: (8)                   if len(self.submobjects) == 0 and len(self.points) == 0:
1543: (12)                      # If we have no points and no submobjects, return 0 (e.g. center)
1544: (12)                      return 0
1545: (8)                   # If we do not have points (but do have submobjects)
1546: (8)                   # use only the points from those.
1547: (8)                   if len(self.points) == 0:
1548: (12)                      rv = None
1549: (8)                   else:
1550: (12)                      # Otherwise, be sure to include our own points
1551: (12)                      rv = reduce_func(self.points[:, dim])
1552: (8)                   # Recursively ask submobjects (if any) for the biggest/
1553: (8)                   # smallest dimension they have and compare it to the return value.
1554: (8)                   for mobj in self.submobjects:
1555: (12)                      value = mobj.reduce_across_dimension(reduce_func, dim)
1556: (12)                      if rv is None:
1557: (16)                          rv = value
1558: (12)                      else:
1559: (16)                          rv = reduce_func([value, rv])
1560: (8)                   return rv
1561: (4)               def nonempty_submobjects(self) -> list[Self]:
1562: (8)                   return [
1563: (12)                      submob
1564: (12)                      for submob in self.submobjects
1565: (12)                      if len(submob.submobjects) != 0 or len(submob.points) != 0
1566: (8)                   ]
1567: (4)               def get_merged_array(self, array_attr: str) -> np.ndarray:
1568: (8)                   """Return all of a given attribute from this mobject and all submobjects.
1569: (8)                   May contain duplicates; the order is in a depth-first (pre-order)
1570: (8)                   traversal of the submobjects.
1571: (8)                   """
1572: (8)                   result = getattr(self, array_attr)
1573: (8)                   for submob in self.submobjects:
1574: (12)                      result = np.append(result, submob.get_merged_array(array_attr), axis=0)
1575: (8)                   return result
1576: (4)               def get_all_points(self) -> Point3D_Array:
1577: (8)                   """Return all points from this mobject and all submobjects.
1578: (8)                   May contain duplicates; the order is in a depth-first (pre-order)
1579: (8)                   traversal of the submobjects.
1580: (8)                   """
1581: (8)                   return self.get_merged_array("points")
1582: (4)               # Getters
1583: (4)               def get_points_defining_boundary(self) -> Point3D_Array:
1584: (8)                   return self.get_all_points()
1585: (4)               def get_num_points(self) -> int:
1586: (8)                   return len(self.points)
1587: (4)               def get_extremum_along_dim(
1588: (8)                   self, points: Point3D_Array | None = None, dim: int = 0, key: int = 0
1589: (4)               ) -> np.ndarray | float:
1590: (8)                   if points is None:
1591: (12)                      points = self.get_points_defining_boundary()
1592: (8)                   values = points[:, dim]
1593: (8)                   if key < 0:
1594: (12)                      return np.min(values)
1595: (8)                   elif key == 0:
1596: (12)                      return (np.min(values) + np.max(values)) / 2
1597: (8)                   else:
1598: (12)                      return np.max(values)
1599: (4)               def get_critical_point(self, direction: Vector3D) -> Point3D:
1600: (8)                   """Picture a box bounding the :class:`~.Mobject`.  Such a box has
1601: (8)                   9 'critical points': 4 corners, 4 edge center, the
1602: (8)                   center. This returns one of them, along the given direction.
1603: (8)                   ::
1604: (12)                      sample = Arc(start_angle=PI/7, angle = PI/5)
1605: (12)                      # These are all equivalent
1606: (12)                      max_y_1 = sample.get_top()[1]
1607: (12)                      max_y_2 = sample.get_critical_point(UP)[1]
1608: (12)                      max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)
1609: (8)                   """
1610: (8)                   result = np.zeros(self.dim)
1611: (8)                   all_points = self.get_points_defining_boundary()
1612: (8)                   if len(all_points) == 0:
1613: (12)                      return result
1614: (8)                   for dim in range(self.dim):
1615: (12)                      result[dim] = self.get_extremum_along_dim(
1616: (16)                          all_points,
1617: (16)                          dim=dim,
1618: (16)                          key=direction[dim],
1619: (12)                      )
1620: (8)                   return result
1621: (4)               # Pseudonyms for more general get_critical_point method
1622: (4)               def get_edge_center(self, direction: Vector3D) -> Point3D:
1623: (8)                   """Get edge Point3Ds for certain direction."""
1624: (8)                   return self.get_critical_point(direction)
1625: (4)               def get_corner(self, direction: Vector3D) -> Point3D:
1626: (8)                   """Get corner Point3Ds for certain direction."""
1627: (8)                   return self.get_critical_point(direction)
1628: (4)               def get_center(self) -> Point3D:
1629: (8)                   """Get center Point3Ds"""
1630: (8)                   return self.get_critical_point(np.zeros(self.dim))
1631: (4)               def get_center_of_mass(self) -> Point3D:
1632: (8)                   return np.apply_along_axis(np.mean, 0, self.get_all_points())
1633: (4)               def get_boundary_point(self, direction: Vector3D) -> Point3D:
1634: (8)                   all_points = self.get_points_defining_boundary()
1635: (8)                   index = np.argmax(np.dot(all_points, np.array(direction).T))
1636: (8)                   return all_points[index]
1637: (4)               def get_midpoint(self) -> Point3D:
1638: (8)                   """Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.
1639: (8)                   Examples
1640: (8)                   --------
1641: (8)                   .. manim:: AngleMidPoint
1642: (12)                      :save_last_frame:
1643: (12)                      class AngleMidPoint(Scene):
1644: (16)                          def construct(self):
1645: (20)                              line1 = Line(ORIGIN, 2*RIGHT)
1646: (20)                              line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)
1647: (20)                              a = Angle(line1, line2, radius=1.5, other_angle=False)
1648: (20)                              d = Dot(a.get_midpoint()).set_color(RED)
1649: (20)                              self.add(line1, line2, a, d)
1650: (20)                              self.wait()
1651: (8)                   """
1652: (8)                   return self.point_from_proportion(0.5)
1653: (4)               def get_top(self) -> Point3D:
1654: (8)                   """Get top Point3Ds of a box bounding the :class:`~.Mobject`"""
1655: (8)                   return self.get_edge_center(UP)
1656: (4)               def get_bottom(self) -> Point3D:
1657: (8)                   """Get bottom Point3Ds of a box bounding the :class:`~.Mobject`"""
1658: (8)                   return self.get_edge_center(DOWN)
1659: (4)               def get_right(self) -> Point3D:
1660: (8)                   """Get right Point3Ds of a box bounding the :class:`~.Mobject`"""
1661: (8)                   return self.get_edge_center(RIGHT)
1662: (4)               def get_left(self) -> Point3D:
1663: (8)                   """Get left Point3Ds of a box bounding the :class:`~.Mobject`"""
1664: (8)                   return self.get_edge_center(LEFT)
1665: (4)               def get_zenith(self) -> Point3D:
1666: (8)                   """Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`."""
1667: (8)                   return self.get_edge_center(OUT)
1668: (4)               def get_nadir(self) -> Point3D:
1669: (8)                   """Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`."""
1670: (8)                   return self.get_edge_center(IN)
1671: (4)               def length_over_dim(self, dim: int) -> float:
1672: (8)                   """Measure the length of an :class:`~.Mobject` in a certain direction."""
1673: (8)                   return self.reduce_across_dimension(
1674: (12)                      max,
1675: (12)                      dim,
1676: (8)                   ) - self.reduce_across_dimension(min, dim)
1677: (4)               def get_coord(self, dim: int, direction: Vector3D = ORIGIN):
1678: (8)                   """Meant to generalize ``get_x``, ``get_y`` and ``get_z``"""
1679: (8)                   return self.get_extremum_along_dim(dim=dim, key=direction[dim])
1680: (4)               def get_x(self, direction: Vector3D = ORIGIN) -> ManimFloat:
1681: (8)                   """Returns x Point3D of the center of the :class:`~.Mobject` as ``float``"""
1682: (8)                   return self.get_coord(0, direction)
1683: (4)               def get_y(self, direction: Vector3D = ORIGIN) -> ManimFloat:
1684: (8)                   """Returns y Point3D of the center of the :class:`~.Mobject` as ``float``"""
1685: (8)                   return self.get_coord(1, direction)
1686: (4)               def get_z(self, direction: Vector3D = ORIGIN) -> ManimFloat:
1687: (8)                   """Returns z Point3D of the center of the :class:`~.Mobject` as ``float``"""
1688: (8)                   return self.get_coord(2, direction)
1689: (4)               def get_start(self) -> Point3D:
1690: (8)                   """Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts."""
1691: (8)                   self.throw_error_if_no_points()
1692: (8)                   return np.array(self.points[0])
1693: (4)               def get_end(self) -> Point3D:
1694: (8)                   """Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends."""
1695: (8)                   self.throw_error_if_no_points()
1696: (8)                   return np.array(self.points[-1])
1697: (4)               def get_start_and_end(self) -> tuple[Point3D, Point3D]:
1698: (8)                   """Returns starting and ending point of a stroke as a ``tuple``."""
1699: (8)                   return self.get_start(), self.get_end()
1700: (4)               def point_from_proportion(self, alpha: float) -> Point3D:
1701: (8)                   raise NotImplementedError("Please override in a child class.")
1702: (4)               def proportion_from_point(self, point: Point3D) -> float:
1703: (8)                   raise NotImplementedError("Please override in a child class.")
1704: (4)               def get_pieces(self, n_pieces: float) -> Group:
1705: (8)                   template = self.copy()
1706: (8)                   template.submobjects = []
1707: (8)                   alphas = np.linspace(0, 1, n_pieces + 1)
1708: (8)                   return Group(
1709: (12)                      *(
1710: (16)                          template.copy().pointwise_become_partial(self, a1, a2)
1711: (16)                          for a1, a2 in zip(alphas[:-1], alphas[1:])
1712: (12)                      )
1713: (8)                   )
1714: (4)               def get_z_index_reference_point(self) -> Point3D:
1715: (8)                   # TODO, better place to define default z_index_group?
1716: (8)                   z_index_group = getattr(self, "z_index_group", self)
1717: (8)                   return z_index_group.get_center()
1718: (4)               def has_points(self) -> bool:
1719: (8)                   """Check if :class:`~.Mobject` contains points."""
1720: (8)                   return len(self.points) > 0
1721: (4)               def has_no_points(self) -> bool:
1722: (8)                   """Check if :class:`~.Mobject` *does not* contains points."""
1723: (8)                   return not self.has_points()
1724: (4)               # Match other mobject properties
1725: (4)               def match_color(self, mobject: Mobject) -> Self:
1726: (8)                   """Match the color with the color of another :class:`~.Mobject`."""
1727: (8)                   return self.set_color(mobject.get_color())
1728: (4)               def match_dim_size(self, mobject: Mobject, dim: int, **kwargs) -> Self:
1729: (8)                   """Match the specified dimension with the dimension of another :class:`~.Mobject`."""
1730: (8)                   return self.rescale_to_fit(mobject.length_over_dim(dim), dim, **kwargs)
1731: (4)               def match_width(self, mobject: Mobject, **kwargs) -> Self:
1732: (8)                   """Match the width with the width of another :class:`~.Mobject`."""
1733: (8)                   return self.match_dim_size(mobject, 0, **kwargs)
1734: (4)               def match_height(self, mobject: Mobject, **kwargs) -> Self:
1735: (8)                   """Match the height with the height of another :class:`~.Mobject`."""
1736: (8)                   return self.match_dim_size(mobject, 1, **kwargs)
1737: (4)               def match_depth(self, mobject: Mobject, **kwargs) -> Self:
1738: (8)                   """Match the depth with the depth of another :class:`~.Mobject`."""
1739: (8)                   return self.match_dim_size(mobject, 2, **kwargs)
1740: (4)               def match_coord(
1741: (8)                   self, mobject: Mobject, dim: int, direction: Vector3D = ORIGIN
1742: (4)               ) -> Self:
1743: (8)                   """Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`."""
1744: (8)                   return self.set_coord(
1745: (12)                      mobject.get_coord(dim, direction),
1746: (12)                      dim=dim,
1747: (12)                      direction=direction,
1748: (8)                   )
1749: (4)               def match_x(self, mobject: Mobject, direction=ORIGIN) -> Self:
1750: (8)                   """Match x coord. to the x coord. of another :class:`~.Mobject`."""
1751: (8)                   return self.match_coord(mobject, 0, direction)
1752: (4)               def match_y(self, mobject: Mobject, direction=ORIGIN) -> Self:
1753: (8)                   """Match y coord. to the x coord. of another :class:`~.Mobject`."""
1754: (8)                   return self.match_coord(mobject, 1, direction)
1755: (4)               def match_z(self, mobject: Mobject, direction=ORIGIN) -> Self:
1756: (8)                   """Match z coord. to the x coord. of another :class:`~.Mobject`."""
1757: (8)                   return self.match_coord(mobject, 2, direction)
1758: (4)               def align_to(
1759: (8)                   self,
1760: (8)                   mobject_or_point: Mobject | Point3D,
1761: (8)                   direction: Vector3D = ORIGIN,
1762: (4)               ) -> Self:
1763: (8)                   """Aligns mobject to another :class:`~.Mobject` in a certain direction.
1764: (8)                   Examples:
1765: (8)                   mob1.align_to(mob2, UP) moves mob1 vertically so that its
1766: (8)                   top edge lines ups with mob2's top edge.
1767: (8)                   """
1768: (8)                   if isinstance(mobject_or_point, Mobject):
1769: (12)                      point = mobject_or_point.get_critical_point(direction)
1770: (8)                   else:
1771: (12)                      point = mobject_or_point
1772: (8)                   for dim in range(self.dim):
1773: (12)                      if direction[dim] != 0:
1774: (16)                          self.set_coord(point[dim], dim, direction)
1775: (8)                   return self
1776: (4)               # Family matters
1777: (4)               def __getitem__(self, value):
1778: (8)                   self_list = self.split()
1779: (8)                   if isinstance(value, slice):
1780: (12)                      GroupClass = self.get_group_class()
1781: (12)                      return GroupClass(*self_list.__getitem__(value))
1782: (8)                   return self_list.__getitem__(value)
1783: (4)               def __iter__(self):
1784: (8)                   return iter(self.split())
1785: (4)               def __len__(self):
1786: (8)                   return len(self.split())
1787: (4)               def get_group_class(self) -> type[Group]:
1788: (8)                   return Group
1789: (4)               @staticmethod
1790: (4)               def get_mobject_type_class() -> type[Mobject]:
1791: (8)                   """Return the base class of this mobject type."""
1792: (8)                   return Mobject
1793: (4)               def split(self) -> list[Self]:
1794: (8)                   result = [self] if len(self.points) > 0 else []
1795: (8)                   return result + self.submobjects
1796: (4)               def get_family(self, recurse: bool = True) -> list[Self]:
1797: (8)                   sub_families = [x.get_family() for x in self.submobjects]
1798: (8)                   all_mobjects = [self] + list(it.chain(*sub_families))
1799: (8)                   return remove_list_redundancies(all_mobjects)
1800: (4)               def family_members_with_points(self) -> list[Self]:
1801: (8)                   return [m for m in self.get_family() if m.get_num_points() > 0]
1802: (4)               def arrange(
1803: (8)                   self,
1804: (8)                   direction: Vector3D = RIGHT,
1805: (8)                   buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,
1806: (8)                   center: bool = True,
1807: (8)                   **kwargs,
1808: (4)               ) -> Self:
1809: (8)                   """Sorts :class:`~.Mobject` next to each other on screen.
1810: (8)                   Examples
1811: (8)                   --------
1812: (8)                   .. manim:: Example
1813: (12)                      :save_last_frame:
1814: (12)                      class Example(Scene):
1815: (16)                          def construct(self):
1816: (20)                              s1 = Square()
1817: (20)                              s2 = Square()
1818: (20)                              s3 = Square()
1819: (20)                              s4 = Square()
1820: (20)                              x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)
1821: (20)                              self.add(x)
1822: (8)                   """
1823: (8)                   for m1, m2 in zip(self.submobjects, self.submobjects[1:]):
1824: (12)                      m2.next_to(m1, direction, buff, **kwargs)
1825: (8)                   if center:
1826: (12)                      self.center()
1827: (8)                   return self
1828: (4)               def arrange_in_grid(
1829: (8)                   self,
1830: (8)                   rows: int | None = None,
1831: (8)                   cols: int | None = None,
1832: (8)                   buff: float | tuple[float, float] = MED_SMALL_BUFF,
1833: (8)                   cell_alignment: Vector3D = ORIGIN,
1834: (8)                   row_alignments: str | None = None,  # "ucd"
1835: (8)                   col_alignments: str | None = None,  # "lcr"
1836: (8)                   row_heights: Iterable[float | None] | None = None,
1837: (8)                   col_widths: Iterable[float | None] | None = None,
1838: (8)                   flow_order: str = "rd",
1839: (8)                   **kwargs,
1840: (4)               ) -> Self:
1841: (8)                   """Arrange submobjects in a grid.
1842: (8)                   Parameters
1843: (8)                   ----------
1844: (8)                   rows
1845: (12)                      The number of rows in the grid.
1846: (8)                   cols
1847: (12)                      The number of columns in the grid.
1848: (8)                   buff
1849: (12)                      The gap between grid cells. To specify a different buffer in the horizontal and
1850: (12)                      vertical directions, a tuple of two values can be given - ``(row, col)``.
1851: (8)                   cell_alignment
1852: (12)                      The way each submobject is aligned in its grid cell.
1853: (8)                   row_alignments
1854: (12)                      The vertical alignment for each row (top to bottom). Accepts the following characters: ``"u"`` -
1855: (12)                      up, ``"c"`` - center, ``"d"`` - down.
1856: (8)                   col_alignments
1857: (12)                      The horizontal alignment for each column (left to right). Accepts the following characters ``"l"`` - left,
1858: (12)                      ``"c"`` - center, ``"r"`` - right.
1859: (8)                   row_heights
1860: (12)                      Defines a list of heights for certain rows (top to bottom). If the list contains
1861: (12)                      ``None``, the corresponding row will fit its height automatically based
1862: (12)                      on the highest element in that row.
1863: (8)                   col_widths
1864: (12)                      Defines a list of widths for certain columns (left to right). If the list contains ``None``, the
1865: (12)                      corresponding column will fit its width automatically based on the widest element in that column.
1866: (8)                   flow_order
1867: (12)                      The order in which submobjects fill the grid. Can be one of the following values:
1868: (12)                      "rd", "dr", "ld", "dl", "ru", "ur", "lu", "ul". ("rd" -> fill rightwards then downwards)
1869: (8)                   Returns
1870: (8)                   -------
1871: (8)                   :class:`Mobject`
1872: (12)                      ``self``
1873: (8)                   Raises
1874: (8)                   ------
1875: (8)                   ValueError
1876: (12)                      If ``rows`` and ``cols`` are too small to fit all submobjects.
1877: (8)                   ValueError
1878: (12)                      If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,
1879: (12)                      :code:`row_alignments` and :code:`row_heights` have mismatching sizes.
1880: (8)                   Notes
1881: (8)                   -----
1882: (8)                   If only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big
1883: (8)                   enough to fit all submobjects. If neither is set, they will be chosen to be about the same,
1884: (8)                   tending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).
1885: (8)                   If both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are
1886: (8)                   defined, the latter has higher priority.
1887: (8)                   Examples
1888: (8)                   --------
1889: (8)                   .. manim:: ExampleBoxes
1890: (12)                      :save_last_frame:
1891: (12)                      class ExampleBoxes(Scene):
1892: (16)                          def construct(self):
1893: (20)                              boxes=VGroup(*[Square() for s in range(0,6)])
1894: (20)                              boxes.arrange_in_grid(rows=2, buff=0.1)
1895: (20)                              self.add(boxes)
1896: (8)                   .. manim:: ArrangeInGrid
1897: (12)                      :save_last_frame:
1898: (12)                      class ArrangeInGrid(Scene):
1899: (16)                          def construct(self):
1900: (20)                              boxes = VGroup(*[
1901: (24)                                  Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))
1902: (24)                                  for i in range(24)
1903: (20)                              ])
1904: (20)                              self.add(boxes)
1905: (20)                              boxes.arrange_in_grid(
1906: (24)                                  buff=(0.25,0.5),
1907: (24)                                  col_alignments="lccccr",
1908: (24)                                  row_alignments="uccd",
1909: (24)                                  col_widths=[1, *[None]*4, 1],
1910: (24)                                  row_heights=[1, None, None, 1],
1911: (24)                                  flow_order="dr"
1912: (20)                              )
1913: (8)                   """
1914: (8)                   from manim.mobject.geometry.line import Line
1915: (8)                   mobs = self.submobjects.copy()
1916: (8)                   start_pos = self.get_center()
1917: (8)                   # get cols / rows values if given (implicitly)
1918: (8)                   def init_size(num, alignments, sizes):
1919: (12)                      if num is not None:
1920: (16)                          return num
1921: (12)                      if alignments is not None:
1922: (16)                          return len(alignments)
1923: (12)                      if sizes is not None:
1924: (16)                          return len(sizes)
1925: (8)                   cols = init_size(cols, col_alignments, col_widths)
1926: (8)                   rows = init_size(rows, row_alignments, row_heights)
1927: (8)                   # calculate rows cols
1928: (8)                   if rows is None and cols is None:
1929: (12)                      cols = math.ceil(math.sqrt(len(mobs)))
1930: (12)                      # make the grid as close to quadratic as possible.
1931: (12)                      # choosing cols first can results in cols>rows.
1932: (12)                      # This is favored over rows>cols since in general
1933: (12)                      # the sceene is wider than high.
1934: (8)                   if rows is None:
1935: (12)                      rows = math.ceil(len(mobs) / cols)
1936: (8)                   if cols is None:
1937: (12)                      cols = math.ceil(len(mobs) / rows)
1938: (8)                   if rows * cols < len(mobs):
1939: (12)                      raise ValueError("Too few rows and columns to fit all submobjetcs.")
1940: (8)                   # rows and cols are now finally valid.
1941: (8)                   if isinstance(buff, tuple):
1942: (12)                      buff_x = buff[0]
1943: (12)                      buff_y = buff[1]
1944: (8)                   else:
1945: (12)                      buff_x = buff_y = buff
1946: (8)                   # Initialize alignments correctly
1947: (8)                   def init_alignments(alignments, num, mapping, name, dir):
1948: (12)                      if alignments is None:
1949: (16)                          # Use cell_alignment as fallback
1950: (16)                          return [cell_alignment * dir] * num
1951: (12)                      if len(alignments) != num:
1952: (16)                          raise ValueError(f"{name}_alignments has a mismatching size.")
1953: (12)                      alignments = list(alignments)
1954: (12)                      for i in range(num):
1955: (16)                          alignments[i] = mapping[alignments[i]]
1956: (12)                      return alignments
1957: (8)                   row_alignments = init_alignments(
1958: (12)                      row_alignments,
1959: (12)                      rows,
1960: (12)                      {"u": UP, "c": ORIGIN, "d": DOWN},
1961: (12)                      "row",
1962: (12)                      RIGHT,
1963: (8)                   )
1964: (8)                   col_alignments = init_alignments(
1965: (12)                      col_alignments,
1966: (12)                      cols,
1967: (12)                      {"l": LEFT, "c": ORIGIN, "r": RIGHT},
1968: (12)                      "col",
1969: (12)                      UP,
1970: (8)                   )
1971: (8)                   # Now row_alignment[r] + col_alignment[c] is the alignment in cell [r][c]
1972: (8)                   mapper = {
1973: (12)                      "dr": lambda r, c: (rows - r - 1) + c * rows,
1974: (12)                      "dl": lambda r, c: (rows - r - 1) + (cols - c - 1) * rows,
1975: (12)                      "ur": lambda r, c: r + c * rows,
1976: (12)                      "ul": lambda r, c: r + (cols - c - 1) * rows,
1977: (12)                      "rd": lambda r, c: (rows - r - 1) * cols + c,
1978: (12)                      "ld": lambda r, c: (rows - r - 1) * cols + (cols - c - 1),
1979: (12)                      "ru": lambda r, c: r * cols + c,
1980: (12)                      "lu": lambda r, c: r * cols + (cols - c - 1),
1981: (8)                   }
1982: (8)                   if flow_order not in mapper:
1983: (12)                      raise ValueError(
1984: (16)                          'flow_order must be one of the following values: "dr", "rd", "ld" "dl", "ru", "ur", "lu", "ul".',
1985: (12)                      )
1986: (8)                   flow_order = mapper[flow_order]
1987: (8)                   # Reverse row_alignments and row_heights. Necessary since the
1988: (8)                   # grid filling is handled bottom up for simplicity reasons.
1989: (8)                   def reverse(maybe_list):
1990: (12)                      if maybe_list is not None:
1991: (16)                          maybe_list = list(maybe_list)
1992: (16)                          maybe_list.reverse()
1993: (16)                          return maybe_list
1994: (8)                   row_alignments = reverse(row_alignments)
1995: (8)                   row_heights = reverse(row_heights)
1996: (8)                   placeholder = Mobject()
1997: (8)                   # Used to fill up the grid temporarily, doesn't get added to the scene.
1998: (8)                   # In this case a Mobject is better than None since it has width and height
1999: (8)                   # properties of 0.
2000: (8)                   mobs.extend([placeholder] * (rows * cols - len(mobs)))
2001: (8)                   grid = [[mobs[flow_order(r, c)] for c in range(cols)] for r in range(rows)]
2002: (8)                   measured_heigths = [
2003: (12)                      max(grid[r][c].height for c in range(cols)) for r in range(rows)
2004: (8)                   ]
2005: (8)                   measured_widths = [
2006: (12)                      max(grid[r][c].width for r in range(rows)) for c in range(cols)
2007: (8)                   ]
2008: (8)                   # Initialize row_heights / col_widths correctly using measurements as fallback
2009: (8)                   def init_sizes(sizes, num, measures, name):
2010: (12)                      if sizes is None:
2011: (16)                          sizes = [None] * num
2012: (12)                      if len(sizes) != num:
2013: (16)                          raise ValueError(f"{name} has a mismatching size.")
2014: (12)                      return [
2015: (16)                          sizes[i] if sizes[i] is not None else measures[i] for i in range(num)
2016: (12)                      ]
2017: (8)                   heights = init_sizes(row_heights, rows, measured_heigths, "row_heights")
2018: (8)                   widths = init_sizes(col_widths, cols, measured_widths, "col_widths")
2019: (8)                   x, y = 0, 0
2020: (8)                   for r in range(rows):
2021: (12)                      x = 0
2022: (12)                      for c in range(cols):
2023: (16)                          if grid[r][c] is not placeholder:
2024: (20)                              alignment = row_alignments[r] + col_alignments[c]
2025: (20)                              line = Line(
2026: (24)                                  x * RIGHT + y * UP,
2027: (24)                                  (x + widths[c]) * RIGHT + (y + heights[r]) * UP,
2028: (20)                              )
2029: (20)                              # Use a mobject to avoid rewriting align inside
2030: (20)                              # box code that Mobject.move_to(Mobject) already
2031: (20)                              # includes.
2032: (20)                              grid[r][c].move_to(line, alignment)
2033: (16)                          x += widths[c] + buff_x
2034: (12)                      y += heights[r] + buff_y
2035: (8)                   self.move_to(start_pos)
2036: (8)                   return self
2037: (4)               def sort(
2038: (8)                   self,
2039: (8)                   point_to_num_func: Callable[[Point3D], ManimInt] = lambda p: p[0],
2040: (8)                   submob_func: Callable[[Mobject], ManimInt] | None = None,
2041: (4)               ) -> Self:
2042: (8)                   """Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``."""
2043: (8)                   if submob_func is None:
2044: (12)                      def submob_func(m: Mobject):
2045: (16)                          return point_to_num_func(m.get_center())
2046: (8)                   self.submobjects.sort(key=submob_func)
2047: (8)                   return self
2048: (4)               def shuffle(self, recursive: bool = False) -> None:
2049: (8)                   """Shuffles the list of :attr:`submobjects`."""
2050: (8)                   if recursive:
2051: (12)                      for submob in self.submobjects:
2052: (16)                          submob.shuffle(recursive=True)
2053: (8)                   random.shuffle(self.submobjects)
2054: (4)               def invert(self, recursive: bool = False) -> None:
2055: (8)                   """Inverts the list of :attr:`submobjects`.
2056: (8)                   Parameters
2057: (8)                   ----------
2058: (8)                   recursive
2059: (12)                      If ``True``, all submobject lists of this mobject's family are inverted.
2060: (8)                   Examples
2061: (8)                   --------
2062: (8)                   .. manim:: InvertSumobjectsExample
2063: (12)                      class InvertSumobjectsExample(Scene):
2064: (16)                          def construct(self):
2065: (20)                              s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
2066: (20)                              s2 = s.copy()
2067: (20)                              s2.invert()
2068: (20)                              s2.shift(DOWN)
2069: (20)                              self.play(Write(s), Write(s2))
2070: (8)                   """
2071: (8)                   if recursive:
2072: (12)                      for submob in self.submobjects:
2073: (16)                          submob.invert(recursive=True)
2074: (8)                   self.submobjects.reverse()
2075: (4)               # Just here to keep from breaking old scenes.
2076: (4)               def arrange_submobjects(self, *args, **kwargs) -> Self:
2077: (8)                   """Arrange the position of :attr:`submobjects` with a small buffer.
2078: (8)                   Examples
2079: (8)                   --------
2080: (8)                   .. manim:: ArrangeSumobjectsExample
2081: (12)                      :save_last_frame:
2082: (12)                      class ArrangeSumobjectsExample(Scene):
2083: (16)                          def construct(self):
2084: (20)                              s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])
2085: (20)                              s.shift(UP).set_color(BLUE)
2086: (20)                              s2= s.copy().set_color(RED)
2087: (20)                              s2.arrange_submobjects()
2088: (20)                              s2.shift(DOWN)
2089: (20)                              self.add(s,s2)
2090: (8)                   """
2091: (8)                   return self.arrange(*args, **kwargs)
2092: (4)               def sort_submobjects(self, *args, **kwargs) -> Self:
2093: (8)                   """Sort the :attr:`submobjects`"""
2094: (8)                   return self.sort(*args, **kwargs)
2095: (4)               def shuffle_submobjects(self, *args, **kwargs) -> None:
2096: (8)                   """Shuffles the order of :attr:`submobjects`
2097: (8)                   Examples
2098: (8)                   --------
2099: (8)                   .. manim:: ShuffleSubmobjectsExample
2100: (12)                      class ShuffleSubmobjectsExample(Scene):
2101: (16)                          def construct(self):
2102: (20)                              s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
2103: (20)                              s2= s.copy()
2104: (20)                              s2.shuffle_submobjects()
2105: (20)                              s2.shift(DOWN)
2106: (20)                              self.play(Write(s), Write(s2))
2107: (8)                   """
2108: (8)                   return self.shuffle(*args, **kwargs)
2109: (4)               # Alignment
2110: (4)               def align_data(self, mobject: Mobject, skip_point_alignment: bool = False) -> None:
2111: (8)                   """Aligns the data of this mobject with another mobject.
2112: (8)                   Afterwards, the two mobjects will have the same number of submobjects
2113: (8)                   (see :meth:`.align_submobjects`), the same parent structure (see
2114: (8)                   :meth:`.null_point_align`). If ``skip_point_alignment`` is false,
2115: (8)                   they will also have the same number of points (see :meth:`.align_points`).
2116: (8)                   Parameters
2117: (8)                   ----------
2118: (8)                   mobject
2119: (12)                      The other mobject this mobject should be aligned to.
2120: (8)                   skip_point_alignment
2121: (12)                      Controls whether or not the computationally expensive
2122: (12)                      point alignment is skipped (default: False).
2123: (8)                   """
2124: (8)                   self.null_point_align(mobject)
2125: (8)                   self.align_submobjects(mobject)
2126: (8)                   if not skip_point_alignment:
2127: (12)                      self.align_points(mobject)
2128: (8)                   # Recurse
2129: (8)                   for m1, m2 in zip(self.submobjects, mobject.submobjects):
2130: (12)                      m1.align_data(m2)
2131: (4)               def get_point_mobject(self, center=None):
2132: (8)                   """The simplest :class:`~.Mobject` to be transformed to or from self.
2133: (8)                   Should by a point of the appropriate type
2134: (8)                   """
2135: (8)                   msg = f"get_point_mobject not implemented for {self.__class__.__name__}"
2136: (8)                   raise NotImplementedError(msg)
2137: (4)               def align_points(self, mobject: Mobject) -> Self:
2138: (8)                   count1 = self.get_num_points()
2139: (8)                   count2 = mobject.get_num_points()
2140: (8)                   if count1 < count2:
2141: (12)                      self.align_points_with_larger(mobject)
2142: (8)                   elif count2 < count1:
2143: (12)                      mobject.align_points_with_larger(self)
2144: (8)                   return self
2145: (4)               def align_points_with_larger(self, larger_mobject: Mobject):
2146: (8)                   raise NotImplementedError("Please override in a child class.")
2147: (4)               def align_submobjects(self, mobject: Mobject) -> Self:
2148: (8)                   mob1 = self
2149: (8)                   mob2 = mobject
2150: (8)                   n1 = len(mob1.submobjects)
2151: (8)                   n2 = len(mob2.submobjects)
2152: (8)                   mob1.add_n_more_submobjects(max(0, n2 - n1))
2153: (8)                   mob2.add_n_more_submobjects(max(0, n1 - n2))
2154: (8)                   return self
2155: (4)               def null_point_align(self, mobject: Mobject):
2156: (8)                   """If a :class:`~.Mobject` with points is being aligned to
2157: (8)                   one without, treat both as groups, and push
2158: (8)                   the one with points into its own submobjects
2159: (8)                   list.
2160: (8)                   Returns
2161: (8)                   -------
2162: (8)                   :class:`Mobject`
2163: (12)                      ``self``
2164: (8)                   """
2165: (8)                   for m1, m2 in (self, mobject), (mobject, self):
2166: (12)                      if m1.has_no_points() and m2.has_points():
2167: (16)                          m2.push_self_into_submobjects()
2168: (8)                   return self
2169: (4)               def push_self_into_submobjects(self) -> Self:
2170: (8)                   copy = self.copy()
2171: (8)                   copy.submobjects = []
2172: (8)                   self.reset_points()
2173: (8)                   self.add(copy)
2174: (8)                   return self
2175: (4)               def add_n_more_submobjects(self, n: int) -> Self | None:
2176: (8)                   if n == 0:
2177: (12)                      return None
2178: (8)                   curr = len(self.submobjects)
2179: (8)                   if curr == 0:
2180: (12)                      # If empty, simply add n point mobjects
2181: (12)                      self.submobjects = [self.get_point_mobject() for k in range(n)]
2182: (12)                      return None
2183: (8)                   target = curr + n
2184: (8)                   # TODO, factor this out to utils so as to reuse
2185: (8)                   # with VMobject.insert_n_curves
2186: (8)                   repeat_indices = (np.arange(target) * curr) // target
2187: (8)                   split_factors = [sum(repeat_indices == i) for i in range(curr)]
2188: (8)                   new_submobs = []
2189: (8)                   for submob, sf in zip(self.submobjects, split_factors):
2190: (12)                      new_submobs.append(submob)
2191: (12)                      for _ in range(1, sf):
2192: (16)                          new_submobs.append(submob.copy().fade(1))
2193: (8)                   self.submobjects = new_submobs
2194: (8)                   return self
2195: (4)               def repeat_submobject(self, submob: Mobject) -> Self:
2196: (8)                   return submob.copy()
2197: (4)               def interpolate(
2198: (8)                   self,
2199: (8)                   mobject1: Mobject,
2200: (8)                   mobject2: Mobject,
2201: (8)                   alpha: float,
2202: (8)                   path_func: PathFuncType = straight_path(),
2203: (4)               ) -> Self:
2204: (8)                   """Turns this :class:`~.Mobject` into an interpolation between ``mobject1``
2205: (8)                   and ``mobject2``.
2206: (8)                   Examples
2207: (8)                   --------
2208: (8)                   .. manim:: DotInterpolation
2209: (12)                      :save_last_frame:
2210: (12)                      class DotInterpolation(Scene):
2211: (16)                          def construct(self):
2212: (20)                              dotR = Dot(color=DARK_GREY)
2213: (20)                              dotR.shift(2 * RIGHT)
2214: (20)                              dotL = Dot(color=WHITE)
2215: (20)                              dotL.shift(2 * LEFT)
2216: (20)                              dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)
2217: (20)                              self.add(dotL, dotR, dotMiddle)
2218: (8)                   """
2219: (8)                   self.points = path_func(mobject1.points, mobject2.points, alpha)
2220: (8)                   self.interpolate_color(mobject1, mobject2, alpha)
2221: (8)                   return self
2222: (4)               def interpolate_color(self, mobject1: Mobject, mobject2: Mobject, alpha: float):
2223: (8)                   raise NotImplementedError("Please override in a child class.")
2224: (4)               def become(
2225: (8)                   self,
2226: (8)                   mobject: Mobject,
2227: (8)                   match_height: bool = False,
2228: (8)                   match_width: bool = False,
2229: (8)                   match_depth: bool = False,
2230: (8)                   match_center: bool = False,
2231: (8)                   stretch: bool = False,
2232: (4)               ) -> Self:
2233: (8)                   """Edit points, colors and submobjects to be identical
2234: (8)                   to another :class:`~.Mobject`
2235: (8)                   .. note::
2236: (12)                      If both match_height and match_width are ``True`` then the transformed :class:`~.Mobject`
2237: (12)                      will match the height first and then the width.
2238: (8)                   Parameters
2239: (8)                   ----------
2240: (8)                   match_height
2241: (12)                      Whether or not to preserve the height of the original
2242: (12)                      :class:`~.Mobject`.
2243: (8)                   match_width
2244: (12)                      Whether or not to preserve the width of the original
2245: (12)                      :class:`~.Mobject`.
2246: (8)                   match_depth
2247: (12)                      Whether or not to preserve the depth of the original
2248: (12)                      :class:`~.Mobject`.
2249: (8)                   match_center
2250: (12)                      Whether or not to preserve the center of the original
2251: (12)                      :class:`~.Mobject`.
2252: (8)                   stretch
2253: (12)                      Whether or not to stretch the target mobject to match the
2254: (12)                      the proportions of the original :class:`~.Mobject`.
2255: (8)                   Examples
2256: (8)                   --------
2257: (8)                   .. manim:: BecomeScene
2258: (12)                      class BecomeScene(Scene):
2259: (16)                          def construct(self):
2260: (20)                              circ = Circle(fill_color=RED, fill_opacity=0.8)
2261: (20)                              square = Square(fill_color=BLUE, fill_opacity=0.2)
2262: (20)                              self.add(circ)
2263: (20)                              self.wait(0.5)
2264: (20)                              circ.become(square)
2265: (20)                              self.wait(0.5)
2266: (8)                   The following examples illustrate how mobject measurements
2267: (8)                   change when using the ``match_...`` and ``stretch`` arguments.
2268: (8)                   We start with a rectangle that is 2 units high and 4 units wide,
2269: (8)                   which we want to turn into a circle of radius 3::
2270: (12)                      >>> from manim import Rectangle, Circle
2271: (12)                      >>> import numpy as np
2272: (12)                      >>> rect = Rectangle(height=2, width=4)
2273: (12)                      >>> circ = Circle(radius=3)
2274: (8)                   With ``stretch=True``, the target circle is deformed to match
2275: (8)                   the proportions of the rectangle, which results in the target
2276: (8)                   mobject being an ellipse with height 2 and width 4. We can
2277: (8)                   check that the resulting points satisfy the ellipse equation
2278: (8)                   :math:`x^2/a^2 + y^2/b^2 = 1` with :math:`a = 4/2` and :math:`b = 2/2`
2279: (8)                   being the semi-axes::
2280: (12)                      >>> result = rect.copy().become(circ, stretch=True)
2281: (12)                      >>> result.height, result.width
2282: (12)                      (2.0, 4.0)
2283: (12)                      >>> ellipse_points = np.array(result.get_anchors())
2284: (12)                      >>> ellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)
2285: (12)                      >>> np.allclose(ellipse_eq, 1)
2286: (12)                      True
2287: (8)                   With ``match_height=True`` and ``match_width=True`` the circle is
2288: (8)                   scaled such that the height or the width of the rectangle will
2289: (8)                   be preserved, respectively.
2290: (8)                   The points of the resulting mobject satisfy the circle equation
2291: (8)                   :math:`x^2 + y^2 = r^2` for the corresponding radius :math:`r`::
2292: (12)                      >>> result = rect.copy().become(circ, match_height=True)
2293: (12)                      >>> result.height, result.width
2294: (12)                      (2.0, 2.0)
2295: (12)                      >>> circle_points = np.array(result.get_anchors())
2296: (12)                      >>> circle_eq = np.sum(circle_points**2, axis=1)
2297: (12)                      >>> np.allclose(circle_eq, 1)
2298: (12)                      True
2299: (12)                      >>> result = rect.copy().become(circ, match_width=True)
2300: (12)                      >>> result.height, result.width
2301: (12)                      (4.0, 4.0)
2302: (12)                      >>> circle_points = np.array(result.get_anchors())
2303: (12)                      >>> circle_eq = np.sum(circle_points**2, axis=1)
2304: (12)                      >>> np.allclose(circle_eq, 2**2)
2305: (12)                      True
2306: (8)                   With ``match_center=True``, the resulting mobject is moved such that
2307: (8)                   its center is the same as the center of the original mobject::
2308: (12)                      >>> rect = rect.shift(np.array([0, 1, 0]))
2309: (12)                      >>> np.allclose(rect.get_center(), circ.get_center())
2310: (12)                      False
2311: (12)                      >>> result = rect.copy().become(circ, match_center=True)
2312: (12)                      >>> np.allclose(rect.get_center(), result.get_center())
2313: (12)                      True
2314: (8)                   """
2315: (8)                   mobject = mobject.copy()
2316: (8)                   if stretch:
2317: (12)                      mobject.stretch_to_fit_height(self.height)
2318: (12)                      mobject.stretch_to_fit_width(self.width)
2319: (12)                      mobject.stretch_to_fit_depth(self.depth)
2320: (8)                   else:
2321: (12)                      if match_height:
2322: (16)                          mobject.match_height(self)
2323: (12)                      if match_width:
2324: (16)                          mobject.match_width(self)
2325: (12)                      if match_depth:
2326: (16)                          mobject.match_depth(self)
2327: (8)                   if match_center:
2328: (12)                      mobject.move_to(self.get_center())
2329: (8)                   self.align_data(mobject, skip_point_alignment=True)
2330: (8)                   for sm1, sm2 in zip(self.get_family(), mobject.get_family()):
2331: (12)                      sm1.points = np.array(sm2.points)
2332: (12)                      sm1.interpolate_color(sm1, sm2, 1)
2333: (8)                   return self
2334: (4)               def match_points(self, mobject: Mobject, copy_submobjects: bool = True) -> Self:
2335: (8)                   """Edit points, positions, and submobjects to be identical
2336: (8)                   to another :class:`~.Mobject`, while keeping the style unchanged.
2337: (8)                   Examples
2338: (8)                   --------
2339: (8)                   .. manim:: MatchPointsScene
2340: (12)                      class MatchPointsScene(Scene):
2341: (16)                          def construct(self):
2342: (20)                              circ = Circle(fill_color=RED, fill_opacity=0.8)
2343: (20)                              square = Square(fill_color=BLUE, fill_opacity=0.2)
2344: (20)                              self.add(circ)
2345: (20)                              self.wait(0.5)
2346: (20)                              self.play(circ.animate.match_points(square))
2347: (20)                              self.wait(0.5)
2348: (8)                   """
2349: (8)                   for sm1, sm2 in zip(self.get_family(), mobject.get_family()):
2350: (12)                      sm1.points = np.array(sm2.points)
2351: (8)                   return self
2352: (4)               # Errors
2353: (4)               def throw_error_if_no_points(self) -> None:
2354: (8)                   if self.has_no_points():
2355: (12)                      caller_name = sys._getframe(1).f_code.co_name
2356: (12)                      raise Exception(
2357: (16)                          f"Cannot call Mobject.{caller_name} for a Mobject with no points",
2358: (12)                      )
2359: (4)               # About z-index
2360: (4)               def set_z_index(
2361: (8)                   self,
2362: (8)                   z_index_value: float,
2363: (8)                   family: bool = True,
2364: (4)               ) -> Self:
2365: (8)                   """Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.
2366: (8)                   Parameters
2367: (8)                   ----------
2368: (8)                   z_index_value
2369: (12)                      The new value of :attr:`z_index` set.
2370: (8)                   family
2371: (12)                      If ``True``, the :attr:`z_index` value of all submobjects is also set.
2372: (8)                   Returns
2373: (8)                   -------
2374: (8)                   :class:`Mobject`
2375: (12)                      The Mobject itself, after :attr:`z_index` is set. For chaining purposes. (Returns `self`.)
2376: (8)                   Examples
2377: (8)                   --------
2378: (8)                   .. manim:: SetZIndex
2379: (12)                      :save_last_frame:
2380: (12)                      class SetZIndex(Scene):
2381: (16)                          def construct(self):
2382: (20)                              text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)
2383: (20)                              square = Square(2, fill_opacity=1).set_z_index(2)
2384: (20)                              tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)
2385: (20)                              circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0
2386: (20)                              # Displaying order is now defined by z_index values
2387: (20)                              self.add(text)
2388: (20)                              self.add(square)
2389: (20)                              self.add(tex)
2390: (20)                              self.add(circle)
2391: (8)                   """
2392: (8)                   if family:
2393: (12)                      for submob in self.submobjects:
2394: (16)                          submob.set_z_index(z_index_value, family=family)
2395: (8)                   self.z_index = z_index_value
2396: (8)                   return self
2397: (4)               def set_z_index_by_z_Point3D(self) -> Self:
2398: (8)                   """Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.
2399: (8)                   Returns
2400: (8)                   -------
2401: (8)                   :class:`Mobject`
2402: (12)                      The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)
2403: (8)                   """
2404: (8)                   z_coord = self.get_center()[-1]
2405: (8)                   self.set_z_index(z_coord)
2406: (8)                   return self
2407: (0)           class Group(Mobject, metaclass=ConvertToOpenGL):
2408: (4)               """Groups together multiple :class:`Mobjects <.Mobject>`.
2409: (4)               Notes
2410: (4)               -----
2411: (4)               When adding the same mobject more than once, repetitions are ignored.
2412: (4)               Use :meth:`.Mobject.copy` to create a separate copy which can then
2413: (4)               be added to the group.
2414: (4)               """
2415: (4)               def __init__(self, *mobjects, **kwargs) -> None:
2416: (8)                   super().__init__(**kwargs)
2417: (8)                   self.add(*mobjects)
2418: (0)           class _AnimationBuilder:
2419: (4)               def __init__(self, mobject) -> None:
2420: (8)                   self.mobject = mobject
2421: (8)                   self.mobject.generate_target()
2422: (8)                   self.overridden_animation = None
2423: (8)                   self.is_chaining = False
2424: (8)                   self.methods = []
2425: (8)                   # Whether animation args can be passed
2426: (8)                   self.cannot_pass_args = False
2427: (8)                   self.anim_args = {}
2428: (4)               def __call__(self, **kwargs) -> Self:
2429: (8)                   if self.cannot_pass_args:
2430: (12)                      raise ValueError(
2431: (16)                          "Animation arguments must be passed before accessing methods and can only be passed once",
2432: (12)                      )
2433: (8)                   self.anim_args = kwargs
2434: (8)                   self.cannot_pass_args = True
2435: (8)                   return self
2436: (4)               def __getattr__(self, method_name) -> types.MethodType:
2437: (8)                   method = getattr(self.mobject.target, method_name)
2438: (8)                   has_overridden_animation = hasattr(method, "_override_animate")
2439: (8)                   if (self.is_chaining and has_overridden_animation) or self.overridden_animation:
2440: (12)                      raise NotImplementedError(
2441: (16)                          "Method chaining is currently not supported for "
2442: (16)                          "overridden animations",
2443: (12)                      )
2444: (8)                   def update_target(*method_args, **method_kwargs):
2445: (12)                      if has_overridden_animation:
2446: (16)                          self.overridden_animation = method._override_animate(
2447: (20)                              self.mobject,
2448: (20)                              *method_args,
2449: (20)                              anim_args=self.anim_args,
2450: (20)                              **method_kwargs,
2451: (16)                          )
2452: (12)                      else:
2453: (16)                          self.methods.append([method, method_args, method_kwargs])
2454: (16)                          method(*method_args, **method_kwargs)
2455: (12)                      return self
2456: (8)                   self.is_chaining = True
2457: (8)                   self.cannot_pass_args = True
2458: (8)                   return update_target
2459: (4)               def build(self) -> Animation:
2460: (8)                   from ..animation.transform import (  # is this to prevent circular import?
2461: (12)                      _MethodAnimation,
2462: (8)                   )
2463: (8)                   if self.overridden_animation:
2464: (12)                      anim = self.overridden_animation
2465: (8)                   else:
2466: (12)                      anim = _MethodAnimation(self.mobject, self.methods)
2467: (8)                   for attr, value in self.anim_args.items():
2468: (12)                      setattr(anim, attr, value)
2469: (8)                   return anim
2470: (0)           def override_animate(method) -> types.FunctionType:
2471: (4)               r"""Decorator for overriding method animations.
2472: (4)               This allows to specify a method (returning an :class:`~.Animation`)
2473: (4)               which is called when the decorated method is used with the ``.animate`` syntax
2474: (4)               for animating the application of a method.
2475: (4)               .. seealso::
2476: (8)                   :attr:`Mobject.animate`
2477: (4)               .. note::
2478: (8)                   Overridden methods cannot be combined with normal or other overridden
2479: (8)                   methods using method chaining with the ``.animate`` syntax.
2480: (4)               Examples
2481: (4)               --------
2482: (4)               .. manim:: AnimationOverrideExample
2483: (8)                   class CircleWithContent(VGroup):
2484: (12)                      def __init__(self, content):
2485: (16)                          super().__init__()
2486: (16)                          self.circle = Circle()
2487: (16)                          self.content = content
2488: (16)                          self.add(self.circle, content)
2489: (16)                          content.move_to(self.circle.get_center())
2490: (12)                      def clear_content(self):
2491: (16)                          self.remove(self.content)
2492: (16)                          self.content = None
2493: (12)                      @override_animate(clear_content)
2494: (12)                      def _clear_content_animation(self, anim_args=None):
2495: (16)                          if anim_args is None:
2496: (20)                              anim_args = {}
2497: (16)                          anim = Uncreate(self.content, **anim_args)
2498: (16)                          self.clear_content()
2499: (16)                          return anim
2500: (8)                   class AnimationOverrideExample(Scene):
2501: (12)                      def construct(self):
2502: (16)                          t = Text("hello!")
2503: (16)                          my_mobject = CircleWithContent(t)
2504: (16)                          self.play(Create(my_mobject))
2505: (16)                          self.play(my_mobject.animate.clear_content())
2506: (16)                          self.wait()
2507: (4)               """
2508: (4)               def decorator(animation_method):
2509: (8)                   method._override_animate = animation_method
2510: (8)                   return animation_method
2511: (4)               return decorator

----------------------------------------

File 10 - .\geometry \labeled.py:

1: (0)              r"""Mobjects that inherit from lines and contain a label along the length."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["LabeledLine", "LabeledArrow"]
4: (0)              from manim.constants import *
5: (0)              from manim.mobject.geometry.line import Arrow, Line
6: (0)              from manim.mobject.geometry.shape_matchers import (
7: (4)                  BackgroundRectangle,
8: (4)                  SurroundingRectangle,
9: (0)              )
10: (0)             from manim.mobject.text.tex_mobject import MathTex, Tex
11: (0)             from manim.mobject.text.text_mobject import Text
12: (0)             from manim.utils.color import WHITE, ManimColor, ParsableManimColor
13: (0)             class LabeledLine(Line):
14: (4)                 """Constructs a line containing a label box somewhere along its length.
15: (4)                 Parameters
16: (4)                 ----------
17: (4)                 label : str | Tex | MathTex | Text
18: (8)                     Label that will be displayed on the line.
19: (4)                 label_position : float | optional
20: (8)                     A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.
21: (4)                 font_size : float | optional
22: (8)                     Control font size for the label. This parameter is only used when `label` is of type `str`.
23: (4)                 label_color: ParsableManimColor | optional
24: (8)                     The color of the label's text. This parameter is only used when `label` is of type `str`.
25: (4)                 label_frame : Bool | optional
26: (8)                     Add a `SurroundingRectangle` frame to the label box.
27: (4)                 frame_fill_color : ParsableManimColor | optional
28: (8)                     Background color to fill the label box. If no value is provided, the background color of the canvas will be used.
29: (4)                 frame_fill_opacity : float | optional
30: (8)                     Determine the opacity of the label box by passing a value in the range [0-1], where 0 indicates complete transparency and 1 means full opacity.
31: (4)                 .. seealso::
32: (8)                     :class:`LabeledArrow`
33: (4)                 Examples
34: (4)                 --------
35: (4)                 .. manim:: LabeledLineExample
36: (8)                     :save_last_frame:
37: (8)                     class LabeledLineExample(Scene):
38: (12)                        def construct(self):
39: (16)                            line = LabeledLine(
40: (20)                                label          = '0.5',
41: (20)                                label_position = 0.8,
42: (20)                                font_size      = 20,
43: (20)                                label_color    = WHITE,
44: (20)                                label_frame    = True,
45: (20)                                start=LEFT+DOWN,
46: (20)                                end=RIGHT+UP)
47: (16)                            line.set_length(line.get_length() * 2)
48: (16)                            self.add(line)
49: (4)                 """
50: (4)                 def __init__(
51: (8)                     self,
52: (8)                     label: str | Tex | MathTex | Text,
53: (8)                     label_position: float = 0.5,
54: (8)                     font_size: float = DEFAULT_FONT_SIZE,
55: (8)                     label_color: ParsableManimColor = WHITE,
56: (8)                     label_frame: bool = True,
57: (8)                     frame_fill_color: ParsableManimColor = None,
58: (8)                     frame_fill_opacity: float = 1,
59: (8)                     *args,
60: (8)                     **kwargs,
61: (4)                 ) -> None:
62: (8)                     label_color = ManimColor(label_color)
63: (8)                     frame_fill_color = ManimColor(frame_fill_color)
64: (8)                     if isinstance(label, str):
65: (12)                        from manim import MathTex
66: (12)                        rendered_label = MathTex(label, color=label_color, font_size=font_size)
67: (8)                     else:
68: (12)                        rendered_label = label
69: (8)                     super().__init__(*args, **kwargs)
70: (8)                     # calculating the vector for the label position
71: (8)                     line_start, line_end = self.get_start_and_end()
72: (8)                     new_vec = (line_end - line_start) * label_position
73: (8)                     label_coords = line_start + new_vec
74: (8)                     # rendered_label.move_to(self.get_vector() * label_position)
75: (8)                     rendered_label.move_to(label_coords)
76: (8)                     box = BackgroundRectangle(
77: (12)                        rendered_label,
78: (12)                        buff=0.05,
79: (12)                        color=frame_fill_color,
80: (12)                        fill_opacity=frame_fill_opacity,
81: (12)                        stroke_width=0.5,
82: (8)                     )
83: (8)                     self.add(box)
84: (8)                     if label_frame:
85: (12)                        box_frame = SurroundingRectangle(
86: (16)                            rendered_label, buff=0.05, color=label_color, stroke_width=0.5
87: (12)                        )
88: (12)                        self.add(box_frame)
89: (8)                     self.add(rendered_label)
90: (0)             class LabeledArrow(LabeledLine, Arrow):
91: (4)                 """Constructs an arrow containing a label box somewhere along its length.
92: (4)                 This class inherits its label properties from `LabeledLine`, so the main parameters controlling it are the same.
93: (4)                 Parameters
94: (4)                 ----------
95: (4)                 label : str | Tex | MathTex | Text
96: (8)                     Label that will be displayed on the line.
97: (4)                 label_position : float | optional
98: (8)                     A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.
99: (4)                 font_size : float | optional
100: (8)                    Control font size for the label. This parameter is only used when `label` is of type `str`.
101: (4)                label_color: ParsableManimColor | optional
102: (8)                    The color of the label's text. This parameter is only used when `label` is of type `str`.
103: (4)                label_frame : Bool | optional
104: (8)                    Add a `SurroundingRectangle` frame to the label box.
105: (4)                frame_fill_color : ParsableManimColor | optional
106: (8)                    Background color to fill the label box. If no value is provided, the background color of the canvas will be used.
107: (4)                frame_fill_opacity : float | optional
108: (8)                    Determine the opacity of the label box by passing a value in the range [0-1], where 0 indicates complete transparency and 1 means full opacity.
109: (4)                .. seealso::
110: (8)                    :class:`LabeledLine`
111: (4)                Examples
112: (4)                --------
113: (4)                .. manim:: LabeledArrowExample
114: (8)                    :save_last_frame:
115: (8)                    class LabeledArrowExample(Scene):
116: (12)                       def construct(self):
117: (16)                           l_arrow = LabeledArrow("0.5", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)
118: (16)                           self.add(l_arrow)
119: (4)                """
120: (4)                def __init__(
121: (8)                    self,
122: (8)                    *args,
123: (8)                    **kwargs,
124: (4)                ) -> None:
125: (8)                    super().__init__(*args, **kwargs)

----------------------------------------

File 11 - . \__init__.py:

1: (0)              

----------------------------------------

File 12 - .\geometry \polygram.py:

1: (0)              r"""Mobjects that are simple geometric shapes."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "Polygram",
5: (4)                  "Polygon",
6: (4)                  "RegularPolygram",
7: (4)                  "RegularPolygon",
8: (4)                  "Star",
9: (4)                  "Triangle",
10: (4)                 "Rectangle",
11: (4)                 "Square",
12: (4)                 "RoundedRectangle",
13: (4)                 "Cutout",
14: (0)             ]
15: (0)             from math import ceil
16: (0)             from typing import TYPE_CHECKING
17: (0)             import numpy as np
18: (0)             from manim.constants import *
19: (0)             from manim.mobject.geometry.arc import ArcBetweenPoints
20: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
21: (0)             from manim.mobject.types.vectorized_mobject import VGroup, VMobject
22: (0)             from manim.utils.color import BLUE, WHITE, ParsableManimColor
23: (0)             from manim.utils.iterables import adjacent_n_tuples, adjacent_pairs
24: (0)             from manim.utils.space_ops import angle_between_vectors, normalize, regular_vertices
25: (0)             if TYPE_CHECKING:
26: (4)                 from typing_extensions import Self
27: (4)                 from manim.typing import Point3D, Point3D_Array
28: (4)                 from manim.utils.color import ParsableManimColor
29: (0)             class Polygram(VMobject, metaclass=ConvertToOpenGL):
30: (4)                 """A generalized :class:`Polygon`, allowing for disconnected sets of edges.
31: (4)                 Parameters
32: (4)                 ----------
33: (4)                 vertex_groups
34: (8)                     The groups of vertices making up the :class:`Polygram`.
35: (8)                     The first vertex in each group is repeated to close the shape.
36: (8)                     Each point must be 3-dimensional: ``[x,y,z]``
37: (4)                 color
38: (8)                     The color of the :class:`Polygram`.
39: (4)                 kwargs
40: (8)                     Forwarded to the parent constructor.
41: (4)                 Examples
42: (4)                 --------
43: (4)                 .. manim:: PolygramExample
44: (8)                     import numpy as np
45: (8)                     class PolygramExample(Scene):
46: (12)                        def construct(self):
47: (16)                            hexagram = Polygram(
48: (20)                                [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],
49: (20)                                [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],
50: (16)                            )
51: (16)                            self.add(hexagram)
52: (16)                            dot = Dot()
53: (16)                            self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)
54: (16)                            self.remove(dot)
55: (16)                            self.wait()
56: (4)                 """
57: (4)                 def __init__(
58: (8)                     self, *vertex_groups: Point3D, color: ParsableManimColor = BLUE, **kwargs
59: (4)                 ):
60: (8)                     super().__init__(color=color, **kwargs)
61: (8)                     for vertices in vertex_groups:
62: (12)                        first_vertex, *vertices = vertices
63: (12)                        first_vertex = np.array(first_vertex)
64: (12)                        self.start_new_path(first_vertex)
65: (12)                        self.add_points_as_corners(
66: (16)                            [*(np.array(vertex) for vertex in vertices), first_vertex],
67: (12)                        )
68: (4)                 def get_vertices(self) -> Point3D_Array:
69: (8)                     """Gets the vertices of the :class:`Polygram`.
70: (8)                     Returns
71: (8)                     -------
72: (8)                     :class:`numpy.ndarray`
73: (12)                        The vertices of the :class:`Polygram`.
74: (8)                     Examples
75: (8)                     --------
76: (8)                     ::
77: (12)                        >>> sq = Square()
78: (12)                        >>> sq.get_vertices()
79: (12)                        array([[ 1.,  1.,  0.],
80: (19)                               [-1.,  1.,  0.],
81: (19)                               [-1., -1.,  0.],
82: (19)                               [ 1., -1.,  0.]])
83: (8)                     """
84: (8)                     return self.get_start_anchors()
85: (4)                 def get_vertex_groups(self) -> np.ndarray[Point3D_Array]:
86: (8)                     """Gets the vertex groups of the :class:`Polygram`.
87: (8)                     Returns
88: (8)                     -------
89: (8)                     :class:`numpy.ndarray`
90: (12)                        The vertex groups of the :class:`Polygram`.
91: (8)                     Examples
92: (8)                     --------
93: (8)                     ::
94: (12)                        >>> poly = Polygram([ORIGIN, RIGHT, UP], [LEFT, LEFT + UP, 2 * LEFT])
95: (12)                        >>> poly.get_vertex_groups()
96: (12)                        array([[[ 0.,  0.,  0.],
97: (20)                                [ 1.,  0.,  0.],
98: (20)                                [ 0.,  1.,  0.]],
99: (12)                        <BLANKLINE>
100: (19)                              [[-1.,  0.,  0.],
101: (20)                               [-1.,  1.,  0.],
102: (20)                               [-2.,  0.,  0.]]])
103: (8)                    """
104: (8)                    vertex_groups = []
105: (8)                    group = []
106: (8)                    for start, end in zip(self.get_start_anchors(), self.get_end_anchors()):
107: (12)                       group.append(start)
108: (12)                       if self.consider_points_equals(end, group[0]):
109: (16)                           vertex_groups.append(group)
110: (16)                           group = []
111: (8)                    return np.array(vertex_groups)
112: (4)                def round_corners(
113: (8)                    self,
114: (8)                    radius: float | list[float] = 0.5,
115: (8)                    evenly_distribute_anchors: bool = False,
116: (8)                    components_per_rounded_corner: int = 2,
117: (4)                ) -> Self:
118: (8)                    """Rounds off the corners of the :class:`Polygram`.
119: (8)                    Parameters
120: (8)                    ----------
121: (8)                    radius
122: (12)                       The curvature of the corners of the :class:`Polygram`.
123: (8)                    evenly_distribute_anchors
124: (12)                       Break long line segments into proportionally-sized segments.
125: (8)                    components_per_rounded_corner
126: (12)                       The number of points used to represent the rounded corner curve.
127: (8)                    .. seealso::
128: (12)                       :class:`.~RoundedRectangle`
129: (8)                    .. note::
130: (12)                       If `radius` is supplied as a single value, then the same radius
131: (12)                       will be applied to all corners.  If `radius` is a list, then the
132: (12)                       individual values will be applied sequentially, with the first
133: (12)                       corner receiving `radius[0]`, the second corner receiving
134: (12)                       `radius[1]`, etc.  The radius list will be repeated as necessary.
135: (12)                       The `components_per_rounded_corner` value is provided so that the
136: (12)                       fidelity of the rounded corner may be fine-tuned as needed.  2 is
137: (12)                       an appropriate value for most shapes, however a larger value may be
138: (12)                       need if the rounded corner is particularly large.  2 is the minimum
139: (12)                       number allowed, representing the start and end of the curve.  3 will
140: (12)                       result in a start, middle, and end point, meaning 2 curves will be
141: (12)                       generated.
142: (12)                       The option to `evenly_distribute_anchors` is provided so that the
143: (12)                       line segments (the part part of each line remaining after rounding
144: (12)                       off the corners) can be subdivided to a density similar to that of
145: (12)                       the average density of the rounded corners.  This may be desirable
146: (12)                       in situations in which an even distribution of curves is desired
147: (12)                       for use in later transformation animations.  Be aware, though, that
148: (12)                       enabling this option can result in an an object containing
149: (12)                       significantly more points than the original, especially when the
150: (12)                       rounded corner curves are small.
151: (8)                    Examples
152: (8)                    --------
153: (8)                    .. manim:: PolygramRoundCorners
154: (12)                       :save_last_frame:
155: (12)                       class PolygramRoundCorners(Scene):
156: (16)                           def construct(self):
157: (20)                               star = Star(outer_radius=2)
158: (20)                               shapes = VGroup(star)
159: (20)                               shapes.add(star.copy().round_corners(radius=0.1))
160: (20)                               shapes.add(star.copy().round_corners(radius=0.25))
161: (20)                               shapes.arrange(RIGHT)
162: (20)                               self.add(shapes)
163: (8)                    """
164: (8)                    if radius == 0:
165: (12)                       return self
166: (8)                    new_points = []
167: (8)                    for vertices in self.get_vertex_groups():
168: (12)                       arcs = []
169: (12)                       # Repeat the radius list as necessary in order to provide a radius
170: (12)                       # for each vertex.
171: (12)                       if isinstance(radius, (int, float)):
172: (16)                           radius_list = [radius] * len(vertices)
173: (12)                       else:
174: (16)                           radius_list = radius * ceil(len(vertices) / len(radius))
175: (12)                       for currentRadius, (v1, v2, v3) in zip(
176: (16)                           radius_list, adjacent_n_tuples(vertices, 3)
177: (12)                       ):
178: (16)                           vect1 = v2 - v1
179: (16)                           vect2 = v3 - v2
180: (16)                           unit_vect1 = normalize(vect1)
181: (16)                           unit_vect2 = normalize(vect2)
182: (16)                           angle = angle_between_vectors(vect1, vect2)
183: (16)                           # Negative radius gives concave curves
184: (16)                           angle *= np.sign(currentRadius)
185: (16)                           # Distance between vertex and start of the arc
186: (16)                           cut_off_length = currentRadius * np.tan(angle / 2)
187: (16)                           # Determines counterclockwise vs. clockwise
188: (16)                           sign = np.sign(np.cross(vect1, vect2)[2])
189: (16)                           arc = ArcBetweenPoints(
190: (20)                               v2 - unit_vect1 * cut_off_length,
191: (20)                               v2 + unit_vect2 * cut_off_length,
192: (20)                               angle=sign * angle,
193: (20)                               num_components=components_per_rounded_corner,
194: (16)                           )
195: (16)                           arcs.append(arc)
196: (12)                       if evenly_distribute_anchors:
197: (16)                           # Determine the average length of each curve
198: (16)                           nonZeroLengthArcs = [arc for arc in arcs if len(arc.points) > 4]
199: (16)                           if len(nonZeroLengthArcs):
200: (20)                               totalArcLength = sum(
201: (24)                                   [arc.get_arc_length() for arc in nonZeroLengthArcs]
202: (20)                               )
203: (20)                               totalCurveCount = (
204: (24)                                   sum([len(arc.points) for arc in nonZeroLengthArcs]) / 4
205: (20)                               )
206: (20)                               averageLengthPerCurve = totalArcLength / totalCurveCount
207: (16)                           else:
208: (20)                               averageLengthPerCurve = 1
209: (12)                       # To ensure that we loop through starting with last
210: (12)                       arcs = [arcs[-1], *arcs[:-1]]
211: (12)                       from manim.mobject.geometry.line import Line
212: (12)                       for arc1, arc2 in adjacent_pairs(arcs):
213: (16)                           new_points.extend(arc1.points)
214: (16)                           line = Line(arc1.get_end(), arc2.get_start())
215: (16)                           # Make sure anchors are evenly distributed, if necessary
216: (16)                           if evenly_distribute_anchors:
217: (20)                               line.insert_n_curves(
218: (24)                                   ceil(line.get_length() / averageLengthPerCurve)
219: (20)                               )
220: (16)                           new_points.extend(line.points)
221: (8)                    self.set_points(new_points)
222: (8)                    return self
223: (0)            class Polygon(Polygram):
224: (4)                """A shape consisting of one closed loop of vertices.
225: (4)                Parameters
226: (4)                ----------
227: (4)                vertices
228: (8)                    The vertices of the :class:`Polygon`.
229: (4)                kwargs
230: (8)                    Forwarded to the parent constructor.
231: (4)                Examples
232: (4)                --------
233: (4)                .. manim:: PolygonExample
234: (8)                    :save_last_frame:
235: (8)                    class PolygonExample(Scene):
236: (12)                       def construct(self):
237: (16)                           isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])
238: (16)                           position_list = [
239: (20)                               [4, 1, 0],  # middle right
240: (20)                               [4, -2.5, 0],  # bottom right
241: (20)                               [0, -2.5, 0],  # bottom left
242: (20)                               [0, 3, 0],  # top left
243: (20)                               [2, 1, 0],  # middle
244: (20)                               [4, 3, 0],  # top right
245: (16)                           ]
246: (16)                           square_and_triangles = Polygon(*position_list, color=PURPLE_B)
247: (16)                           self.add(isosceles, square_and_triangles)
248: (4)                """
249: (4)                def __init__(self, *vertices: Point3D, **kwargs) -> None:
250: (8)                    super().__init__(vertices, **kwargs)
251: (0)            class RegularPolygram(Polygram):
252: (4)                """A :class:`Polygram` with regularly spaced vertices.
253: (4)                Parameters
254: (4)                ----------
255: (4)                num_vertices
256: (8)                    The number of vertices.
257: (4)                density
258: (8)                    The density of the :class:`RegularPolygram`.
259: (8)                    Can be thought of as how many vertices to hop
260: (8)                    to draw a line between them. Every ``density``-th
261: (8)                    vertex is connected.
262: (4)                radius
263: (8)                    The radius of the circle that the vertices are placed on.
264: (4)                start_angle
265: (8)                    The angle the vertices start at; the rotation of
266: (8)                    the :class:`RegularPolygram`.
267: (4)                kwargs
268: (8)                    Forwarded to the parent constructor.
269: (4)                Examples
270: (4)                --------
271: (4)                .. manim:: RegularPolygramExample
272: (8)                    :save_last_frame:
273: (8)                    class RegularPolygramExample(Scene):
274: (12)                       def construct(self):
275: (16)                           pentagram = RegularPolygram(5, radius=2)
276: (16)                           self.add(pentagram)
277: (4)                """
278: (4)                def __init__(
279: (8)                    self,
280: (8)                    num_vertices: int,
281: (8)                    *,
282: (8)                    density: int = 2,
283: (8)                    radius: float = 1,
284: (8)                    start_angle: float | None = None,
285: (8)                    **kwargs,
286: (4)                ) -> None:
287: (8)                    # Regular polygrams can be expressed by the number of their vertices
288: (8)                    # and their density. This relation can be expressed as its Schläfli
289: (8)                    # symbol: {num_vertices/density}.
290: (8)                    #
291: (8)                    # For instance, a pentagon can be expressed as {5/1} or just {5}.
292: (8)                    # A pentagram, however, can be expressed as {5/2}.
293: (8)                    # A hexagram *would* be expressed as {6/2}, except that 6 and 2
294: (8)                    # are not coprime, and it can be simplified to 2{3}, which corresponds
295: (8)                    # to the fact that a hexagram is actually made up of 2 triangles.
296: (8)                    #
297: (8)                    # See https://en.wikipedia.org/wiki/Polygram_(geometry)#Generalized_regular_polygons
298: (8)                    # for more information.
299: (8)                    num_gons = np.gcd(num_vertices, density)
300: (8)                    num_vertices //= num_gons
301: (8)                    density //= num_gons
302: (8)                    # Utility function for generating the individual
303: (8)                    # polygon vertices.
304: (8)                    def gen_polygon_vertices(start_angle):
305: (12)                       reg_vertices, start_angle = regular_vertices(
306: (16)                           num_vertices,
307: (16)                           radius=radius,
308: (16)                           start_angle=start_angle,
309: (12)                       )
310: (12)                       vertices = []
311: (12)                       i = 0
312: (12)                       while True:
313: (16)                           vertices.append(reg_vertices[i])
314: (16)                           i += density
315: (16)                           i %= num_vertices
316: (16)                           if i == 0:
317: (20)                               break
318: (12)                       return vertices, start_angle
319: (8)                    first_group, self.start_angle = gen_polygon_vertices(start_angle)
320: (8)                    vertex_groups = [first_group]
321: (8)                    for i in range(1, num_gons):
322: (12)                       start_angle = self.start_angle + (i / num_gons) * TAU / num_vertices
323: (12)                       group, _ = gen_polygon_vertices(start_angle)
324: (12)                       vertex_groups.append(group)
325: (8)                    super().__init__(*vertex_groups, **kwargs)
326: (0)            class RegularPolygon(RegularPolygram):
327: (4)                """An n-sided regular :class:`Polygon`.
328: (4)                Parameters
329: (4)                ----------
330: (4)                n
331: (8)                    The number of sides of the :class:`RegularPolygon`.
332: (4)                kwargs
333: (8)                    Forwarded to the parent constructor.
334: (4)                Examples
335: (4)                --------
336: (4)                .. manim:: RegularPolygonExample
337: (8)                    :save_last_frame:
338: (8)                    class RegularPolygonExample(Scene):
339: (12)                       def construct(self):
340: (16)                           poly_1 = RegularPolygon(n=6)
341: (16)                           poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)
342: (16)                           poly_3 = RegularPolygon(n=10, color=RED)
343: (16)                           poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)
344: (16)                           self.add(poly_group)
345: (4)                """
346: (4)                def __init__(self, n: int = 6, **kwargs) -> None:
347: (8)                    super().__init__(n, density=1, **kwargs)
348: (0)            class Star(Polygon):
349: (4)                """A regular polygram without the intersecting lines.
350: (4)                Parameters
351: (4)                ----------
352: (4)                n
353: (8)                    How many points on the :class:`Star`.
354: (4)                outer_radius
355: (8)                    The radius of the circle that the outer vertices are placed on.
356: (4)                inner_radius
357: (8)                    The radius of the circle that the inner vertices are placed on.
358: (8)                    If unspecified, the inner radius will be
359: (8)                    calculated such that the edges of the :class:`Star`
360: (8)                    perfectly follow the edges of its :class:`RegularPolygram`
361: (8)                    counterpart.
362: (4)                density
363: (8)                    The density of the :class:`Star`. Only used if
364: (8)                    ``inner_radius`` is unspecified.
365: (8)                    See :class:`RegularPolygram` for more information.
366: (4)                start_angle
367: (8)                    The angle the vertices start at; the rotation of
368: (8)                    the :class:`Star`.
369: (4)                kwargs
370: (8)                    Forwardeds to the parent constructor.
371: (4)                Raises
372: (4)                ------
373: (4)                :exc:`ValueError`
374: (8)                    If ``inner_radius`` is unspecified and ``density``
375: (8)                    is not in the range ``[1, n/2)``.
376: (4)                Examples
377: (4)                --------
378: (4)                .. manim:: StarExample
379: (8)                    :save_as_gif:
380: (8)                    class StarExample(Scene):
381: (12)                       def construct(self):
382: (16)                           pentagram = RegularPolygram(5, radius=2)
383: (16)                           star = Star(outer_radius=2, color=RED)
384: (16)                           self.add(pentagram)
385: (16)                           self.play(Create(star), run_time=3)
386: (16)                           self.play(FadeOut(star), run_time=2)
387: (4)                .. manim:: DifferentDensitiesExample
388: (8)                    :save_last_frame:
389: (8)                    class DifferentDensitiesExample(Scene):
390: (12)                       def construct(self):
391: (16)                           density_2 = Star(7, outer_radius=2, density=2, color=RED)
392: (16)                           density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)
393: (16)                           self.add(VGroup(density_2, density_3).arrange(RIGHT))
394: (4)                """
395: (4)                def __init__(
396: (8)                    self,
397: (8)                    n: int = 5,
398: (8)                    *,
399: (8)                    outer_radius: float = 1,
400: (8)                    inner_radius: float | None = None,
401: (8)                    density: int = 2,
402: (8)                    start_angle: float | None = TAU / 4,
403: (8)                    **kwargs,
404: (4)                ) -> None:
405: (8)                    inner_angle = TAU / (2 * n)
406: (8)                    if inner_radius is None:
407: (12)                       # See https://math.stackexchange.com/a/2136292 for an
408: (12)                       # overview of how to calculate the inner radius of a
409: (12)                       # perfect star.
410: (12)                       if density <= 0 or density >= n / 2:
411: (16)                           raise ValueError(
412: (20)                               f"Incompatible density {density} for number of points {n}",
413: (16)                           )
414: (12)                       outer_angle = TAU * density / n
415: (12)                       inverse_x = 1 - np.tan(inner_angle) * (
416: (16)                           (np.cos(outer_angle) - 1) / np.sin(outer_angle)
417: (12)                       )
418: (12)                       inner_radius = outer_radius / (np.cos(inner_angle) * inverse_x)
419: (8)                    outer_vertices, self.start_angle = regular_vertices(
420: (12)                       n,
421: (12)                       radius=outer_radius,
422: (12)                       start_angle=start_angle,
423: (8)                    )
424: (8)                    inner_vertices, _ = regular_vertices(
425: (12)                       n,
426: (12)                       radius=inner_radius,
427: (12)                       start_angle=self.start_angle + inner_angle,
428: (8)                    )
429: (8)                    vertices = []
430: (8)                    for pair in zip(outer_vertices, inner_vertices):
431: (12)                       vertices.extend(pair)
432: (8)                    super().__init__(*vertices, **kwargs)
433: (0)            class Triangle(RegularPolygon):
434: (4)                """An equilateral triangle.
435: (4)                Parameters
436: (4)                ----------
437: (4)                kwargs
438: (8)                    Additional arguments to be passed to :class:`RegularPolygon`
439: (4)                Examples
440: (4)                --------
441: (4)                .. manim:: TriangleExample
442: (8)                    :save_last_frame:
443: (8)                    class TriangleExample(Scene):
444: (12)                       def construct(self):
445: (16)                           triangle_1 = Triangle()
446: (16)                           triangle_2 = Triangle().scale(2).rotate(60*DEGREES)
447: (16)                           tri_group = Group(triangle_1, triangle_2).arrange(buff=1)
448: (16)                           self.add(tri_group)
449: (4)                """
450: (4)                def __init__(self, **kwargs) -> None:
451: (8)                    super().__init__(n=3, **kwargs)
452: (0)            class Rectangle(Polygon):
453: (4)                """A quadrilateral with two sets of parallel sides.
454: (4)                Parameters
455: (4)                ----------
456: (4)                color
457: (8)                    The color of the rectangle.
458: (4)                height
459: (8)                    The vertical height of the rectangle.
460: (4)                width
461: (8)                    The horizontal width of the rectangle.
462: (4)                grid_xstep
463: (8)                    Space between vertical grid lines.
464: (4)                grid_ystep
465: (8)                    Space between horizontal grid lines.
466: (4)                mark_paths_closed
467: (8)                    No purpose.
468: (4)                close_new_points
469: (8)                    No purpose.
470: (4)                kwargs
471: (8)                    Additional arguments to be passed to :class:`Polygon`
472: (4)                Examples
473: (4)                ----------
474: (4)                .. manim:: RectangleExample
475: (8)                    :save_last_frame:
476: (8)                    class RectangleExample(Scene):
477: (12)                       def construct(self):
478: (16)                           rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)
479: (16)                           rect2 = Rectangle(width=1.0, height=4.0)
480: (16)                           rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)
481: (16)                           rect3.grid_lines.set_stroke(width=1)
482: (16)                           rects = Group(rect1, rect2, rect3).arrange(buff=1)
483: (16)                           self.add(rects)
484: (4)                """
485: (4)                def __init__(
486: (8)                    self,
487: (8)                    color: ParsableManimColor = WHITE,
488: (8)                    height: float = 2.0,
489: (8)                    width: float = 4.0,
490: (8)                    grid_xstep: float | None = None,
491: (8)                    grid_ystep: float | None = None,
492: (8)                    mark_paths_closed: bool = True,
493: (8)                    close_new_points: bool = True,
494: (8)                    **kwargs,
495: (4)                ):
496: (8)                    super().__init__(UR, UL, DL, DR, color=color, **kwargs)
497: (8)                    self.stretch_to_fit_width(width)
498: (8)                    self.stretch_to_fit_height(height)
499: (8)                    v = self.get_vertices()
500: (8)                    self.grid_lines = VGroup()
501: (8)                    if grid_xstep or grid_ystep:
502: (12)                       from manim.mobject.geometry.line import Line
503: (12)                       v = self.get_vertices()
504: (8)                    if grid_xstep:
505: (12)                       grid_xstep = abs(grid_xstep)
506: (12)                       count = int(width / grid_xstep)
507: (12)                       grid = VGroup(
508: (16)                           *(
509: (20)                               Line(
510: (24)                                   v[1] + i * grid_xstep * RIGHT,
511: (24)                                   v[1] + i * grid_xstep * RIGHT + height * DOWN,
512: (24)                                   color=color,
513: (20)                               )
514: (20)                               for i in range(1, count)
515: (16)                           )
516: (12)                       )
517: (12)                       self.grid_lines.add(grid)
518: (8)                    if grid_ystep:
519: (12)                       grid_ystep = abs(grid_ystep)
520: (12)                       count = int(height / grid_ystep)
521: (12)                       grid = VGroup(
522: (16)                           *(
523: (20)                               Line(
524: (24)                                   v[1] + i * grid_ystep * DOWN,
525: (24)                                   v[1] + i * grid_ystep * DOWN + width * RIGHT,
526: (24)                                   color=color,
527: (20)                               )
528: (20)                               for i in range(1, count)
529: (16)                           )
530: (12)                       )
531: (12)                       self.grid_lines.add(grid)
532: (8)                    if self.grid_lines:
533: (12)                       self.add(self.grid_lines)
534: (0)            class Square(Rectangle):
535: (4)                """A rectangle with equal side lengths.
536: (4)                Parameters
537: (4)                ----------
538: (4)                side_length
539: (8)                    The length of the sides of the square.
540: (4)                kwargs
541: (8)                    Additional arguments to be passed to :class:`Rectangle`.
542: (4)                Examples
543: (4)                --------
544: (4)                .. manim:: SquareExample
545: (8)                    :save_last_frame:
546: (8)                    class SquareExample(Scene):
547: (12)                       def construct(self):
548: (16)                           square_1 = Square(side_length=2.0).shift(DOWN)
549: (16)                           square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)
550: (16)                           square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)
551: (16)                           self.add(square_1, square_2, square_3)
552: (4)                """
553: (4)                def __init__(self, side_length: float = 2.0, **kwargs) -> None:
554: (8)                    self.side_length = side_length
555: (8)                    super().__init__(height=side_length, width=side_length, **kwargs)
556: (0)            class RoundedRectangle(Rectangle):
557: (4)                """A rectangle with rounded corners.
558: (4)                Parameters
559: (4)                ----------
560: (4)                corner_radius
561: (8)                    The curvature of the corners of the rectangle.
562: (4)                kwargs
563: (8)                    Additional arguments to be passed to :class:`Rectangle`
564: (4)                Examples
565: (4)                --------
566: (4)                .. manim:: RoundedRectangleExample
567: (8)                    :save_last_frame:
568: (8)                    class RoundedRectangleExample(Scene):
569: (12)                       def construct(self):
570: (16)                           rect_1 = RoundedRectangle(corner_radius=0.5)
571: (16)                           rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)
572: (16)                           rect_group = Group(rect_1, rect_2).arrange(buff=1)
573: (16)                           self.add(rect_group)
574: (4)                """
575: (4)                def __init__(self, corner_radius: float | list[float] = 0.5, **kwargs):
576: (8)                    super().__init__(**kwargs)
577: (8)                    self.corner_radius = corner_radius
578: (8)                    self.round_corners(self.corner_radius)
579: (0)            class Cutout(VMobject, metaclass=ConvertToOpenGL):
580: (4)                """A shape with smaller cutouts.
581: (4)                Parameters
582: (4)                ----------
583: (4)                main_shape
584: (8)                    The primary shape from which cutouts are made.
585: (4)                mobjects
586: (8)                    The smaller shapes which are to be cut out of the ``main_shape``.
587: (4)                kwargs
588: (8)                    Further keyword arguments that are passed to the constructor of
589: (8)                    :class:`~.VMobject`.
590: (4)                .. warning::
591: (8)                    Technically, this class behaves similar to a symmetric difference: if
592: (8)                    parts of the ``mobjects`` are not located within the ``main_shape``,
593: (8)                    these parts will be added to the resulting :class:`~.VMobject`.
594: (4)                Examples
595: (4)                --------
596: (4)                .. manim:: CutoutExample
597: (8)                    class CutoutExample(Scene):
598: (12)                       def construct(self):
599: (16)                           s1 = Square().scale(2.5)
600: (16)                           s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)
601: (16)                           s3 = Square().shift(UP + RIGHT).scale(0.5)
602: (16)                           s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)
603: (16)                           s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)
604: (16)                           c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)
605: (16)                           self.play(Write(c), run_time=4)
606: (16)                           self.wait()
607: (4)                """
608: (4)                def __init__(self, main_shape: VMobject, *mobjects: VMobject, **kwargs) -> None:
609: (8)                    super().__init__(**kwargs)
610: (8)                    self.append_points(main_shape.points)
611: (8)                    if main_shape.get_direction() == "CW":
612: (12)                       sub_direction = "CCW"
613: (8)                    else:
614: (12)                       sub_direction = "CW"
615: (8)                    for mobject in mobjects:
616: (12)                       self.append_points(mobject.force_direction(sub_direction).points)

----------------------------------------

File 13 - .\geometry \__init__.py:

1: (0)              """Various geometric Mobjects.
2: (0)              Modules
3: (0)              =======
4: (0)              .. autosummary::
5: (4)                  :toctree: ../reference
6: (4)                  ~arc
7: (4)                  ~boolean_ops
8: (4)                  ~labeled
9: (4)                  ~line
10: (4)                 ~polygram
11: (4)                 ~shape_matchers
12: (4)                 ~tips
13: (0)             """

----------------------------------------

File 14 - .\graphing \__init__.py:

1: (0)              """Coordinate systems and function graphing related mobjects.
2: (0)              Modules
3: (0)              =======
4: (0)              .. autosummary::
5: (4)                  :toctree: ../reference
6: (4)                  ~coordinate_systems
7: (4)                  ~functions
8: (4)                  ~number_line
9: (4)                  ~probability
10: (4)                 ~scale
11: (0)             """

----------------------------------------

File 15 - .\opengl \__init__.py:

1: (0)              

----------------------------------------

File 16 - .\graphing \functions.py:

1: (0)              """Mobjects representing function graphs."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["ParametricFunction", "FunctionGraph", "ImplicitFunction"]
4: (0)              from typing import TYPE_CHECKING, Callable, Iterable, Sequence
5: (0)              import numpy as np
6: (0)              from isosurfaces import plot_isoline
7: (0)              from manim import config
8: (0)              from manim.mobject.graphing.scale import LinearBase, _ScaleBase
9: (0)              from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
10: (0)             from manim.mobject.types.vectorized_mobject import VMobject
11: (0)             if TYPE_CHECKING:
12: (4)                 from manim.typing import Point2D, Point3D
13: (0)             from manim.utils.color import YELLOW
14: (0)             class ParametricFunction(VMobject, metaclass=ConvertToOpenGL):
15: (4)                 """A parametric curve.
16: (4)                 Parameters
17: (4)                 ----------
18: (4)                 function
19: (8)                     The function to be plotted in the form of ``(lambda t: (x(t), y(t), z(t)))``
20: (4)                 t_range
21: (8)                     Determines the length that the function spans in the form of (t_min, t_max, step=0.01). By default ``[0, 1]``
22: (4)                 scaling
23: (8)                     Scaling class applied to the points of the function. Default of :class:`~.LinearBase`.
24: (4)                 use_smoothing
25: (8)                     Whether to interpolate between the points of the function after they have been created.
26: (8)                     (Will have odd behaviour with a low number of points)
27: (4)                 use_vectorized
28: (8)                     Whether to pass in the generated t value array to the function as ``[t_0, t_1, ...]``.
29: (8)                     Only use this if your function supports it. Output should be a numpy array
30: (8)                     of shape ``[[x_0, x_1, ...], [y_0, y_1, ...], [z_0, z_1, ...]]`` but ``z`` can
31: (8)                     also be 0 if the Axes is 2D
32: (4)                 discontinuities
33: (8)                     Values of t at which the function experiences discontinuity.
34: (4)                 dt
35: (8)                     The left and right tolerance for the discontinuities.
36: (4)                 Examples
37: (4)                 --------
38: (4)                 .. manim:: PlotParametricFunction
39: (8)                     :save_last_frame:
40: (8)                     class PlotParametricFunction(Scene):
41: (12)                        def func(self, t):
42: (16)                            return (np.sin(2 * t), np.sin(3 * t), 0)
43: (12)                        def construct(self):
44: (16)                            func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)
45: (16)                            self.add(func.scale(3))
46: (4)                 .. manim:: ThreeDParametricSpring
47: (8)                     :save_last_frame:
48: (8)                     class ThreeDParametricSpring(ThreeDScene):
49: (12)                        def construct(self):
50: (16)                            curve1 = ParametricFunction(
51: (20)                                lambda u: (
52: (24)                                    1.2 * np.cos(u),
53: (24)                                    1.2 * np.sin(u),
54: (24)                                    u * 0.05
55: (20)                                ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)
56: (16)                            ).set_shade_in_3d(True)
57: (16)                            axes = ThreeDAxes()
58: (16)                            self.add(axes, curve1)
59: (16)                            self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)
60: (16)                            self.wait()
61: (4)                 .. attention::
62: (8)                     If your function has discontinuities, you'll have to specify the location
63: (8)                     of the discontinuities manually. See the following example for guidance.
64: (4)                 .. manim:: DiscontinuousExample
65: (8)                     :save_last_frame:
66: (8)                     class DiscontinuousExample(Scene):
67: (12)                        def construct(self):
68: (16)                            ax1 = NumberPlane((-3, 3), (-4, 4))
69: (16)                            ax2 = NumberPlane((-3, 3), (-4, 4))
70: (16)                            VGroup(ax1, ax2).arrange()
71: (16)                            discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)
72: (16)                            incorrect = ax1.plot(discontinuous_function, color=RED)
73: (16)                            correct = ax2.plot(
74: (20)                                discontinuous_function,
75: (20)                                discontinuities=[-2, 2],  # discontinuous points
76: (20)                                dt=0.1,  # left and right tolerance of discontinuity
77: (20)                                color=GREEN,
78: (16)                            )
79: (16)                            self.add(ax1, ax2, incorrect, correct)
80: (4)                 """
81: (4)                 def __init__(
82: (8)                     self,
83: (8)                     function: Callable[[float], Point3D],
84: (8)                     t_range: Point2D | Point3D = (0, 1),
85: (8)                     scaling: _ScaleBase = LinearBase(),
86: (8)                     dt: float = 1e-8,
87: (8)                     discontinuities: Iterable[float] | None = None,
88: (8)                     use_smoothing: bool = True,
89: (8)                     use_vectorized: bool = False,
90: (8)                     **kwargs,
91: (4)                 ):
92: (8)                     self.function = function
93: (8)                     t_range = (0, 1, 0.01) if t_range is None else t_range
94: (8)                     if len(t_range) == 2:
95: (12)                        t_range = np.array([*t_range, 0.01])
96: (8)                     self.scaling = scaling
97: (8)                     self.dt = dt
98: (8)                     self.discontinuities = discontinuities
99: (8)                     self.use_smoothing = use_smoothing
100: (8)                    self.use_vectorized = use_vectorized
101: (8)                    self.t_min, self.t_max, self.t_step = t_range
102: (8)                    super().__init__(**kwargs)
103: (4)                def get_function(self):
104: (8)                    return self.function
105: (4)                def get_point_from_function(self, t):
106: (8)                    return self.function(t)
107: (4)                def generate_points(self):
108: (8)                    if self.discontinuities is not None:
109: (12)                       discontinuities = filter(
110: (16)                           lambda t: self.t_min <= t <= self.t_max,
111: (16)                           self.discontinuities,
112: (12)                       )
113: (12)                       discontinuities = np.array(list(discontinuities))
114: (12)                       boundary_times = np.array(
115: (16)                           [
116: (20)                               self.t_min,
117: (20)                               self.t_max,
118: (20)                               *(discontinuities - self.dt),
119: (20)                               *(discontinuities + self.dt),
120: (16)                           ],
121: (12)                       )
122: (12)                       boundary_times.sort()
123: (8)                    else:
124: (12)                       boundary_times = [self.t_min, self.t_max]
125: (8)                    for t1, t2 in zip(boundary_times[0::2], boundary_times[1::2]):
126: (12)                       t_range = np.array(
127: (16)                           [
128: (20)                               *self.scaling.function(np.arange(t1, t2, self.t_step)),
129: (20)                               self.scaling.function(t2),
130: (16)                           ],
131: (12)                       )
132: (12)                       if self.use_vectorized:
133: (16)                           x, y, z = self.function(t_range)
134: (16)                           if not isinstance(z, np.ndarray):
135: (20)                               z = np.zeros_like(x)
136: (16)                           points = np.stack([x, y, z], axis=1)
137: (12)                       else:
138: (16)                           points = np.array([self.function(t) for t in t_range])
139: (12)                       self.start_new_path(points[0])
140: (12)                       self.add_points_as_corners(points[1:])
141: (8)                    if self.use_smoothing:
142: (12)                       # TODO: not in line with upstream, approx_smooth does not exist
143: (12)                       self.make_smooth()
144: (8)                    return self
145: (4)                init_points = generate_points
146: (0)            class FunctionGraph(ParametricFunction):
147: (4)                """A :class:`ParametricFunction` that spans the length of the scene by default.
148: (4)                Examples
149: (4)                --------
150: (4)                .. manim:: ExampleFunctionGraph
151: (8)                    :save_last_frame:
152: (8)                    class ExampleFunctionGraph(Scene):
153: (12)                       def construct(self):
154: (16)                           cos_func = FunctionGraph(
155: (20)                               lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),
156: (20)                               color=RED,
157: (16)                           )
158: (16)                           sin_func_1 = FunctionGraph(
159: (20)                               lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
160: (20)                               color=BLUE,
161: (16)                           )
162: (16)                           sin_func_2 = FunctionGraph(
163: (20)                               lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
164: (20)                               x_range=[-4, 4],
165: (20)                               color=GREEN,
166: (16)                           ).move_to([0, 1, 0])
167: (16)                           self.add(cos_func, sin_func_1, sin_func_2)
168: (4)                """
169: (4)                def __init__(self, function, x_range=None, color=YELLOW, **kwargs):
170: (8)                    if x_range is None:
171: (12)                       x_range = np.array([-config["frame_x_radius"], config["frame_x_radius"]])
172: (8)                    self.x_range = x_range
173: (8)                    self.parametric_function = lambda t: np.array([t, function(t), 0])
174: (8)                    self.function = function
175: (8)                    super().__init__(self.parametric_function, self.x_range, color=color, **kwargs)
176: (4)                def get_function(self):
177: (8)                    return self.function
178: (4)                def get_point_from_function(self, x):
179: (8)                    return self.parametric_function(x)
180: (0)            class ImplicitFunction(VMobject, metaclass=ConvertToOpenGL):
181: (4)                def __init__(
182: (8)                    self,
183: (8)                    func: Callable[[float, float], float],
184: (8)                    x_range: Sequence[float] | None = None,
185: (8)                    y_range: Sequence[float] | None = None,
186: (8)                    min_depth: int = 5,
187: (8)                    max_quads: int = 1500,
188: (8)                    use_smoothing: bool = True,
189: (8)                    **kwargs,
190: (4)                ):
191: (8)                    """An implicit function.
192: (8)                    Parameters
193: (8)                    ----------
194: (8)                    func
195: (12)                       The implicit function in the form ``f(x, y) = 0``.
196: (8)                    x_range
197: (12)                       The x min and max of the function.
198: (8)                    y_range
199: (12)                       The y min and max of the function.
200: (8)                    min_depth
201: (12)                       The minimum depth of the function to calculate.
202: (8)                    max_quads
203: (12)                       The maximum number of quads to use.
204: (8)                    use_smoothing
205: (12)                       Whether or not to smoothen the curves.
206: (8)                    kwargs
207: (12)                       Additional parameters to pass into :class:`VMobject`
208: (8)                    .. note::
209: (12)                       A small ``min_depth`` :math:`d` means that some small details might
210: (12)                       be ignored if they don't cross an edge of one of the
211: (12)                       :math:`4^d` uniform quads.
212: (12)                       The value of ``max_quads`` strongly corresponds to the
213: (12)                       quality of the curve, but a higher number of quads
214: (12)                       may take longer to render.
215: (8)                    Examples
216: (8)                    --------
217: (8)                    .. manim:: ImplicitFunctionExample
218: (12)                       :save_last_frame:
219: (12)                       class ImplicitFunctionExample(Scene):
220: (16)                           def construct(self):
221: (20)                               graph = ImplicitFunction(
222: (24)                                   lambda x, y: x * y ** 2 - x ** 2 * y - 2,
223: (24)                                   color=YELLOW
224: (20)                               )
225: (20)                               self.add(NumberPlane(), graph)
226: (8)                    """
227: (8)                    self.function = func
228: (8)                    self.min_depth = min_depth
229: (8)                    self.max_quads = max_quads
230: (8)                    self.use_smoothing = use_smoothing
231: (8)                    self.x_range = x_range or [
232: (12)                       -config.frame_width / 2,
233: (12)                       config.frame_width / 2,
234: (8)                    ]
235: (8)                    self.y_range = y_range or [
236: (12)                       -config.frame_height / 2,
237: (12)                       config.frame_height / 2,
238: (8)                    ]
239: (8)                    super().__init__(**kwargs)
240: (4)                def generate_points(self):
241: (8)                    p_min, p_max = (
242: (12)                       np.array([self.x_range[0], self.y_range[0]]),
243: (12)                       np.array([self.x_range[1], self.y_range[1]]),
244: (8)                    )
245: (8)                    curves = plot_isoline(
246: (12)                       fn=lambda u: self.function(u[0], u[1]),
247: (12)                       pmin=p_min,
248: (12)                       pmax=p_max,
249: (12)                       min_depth=self.min_depth,
250: (12)                       max_quads=self.max_quads,
251: (8)                    )  # returns a list of lists of 2D points
252: (8)                    curves = [
253: (12)                       np.pad(curve, [(0, 0), (0, 1)]) for curve in curves if curve != []
254: (8)                    ]  # add z coord as 0
255: (8)                    for curve in curves:
256: (12)                       self.start_new_path(curve[0])
257: (12)                       self.add_points_as_corners(curve[1:])
258: (8)                    if self.use_smoothing:
259: (12)                       self.make_smooth()
260: (8)                    return self
261: (4)                init_points = generate_points

----------------------------------------

File 17 - .\opengl \dot_cloud.py:

1: (0)              from __future__ import annotations
2: (0)              __all__ = ["TrueDot", "DotCloud"]
3: (0)              import numpy as np
4: (0)              from manim.constants import ORIGIN, RIGHT, UP
5: (0)              from manim.mobject.opengl.opengl_point_cloud_mobject import OpenGLPMobject
6: (0)              from manim.utils.color import YELLOW
7: (0)              class DotCloud(OpenGLPMobject):
8: (4)                  def __init__(
9: (8)                      self, color=YELLOW, stroke_width=2.0, radius=2.0, density=10, **kwargs
10: (4)                 ):
11: (8)                     self.radius = radius
12: (8)                     self.epsilon = 1.0 / density
13: (8)                     super().__init__(
14: (12)                        stroke_width=stroke_width, density=density, color=color, **kwargs
15: (8)                     )
16: (4)                 def init_points(self):
17: (8)                     self.points = np.array(
18: (12)                        [
19: (16)                            r * (np.cos(theta) * RIGHT + np.sin(theta) * UP)
20: (16)                            for r in np.arange(self.epsilon, self.radius, self.epsilon)
21: (16)                            # Num is equal to int(stop - start)/ (step + 1) reformulated.
22: (16)                            for theta in np.linspace(
23: (20)                                0,
24: (20)                                2 * np.pi,
25: (20)                                num=int(2 * np.pi * (r + self.epsilon) / self.epsilon),
26: (16)                            )
27: (12)                        ],
28: (12)                        dtype=np.float32,
29: (8)                     )
30: (4)                 def make_3d(self, gloss=0.5, shadow=0.2):
31: (8)                     self.set_gloss(gloss)
32: (8)                     self.set_shadow(shadow)
33: (8)                     self.apply_depth_test()
34: (8)                     return self
35: (0)             class TrueDot(DotCloud):
36: (4)                 def __init__(self, center=ORIGIN, stroke_width=2.0, **kwargs):
37: (8)                     self.radius = stroke_width
38: (8)                     super().__init__(points=[center], stroke_width=stroke_width, **kwargs)

----------------------------------------

File 18 - .\geometry \boolean_ops.py:

1: (0)              """Boolean operations for two-dimensional mobjects."""
2: (0)              from __future__ import annotations
3: (0)              from typing import TYPE_CHECKING
4: (0)              import numpy as np
5: (0)              from pathops import Path as SkiaPath
6: (0)              from pathops import PathVerb, difference, intersection, union, xor
7: (0)              from manim import config
8: (0)              from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
9: (0)              from manim.mobject.types.vectorized_mobject import VMobject
10: (0)             if TYPE_CHECKING:
11: (4)                 from manim.typing import Point2D_Array, Point3D_Array
12: (0)             from ...constants import RendererType
13: (0)             __all__ = ["Union", "Intersection", "Difference", "Exclusion"]
14: (0)             class _BooleanOps(VMobject, metaclass=ConvertToOpenGL):
15: (4)                 """This class contains some helper functions which
16: (4)                 helps to convert to and from skia objects and manim
17: (4)                 objects (:class:`~.VMobject`).
18: (4)                 """
19: (4)                 def _convert_2d_to_3d_array(
20: (8)                     self,
21: (8)                     points: Point2D_Array,
22: (8)                     z_dim: float = 0.0,
23: (4)                 ) -> Point3D_Array:
24: (8)                     """Converts an iterable with coordinates in 2D to 3D by adding
25: (8)                     :attr:`z_dim` as the Z coordinate.
26: (8)                     Parameters
27: (8)                     ----------
28: (8)                     points:
29: (12)                        An iterable of points.
30: (8)                     z_dim:
31: (12)                        Default value for the Z coordinate.
32: (8)                     Returns
33: (8)                     -------
34: (8)                     Point3D_Array
35: (12)                        A list of the points converted to 3D.
36: (8)                     Example
37: (8)                     -------
38: (8)                     >>> a = _BooleanOps()
39: (8)                     >>> p = [(1, 2), (3, 4)]
40: (8)                     >>> a._convert_2d_to_3d_array(p)
41: (8)                     [array([1., 2., 0.]), array([3., 4., 0.])]
42: (8)                     """
43: (8)                     points = list(points)
44: (8)                     for i, point in enumerate(points):
45: (12)                        if len(point) == 2:
46: (16)                            points[i] = np.array(list(point) + [z_dim])
47: (8)                     return points
48: (4)                 def _convert_vmobject_to_skia_path(self, vmobject: VMobject) -> SkiaPath:
49: (8)                     """Converts a :class:`~.VMobject` to SkiaPath. This method only works for
50: (8)                     cairo renderer because it treats the points as Cubic beizer curves.
51: (8)                     Parameters
52: (8)                     ----------
53: (8)                     vmobject:
54: (12)                        The :class:`~.VMobject` to convert from.
55: (8)                     Returns
56: (8)                     -------
57: (8)                     SkiaPath
58: (12)                        The converted path.
59: (8)                     """
60: (8)                     path = SkiaPath()
61: (8)                     if not np.all(np.isfinite(vmobject.points)):
62: (12)                        points = np.zeros((1, 3))  # point invalid?
63: (8)                     else:
64: (12)                        points = vmobject.points
65: (8)                     if len(points) == 0:  # what? No points so return empty path
66: (12)                        return path
67: (8)                     # In OpenGL it's quadratic beizer curves while on Cairo it's cubic...
68: (8)                     if config.renderer == RendererType.OPENGL:
69: (12)                        subpaths = vmobject.get_subpaths_from_points(points)
70: (12)                        for subpath in subpaths:
71: (16)                            quads = vmobject.get_bezier_tuples_from_points(subpath)
72: (16)                            start = subpath[0]
73: (16)                            path.moveTo(*start[:2])
74: (16)                            for p0, p1, p2 in quads:
75: (20)                                path.quadTo(*p1[:2], *p2[:2])
76: (16)                            if vmobject.consider_points_equals(subpath[0], subpath[-1]):
77: (20)                                path.close()
78: (8)                     elif config.renderer == RendererType.CAIRO:
79: (12)                        subpaths = vmobject.gen_subpaths_from_points_2d(points)
80: (12)                        for subpath in subpaths:
81: (16)                            quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)
82: (16)                            start = subpath[0]
83: (16)                            path.moveTo(*start[:2])
84: (16)                            for p0, p1, p2, p3 in quads:
85: (20)                                path.cubicTo(*p1[:2], *p2[:2], *p3[:2])
86: (16)                            if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):
87: (20)                                path.close()
88: (8)                     return path
89: (4)                 def _convert_skia_path_to_vmobject(self, path: SkiaPath) -> VMobject:
90: (8)                     """Converts SkiaPath back to VMobject.
91: (8)                     Parameters
92: (8)                     ----------
93: (8)                     path:
94: (12)                        The SkiaPath to convert.
95: (8)                     Returns
96: (8)                     -------
97: (8)                     VMobject:
98: (12)                        The converted VMobject.
99: (8)                     """
100: (8)                    vmobject = self
101: (8)                    current_path_start = np.array([0, 0, 0])
102: (8)                    for path_verb, points in path:
103: (12)                       if path_verb == PathVerb.MOVE:
104: (16)                           parts = self._convert_2d_to_3d_array(points)
105: (16)                           for part in parts:
106: (20)                               current_path_start = part
107: (20)                               vmobject.start_new_path(part)
108: (20)                               # vmobject.move_to(*part)
109: (12)                       elif path_verb == PathVerb.CUBIC:
110: (16)                           n1, n2, n3 = self._convert_2d_to_3d_array(points)
111: (16)                           vmobject.add_cubic_bezier_curve_to(n1, n2, n3)
112: (12)                       elif path_verb == PathVerb.LINE:
113: (16)                           parts = self._convert_2d_to_3d_array(points)
114: (16)                           vmobject.add_line_to(parts[0])
115: (12)                       elif path_verb == PathVerb.CLOSE:
116: (16)                           vmobject.add_line_to(current_path_start)
117: (12)                       elif path_verb == PathVerb.QUAD:
118: (16)                           n1, n2 = self._convert_2d_to_3d_array(points)
119: (16)                           vmobject.add_quadratic_bezier_curve_to(n1, n2)
120: (12)                       else:
121: (16)                           raise Exception("Unsupported: %s" % path_verb)
122: (8)                    return vmobject
123: (0)            class Union(_BooleanOps):
124: (4)                """Union of two or more :class:`~.VMobject` s. This returns the common region of
125: (4)                the :class:`~VMobject` s.
126: (4)                Parameters
127: (4)                ----------
128: (4)                vmobjects
129: (8)                    The :class:`~.VMobject` s to find the union of.
130: (4)                Raises
131: (4)                ------
132: (4)                ValueError
133: (8)                    If less than 2 :class:`~.VMobject` s are passed.
134: (4)                Example
135: (4)                -------
136: (4)                .. manim:: UnionExample
137: (8)                    :save_last_frame:
138: (8)                    class UnionExample(Scene):
139: (12)                       def construct(self):
140: (16)                           sq = Square(color=RED, fill_opacity=1)
141: (16)                           sq.move_to([-2, 0, 0])
142: (16)                           cr = Circle(color=BLUE, fill_opacity=1)
143: (16)                           cr.move_to([-1.3, 0.7, 0])
144: (16)                           un = Union(sq, cr, color=GREEN, fill_opacity=1)
145: (16)                           un.move_to([1.5, 0.3, 0])
146: (16)                           self.add(sq, cr, un)
147: (4)                """
148: (4)                def __init__(self, *vmobjects: VMobject, **kwargs) -> None:
149: (8)                    if len(vmobjects) < 2:
150: (12)                       raise ValueError("At least 2 mobjects needed for Union.")
151: (8)                    super().__init__(**kwargs)
152: (8)                    paths = []
153: (8)                    for vmobject in vmobjects:
154: (12)                       paths.append(self._convert_vmobject_to_skia_path(vmobject))
155: (8)                    outpen = SkiaPath()
156: (8)                    union(paths, outpen.getPen())
157: (8)                    self._convert_skia_path_to_vmobject(outpen)
158: (0)            class Difference(_BooleanOps):
159: (4)                """Subtracts one :class:`~.VMobject` from another one.
160: (4)                Parameters
161: (4)                ----------
162: (4)                subject
163: (8)                    The 1st :class:`~.VMobject`.
164: (4)                clip
165: (8)                    The 2nd :class:`~.VMobject`
166: (4)                Example
167: (4)                -------
168: (4)                .. manim:: DifferenceExample
169: (8)                    :save_last_frame:
170: (8)                    class DifferenceExample(Scene):
171: (12)                       def construct(self):
172: (16)                           sq = Square(color=RED, fill_opacity=1)
173: (16)                           sq.move_to([-2, 0, 0])
174: (16)                           cr = Circle(color=BLUE, fill_opacity=1)
175: (16)                           cr.move_to([-1.3, 0.7, 0])
176: (16)                           un = Difference(sq, cr, color=GREEN, fill_opacity=1)
177: (16)                           un.move_to([1.5, 0, 0])
178: (16)                           self.add(sq, cr, un)
179: (4)                """
180: (4)                def __init__(self, subject: VMobject, clip: VMobject, **kwargs) -> None:
181: (8)                    super().__init__(**kwargs)
182: (8)                    outpen = SkiaPath()
183: (8)                    difference(
184: (12)                       [self._convert_vmobject_to_skia_path(subject)],
185: (12)                       [self._convert_vmobject_to_skia_path(clip)],
186: (12)                       outpen.getPen(),
187: (8)                    )
188: (8)                    self._convert_skia_path_to_vmobject(outpen)
189: (0)            class Intersection(_BooleanOps):
190: (4)                """Find the intersection of two :class:`~.VMobject` s.
191: (4)                This keeps the parts covered by both :class:`~.VMobject` s.
192: (4)                Parameters
193: (4)                ----------
194: (4)                vmobjects
195: (8)                    The :class:`~.VMobject` to find the intersection.
196: (4)                Raises
197: (4)                ------
198: (4)                ValueError
199: (8)                    If less the 2 :class:`~.VMobject` are passed.
200: (4)                Example
201: (4)                -------
202: (4)                .. manim:: IntersectionExample
203: (8)                    :save_last_frame:
204: (8)                    class IntersectionExample(Scene):
205: (12)                       def construct(self):
206: (16)                           sq = Square(color=RED, fill_opacity=1)
207: (16)                           sq.move_to([-2, 0, 0])
208: (16)                           cr = Circle(color=BLUE, fill_opacity=1)
209: (16)                           cr.move_to([-1.3, 0.7, 0])
210: (16)                           un = Intersection(sq, cr, color=GREEN, fill_opacity=1)
211: (16)                           un.move_to([1.5, 0, 0])
212: (16)                           self.add(sq, cr, un)
213: (4)                """
214: (4)                def __init__(self, *vmobjects: VMobject, **kwargs) -> None:
215: (8)                    if len(vmobjects) < 2:
216: (12)                       raise ValueError("At least 2 mobjects needed for Intersection.")
217: (8)                    super().__init__(**kwargs)
218: (8)                    outpen = SkiaPath()
219: (8)                    intersection(
220: (12)                       [self._convert_vmobject_to_skia_path(vmobjects[0])],
221: (12)                       [self._convert_vmobject_to_skia_path(vmobjects[1])],
222: (12)                       outpen.getPen(),
223: (8)                    )
224: (8)                    new_outpen = outpen
225: (8)                    for _i in range(2, len(vmobjects)):
226: (12)                       new_outpen = SkiaPath()
227: (12)                       intersection(
228: (16)                           [outpen],
229: (16)                           [self._convert_vmobject_to_skia_path(vmobjects[_i])],
230: (16)                           new_outpen.getPen(),
231: (12)                       )
232: (12)                       outpen = new_outpen
233: (8)                    self._convert_skia_path_to_vmobject(outpen)
234: (0)            class Exclusion(_BooleanOps):
235: (4)                """Find the XOR between two :class:`~.VMobject`.
236: (4)                This creates a new :class:`~.VMobject` consisting of the region
237: (4)                covered by exactly one of them.
238: (4)                Parameters
239: (4)                ----------
240: (4)                subject
241: (8)                    The 1st :class:`~.VMobject`.
242: (4)                clip
243: (8)                    The 2nd :class:`~.VMobject`
244: (4)                Example
245: (4)                -------
246: (4)                .. manim:: IntersectionExample
247: (8)                    :save_last_frame:
248: (8)                    class IntersectionExample(Scene):
249: (12)                       def construct(self):
250: (16)                           sq = Square(color=RED, fill_opacity=1)
251: (16)                           sq.move_to([-2, 0, 0])
252: (16)                           cr = Circle(color=BLUE, fill_opacity=1)
253: (16)                           cr.move_to([-1.3, 0.7, 0])
254: (16)                           un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)
255: (16)                           un.move_to([1.5, 0.4, 0])
256: (16)                           self.add(sq, cr, un)
257: (4)                """
258: (4)                def __init__(self, subject: VMobject, clip: VMobject, **kwargs) -> None:
259: (8)                    super().__init__(**kwargs)
260: (8)                    outpen = SkiaPath()
261: (8)                    xor(
262: (12)                       [self._convert_vmobject_to_skia_path(subject)],
263: (12)                       [self._convert_vmobject_to_skia_path(clip)],
264: (12)                       outpen.getPen(),
265: (8)                    )
266: (8)                    self._convert_skia_path_to_vmobject(outpen)

----------------------------------------

File 19 - .\graphing \number_line.py:

1: (0)              """Mobject representing a number line."""
2: (0)              from __future__ import annotations
3: (0)              from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject
4: (0)              __all__ = ["NumberLine", "UnitInterval"]
5: (0)              from typing import TYPE_CHECKING, Callable, Iterable, Sequence
6: (0)              if TYPE_CHECKING:
7: (4)                  from manim.mobject.geometry.tips import ArrowTip
8: (0)              import numpy as np
9: (0)              from manim import config
10: (0)             from manim.constants import *
11: (0)             from manim.mobject.geometry.line import Line
12: (0)             from manim.mobject.graphing.scale import LinearBase, _ScaleBase
13: (0)             from manim.mobject.text.numbers import DecimalNumber
14: (0)             from manim.mobject.text.tex_mobject import MathTex, Tex
15: (0)             from manim.mobject.types.vectorized_mobject import VGroup, VMobject
16: (0)             from manim.utils.bezier import interpolate
17: (0)             from manim.utils.config_ops import merge_dicts_recursively
18: (0)             from manim.utils.space_ops import normalize
19: (0)             class NumberLine(Line):
20: (4)                 """Creates a number line with tick marks.
21: (4)                 Parameters
22: (4)                 ----------
23: (4)                 x_range
24: (8)                     The ``[x_min, x_max, x_step]`` values to create the line.
25: (4)                 length
26: (8)                     The length of the number line.
27: (4)                 unit_size
28: (8)                     The distance between each tick of the line. Overwritten by :attr:`length`, if specified.
29: (4)                 include_ticks
30: (8)                     Whether to include ticks on the number line.
31: (4)                 tick_size
32: (8)                     The length of each tick mark.
33: (4)                 numbers_with_elongated_ticks
34: (8)                     An iterable of specific values with elongated ticks.
35: (4)                 longer_tick_multiple
36: (8)                     Influences how many times larger elongated ticks are than regular ticks (2 = 2x).
37: (4)                 rotation
38: (8)                     The angle (in radians) at which the line is rotated.
39: (4)                 stroke_width
40: (8)                     The thickness of the line.
41: (4)                 include_tip
42: (8)                     Whether to add a tip to the end of the line.
43: (4)                 tip_width
44: (8)                     The width of the tip.
45: (4)                 tip_height
46: (8)                     The height of the tip.
47: (4)                 tip_shape
48: (8)                     The mobject class used to construct the tip, or ``None`` (the
49: (8)                     default) for the default arrow tip. Passed classes have to inherit
50: (8)                     from :class:`.ArrowTip`.
51: (4)                 include_numbers
52: (8)                     Whether to add numbers to the tick marks. The number of decimal places is determined
53: (8)                     by the step size, this default can be overridden by ``decimal_number_config``.
54: (4)                 scaling
55: (8)                     The way the ``x_range`` is value is scaled, i.e. :class:`~.LogBase` for a logarithmic numberline. Defaults to :class:`~.LinearBase`.
56: (4)                 font_size
57: (8)                     The size of the label mobjects. Defaults to 36.
58: (4)                 label_direction
59: (8)                     The specific position to which label mobjects are added on the line.
60: (4)                 label_constructor
61: (8)                     Determines the mobject class that will be used to construct the labels of the number line.
62: (4)                 line_to_number_buff
63: (8)                     The distance between the line and the label mobject.
64: (4)                 decimal_number_config
65: (8)                     Arguments that can be passed to :class:`~.numbers.DecimalNumber` to influence number mobjects.
66: (4)                 numbers_to_exclude
67: (8)                     An explicit iterable of numbers to not be added to the number line.
68: (4)                 numbers_to_include
69: (8)                     An explicit iterable of numbers to add to the number line
70: (4)                 kwargs
71: (8)                     Additional arguments to be passed to :class:`~.Line`.
72: (4)                 .. note::
73: (8)                     Number ranges that include both negative and positive values will be generated
74: (8)                     from the 0 point, and may not include a tick at the min / max
75: (8)                     values as the tick locations are dependent on the step size.
76: (4)                 Examples
77: (4)                 --------
78: (4)                 .. manim:: NumberLineExample
79: (8)                     :save_last_frame:
80: (8)                     class NumberLineExample(Scene):
81: (12)                        def construct(self):
82: (16)                            l0 = NumberLine(
83: (20)                                x_range=[-10, 10, 2],
84: (20)                                length=10,
85: (20)                                color=BLUE,
86: (20)                                include_numbers=True,
87: (20)                                label_direction=UP,
88: (16)                            )
89: (16)                            l1 = NumberLine(
90: (20)                                x_range=[-10, 10, 2],
91: (20)                                unit_size=0.5,
92: (20)                                numbers_with_elongated_ticks=[-2, 4],
93: (20)                                include_numbers=True,
94: (20)                                font_size=24,
95: (16)                            )
96: (16)                            num6 = l1.numbers[8]
97: (16)                            num6.set_color(RED)
98: (16)                            l2 = NumberLine(
99: (20)                                x_range=[-2.5, 2.5 + 0.5, 0.5],
100: (20)                               length=12,
101: (20)                               decimal_number_config={"num_decimal_places": 2},
102: (20)                               include_numbers=True,
103: (16)                           )
104: (16)                           l3 = NumberLine(
105: (20)                               x_range=[-5, 5 + 1, 1],
106: (20)                               length=6,
107: (20)                               include_tip=True,
108: (20)                               include_numbers=True,
109: (20)                               rotation=10 * DEGREES,
110: (16)                           )
111: (16)                           line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)
112: (16)                           self.add(line_group)
113: (4)                """
114: (4)                def __init__(
115: (8)                    self,
116: (8)                    x_range: Sequence[float] | None = None,  # must be first
117: (8)                    length: float | None = None,
118: (8)                    unit_size: float = 1,
119: (8)                    # ticks
120: (8)                    include_ticks: bool = True,
121: (8)                    tick_size: float = 0.1,
122: (8)                    numbers_with_elongated_ticks: Iterable[float] | None = None,
123: (8)                    longer_tick_multiple: int = 2,
124: (8)                    exclude_origin_tick: bool = False,
125: (8)                    # visuals
126: (8)                    rotation: float = 0,
127: (8)                    stroke_width: float = 2.0,
128: (8)                    # tip
129: (8)                    include_tip: bool = False,
130: (8)                    tip_width: float = DEFAULT_ARROW_TIP_LENGTH,
131: (8)                    tip_height: float = DEFAULT_ARROW_TIP_LENGTH,
132: (8)                    tip_shape: type[ArrowTip] | None = None,
133: (8)                    # numbers/labels
134: (8)                    include_numbers: bool = False,
135: (8)                    font_size: float = 36,
136: (8)                    label_direction: Sequence[float] = DOWN,
137: (8)                    label_constructor: VMobject = MathTex,
138: (8)                    scaling: _ScaleBase = LinearBase(),
139: (8)                    line_to_number_buff: float = MED_SMALL_BUFF,
140: (8)                    decimal_number_config: dict | None = None,
141: (8)                    numbers_to_exclude: Iterable[float] | None = None,
142: (8)                    numbers_to_include: Iterable[float] | None = None,
143: (8)                    **kwargs,
144: (4)                ):
145: (8)                    # avoid mutable arguments in defaults
146: (8)                    if numbers_to_exclude is None:
147: (12)                       numbers_to_exclude = []
148: (8)                    if numbers_with_elongated_ticks is None:
149: (12)                       numbers_with_elongated_ticks = []
150: (8)                    if x_range is None:
151: (12)                       x_range = [
152: (16)                           round(-config["frame_x_radius"]),
153: (16)                           round(config["frame_x_radius"]),
154: (16)                           1,
155: (12)                       ]
156: (8)                    elif len(x_range) == 2:
157: (12)                       # adds x_step if not specified. not sure how to feel about this. a user can't know default without peeking at source code
158: (12)                       x_range = [*x_range, 1]
159: (8)                    if decimal_number_config is None:
160: (12)                       decimal_number_config = {
161: (16)                           "num_decimal_places": self._decimal_places_from_step(x_range[2]),
162: (12)                       }
163: (8)                    # turn into a NumPy array to scale by just applying the function
164: (8)                    self.x_range = np.array(x_range, dtype=float)
165: (8)                    self.x_min, self.x_max, self.x_step = scaling.function(self.x_range)
166: (8)                    self.length = length
167: (8)                    self.unit_size = unit_size
168: (8)                    # ticks
169: (8)                    self.include_ticks = include_ticks
170: (8)                    self.tick_size = tick_size
171: (8)                    self.numbers_with_elongated_ticks = numbers_with_elongated_ticks
172: (8)                    self.longer_tick_multiple = longer_tick_multiple
173: (8)                    self.exclude_origin_tick = exclude_origin_tick
174: (8)                    # visuals
175: (8)                    self.rotation = rotation
176: (8)                    # tip
177: (8)                    self.include_tip = include_tip
178: (8)                    self.tip_width = tip_width
179: (8)                    self.tip_height = tip_height
180: (8)                    # numbers
181: (8)                    self.font_size = font_size
182: (8)                    self.include_numbers = include_numbers
183: (8)                    self.label_direction = label_direction
184: (8)                    self.label_constructor = label_constructor
185: (8)                    self.line_to_number_buff = line_to_number_buff
186: (8)                    self.decimal_number_config = decimal_number_config
187: (8)                    self.numbers_to_exclude = numbers_to_exclude
188: (8)                    self.numbers_to_include = numbers_to_include
189: (8)                    self.scaling = scaling
190: (8)                    super().__init__(
191: (12)                       self.x_range[0] * RIGHT,
192: (12)                       self.x_range[1] * RIGHT,
193: (12)                       stroke_width=stroke_width,
194: (12)                       **kwargs,
195: (8)                    )
196: (8)                    if self.length:
197: (12)                       self.set_length(self.length)
198: (12)                       self.unit_size = self.get_unit_size()
199: (8)                    else:
200: (12)                       self.scale(self.unit_size)
201: (8)                    self.center()
202: (8)                    if self.include_tip:
203: (12)                       self.add_tip(
204: (16)                           tip_length=self.tip_height,
205: (16)                           tip_width=self.tip_width,
206: (16)                           tip_shape=tip_shape,
207: (12)                       )
208: (12)                       self.tip.set_stroke(self.stroke_color, self.stroke_width)
209: (8)                    if self.include_ticks:
210: (12)                       self.add_ticks()
211: (8)                    self.rotate(self.rotation)
212: (8)                    if self.include_numbers or self.numbers_to_include is not None:
213: (12)                       if self.scaling.custom_labels:
214: (16)                           tick_range = self.get_tick_range()
215: (16)                           self.add_labels(
216: (20)                               dict(
217: (24)                                   zip(
218: (28)                                       tick_range,
219: (28)                                       self.scaling.get_custom_labels(
220: (32)                                           tick_range,
221: (32)                                           unit_decimal_places=decimal_number_config[
222: (36)                                               "num_decimal_places"
223: (32)                                           ],
224: (28)                                       ),
225: (24)                                   )
226: (20)                               ),
227: (16)                           )
228: (12)                       else:
229: (16)                           self.add_numbers(
230: (20)                               x_values=self.numbers_to_include,
231: (20)                               excluding=self.numbers_to_exclude,
232: (20)                               font_size=self.font_size,
233: (16)                           )
234: (4)                def rotate_about_zero(self, angle: float, axis: Sequence[float] = OUT, **kwargs):
235: (8)                    return self.rotate_about_number(0, angle, axis, **kwargs)
236: (4)                def rotate_about_number(
237: (8)                    self, number: float, angle: float, axis: Sequence[float] = OUT, **kwargs
238: (4)                ):
239: (8)                    return self.rotate(angle, axis, about_point=self.n2p(number), **kwargs)
240: (4)                def add_ticks(self):
241: (8)                    """Adds ticks to the number line. Ticks can be accessed after creation
242: (8)                    via ``self.ticks``."""
243: (8)                    ticks = VGroup()
244: (8)                    elongated_tick_size = self.tick_size * self.longer_tick_multiple
245: (8)                    elongated_tick_offsets = self.numbers_with_elongated_ticks - self.x_min
246: (8)                    for x in self.get_tick_range():
247: (12)                       size = self.tick_size
248: (12)                       if np.any(np.isclose(x - self.x_min, elongated_tick_offsets)):
249: (16)                           size = elongated_tick_size
250: (12)                       ticks.add(self.get_tick(x, size))
251: (8)                    self.add(ticks)
252: (8)                    self.ticks = ticks
253: (4)                def get_tick(self, x: float, size: float | None = None) -> Line:
254: (8)                    """Generates a tick and positions it along the number line.
255: (8)                    Parameters
256: (8)                    ----------
257: (8)                    x
258: (12)                       The position of the tick.
259: (8)                    size
260: (12)                       The factor by which the tick is scaled.
261: (8)                    Returns
262: (8)                    -------
263: (8)                    :class:`~.Line`
264: (12)                       A positioned tick.
265: (8)                    """
266: (8)                    if size is None:
267: (12)                       size = self.tick_size
268: (8)                    result = Line(size * DOWN, size * UP)
269: (8)                    result.rotate(self.get_angle())
270: (8)                    result.move_to(self.number_to_point(x))
271: (8)                    result.match_style(self)
272: (8)                    return result
273: (4)                def get_tick_marks(self) -> VGroup:
274: (8)                    return self.ticks
275: (4)                def get_tick_range(self) -> np.ndarray:
276: (8)                    """Generates the range of values on which labels are plotted based on the
277: (8)                    ``x_range`` attribute of the number line.
278: (8)                    Returns
279: (8)                    -------
280: (8)                    np.ndarray
281: (12)                       A numpy array of floats represnting values along the number line.
282: (8)                    """
283: (8)                    x_min, x_max, x_step = self.x_range
284: (8)                    if not self.include_tip:
285: (12)                       x_max += 1e-6
286: (8)                    # Handle cases where min and max are both positive or both negative
287: (8)                    if x_min < x_max < 0 or x_max > x_min > 0:
288: (12)                       tick_range = np.arange(x_min, x_max, x_step)
289: (8)                    else:
290: (12)                       start_point = 0
291: (12)                       if self.exclude_origin_tick:
292: (16)                           start_point += x_step
293: (12)                       x_min_segment = np.arange(start_point, np.abs(x_min) + 1e-6, x_step) * -1
294: (12)                       x_max_segment = np.arange(start_point, x_max, x_step)
295: (12)                       tick_range = np.unique(np.concatenate((x_min_segment, x_max_segment)))
296: (8)                    return self.scaling.function(tick_range)
297: (4)                def number_to_point(self, number: float | np.ndarray) -> np.ndarray:
298: (8)                    """Accepts a value along the number line and returns a point with
299: (8)                    respect to the scene.
300: (8)                    Parameters
301: (8)                    ----------
302: (8)                    number
303: (12)                       The value to be transformed into a coordinate. Or a list of values.
304: (8)                    Returns
305: (8)                    -------
306: (8)                    np.ndarray
307: (12)                       A point with respect to the scene's coordinate system. Or a list of points.
308: (8)                    Examples
309: (8)                    --------
310: (12)                       >>> from manim import NumberLine
311: (12)                       >>> number_line = NumberLine()
312: (12)                       >>> number_line.number_to_point(0)
313: (12)                       array([0., 0., 0.])
314: (12)                       >>> number_line.number_to_point(1)
315: (12)                       array([1., 0., 0.])
316: (12)                       >>> number_line.number_to_point([1,2,3])
317: (12)                       array([[1., 0., 0.],
318: (19)                              [2., 0., 0.],
319: (19)                              [3., 0., 0.]])
320: (8)                    """
321: (8)                    number = np.asarray(number)
322: (8)                    scalar = number.ndim == 0
323: (8)                    number = self.scaling.inverse_function(number)
324: (8)                    alphas = (number - self.x_range[0]) / (self.x_range[1] - self.x_range[0])
325: (8)                    alphas = float(alphas) if scalar else np.vstack(alphas)
326: (8)                    val = interpolate(self.get_start(), self.get_end(), alphas)
327: (8)                    return val
328: (4)                def point_to_number(self, point: Sequence[float]) -> float:
329: (8)                    """Accepts a point with respect to the scene and returns
330: (8)                    a float along the number line.
331: (8)                    Parameters
332: (8)                    ----------
333: (8)                    point
334: (12)                       A sequence of values consisting of ``(x_coord, y_coord, z_coord)``.
335: (8)                    Returns
336: (8)                    -------
337: (8)                    float
338: (12)                       A float representing a value along the number line.
339: (8)                    Examples
340: (8)                    --------
341: (12)                       >>> from manim import NumberLine
342: (12)                       >>> number_line = NumberLine()
343: (12)                       >>> number_line.point_to_number((0,0,0))
344: (12)                       0.0
345: (12)                       >>> number_line.point_to_number((1,0,0))
346: (12)                       1.0
347: (12)                       >>> number_line.point_to_number([[0.5,0,0],[1,0,0],[1.5,0,0]])
348: (12)                       array([0.5, 1. , 1.5])
349: (8)                    """
350: (8)                    point = np.asarray(point)
351: (8)                    start, end = self.get_start_and_end()
352: (8)                    unit_vect = normalize(end - start)
353: (8)                    proportion = np.dot(point - start, unit_vect) / np.dot(end - start, unit_vect)
354: (8)                    return interpolate(self.x_min, self.x_max, proportion)
355: (4)                def n2p(self, number: float | np.ndarray) -> np.ndarray:
356: (8)                    """Abbreviation for :meth:`~.NumberLine.number_to_point`."""
357: (8)                    return self.number_to_point(number)
358: (4)                def p2n(self, point: Sequence[float]) -> float:
359: (8)                    """Abbreviation for :meth:`~.NumberLine.point_to_number`."""
360: (8)                    return self.point_to_number(point)
361: (4)                def get_unit_size(self) -> float:
362: (8)                    return self.get_length() / (self.x_range[1] - self.x_range[0])
363: (4)                def get_unit_vector(self) -> np.ndarray:
364: (8)                    return super().get_unit_vector() * self.unit_size
365: (4)                def get_number_mobject(
366: (8)                    self,
367: (8)                    x: float,
368: (8)                    direction: Sequence[float] | None = None,
369: (8)                    buff: float | None = None,
370: (8)                    font_size: float | None = None,
371: (8)                    label_constructor: VMobject | None = None,
372: (8)                    **number_config,
373: (4)                ) -> VMobject:
374: (8)                    """Generates a positioned :class:`~.DecimalNumber` mobject
375: (8)                    generated according to ``label_constructor``.
376: (8)                    Parameters
377: (8)                    ----------
378: (8)                    x
379: (12)                       The x-value at which the mobject should be positioned.
380: (8)                    direction
381: (12)                       Determines the direction at which the label is positioned next to the line.
382: (8)                    buff
383: (12)                       The distance of the label from the line.
384: (8)                    font_size
385: (12)                       The font size of the label mobject.
386: (8)                    label_constructor
387: (12)                       The :class:`~.VMobject` class that will be used to construct the label.
388: (12)                       Defaults to the ``label_constructor`` attribute of the number line
389: (12)                       if not specified.
390: (8)                    Returns
391: (8)                    -------
392: (8)                    :class:`~.DecimalNumber`
393: (12)                       The positioned mobject.
394: (8)                    """
395: (8)                    number_config = merge_dicts_recursively(
396: (12)                       self.decimal_number_config,
397: (12)                       number_config,
398: (8)                    )
399: (8)                    if direction is None:
400: (12)                       direction = self.label_direction
401: (8)                    if buff is None:
402: (12)                       buff = self.line_to_number_buff
403: (8)                    if font_size is None:
404: (12)                       font_size = self.font_size
405: (8)                    if label_constructor is None:
406: (12)                       label_constructor = self.label_constructor
407: (8)                    num_mob = DecimalNumber(
408: (12)                       x, font_size=font_size, mob_class=label_constructor, **number_config
409: (8)                    )
410: (8)                    num_mob.next_to(self.number_to_point(x), direction=direction, buff=buff)
411: (8)                    if x < 0 and self.label_direction[0] == 0:
412: (12)                       # Align without the minus sign
413: (12)                       num_mob.shift(num_mob[0].width * LEFT / 2)
414: (8)                    return num_mob
415: (4)                def get_number_mobjects(self, *numbers, **kwargs) -> VGroup:
416: (8)                    if len(numbers) == 0:
417: (12)                       numbers = self.default_numbers_to_display()
418: (8)                    return VGroup([self.get_number_mobject(number, **kwargs) for number in numbers])
419: (4)                def get_labels(self) -> VGroup:
420: (8)                    return self.get_number_mobjects()
421: (4)                def add_numbers(
422: (8)                    self,
423: (8)                    x_values: Iterable[float] | None = None,
424: (8)                    excluding: Iterable[float] | None = None,
425: (8)                    font_size: float | None = None,
426: (8)                    label_constructor: VMobject | None = None,
427: (8)                    **kwargs,
428: (4)                ):
429: (8)                    """Adds :class:`~.DecimalNumber` mobjects representing their position
430: (8)                    at each tick of the number line. The numbers can be accessed after creation
431: (8)                    via ``self.numbers``.
432: (8)                    Parameters
433: (8)                    ----------
434: (8)                    x_values
435: (12)                       An iterable of the values used to position and create the labels.
436: (12)                       Defaults to the output produced by :meth:`~.NumberLine.get_tick_range`
437: (8)                    excluding
438: (12)                       A list of values to exclude from :attr:`x_values`.
439: (8)                    font_size
440: (12)                       The font size of the labels. Defaults to the ``font_size`` attribute
441: (12)                       of the number line.
442: (8)                    label_constructor
443: (12)                       The :class:`~.VMobject` class that will be used to construct the label.
444: (12)                       Defaults to the ``label_constructor`` attribute of the number line
445: (12)                       if not specified.
446: (8)                    """
447: (8)                    if x_values is None:
448: (12)                       x_values = self.get_tick_range()
449: (8)                    if excluding is None:
450: (12)                       excluding = self.numbers_to_exclude
451: (8)                    if font_size is None:
452: (12)                       font_size = self.font_size
453: (8)                    if label_constructor is None:
454: (12)                       label_constructor = self.label_constructor
455: (8)                    numbers = VGroup()
456: (8)                    for x in x_values:
457: (12)                       if x in excluding:
458: (16)                           continue
459: (12)                       numbers.add(
460: (16)                           self.get_number_mobject(
461: (20)                               x,
462: (20)                               font_size=font_size,
463: (20)                               label_constructor=label_constructor,
464: (20)                               **kwargs,
465: (16)                           )
466: (12)                       )
467: (8)                    self.add(numbers)
468: (8)                    self.numbers = numbers
469: (8)                    return self
470: (4)                def add_labels(
471: (8)                    self,
472: (8)                    dict_values: dict[float, str | float | VMobject],
473: (8)                    direction: Sequence[float] = None,
474: (8)                    buff: float | None = None,
475: (8)                    font_size: float | None = None,
476: (8)                    label_constructor: VMobject | None = None,
477: (4)                ):
478: (8)                    """Adds specifically positioned labels to the :class:`~.NumberLine` using a ``dict``.
479: (8)                    The labels can be accessed after creation via ``self.labels``.
480: (8)                    Parameters
481: (8)                    ----------
482: (8)                    dict_values
483: (12)                       A dictionary consisting of the position along the number line and the mobject to be added:
484: (12)                       ``{1: Tex("Monday"), 3: Tex("Tuesday")}``. :attr:`label_constructor` will be used
485: (12)                       to construct the labels if the value is not a mobject (``str`` or ``float``).
486: (8)                    direction
487: (12)                       Determines the direction at which the label is positioned next to the line.
488: (8)                    buff
489: (12)                       The distance of the label from the line.
490: (8)                    font_size
491: (12)                       The font size of the mobject to be positioned.
492: (8)                    label_constructor
493: (12)                       The :class:`~.VMobject` class that will be used to construct the label.
494: (12)                       Defaults to the ``label_constructor`` attribute of the number line
495: (12)                       if not specified.
496: (8)                    Raises
497: (8)                    ------
498: (8)                    AttributeError
499: (12)                       If the label does not have a ``font_size`` attribute, an ``AttributeError`` is raised.
500: (8)                    """
501: (8)                    direction = self.label_direction if direction is None else direction
502: (8)                    buff = self.line_to_number_buff if buff is None else buff
503: (8)                    font_size = self.font_size if font_size is None else font_size
504: (8)                    if label_constructor is None:
505: (12)                       label_constructor = self.label_constructor
506: (8)                    labels = VGroup()
507: (8)                    for x, label in dict_values.items():
508: (12)                       # TODO: remove this check and ability to call
509: (12)                       # this method via CoordinateSystem.add_coordinates()
510: (12)                       # must be explicitly called
511: (12)                       if isinstance(label, str) and label_constructor is MathTex:
512: (16)                           label = Tex(label)
513: (12)                       else:
514: (16)                           label = self._create_label_tex(label, label_constructor)
515: (12)                       if hasattr(label, "font_size"):
516: (16)                           label.font_size = font_size
517: (12)                       else:
518: (16)                           raise AttributeError(f"{label} is not compatible with add_labels.")
519: (12)                       label.next_to(self.number_to_point(x), direction=direction, buff=buff)
520: (12)                       labels.add(label)
521: (8)                    self.labels = labels
522: (8)                    self.add(labels)
523: (8)                    return self
524: (4)                def _create_label_tex(
525: (8)                    self,
526: (8)                    label_tex: str | float | VMobject,
527: (8)                    label_constructor: Callable | None = None,
528: (8)                    **kwargs,
529: (4)                ) -> VMobject:
530: (8)                    """Checks if the label is a :class:`~.VMobject`, otherwise, creates a
531: (8)                    label by passing ``label_tex`` to ``label_constructor``.
532: (8)                    Parameters
533: (8)                    ----------
534: (8)                    label_tex
535: (12)                       The label for which a mobject should be created. If the label already
536: (12)                       is a mobject, no new mobject is created.
537: (8)                    label_constructor
538: (12)                       Optional. A class or function returning a mobject when
539: (12)                       passing ``label_tex`` as an argument. If ``None`` is passed
540: (12)                       (the default), the label constructor from the :attr:`.label_constructor`
541: (12)                       attribute is used.
542: (8)                    Returns
543: (8)                    -------
544: (8)                    :class:`~.VMobject`
545: (12)                       The label.
546: (8)                    """
547: (8)                    if label_constructor is None:
548: (12)                       label_constructor = self.label_constructor
549: (8)                    if isinstance(label_tex, (VMobject, OpenGLVMobject)):
550: (12)                       return label_tex
551: (8)                    else:
552: (12)                       return label_constructor(label_tex, **kwargs)
553: (4)                @staticmethod
554: (4)                def _decimal_places_from_step(step) -> int:
555: (8)                    step = str(step)
556: (8)                    if "." not in step:
557: (12)                       return 0
558: (8)                    return len(step.split(".")[-1])
559: (0)            class UnitInterval(NumberLine):
560: (4)                def __init__(
561: (8)                    self,
562: (8)                    unit_size=10,
563: (8)                    numbers_with_elongated_ticks=None,
564: (8)                    decimal_number_config=None,
565: (8)                    **kwargs,
566: (4)                ):
567: (8)                    numbers_with_elongated_ticks = (
568: (12)                       [0, 1]
569: (12)                       if numbers_with_elongated_ticks is None
570: (12)                       else numbers_with_elongated_ticks
571: (8)                    )
572: (8)                    decimal_number_config = (
573: (12)                       {
574: (16)                           "num_decimal_places": 1,
575: (12)                       }
576: (12)                       if decimal_number_config is None
577: (12)                       else decimal_number_config
578: (8)                    )
579: (8)                    super().__init__(
580: (12)                       x_range=(0, 1, 0.1),
581: (12)                       unit_size=unit_size,
582: (12)                       numbers_with_elongated_ticks=numbers_with_elongated_ticks,
583: (12)                       decimal_number_config=decimal_number_config,
584: (12)                       **kwargs,
585: (8)                    )

----------------------------------------

File 20 - .\graphing \probability.py:

1: (0)              """Mobjects representing objects from probability theory and statistics."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["SampleSpace", "BarChart"]
4: (0)              from typing import Iterable, MutableSequence, Sequence
5: (0)              import numpy as np
6: (0)              from manim import config, logger
7: (0)              from manim.constants import *
8: (0)              from manim.mobject.geometry.polygram import Rectangle
9: (0)              from manim.mobject.graphing.coordinate_systems import Axes
10: (0)             from manim.mobject.mobject import Mobject
11: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLMobject
12: (0)             from manim.mobject.svg.brace import Brace
13: (0)             from manim.mobject.text.tex_mobject import MathTex, Tex
14: (0)             from manim.mobject.types.vectorized_mobject import VGroup, VMobject
15: (0)             from manim.utils.color import (
16: (4)                 BLUE_E,
17: (4)                 DARK_GREY,
18: (4)                 GREEN_E,
19: (4)                 LIGHT_GREY,
20: (4)                 MAROON_B,
21: (4)                 YELLOW,
22: (4)                 ParsableManimColor,
23: (4)                 color_gradient,
24: (0)             )
25: (0)             from manim.utils.iterables import tuplify
26: (0)             EPSILON = 0.0001
27: (0)             class SampleSpace(Rectangle):
28: (4)                 """A mobject representing a twodimensional rectangular
29: (4)                 sampling space.
30: (4)                 Examples
31: (4)                 --------
32: (4)                 .. manim:: ExampleSampleSpace
33: (8)                     :save_last_frame:
34: (8)                     class ExampleSampleSpace(Scene):
35: (12)                        def construct(self):
36: (16)                            poly1 = SampleSpace(stroke_width=15, fill_opacity=1)
37: (16)                            poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)
38: (16)                            poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)
39: (16)                            poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)
40: (16)                            poly_group = VGroup(poly1, poly2, poly3).arrange()
41: (16)                            self.add(poly_group)
42: (4)                 """
43: (4)                 def __init__(
44: (8)                     self,
45: (8)                     height=3,
46: (8)                     width=3,
47: (8)                     fill_color=DARK_GREY,
48: (8)                     fill_opacity=1,
49: (8)                     stroke_width=0.5,
50: (8)                     stroke_color=LIGHT_GREY,
51: (8)                     default_label_scale_val=1,
52: (4)                 ):
53: (8)                     super().__init__(
54: (12)                        height=height,
55: (12)                        width=width,
56: (12)                        fill_color=fill_color,
57: (12)                        fill_opacity=fill_opacity,
58: (12)                        stroke_width=stroke_width,
59: (12)                        stroke_color=stroke_color,
60: (8)                     )
61: (8)                     self.default_label_scale_val = default_label_scale_val
62: (4)                 def add_title(self, title="Sample space", buff=MED_SMALL_BUFF):
63: (8)                     # TODO, should this really exist in SampleSpaceScene
64: (8)                     title_mob = Tex(title)
65: (8)                     if title_mob.width > self.width:
66: (12)                        title_mob.width = self.width
67: (8)                     title_mob.next_to(self, UP, buff=buff)
68: (8)                     self.title = title_mob
69: (8)                     self.add(title_mob)
70: (4)                 def add_label(self, label):
71: (8)                     self.label = label
72: (4)                 def complete_p_list(self, p_list):
73: (8)                     new_p_list = list(tuplify(p_list))
74: (8)                     remainder = 1.0 - sum(new_p_list)
75: (8)                     if abs(remainder) > EPSILON:
76: (12)                        new_p_list.append(remainder)
77: (8)                     return new_p_list
78: (4)                 def get_division_along_dimension(self, p_list, dim, colors, vect):
79: (8)                     p_list = self.complete_p_list(p_list)
80: (8)                     colors = color_gradient(colors, len(p_list))
81: (8)                     last_point = self.get_edge_center(-vect)
82: (8)                     parts = VGroup()
83: (8)                     for factor, color in zip(p_list, colors):
84: (12)                        part = SampleSpace()
85: (12)                        part.set_fill(color, 1)
86: (12)                        part.replace(self, stretch=True)
87: (12)                        part.stretch(factor, dim)
88: (12)                        part.move_to(last_point, -vect)
89: (12)                        last_point = part.get_edge_center(vect)
90: (12)                        parts.add(part)
91: (8)                     return parts
92: (4)                 def get_horizontal_division(self, p_list, colors=[GREEN_E, BLUE_E], vect=DOWN):
93: (8)                     return self.get_division_along_dimension(p_list, 1, colors, vect)
94: (4)                 def get_vertical_division(self, p_list, colors=[MAROON_B, YELLOW], vect=RIGHT):
95: (8)                     return self.get_division_along_dimension(p_list, 0, colors, vect)
96: (4)                 def divide_horizontally(self, *args, **kwargs):
97: (8)                     self.horizontal_parts = self.get_horizontal_division(*args, **kwargs)
98: (8)                     self.add(self.horizontal_parts)
99: (4)                 def divide_vertically(self, *args, **kwargs):
100: (8)                    self.vertical_parts = self.get_vertical_division(*args, **kwargs)
101: (8)                    self.add(self.vertical_parts)
102: (4)                def get_subdivision_braces_and_labels(
103: (8)                    self,
104: (8)                    parts,
105: (8)                    labels,
106: (8)                    direction,
107: (8)                    buff=SMALL_BUFF,
108: (8)                    min_num_quads=1,
109: (4)                ):
110: (8)                    label_mobs = VGroup()
111: (8)                    braces = VGroup()
112: (8)                    for label, part in zip(labels, parts):
113: (12)                       brace = Brace(part, direction, min_num_quads=min_num_quads, buff=buff)
114: (12)                       if isinstance(label, (Mobject, OpenGLMobject)):
115: (16)                           label_mob = label
116: (12)                       else:
117: (16)                           label_mob = MathTex(label)
118: (16)                           label_mob.scale(self.default_label_scale_val)
119: (12)                       label_mob.next_to(brace, direction, buff)
120: (12)                       braces.add(brace)
121: (12)                       label_mobs.add(label_mob)
122: (8)                    parts.braces = braces
123: (8)                    parts.labels = label_mobs
124: (8)                    parts.label_kwargs = {
125: (12)                       "labels": label_mobs.copy(),
126: (12)                       "direction": direction,
127: (12)                       "buff": buff,
128: (8)                    }
129: (8)                    return VGroup(parts.braces, parts.labels)
130: (4)                def get_side_braces_and_labels(self, labels, direction=LEFT, **kwargs):
131: (8)                    assert hasattr(self, "horizontal_parts")
132: (8)                    parts = self.horizontal_parts
133: (8)                    return self.get_subdivision_braces_and_labels(
134: (12)                       parts, labels, direction, **kwargs
135: (8)                    )
136: (4)                def get_top_braces_and_labels(self, labels, **kwargs):
137: (8)                    assert hasattr(self, "vertical_parts")
138: (8)                    parts = self.vertical_parts
139: (8)                    return self.get_subdivision_braces_and_labels(parts, labels, UP, **kwargs)
140: (4)                def get_bottom_braces_and_labels(self, labels, **kwargs):
141: (8)                    assert hasattr(self, "vertical_parts")
142: (8)                    parts = self.vertical_parts
143: (8)                    return self.get_subdivision_braces_and_labels(parts, labels, DOWN, **kwargs)
144: (4)                def add_braces_and_labels(self):
145: (8)                    for attr in "horizontal_parts", "vertical_parts":
146: (12)                       if not hasattr(self, attr):
147: (16)                           continue
148: (12)                       parts = getattr(self, attr)
149: (12)                       for subattr in "braces", "labels":
150: (16)                           if hasattr(parts, subattr):
151: (20)                               self.add(getattr(parts, subattr))
152: (4)                def __getitem__(self, index):
153: (8)                    if hasattr(self, "horizontal_parts"):
154: (12)                       return self.horizontal_parts[index]
155: (8)                    elif hasattr(self, "vertical_parts"):
156: (12)                       return self.vertical_parts[index]
157: (8)                    return self.split()[index]
158: (0)            class BarChart(Axes):
159: (4)                """Creates a bar chart. Inherits from :class:`~.Axes`, so it shares its methods
160: (4)                and attributes. Each axis inherits from :class:`~.NumberLine`, so pass in ``x_axis_config``/``y_axis_config``
161: (4)                to control their attributes.
162: (4)                Parameters
163: (4)                ----------
164: (4)                values
165: (8)                    A sequence of values that determines the height of each bar. Accepts negative values.
166: (4)                bar_names
167: (8)                    A sequence of names for each bar. Does not have to match the length of ``values``.
168: (4)                y_range
169: (8)                    The y_axis range of values. If ``None``, the range will be calculated based on the
170: (8)                    min/max of ``values`` and the step will be calculated based on ``y_length``.
171: (4)                x_length
172: (8)                    The length of the x-axis. If ``None``, it is automatically calculated based on
173: (8)                    the number of values and the width of the screen.
174: (4)                y_length
175: (8)                    The length of the y-axis.
176: (4)                bar_colors
177: (8)                    The color for the bars. Accepts a sequence of colors (can contain just one item).
178: (8)                    If the length of``bar_colors`` does not match that of ``values``,
179: (8)                    intermediate colors will be automatically determined.
180: (4)                bar_width
181: (8)                    The length of a bar. Must be between 0 and 1.
182: (4)                bar_fill_opacity
183: (8)                    The fill opacity of the bars.
184: (4)                bar_stroke_width
185: (8)                    The stroke width of the bars.
186: (4)                Examples
187: (4)                --------
188: (4)                .. manim:: BarChartExample
189: (8)                    :save_last_frame:
190: (8)                    class BarChartExample(Scene):
191: (12)                       def construct(self):
192: (16)                           chart = BarChart(
193: (20)                               values=[-5, 40, -10, 20, -3],
194: (20)                               bar_names=["one", "two", "three", "four", "five"],
195: (20)                               y_range=[-20, 50, 10],
196: (20)                               y_length=6,
197: (20)                               x_length=10,
198: (20)                               x_axis_config={"font_size": 36},
199: (16)                           )
200: (16)                           c_bar_lbls = chart.get_bar_labels(font_size=48)
201: (16)                           self.add(chart, c_bar_lbls)
202: (4)                """
203: (4)                def __init__(
204: (8)                    self,
205: (8)                    values: MutableSequence[float],
206: (8)                    bar_names: Sequence[str] | None = None,
207: (8)                    y_range: Sequence[float] | None = None,
208: (8)                    x_length: float | None = None,
209: (8)                    y_length: float | None = None,
210: (8)                    bar_colors: Iterable[str] = [
211: (12)                       "#003f5c",
212: (12)                       "#58508d",
213: (12)                       "#bc5090",
214: (12)                       "#ff6361",
215: (12)                       "#ffa600",
216: (8)                    ],
217: (8)                    bar_width: float = 0.6,
218: (8)                    bar_fill_opacity: float = 0.7,
219: (8)                    bar_stroke_width: float = 3,
220: (8)                    **kwargs,
221: (4)                ):
222: (8)                    if isinstance(bar_colors, str):
223: (12)                       logger.warning(
224: (16)                           "Passing a string to `bar_colors` has been deprecated since v0.15.2 and will be removed after v0.17.0, the parameter must be a list.  "
225: (12)                       )
226: (12)                       bar_colors = list(bar_colors)
227: (8)                    y_length = y_length if y_length is not None else config.frame_height - 4
228: (8)                    self.values = values
229: (8)                    self.bar_names = bar_names
230: (8)                    self.bar_colors = bar_colors
231: (8)                    self.bar_width = bar_width
232: (8)                    self.bar_fill_opacity = bar_fill_opacity
233: (8)                    self.bar_stroke_width = bar_stroke_width
234: (8)                    x_range = [0, len(self.values), 1]
235: (8)                    if y_range is None:
236: (12)                       y_range = [
237: (16)                           min(0, min(self.values)),
238: (16)                           max(0, max(self.values)),
239: (16)                           round(max(self.values) / y_length, 2),
240: (12)                       ]
241: (8)                    elif len(y_range) == 2:
242: (12)                       y_range = [*y_range, round(max(self.values) / y_length, 2)]
243: (8)                    if x_length is None:
244: (12)                       x_length = min(len(self.values), config.frame_width - 2)
245: (8)                    x_axis_config = {"font_size": 24, "label_constructor": Tex}
246: (8)                    self._update_default_configs(
247: (12)                       (x_axis_config,), (kwargs.pop("x_axis_config", None),)
248: (8)                    )
249: (8)                    self.bars: VGroup = VGroup()
250: (8)                    self.x_labels: VGroup | None = None
251: (8)                    self.bar_labels: VGroup | None = None
252: (8)                    super().__init__(
253: (12)                       x_range=x_range,
254: (12)                       y_range=y_range,
255: (12)                       x_length=x_length,
256: (12)                       y_length=y_length,
257: (12)                       x_axis_config=x_axis_config,
258: (12)                       tips=kwargs.pop("tips", False),
259: (12)                       **kwargs,
260: (8)                    )
261: (8)                    self._add_bars()
262: (8)                    if self.bar_names is not None:
263: (12)                       self._add_x_axis_labels()
264: (8)                    self.y_axis.add_numbers()
265: (4)                def _update_colors(self):
266: (8)                    """Initialize the colors of the bars of the chart.
267: (8)                    Sets the color of ``self.bars`` via ``self.bar_colors``.
268: (8)                    Primarily used when the bars are initialized with ``self._add_bars``
269: (8)                    or updated via ``self.change_bar_values``.
270: (8)                    """
271: (8)                    self.bars.set_color_by_gradient(*self.bar_colors)
272: (4)                def _add_x_axis_labels(self):
273: (8)                    """Essentially :meth`:~.NumberLine.add_labels`, but differs in that
274: (8)                    the direction of the label with respect to the x_axis changes to UP or DOWN
275: (8)                    depending on the value.
276: (8)                    UP for negative values and DOWN for positive values.
277: (8)                    """
278: (8)                    val_range = np.arange(
279: (12)                       0.5, len(self.bar_names), 1
280: (8)                    )  # 0.5 shifted so that labels are centered, not on ticks
281: (8)                    labels = VGroup()
282: (8)                    for i, (value, bar_name) in enumerate(zip(val_range, self.bar_names)):
283: (12)                       # to accommodate negative bars, the label may need to be
284: (12)                       # below or above the x_axis depending on the value of the bar
285: (12)                       if self.values[i] < 0:
286: (16)                           direction = UP
287: (12)                       else:
288: (16)                           direction = DOWN
289: (12)                       bar_name_label = self.x_axis.label_constructor(bar_name)
290: (12)                       bar_name_label.font_size = self.x_axis.font_size
291: (12)                       bar_name_label.next_to(
292: (16)                           self.x_axis.number_to_point(value),
293: (16)                           direction=direction,
294: (16)                           buff=self.x_axis.line_to_number_buff,
295: (12)                       )
296: (12)                       labels.add(bar_name_label)
297: (8)                    self.x_axis.labels = labels
298: (8)                    self.x_axis.add(labels)
299: (4)                def _create_bar(self, bar_number: int, value: float) -> Rectangle:
300: (8)                    """Creates a positioned bar on the chart.
301: (8)                    Parameters
302: (8)                    ----------
303: (8)                    bar_number
304: (12)                       Determines the x-position of the bar.
305: (8)                    value
306: (12)                       The value that determines the height of the bar.
307: (8)                    Returns
308: (8)                    -------
309: (8)                    Rectangle
310: (12)                       A positioned rectangle representing a bar on the chart.
311: (8)                    """
312: (8)                    # bar measurements relative to the axis
313: (8)                    # distance from between the y-axis and the top of the bar
314: (8)                    bar_h = abs(self.c2p(0, value)[1] - self.c2p(0, 0)[1])
315: (8)                    # width of the bar
316: (8)                    bar_w = self.c2p(self.bar_width, 0)[0] - self.c2p(0, 0)[0]
317: (8)                    bar = Rectangle(
318: (12)                       height=bar_h,
319: (12)                       width=bar_w,
320: (12)                       stroke_width=self.bar_stroke_width,
321: (12)                       fill_opacity=self.bar_fill_opacity,
322: (8)                    )
323: (8)                    pos = UP if (value >= 0) else DOWN
324: (8)                    bar.next_to(self.c2p(bar_number + 0.5, 0), pos, buff=0)
325: (8)                    return bar
326: (4)                def _add_bars(self) -> None:
327: (8)                    for i, value in enumerate(self.values):
328: (12)                       tmp_bar = self._create_bar(bar_number=i, value=value)
329: (12)                       self.bars.add(tmp_bar)
330: (8)                    self._update_colors()
331: (8)                    self.add_to_back(self.bars)
332: (4)                def get_bar_labels(
333: (8)                    self,
334: (8)                    color: ParsableManimColor | None = None,
335: (8)                    font_size: float = 24,
336: (8)                    buff: float = MED_SMALL_BUFF,
337: (8)                    label_constructor: type[VMobject] = Tex,
338: (4)                ):
339: (8)                    """Annotates each bar with its corresponding value. Use ``self.bar_labels`` to access the
340: (8)                    labels after creation.
341: (8)                    Parameters
342: (8)                    ----------
343: (8)                    color
344: (12)                       The color of each label. By default ``None`` and is based on the parent's bar color.
345: (8)                    font_size
346: (12)                       The font size of each label.
347: (8)                    buff
348: (12)                       The distance from each label to its bar. By default 0.4.
349: (8)                    label_constructor
350: (12)                       The Mobject class to construct the labels, by default :class:`~.Tex`.
351: (8)                    Examples
352: (8)                    --------
353: (8)                    .. manim:: GetBarLabelsExample
354: (12)                       :save_last_frame:
355: (12)                       class GetBarLabelsExample(Scene):
356: (16)                           def construct(self):
357: (20)                               chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])
358: (20)                               c_bar_lbls = chart.get_bar_labels(
359: (24)                                   color=WHITE, label_constructor=MathTex, font_size=36
360: (20)                               )
361: (20)                               self.add(chart, c_bar_lbls)
362: (8)                    """
363: (8)                    bar_labels = VGroup()
364: (8)                    for bar, value in zip(self.bars, self.values):
365: (12)                       bar_lbl = label_constructor(str(value))
366: (12)                       if color is None:
367: (16)                           bar_lbl.set_color(bar.get_fill_color())
368: (12)                       else:
369: (16)                           bar_lbl.set_color(color)
370: (12)                       bar_lbl.font_size = font_size
371: (12)                       pos = UP if (value >= 0) else DOWN
372: (12)                       bar_lbl.next_to(bar, pos, buff=buff)
373: (12)                       bar_labels.add(bar_lbl)
374: (8)                    return bar_labels
375: (4)                def change_bar_values(self, values: Iterable[float], update_colors: bool = True):
376: (8)                    """Updates the height of the bars of the chart.
377: (8)                    Parameters
378: (8)                    ----------
379: (8)                    values
380: (12)                       The values that will be used to update the height of the bars.
381: (12)                       Does not have to match the number of bars.
382: (8)                    update_colors
383: (12)                       Whether to re-initalize the colors of the bars based on ``self.bar_colors``.
384: (8)                    Examples
385: (8)                    --------
386: (8)                    .. manim:: ChangeBarValuesExample
387: (12)                       :save_last_frame:
388: (12)                       class ChangeBarValuesExample(Scene):
389: (16)                           def construct(self):
390: (20)                               values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]
391: (20)                               chart = BarChart(
392: (24)                                   values,
393: (24)                                   y_range=[-10, 10, 2],
394: (24)                                   y_axis_config={"font_size": 24},
395: (20)                               )
396: (20)                               self.add(chart)
397: (20)                               chart.change_bar_values(list(reversed(values)))
398: (20)                               self.add(chart.get_bar_labels(font_size=24))
399: (8)                    """
400: (8)                    for i, (bar, value) in enumerate(zip(self.bars, values)):
401: (12)                       chart_val = self.values[i]
402: (12)                       if chart_val > 0:
403: (16)                           bar_lim = bar.get_bottom()
404: (16)                           aligned_edge = DOWN
405: (12)                       else:
406: (16)                           bar_lim = bar.get_top()
407: (16)                           aligned_edge = UP
408: (12)                       # check if the bar has height
409: (12)                       if chart_val != 0:
410: (16)                           quotient = value / chart_val
411: (16)                           if quotient < 0:
412: (20)                               aligned_edge = UP if chart_val > 0 else DOWN
413: (20)                               # if the bar is already positive, then we now want to move it
414: (20)                               # so that it is negative. So, we move the top edge of the bar
415: (20)                               # to the location of the previous bottom
416: (20)                               # if already negative, then we move the bottom edge of the bar
417: (20)                               # to the location of the previous top
418: (16)                           bar.stretch_to_fit_height(abs(quotient) * bar.height)
419: (12)                       else:
420: (16)                           # create a new bar since the current one has a height of zero (doesn't exist)
421: (16)                           temp_bar = self._create_bar(i, value)
422: (16)                           self.bars.remove(bar)
423: (16)                           self.bars.insert(i, temp_bar)
424: (12)                       bar.move_to(bar_lim, aligned_edge)
425: (8)                    if update_colors:
426: (12)                       self._update_colors()
427: (8)                    self.values[: len(values)] = values

----------------------------------------

File 21 - .\geometry \shape_matchers.py:

1: (0)              """Mobjects used to mark and annotate other mobjects."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["SurroundingRectangle", "BackgroundRectangle", "Cross", "Underline"]
4: (0)              from typing import Any
5: (0)              from typing_extensions import Self
6: (0)              from manim import config, logger
7: (0)              from manim.constants import *
8: (0)              from manim.mobject.geometry.line import Line
9: (0)              from manim.mobject.geometry.polygram import RoundedRectangle
10: (0)             from manim.mobject.mobject import Mobject
11: (0)             from manim.mobject.types.vectorized_mobject import VGroup
12: (0)             from manim.utils.color import BLACK, RED, YELLOW, ManimColor, ParsableManimColor
13: (0)             class SurroundingRectangle(RoundedRectangle):
14: (4)                 r"""A rectangle surrounding a :class:`~.Mobject`
15: (4)                 Examples
16: (4)                 --------
17: (4)                 .. manim:: SurroundingRectExample
18: (8)                     :save_last_frame:
19: (8)                     class SurroundingRectExample(Scene):
20: (12)                        def construct(self):
21: (16)                            title = Title("A Quote from Newton")
22: (16)                            quote = Text(
23: (20)                                "If I have seen further than others, \n"
24: (20)                                "it is by standing upon the shoulders of giants.",
25: (20)                                color=BLUE,
26: (16)                            ).scale(0.75)
27: (16)                            box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)
28: (16)                            t2 = Tex(r"Hello World").scale(1.5)
29: (16)                            box2 = SurroundingRectangle(t2, corner_radius=0.2)
30: (16)                            mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)
31: (16)                            self.add(title, mobjects)
32: (4)                 """
33: (4)                 def __init__(
34: (8)                     self,
35: (8)                     mobject: Mobject,
36: (8)                     color: ParsableManimColor = YELLOW,
37: (8)                     buff: float = SMALL_BUFF,
38: (8)                     corner_radius: float = 0.0,
39: (8)                     **kwargs,
40: (4)                 ) -> None:
41: (8)                     super().__init__(
42: (12)                        color=color,
43: (12)                        width=mobject.width + 2 * buff,
44: (12)                        height=mobject.height + 2 * buff,
45: (12)                        corner_radius=corner_radius,
46: (12)                        **kwargs,
47: (8)                     )
48: (8)                     self.buff = buff
49: (8)                     self.move_to(mobject)
50: (0)             class BackgroundRectangle(SurroundingRectangle):
51: (4)                 """A background rectangle. Its default color is the background color
52: (4)                 of the scene.
53: (4)                 Examples
54: (4)                 --------
55: (4)                 .. manim:: ExampleBackgroundRectangle
56: (8)                     :save_last_frame:
57: (8)                     class ExampleBackgroundRectangle(Scene):
58: (12)                        def construct(self):
59: (16)                            circle = Circle().shift(LEFT)
60: (16)                            circle.set_stroke(color=GREEN, width=20)
61: (16)                            triangle = Triangle().shift(2 * RIGHT)
62: (16)                            triangle.set_fill(PINK, opacity=0.5)
63: (16)                            backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)
64: (16)                            backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)
65: (16)                            self.add(backgroundRectangle1)
66: (16)                            self.add(backgroundRectangle2)
67: (16)                            self.add(circle)
68: (16)                            self.add(triangle)
69: (16)                            self.play(Rotate(backgroundRectangle1, PI / 4))
70: (16)                            self.play(Rotate(backgroundRectangle2, PI / 2))
71: (4)                 """
72: (4)                 def __init__(
73: (8)                     self,
74: (8)                     mobject: Mobject,
75: (8)                     color: ParsableManimColor | None = None,
76: (8)                     stroke_width: float = 0,
77: (8)                     stroke_opacity: float = 0,
78: (8)                     fill_opacity: float = 0.75,
79: (8)                     buff: float = 0,
80: (8)                     **kwargs,
81: (4)                 ):
82: (8)                     if color is None:
83: (12)                        color = config.background_color
84: (8)                     super().__init__(
85: (12)                        mobject,
86: (12)                        color=color,
87: (12)                        stroke_width=stroke_width,
88: (12)                        stroke_opacity=stroke_opacity,
89: (12)                        fill_opacity=fill_opacity,
90: (12)                        buff=buff,
91: (12)                        **kwargs,
92: (8)                     )
93: (8)                     self.original_fill_opacity: float = self.fill_opacity
94: (4)                 def pointwise_become_partial(self, mobject: Mobject, a: Any, b: float) -> Self:
95: (8)                     self.set_fill(opacity=b * self.original_fill_opacity)
96: (8)                     return self
97: (4)                 def set_style(self, fill_opacity: float, **kwargs) -> Self:
98: (8)                     # Unchangeable style, except for fill_opacity
99: (8)                     # All other style arguments are ignored
100: (8)                    super().set_style(
101: (12)                       stroke_color=BLACK,
102: (12)                       stroke_width=0,
103: (12)                       fill_color=BLACK,
104: (12)                       fill_opacity=fill_opacity,
105: (8)                    )
106: (8)                    if len(kwargs) > 0:
107: (12)                       logger.info(
108: (16)                           "Argument %s is ignored in BackgroundRectangle.set_style.",
109: (16)                           kwargs,
110: (12)                       )
111: (8)                    return self
112: (4)                def get_fill_color(self) -> ManimColor:
113: (8)                    return self.color
114: (0)            class Cross(VGroup):
115: (4)                """Creates a cross.
116: (4)                Parameters
117: (4)                ----------
118: (4)                mobject
119: (8)                    The mobject linked to this instance. It fits the mobject when specified. Defaults to None.
120: (4)                stroke_color
121: (8)                    Specifies the color of the cross lines. Defaults to RED.
122: (4)                stroke_width
123: (8)                    Specifies the width of the cross lines. Defaults to 6.
124: (4)                scale_factor
125: (8)                    Scales the cross to the provided units. Defaults to 1.
126: (4)                Examples
127: (4)                --------
128: (4)                .. manim:: ExampleCross
129: (8)                    :save_last_frame:
130: (8)                    class ExampleCross(Scene):
131: (12)                       def construct(self):
132: (16)                           cross = Cross()
133: (16)                           self.add(cross)
134: (4)                """
135: (4)                def __init__(
136: (8)                    self,
137: (8)                    mobject: Mobject | None = None,
138: (8)                    stroke_color: ParsableManimColor = RED,
139: (8)                    stroke_width: float = 6.0,
140: (8)                    scale_factor: float = 1.0,
141: (8)                    **kwargs,
142: (4)                ) -> None:
143: (8)                    super().__init__(
144: (12)                       Line(UP + LEFT, DOWN + RIGHT), Line(UP + RIGHT, DOWN + LEFT), **kwargs
145: (8)                    )
146: (8)                    if mobject is not None:
147: (12)                       self.replace(mobject, stretch=True)
148: (8)                    self.scale(scale_factor)
149: (8)                    self.set_stroke(color=stroke_color, width=stroke_width)
150: (0)            class Underline(Line):
151: (4)                """Creates an underline.
152: (4)                Examples
153: (4)                --------
154: (4)                .. manim:: UnderLine
155: (8)                    :save_last_frame:
156: (8)                    class UnderLine(Scene):
157: (12)                       def construct(self):
158: (16)                           man = Tex("Manim")  # Full Word
159: (16)                           ul = Underline(man)  # Underlining the word
160: (16)                           self.add(man, ul)
161: (4)                """
162: (4)                def __init__(self, mobject: Mobject, buff: float = SMALL_BUFF, **kwargs) -> None:
163: (8)                    super().__init__(LEFT, RIGHT, buff=buff, **kwargs)
164: (8)                    self.match_width(mobject)
165: (8)                    self.next_to(mobject, DOWN, buff=self.buff)

----------------------------------------

File 22 - .\graphing \coordinate_systems.py:

1: (0)              """Mobjects that represent coordinate systems."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "CoordinateSystem",
5: (4)                  "Axes",
6: (4)                  "ThreeDAxes",
7: (4)                  "NumberPlane",
8: (4)                  "PolarPlane",
9: (4)                  "ComplexPlane",
10: (0)             ]
11: (0)             import fractions as fr
12: (0)             import numbers
13: (0)             from typing import TYPE_CHECKING, Any, Callable, Iterable, Sequence, TypeVar, overload
14: (0)             import numpy as np
15: (0)             from typing_extensions import Self
16: (0)             from manim import config
17: (0)             from manim.constants import *
18: (0)             from manim.mobject.geometry.arc import Circle, Dot
19: (0)             from manim.mobject.geometry.line import Arrow, DashedLine, Line
20: (0)             from manim.mobject.geometry.polygram import Polygon, Rectangle, RegularPolygon
21: (0)             from manim.mobject.graphing.functions import ImplicitFunction, ParametricFunction
22: (0)             from manim.mobject.graphing.number_line import NumberLine
23: (0)             from manim.mobject.graphing.scale import LinearBase
24: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
25: (0)             from manim.mobject.opengl.opengl_surface import OpenGLSurface
26: (0)             from manim.mobject.text.tex_mobject import MathTex
27: (0)             from manim.mobject.three_d.three_dimensions import Surface
28: (0)             from manim.mobject.types.vectorized_mobject import (
29: (4)                 VDict,
30: (4)                 VectorizedPoint,
31: (4)                 VGroup,
32: (4)                 VMobject,
33: (0)             )
34: (0)             from manim.utils.color import (
35: (4)                 BLACK,
36: (4)                 BLUE,
37: (4)                 BLUE_D,
38: (4)                 GREEN,
39: (4)                 WHITE,
40: (4)                 YELLOW,
41: (4)                 ManimColor,
42: (4)                 ParsableManimColor,
43: (4)                 color_gradient,
44: (4)                 invert_color,
45: (0)             )
46: (0)             from manim.utils.config_ops import merge_dicts_recursively, update_dict_recursively
47: (0)             from manim.utils.simple_functions import binary_search
48: (0)             from manim.utils.space_ops import angle_of_vector
49: (0)             if TYPE_CHECKING:
50: (4)                 from manim.mobject.mobject import Mobject
51: (4)                 from manim.typing import ManimFloat, Point2D, Point3D, Vector3D
52: (4)                 LineType = TypeVar("LineType", bound=Line)
53: (0)             class CoordinateSystem:
54: (4)                 r"""Abstract base class for Axes and NumberPlane.
55: (4)                 Examples
56: (4)                 --------
57: (4)                 .. manim:: CoordSysExample
58: (8)                     :save_last_frame:
59: (8)                     class CoordSysExample(Scene):
60: (12)                        def construct(self):
61: (16)                            # the location of the ticks depends on the x_range and y_range.
62: (16)                            grid = Axes(
63: (20)                                x_range=[0, 1, 0.05],  # step size determines num_decimal_places.
64: (20)                                y_range=[0, 1, 0.05],
65: (20)                                x_length=9,
66: (20)                                y_length=5.5,
67: (20)                                axis_config={
68: (24)                                    "numbers_to_include": np.arange(0, 1 + 0.1, 0.1),
69: (24)                                    "font_size": 24,
70: (20)                                },
71: (20)                                tips=False,
72: (16)                            )
73: (16)                            # Labels for the x-axis and y-axis.
74: (16)                            y_label = grid.get_y_axis_label("y", edge=LEFT, direction=LEFT, buff=0.4)
75: (16)                            x_label = grid.get_x_axis_label("x")
76: (16)                            grid_labels = VGroup(x_label, y_label)
77: (16)                            graphs = VGroup()
78: (16)                            for n in np.arange(1, 20 + 0.5, 0.5):
79: (20)                                graphs += grid.plot(lambda x: x ** n, color=WHITE)
80: (20)                                graphs += grid.plot(
81: (24)                                    lambda x: x ** (1 / n), color=WHITE, use_smoothing=False
82: (20)                                )
83: (16)                            # Extra lines and labels for point (1,1)
84: (16)                            graphs += grid.get_horizontal_line(grid.c2p(1, 1, 0), color=BLUE)
85: (16)                            graphs += grid.get_vertical_line(grid.c2p(1, 1, 0), color=BLUE)
86: (16)                            graphs += Dot(point=grid.c2p(1, 1, 0), color=YELLOW)
87: (16)                            graphs += Tex("(1,1)").scale(0.75).next_to(grid.c2p(1, 1, 0))
88: (16)                            title = Title(
89: (20)                                # spaces between braces to prevent SyntaxError
90: (20)                                r"Graphs of $y=x^{ {1}\over{n} }$ and $y=x^n (n=1,2,3,...,20)$",
91: (20)                                include_underline=False,
92: (20)                                font_size=40,
93: (16)                            )
94: (16)                            self.add(title, graphs, grid, grid_labels)
95: (4)                 """
96: (4)                 def __init__(
97: (8)                     self,
98: (8)                     x_range: Sequence[float] | None = None,
99: (8)                     y_range: Sequence[float] | None = None,
100: (8)                    x_length: float | None = None,
101: (8)                    y_length: float | None = None,
102: (8)                    dimension: int = 2,
103: (4)                ) -> None:
104: (8)                    self.dimension = dimension
105: (8)                    default_step = 1
106: (8)                    if x_range is None:
107: (12)                       x_range = [
108: (16)                           round(-config["frame_x_radius"]),
109: (16)                           round(config["frame_x_radius"]),
110: (16)                           default_step,
111: (12)                       ]
112: (8)                    elif len(x_range) == 2:
113: (12)                       x_range = [*x_range, default_step]
114: (8)                    if y_range is None:
115: (12)                       y_range = [
116: (16)                           round(-config["frame_y_radius"]),
117: (16)                           round(config["frame_y_radius"]),
118: (16)                           default_step,
119: (12)                       ]
120: (8)                    elif len(y_range) == 2:
121: (12)                       y_range = [*y_range, default_step]
122: (8)                    self.x_range = x_range
123: (8)                    self.y_range = y_range
124: (8)                    self.x_length = x_length
125: (8)                    self.y_length = y_length
126: (8)                    self.num_sampled_graph_points_per_tick = 10
127: (4)                def coords_to_point(self, *coords: Sequence[ManimFloat]):
128: (8)                    raise NotImplementedError()
129: (4)                def point_to_coords(self, point: Point3D):
130: (8)                    raise NotImplementedError()
131: (4)                def polar_to_point(self, radius: float, azimuth: float) -> Point2D:
132: (8)                    r"""Gets a point from polar coordinates.
133: (8)                    Parameters
134: (8)                    ----------
135: (8)                    radius
136: (12)                       The coordinate radius (:math:`r`).
137: (8)                    azimuth
138: (12)                       The coordinate azimuth (:math:`\theta`).
139: (8)                    Returns
140: (8)                    -------
141: (8)                    numpy.ndarray
142: (12)                       The point.
143: (8)                    Examples
144: (8)                    --------
145: (8)                    .. manim:: PolarToPointExample
146: (12)                       :ref_classes: PolarPlane Vector
147: (12)                       :save_last_frame:
148: (12)                       class PolarToPointExample(Scene):
149: (16)                           def construct(self):
150: (20)                               polarplane_pi = PolarPlane(azimuth_units="PI radians", size=6)
151: (20)                               polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))
152: (20)                               self.add(polarplane_pi)
153: (20)                               self.add(polartopoint_vector)
154: (8)                    """
155: (8)                    return self.coords_to_point(radius * np.cos(azimuth), radius * np.sin(azimuth))
156: (4)                def point_to_polar(self, point: np.ndarray) -> Point2D:
157: (8)                    r"""Gets polar coordinates from a point.
158: (8)                    Parameters
159: (8)                    ----------
160: (8)                    point
161: (12)                       The point.
162: (8)                    Returns
163: (8)                    -------
164: (8)                    Tuple[:class:`float`, :class:`float`]
165: (12)                       The coordinate radius (:math:`r`) and the coordinate azimuth (:math:`\theta`).
166: (8)                    """
167: (8)                    x, y = self.point_to_coords(point)
168: (8)                    return np.sqrt(x**2 + y**2), np.arctan2(y, x)
169: (4)                def c2p(
170: (8)                    self, *coords: float | Sequence[float] | Sequence[Sequence[float]] | np.ndarray
171: (4)                ) -> np.ndarray:
172: (8)                    """Abbreviation for :meth:`coords_to_point`"""
173: (8)                    return self.coords_to_point(*coords)
174: (4)                def p2c(self, point: Point3D):
175: (8)                    """Abbreviation for :meth:`point_to_coords`"""
176: (8)                    return self.point_to_coords(point)
177: (4)                def pr2pt(self, radius: float, azimuth: float) -> np.ndarray:
178: (8)                    """Abbreviation for :meth:`polar_to_point`"""
179: (8)                    return self.polar_to_point(radius, azimuth)
180: (4)                def pt2pr(self, point: np.ndarray) -> tuple[float, float]:
181: (8)                    """Abbreviation for :meth:`point_to_polar`"""
182: (8)                    return self.point_to_polar(point)
183: (4)                def get_axes(self):
184: (8)                    raise NotImplementedError()
185: (4)                def get_axis(self, index: int) -> Mobject:
186: (8)                    return self.get_axes()[index]
187: (4)                def get_origin(self) -> np.ndarray:
188: (8)                    """Gets the origin of :class:`~.Axes`.
189: (8)                    Returns
190: (8)                    -------
191: (8)                    np.ndarray
192: (12)                       The center point.
193: (8)                    """
194: (8)                    return self.coords_to_point(0, 0)
195: (4)                def get_x_axis(self) -> Mobject:
196: (8)                    return self.get_axis(0)
197: (4)                def get_y_axis(self) -> Mobject:
198: (8)                    return self.get_axis(1)
199: (4)                def get_z_axis(self) -> Mobject:
200: (8)                    return self.get_axis(2)
201: (4)                def get_x_unit_size(self) -> float:
202: (8)                    return self.get_x_axis().get_unit_size()
203: (4)                def get_y_unit_size(self) -> float:
204: (8)                    return self.get_y_axis().get_unit_size()
205: (4)                def get_x_axis_label(
206: (8)                    self,
207: (8)                    label: float | str | Mobject,
208: (8)                    edge: Sequence[float] = UR,
209: (8)                    direction: Sequence[float] = UR,
210: (8)                    buff: float = SMALL_BUFF,
211: (8)                    **kwargs,
212: (4)                ) -> Mobject:
213: (8)                    """Generate an x-axis label.
214: (8)                    Parameters
215: (8)                    ----------
216: (8)                    label
217: (12)                       The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
218: (8)                    edge
219: (12)                       The edge of the x-axis to which the label will be added, by default ``UR``.
220: (8)                    direction
221: (12)                       Allows for further positioning of the label from an edge, by default ``UR``.
222: (8)                    buff
223: (12)                       The distance of the label from the line.
224: (8)                    Returns
225: (8)                    -------
226: (8)                    :class:`~.Mobject`
227: (12)                       The positioned label.
228: (8)                    Examples
229: (8)                    --------
230: (8)                    .. manim:: GetXAxisLabelExample
231: (12)                       :save_last_frame:
232: (12)                       class GetXAxisLabelExample(Scene):
233: (16)                           def construct(self):
234: (20)                               ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
235: (20)                               x_label = ax.get_x_axis_label(
236: (24)                                   Tex("$x$-values").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5
237: (20)                               )
238: (20)                               self.add(ax, x_label)
239: (8)                    """
240: (8)                    return self._get_axis_label(
241: (12)                       label, self.get_x_axis(), edge, direction, buff=buff, **kwargs
242: (8)                    )
243: (4)                def get_y_axis_label(
244: (8)                    self,
245: (8)                    label: float | str | Mobject,
246: (8)                    edge: Sequence[float] = UR,
247: (8)                    direction: Sequence[float] = UP * 0.5 + RIGHT,
248: (8)                    buff: float = SMALL_BUFF,
249: (8)                    **kwargs,
250: (4)                ) -> Mobject:
251: (8)                    """Generate a y-axis label.
252: (8)                    Parameters
253: (8)                    ----------
254: (8)                    label
255: (12)                       The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
256: (8)                    edge
257: (12)                       The edge of the y-axis to which the label will be added, by default ``UR``.
258: (8)                    direction
259: (12)                       Allows for further positioning of the label from an edge, by default ``UR``
260: (8)                    buff
261: (12)                       The distance of the label from the line.
262: (8)                    Returns
263: (8)                    -------
264: (8)                    :class:`~.Mobject`
265: (12)                       The positioned label.
266: (8)                    Examples
267: (8)                    --------
268: (8)                    .. manim:: GetYAxisLabelExample
269: (12)                       :save_last_frame:
270: (12)                       class GetYAxisLabelExample(Scene):
271: (16)                           def construct(self):
272: (20)                               ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
273: (20)                               y_label = ax.get_y_axis_label(
274: (24)                                   Tex("$y$-values").scale(0.65).rotate(90 * DEGREES),
275: (24)                                   edge=LEFT,
276: (24)                                   direction=LEFT,
277: (24)                                   buff=0.3,
278: (20)                               )
279: (20)                               self.add(ax, y_label)
280: (8)                    """
281: (8)                    return self._get_axis_label(
282: (12)                       label, self.get_y_axis(), edge, direction, buff=buff, **kwargs
283: (8)                    )
284: (4)                def _get_axis_label(
285: (8)                    self,
286: (8)                    label: float | str | Mobject,
287: (8)                    axis: Mobject,
288: (8)                    edge: Sequence[float],
289: (8)                    direction: Sequence[float],
290: (8)                    buff: float = SMALL_BUFF,
291: (4)                ) -> Mobject:
292: (8)                    """Gets the label for an axis.
293: (8)                    Parameters
294: (8)                    ----------
295: (8)                    label
296: (12)                       The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
297: (8)                    axis
298: (12)                       The axis to which the label will be added.
299: (8)                    edge
300: (12)                       The edge of the axes to which the label will be added. ``RIGHT`` adds to the right side of the axis
301: (8)                    direction
302: (12)                       Allows for further positioning of the label.
303: (8)                    buff
304: (12)                       The distance of the label from the line.
305: (8)                    Returns
306: (8)                    -------
307: (8)                    :class:`~.Mobject`
308: (12)                       The positioned label along the given axis.
309: (8)                    """
310: (8)                    label = self.x_axis._create_label_tex(label)
311: (8)                    label.next_to(axis.get_edge_center(edge), direction=direction, buff=buff)
312: (8)                    label.shift_onto_screen(buff=MED_SMALL_BUFF)
313: (8)                    return label
314: (4)                def get_axis_labels(self):
315: (8)                    raise NotImplementedError()
316: (4)                def add_coordinates(
317: (8)                    self,
318: (8)                    *axes_numbers: Iterable[float] | None | dict[float, str | float | Mobject],
319: (8)                    **kwargs: Any,
320: (4)                ) -> Self:
321: (8)                    """Adds labels to the axes. Use ``Axes.coordinate_labels`` to
322: (8)                    access the coordinates after creation.
323: (8)                    Parameters
324: (8)                    ----------
325: (8)                    axes_numbers
326: (12)                       The numbers to be added to the axes. Use ``None`` to represent an axis with default labels.
327: (8)                    Examples
328: (8)                    --------
329: (8)                    .. code-block:: python
330: (12)                       ax = ThreeDAxes()
331: (12)                       x_labels = range(-4, 5)
332: (12)                       z_labels = range(-4, 4, 2)
333: (12)                       ax.add_coordinates(x_labels, None, z_labels)  # default y labels, custom x & z labels
334: (12)                       ax.add_coordinates(x_labels)  # only x labels
335: (8)                    You can also specifically control the position and value of the labels using a dict.
336: (8)                    .. code-block:: python
337: (12)                       ax = Axes(x_range=[0, 7])
338: (12)                       x_pos = [x for x in range(1, 8)]
339: (12)                       # strings are automatically converted into a Tex mobject.
340: (12)                       x_vals = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
341: (12)                       x_dict = dict(zip(x_pos, x_vals))
342: (12)                       ax.add_coordinates(x_dict)
343: (8)                    """
344: (8)                    self.coordinate_labels = VGroup()
345: (8)                    # if nothing is passed to axes_numbers, produce axes with default labelling
346: (8)                    if not axes_numbers:
347: (12)                       axes_numbers = [None for _ in range(self.dimension)]
348: (8)                    for axis, values in zip(self.axes, axes_numbers):
349: (12)                       if isinstance(values, dict):
350: (16)                           axis.add_labels(values, **kwargs)
351: (16)                           labels = axis.labels
352: (12)                       elif values is None and axis.scaling.custom_labels:
353: (16)                           tick_range = axis.get_tick_range()
354: (16)                           axis.add_labels(
355: (20)                               dict(zip(tick_range, axis.scaling.get_custom_labels(tick_range)))
356: (16)                           )
357: (16)                           labels = axis.labels
358: (12)                       else:
359: (16)                           axis.add_numbers(values, **kwargs)
360: (16)                           labels = axis.numbers
361: (12)                       self.coordinate_labels.add(labels)
362: (8)                    return self
363: (4)                # overload necessary until https://github.com/python/mypy/issues/3737 is supported
364: (4)                @overload
365: (4)                def get_line_from_axis_to_point(
366: (8)                    self,
367: (8)                    index: int,
368: (8)                    point: Sequence[float],
369: (8)                    line_config: dict | None = ...,
370: (8)                    color: ParsableManimColor | None = ...,
371: (8)                    stroke_width: float = ...,
372: (4)                ) -> DashedLine: ...
373: (4)                @overload
374: (4)                def get_line_from_axis_to_point(
375: (8)                    self,
376: (8)                    index: int,
377: (8)                    point: Sequence[float],
378: (8)                    line_func: type[LineType],
379: (8)                    line_config: dict | None = ...,
380: (8)                    color: ParsableManimColor | None = ...,
381: (8)                    stroke_width: float = ...,
382: (4)                ) -> LineType: ...
383: (4)                def get_line_from_axis_to_point(  # type: ignore[no-untyped-def]
384: (8)                    self,
385: (8)                    index,
386: (8)                    point,
387: (8)                    line_func=DashedLine,
388: (8)                    line_config=None,
389: (8)                    color=None,
390: (8)                    stroke_width=2,
391: (4)                ):
392: (8)                    """Returns a straight line from a given axis to a point in the scene.
393: (8)                    Parameters
394: (8)                    ----------
395: (8)                    index
396: (12)                       Specifies the axis from which to draw the line. `0 = x_axis`, `1 = y_axis`
397: (8)                    point
398: (12)                       The point to which the line will be drawn.
399: (8)                    line_func
400: (12)                       The function of the :class:`~.Line` mobject used to construct the line.
401: (8)                    line_config
402: (12)                       Optional arguments to passed to :attr:`line_func`.
403: (8)                    color
404: (12)                       The color of the line.
405: (8)                    stroke_width
406: (12)                       The stroke width of the line.
407: (8)                    Returns
408: (8)                    -------
409: (8)                    :class:`~.Line`
410: (12)                       The line from an axis to a point.
411: (8)                    .. seealso::
412: (12)                       :meth:`~.CoordinateSystem.get_vertical_line`
413: (12)                       :meth:`~.CoordinateSystem.get_horizontal_line`
414: (8)                    """
415: (8)                    line_config = line_config if line_config is not None else {}
416: (8)                    if color is None:
417: (12)                       color = VMobject().color
418: (8)                    line_config["color"] = ManimColor.parse(color)
419: (8)                    line_config["stroke_width"] = stroke_width
420: (8)                    axis = self.get_axis(index)
421: (8)                    line = line_func(axis.get_projection(point), point, **line_config)
422: (8)                    return line
423: (4)                def get_vertical_line(self, point: Sequence[float], **kwargs: Any) -> Line:
424: (8)                    """A vertical line from the x-axis to a given point in the scene.
425: (8)                    Parameters
426: (8)                    ----------
427: (8)                    point
428: (12)                       The point to which the vertical line will be drawn.
429: (8)                    kwargs
430: (12)                       Additional parameters to be passed to :class:`get_line_from_axis_to_point`.
431: (8)                    Returns
432: (8)                    -------
433: (8)                    :class:`Line`
434: (12)                       A vertical line from the x-axis to the point.
435: (8)                    Examples
436: (8)                    --------
437: (8)                    .. manim:: GetVerticalLineExample
438: (12)                       :save_last_frame:
439: (12)                       class GetVerticalLineExample(Scene):
440: (16)                           def construct(self):
441: (20)                               ax = Axes().add_coordinates()
442: (20)                               point = ax.coords_to_point(-3.5, 2)
443: (20)                               dot = Dot(point)
444: (20)                               line = ax.get_vertical_line(point, line_config={"dashed_ratio": 0.85})
445: (20)                               self.add(ax, line, dot)
446: (8)                    """
447: (8)                    return self.get_line_from_axis_to_point(0, point, **kwargs)
448: (4)                def get_horizontal_line(self, point: Sequence[float], **kwargs) -> Line:
449: (8)                    """A horizontal line from the y-axis to a given point in the scene.
450: (8)                    Parameters
451: (8)                    ----------
452: (8)                    point
453: (12)                       The point to which the horizontal line will be drawn.
454: (8)                    kwargs
455: (12)                       Additional parameters to be passed to :class:`get_line_from_axis_to_point`.
456: (8)                    Returns
457: (8)                    -------
458: (8)                    :class:`Line`
459: (12)                       A horizontal line from the y-axis to the point.
460: (8)                    Examples
461: (8)                    --------
462: (8)                    .. manim:: GetHorizontalLineExample
463: (12)                       :save_last_frame:
464: (12)                       class GetHorizontalLineExample(Scene):
465: (16)                           def construct(self):
466: (20)                               ax = Axes().add_coordinates()
467: (20)                               point = ax.c2p(-4, 1.5)
468: (20)                               dot = Dot(point)
469: (20)                               line = ax.get_horizontal_line(point, line_func=Line)
470: (20)                               self.add(ax, line, dot)
471: (8)                    """
472: (8)                    return self.get_line_from_axis_to_point(1, point, **kwargs)
473: (4)                def get_lines_to_point(self, point: Sequence[float], **kwargs) -> VGroup:
474: (8)                    """Generate both horizontal and vertical lines from the axis to a point.
475: (8)                    Parameters
476: (8)                    ----------
477: (8)                    point
478: (12)                       A point on the scene.
479: (8)                    kwargs
480: (12)                       Additional parameters to be passed to :meth:`get_line_from_axis_to_point`
481: (8)                    Returns
482: (8)                    -------
483: (8)                    :class:`~.VGroup`
484: (12)                       A :class:`~.VGroup` of the horizontal and vertical lines.
485: (8)                    .. seealso::
486: (12)                       :meth:`~.CoordinateSystem.get_vertical_line`
487: (12)                       :meth:`~.CoordinateSystem.get_horizontal_line`
488: (8)                    Examples
489: (8)                    --------
490: (8)                    .. manim:: GetLinesToPointExample
491: (12)                       :save_last_frame:
492: (12)                       class GetLinesToPointExample(Scene):
493: (16)                           def construct(self):
494: (20)                               ax = Axes()
495: (20)                               circ = Circle(radius=0.5).move_to([-4, -1.5, 0])
496: (20)                               lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)
497: (20)                               lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)
498: (20)                               self.add(ax, lines_1, lines_2, circ)
499: (8)                    """
500: (8)                    return VGroup(
501: (12)                       self.get_horizontal_line(point, **kwargs),
502: (12)                       self.get_vertical_line(point, **kwargs),
503: (8)                    )
504: (4)                # graphing
505: (4)                def plot(
506: (8)                    self,
507: (8)                    function: Callable[[float], float],
508: (8)                    x_range: Sequence[float] | None = None,
509: (8)                    use_vectorized: bool = False,
510: (8)                    **kwargs: Any,
511: (4)                ) -> ParametricFunction:
512: (8)                    """Generates a curve based on a function.
513: (8)                    Parameters
514: (8)                    ----------
515: (8)                    function
516: (12)                       The function used to construct the :class:`~.ParametricFunction`.
517: (8)                    x_range
518: (12)                       The range of the curve along the axes. ``x_range = [x_min, x_max, x_step]``.
519: (8)                    use_vectorized
520: (12)                       Whether to pass in the generated t value array to the function. Only use this if your function supports it.
521: (12)                       Output should be a numpy array of shape ``[y_0, y_1, ...]``
522: (8)                    kwargs
523: (12)                       Additional parameters to be passed to :class:`~.ParametricFunction`.
524: (8)                    Returns
525: (8)                    -------
526: (8)                    :class:`~.ParametricFunction`
527: (12)                       The plotted curve.
528: (8)                    .. warning::
529: (12)                       This method may not produce accurate graphs since Manim currently relies on interpolation between
530: (12)                       evenly-spaced samples of the curve, instead of intelligent plotting.
531: (12)                       See the example below for some solutions to this problem.
532: (8)                    Examples
533: (8)                    --------
534: (8)                    .. manim:: PlotExample
535: (12)                       :save_last_frame:
536: (12)                       class PlotExample(Scene):
537: (16)                           def construct(self):
538: (20)                               # construct the axes
539: (20)                               ax_1 = Axes(
540: (24)                                   x_range=[0.001, 6],
541: (24)                                   y_range=[-8, 2],
542: (24)                                   x_length=5,
543: (24)                                   y_length=3,
544: (24)                                   tips=False,
545: (20)                               )
546: (20)                               ax_2 = ax_1.copy()
547: (20)                               ax_3 = ax_1.copy()
548: (20)                               # position the axes
549: (20)                               ax_1.to_corner(UL)
550: (20)                               ax_2.to_corner(UR)
551: (20)                               ax_3.to_edge(DOWN)
552: (20)                               axes = VGroup(ax_1, ax_2, ax_3)
553: (20)                               # create the logarithmic curves
554: (20)                               def log_func(x):
555: (24)                                   return np.log(x)
556: (20)                               # a curve without adjustments; poor interpolation.
557: (20)                               curve_1 = ax_1.plot(log_func, color=PURE_RED)
558: (20)                               # disabling interpolation makes the graph look choppy as not enough
559: (20)                               # inputs are available
560: (20)                               curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)
561: (20)                               # taking more inputs of the curve by specifying a step for the
562: (20)                               # x_range yields expected results, but increases rendering time.
563: (20)                               curve_3 = ax_3.plot(
564: (24)                                   log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN
565: (20)                               )
566: (20)                               curves = VGroup(curve_1, curve_2, curve_3)
567: (20)                               self.add(axes, curves)
568: (8)                    """
569: (8)                    t_range = np.array(self.x_range, dtype=float)
570: (8)                    if x_range is not None:
571: (12)                       t_range[: len(x_range)] = x_range
572: (8)                    if x_range is None or len(x_range) < 3:
573: (12)                       # if t_range has a defined step size, increase the number of sample points per tick
574: (12)                       t_range[2] /= self.num_sampled_graph_points_per_tick
575: (8)                    # For axes, the third coordinate of x_range indicates
576: (8)                    # tick frequency.  But for functions, it indicates a
577: (8)                    # sample frequency
578: (8)                    graph = ParametricFunction(
579: (12)                       lambda t: self.coords_to_point(t, function(t)),
580: (12)                       t_range=t_range,
581: (12)                       scaling=self.x_axis.scaling,
582: (12)                       use_vectorized=use_vectorized,
583: (12)                       **kwargs,
584: (8)                    )
585: (8)                    graph.underlying_function = function
586: (8)                    return graph
587: (4)                def plot_implicit_curve(
588: (8)                    self,
589: (8)                    func: Callable[[float, float], float],
590: (8)                    min_depth: int = 5,
591: (8)                    max_quads: int = 1500,
592: (8)                    **kwargs: Any,
593: (4)                ) -> ImplicitFunction:
594: (8)                    """Creates the curves of an implicit function.
595: (8)                    Parameters
596: (8)                    ----------
597: (8)                    func
598: (12)                       The function to graph, in the form of f(x, y) = 0.
599: (8)                    min_depth
600: (12)                       The minimum depth of the function to calculate.
601: (8)                    max_quads
602: (12)                       The maximum number of quads to use.
603: (8)                    kwargs
604: (12)                       Additional parameters to pass into :class:`ImplicitFunction`.
605: (8)                    Examples
606: (8)                    --------
607: (8)                    .. manim:: ImplicitExample
608: (12)                       :save_last_frame:
609: (12)                       class ImplicitExample(Scene):
610: (16)                           def construct(self):
611: (20)                               ax = Axes()
612: (20)                               a = ax.plot_implicit_curve(
613: (24)                                   lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE
614: (20)                               )
615: (20)                               self.add(ax, a)
616: (8)                    """
617: (8)                    x_scale = self.get_x_axis().scaling
618: (8)                    y_scale = self.get_y_axis().scaling
619: (8)                    graph = ImplicitFunction(
620: (12)                       func=(lambda x, y: func(x_scale.function(x), y_scale.function(y))),
621: (12)                       x_range=self.x_range[:2],
622: (12)                       y_range=self.y_range[:2],
623: (12)                       min_depth=min_depth,
624: (12)                       max_quads=max_quads,
625: (12)                       **kwargs,
626: (8)                    )
627: (8)                    (
628: (12)                       graph.stretch(self.get_x_unit_size(), 0, about_point=ORIGIN)
629: (12)                       .stretch(self.get_y_unit_size(), 1, about_point=ORIGIN)
630: (12)                       .shift(self.get_origin())
631: (8)                    )
632: (8)                    return graph
633: (4)                def plot_parametric_curve(
634: (8)                    self,
635: (8)                    function: Callable[[float], np.ndarray],
636: (8)                    use_vectorized: bool = False,
637: (8)                    **kwargs: Any,
638: (4)                ) -> ParametricFunction:
639: (8)                    """A parametric curve.
640: (8)                    Parameters
641: (8)                    ----------
642: (8)                    function
643: (12)                       A parametric function mapping a number to a point in the
644: (12)                       coordinate system.
645: (8)                    use_vectorized
646: (12)                       Whether to pass in the generated t value array to the function. Only use this if your function supports it.
647: (8)                    kwargs
648: (12)                       Any further keyword arguments are passed to :class:`.ParametricFunction`.
649: (8)                    Example
650: (8)                    -------
651: (8)                    .. manim:: ParametricCurveExample
652: (12)                       :save_last_frame:
653: (12)                       class ParametricCurveExample(Scene):
654: (16)                           def construct(self):
655: (20)                               ax = Axes()
656: (20)                               cardioid = ax.plot_parametric_curve(
657: (24)                                   lambda t: np.array(
658: (28)                                       [
659: (32)                                           np.exp(1) * np.cos(t) * (1 - np.cos(t)),
660: (32)                                           np.exp(1) * np.sin(t) * (1 - np.cos(t)),
661: (32)                                           0,
662: (28)                                       ]
663: (24)                                   ),
664: (24)                                   t_range=[0, 2 * PI],
665: (24)                                   color="#0FF1CE",
666: (20)                               )
667: (20)                               self.add(ax, cardioid)
668: (8)                    """
669: (8)                    dim = self.dimension
670: (8)                    graph = ParametricFunction(
671: (12)                       lambda t: self.coords_to_point(*function(t)[:dim]),
672: (12)                       use_vectorized=use_vectorized,
673: (12)                       **kwargs,
674: (8)                    )
675: (8)                    graph.underlying_function = function
676: (8)                    return graph
677: (4)                def plot_polar_graph(
678: (8)                    self,
679: (8)                    r_func: Callable[[float], float],
680: (8)                    theta_range: Sequence[float] | None = None,
681: (8)                    **kwargs: Any,
682: (4)                ) -> ParametricFunction:
683: (8)                    """A polar graph.
684: (8)                    Parameters
685: (8)                    ----------
686: (8)                    r_func
687: (12)                       The function r of theta.
688: (8)                    theta_range
689: (12)                       The range of theta as ``theta_range = [theta_min, theta_max, theta_step]``.
690: (8)                    kwargs
691: (12)                       Additional parameters passed to :class:`~.ParametricFunction`.
692: (8)                    Examples
693: (8)                    --------
694: (8)                    .. manim:: PolarGraphExample
695: (12)                       :ref_classes: PolarPlane
696: (12)                       :save_last_frame:
697: (12)                       class PolarGraphExample(Scene):
698: (16)                           def construct(self):
699: (20)                               plane = PolarPlane()
700: (20)                               r = lambda theta: 2 * np.sin(theta * 5)
701: (20)                               graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)
702: (20)                               self.add(plane, graph)
703: (8)                    """
704: (8)                    theta_range = theta_range if theta_range is not None else [0, 2 * PI]
705: (8)                    graph = ParametricFunction(
706: (12)                       function=lambda th: self.pr2pt(r_func(th), th),
707: (12)                       t_range=theta_range,
708: (12)                       **kwargs,
709: (8)                    )
710: (8)                    graph.underlying_function = r_func
711: (8)                    return graph
712: (4)                def plot_surface(
713: (8)                    self,
714: (8)                    function: Callable[[float], float],
715: (8)                    u_range: Sequence[float] | None = None,
716: (8)                    v_range: Sequence[float] | None = None,
717: (8)                    colorscale: (
718: (12)                       Sequence[ParsableManimColor]
719: (12)                       | Sequence[tuple[ParsableManimColor, float]]
720: (12)                       | None
721: (8)                    ) = None,
722: (8)                    colorscale_axis: int = 2,
723: (8)                    **kwargs: Any,
724: (4)                ) -> Surface | OpenGLSurface:
725: (8)                    """Generates a surface based on a function.
726: (8)                    Parameters
727: (8)                    ----------
728: (8)                    function
729: (12)                       The function used to construct the :class:`~.Surface`.
730: (8)                    u_range
731: (12)                       The range of the ``u`` variable: ``(u_min, u_max)``.
732: (8)                    v_range
733: (12)                       The range of the ``v`` variable: ``(v_min, v_max)``.
734: (8)                    colorscale
735: (12)                       Colors of the surface. Passing a list of colors will color the surface by z-value.
736: (12)                       Passing a list of tuples in the form ``(color, pivot)`` allows user-defined pivots
737: (12)                       where the color transitions.
738: (8)                    colorscale_axis
739: (12)                       Defines the axis on which the colorscale is applied (0 = x, 1 = y, 2 = z), default
740: (12)                       is z-axis (2).
741: (8)                    kwargs
742: (12)                       Additional parameters to be passed to :class:`~.Surface`.
743: (8)                    Returns
744: (8)                    -------
745: (8)                    :class:`~.Surface`
746: (12)                       The plotted surface.
747: (8)                    Examples
748: (8)                    --------
749: (8)                    .. manim:: PlotSurfaceExample
750: (12)                       :save_last_frame:
751: (12)                       class PlotSurfaceExample(ThreeDScene):
752: (16)                           def construct(self):
753: (20)                               resolution_fa = 16
754: (20)                               self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)
755: (20)                               axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))
756: (20)                               def param_trig(u, v):
757: (24)                                   x = u
758: (24)                                   y = v
759: (24)                                   z = 2 * np.sin(x) + 2 * np.cos(y)
760: (24)                                   return z
761: (20)                               trig_plane = axes.plot_surface(
762: (24)                                   param_trig,
763: (24)                                   resolution=(resolution_fa, resolution_fa),
764: (24)                                   u_range = (-3, 3),
765: (24)                                   v_range = (-3, 3),
766: (24)                                   colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],
767: (24)                                   )
768: (20)                               self.add(axes, trig_plane)
769: (8)                    """
770: (8)                    if config.renderer == RendererType.CAIRO:
771: (12)                       surface = Surface(
772: (16)                           lambda u, v: self.c2p(u, v, function(u, v)),
773: (16)                           u_range=u_range,
774: (16)                           v_range=v_range,
775: (16)                           **kwargs,
776: (12)                       )
777: (12)                       if colorscale:
778: (16)                           surface.set_fill_by_value(
779: (20)                               axes=self.copy(),
780: (20)                               colorscale=colorscale,
781: (20)                               axis=colorscale_axis,
782: (16)                           )
783: (8)                    elif config.renderer == RendererType.OPENGL:
784: (12)                       surface = OpenGLSurface(
785: (16)                           lambda u, v: self.c2p(u, v, function(u, v)),
786: (16)                           u_range=u_range,
787: (16)                           v_range=v_range,
788: (16)                           axes=self.copy(),
789: (16)                           colorscale=colorscale,
790: (16)                           colorscale_axis=colorscale_axis,
791: (16)                           **kwargs,
792: (12)                       )
793: (8)                    return surface
794: (4)                def input_to_graph_point(
795: (8)                    self,
796: (8)                    x: float,
797: (8)                    graph: ParametricFunction | VMobject,
798: (4)                ) -> np.ndarray:
799: (8)                    """Returns the coordinates of the point on a ``graph`` corresponding to an ``x`` value.
800: (8)                    Parameters
801: (8)                    ----------
802: (8)                    x
803: (12)                       The x-value of a point on the ``graph``.
804: (8)                    graph
805: (12)                       The :class:`~.ParametricFunction` on which the point lies.
806: (8)                    Returns
807: (8)                    -------
808: (8)                    :class:`np.ndarray`
809: (12)                       The coordinates of the point on the :attr:`graph` corresponding to the :attr:`x` value.
810: (8)                    Raises
811: (8)                    ------
812: (8)                    :exc:`ValueError`
813: (12)                       When the target x is not in the range of the line graph.
814: (8)                    Examples
815: (8)                    --------
816: (8)                    .. manim:: InputToGraphPointExample
817: (12)                       :save_last_frame:
818: (12)                       class InputToGraphPointExample(Scene):
819: (16)                           def construct(self):
820: (20)                               ax = Axes()
821: (20)                               curve = ax.plot(lambda x : np.cos(x))
822: (20)                               # move a square to PI on the cosine curve.
823: (20)                               position = ax.input_to_graph_point(x=PI, graph=curve)
824: (20)                               sq = Square(side_length=1, color=YELLOW).move_to(position)
825: (20)                               self.add(ax, curve, sq)
826: (8)                    """
827: (8)                    if hasattr(graph, "underlying_function"):
828: (12)                       return graph.function(x)
829: (8)                    else:
830: (12)                       alpha = binary_search(
831: (16)                           function=lambda a: self.point_to_coords(graph.point_from_proportion(a))[
832: (20)                               0
833: (16)                           ],
834: (16)                           target=x,
835: (16)                           lower_bound=0,
836: (16)                           upper_bound=1,
837: (12)                       )
838: (12)                       if alpha is not None:
839: (16)                           return graph.point_from_proportion(alpha)
840: (12)                       else:
841: (16)                           raise ValueError(
842: (20)                               f"x={x} not located in the range of the graph ([{self.p2c(graph.get_start())[0]}, {self.p2c(graph.get_end())[0]}])",
843: (16)                           )
844: (4)                def input_to_graph_coords(
845: (8)                    self, x: float, graph: ParametricFunction
846: (4)                ) -> tuple[float, float]:
847: (8)                    """Returns a tuple of the axis relative coordinates of the point
848: (8)                    on the graph based on the x-value given.
849: (8)                    Examples
850: (8)                    --------
851: (8)                    .. code-block:: pycon
852: (12)                       >>> from manim import Axes
853: (12)                       >>> ax = Axes()
854: (12)                       >>> parabola = ax.plot(lambda x: x**2)
855: (12)                       >>> ax.input_to_graph_coords(x=3, graph=parabola)
856: (12)                       (3, 9)
857: (8)                    """
858: (8)                    return x, graph.underlying_function(x)
859: (4)                def i2gc(self, x: float, graph: ParametricFunction) -> tuple[float, float]:
860: (8)                    """Alias for :meth:`input_to_graph_coords`."""
861: (8)                    return self.input_to_graph_coords(x, graph)
862: (4)                def i2gp(self, x: float, graph: ParametricFunction) -> np.ndarray:
863: (8)                    """Alias for :meth:`input_to_graph_point`."""
864: (8)                    return self.input_to_graph_point(x, graph)
865: (4)                def get_graph_label(
866: (8)                    self,
867: (8)                    graph: ParametricFunction,
868: (8)                    label: float | str | Mobject = "f(x)",
869: (8)                    x_val: float | None = None,
870: (8)                    direction: Sequence[float] = RIGHT,
871: (8)                    buff: float = MED_SMALL_BUFF,
872: (8)                    color: ParsableManimColor | None = None,
873: (8)                    dot: bool = False,
874: (8)                    dot_config: dict[str, Any] | None = None,
875: (4)                ) -> Mobject:
876: (8)                    """Creates a properly positioned label for the passed graph, with an optional dot.
877: (8)                    Parameters
878: (8)                    ----------
879: (8)                    graph
880: (12)                       The curve.
881: (8)                    label
882: (12)                       The label for the function's curve. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
883: (8)                    x_val
884: (12)                       The x_value along the curve that positions the label.
885: (8)                    direction
886: (12)                       The cartesian position, relative to the curve that the label will be at --> ``LEFT``, ``RIGHT``.
887: (8)                    buff
888: (12)                       The distance between the curve and the label.
889: (8)                    color
890: (12)                       The color of the label. Defaults to the color of the curve.
891: (8)                    dot
892: (12)                       Whether to add a dot at the point on the graph.
893: (8)                    dot_config
894: (12)                       Additional parameters to be passed to :class:`~.Dot`.
895: (8)                    Returns
896: (8)                    -------
897: (8)                    :class:`Mobject`
898: (12)                       The positioned label and :class:`~.Dot`, if applicable.
899: (8)                    Examples
900: (8)                    --------
901: (8)                    .. manim:: GetGraphLabelExample
902: (12)                       :save_last_frame:
903: (12)                       class GetGraphLabelExample(Scene):
904: (16)                           def construct(self):
905: (20)                               ax = Axes()
906: (20)                               sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)
907: (20)                               label = ax.get_graph_label(
908: (24)                                   graph=sin,
909: (24)                                   label= MathTex(r"\\frac{\\pi}{2}"),
910: (24)                                   x_val=PI / 2,
911: (24)                                   dot=True,
912: (24)                                   direction=UR,
913: (20)                               )
914: (20)                               self.add(ax, sin, label)
915: (8)                    """
916: (8)                    if dot_config is None:
917: (12)                       dot_config = {}
918: (8)                    if color is None:
919: (12)                       color = graph.get_color()
920: (8)                    label = self.x_axis._create_label_tex(label).set_color(color)
921: (8)                    if x_val is None:
922: (12)                       # Search from right to left
923: (12)                       for x in np.linspace(self.x_range[1], self.x_range[0], 100):
924: (16)                           point = self.input_to_graph_point(x, graph)
925: (16)                           if point[1] < config["frame_y_radius"]:
926: (20)                               break
927: (8)                    else:
928: (12)                       point = self.input_to_graph_point(x_val, graph)
929: (8)                    label.next_to(point, direction, buff=buff)
930: (8)                    label.shift_onto_screen()
931: (8)                    if dot:
932: (12)                       dot = Dot(point=point, **dot_config)
933: (12)                       label.add(dot)
934: (12)                       label.dot = dot
935: (8)                    return label
936: (4)                # calculus
937: (4)                def get_riemann_rectangles(
938: (8)                    self,
939: (8)                    graph: ParametricFunction,
940: (8)                    x_range: Sequence[float] | None = None,
941: (8)                    dx: float | None = 0.1,
942: (8)                    input_sample_type: str = "left",
943: (8)                    stroke_width: float = 1,
944: (8)                    stroke_color: ParsableManimColor = BLACK,
945: (8)                    fill_opacity: float = 1,
946: (8)                    color: Iterable[ParsableManimColor] | ParsableManimColor = (BLUE, GREEN),
947: (8)                    show_signed_area: bool = True,
948: (8)                    bounded_graph: ParametricFunction = None,
949: (8)                    blend: bool = False,
950: (8)                    width_scale_factor: float = 1.001,
951: (4)                ) -> VGroup:
952: (8)                    """Generates a :class:`~.VGroup` of the Riemann Rectangles for a given curve.
953: (8)                    Parameters
954: (8)                    ----------
955: (8)                    graph
956: (12)                       The graph whose area will be approximated by Riemann rectangles.
957: (8)                    x_range
958: (12)                       The minimum and maximum x-values of the rectangles. ``x_range = [x_min, x_max]``.
959: (8)                    dx
960: (12)                       The change in x-value that separates each rectangle.
961: (8)                    input_sample_type
962: (12)                       Can be any of ``"left"``, ``"right"`` or ``"center"``. Refers to where
963: (12)                       the sample point for the height of each Riemann Rectangle
964: (12)                       will be inside the segments of the partition.
965: (8)                    stroke_width
966: (12)                       The stroke_width of the border of the rectangles.
967: (8)                    stroke_color
968: (12)                       The color of the border of the rectangle.
969: (8)                    fill_opacity
970: (12)                       The opacity of the rectangles.
971: (8)                    color
972: (12)                       The colors of the rectangles. Creates a balanced gradient if multiple colors are passed.
973: (8)                    show_signed_area
974: (12)                       Indicates negative area when the curve dips below the x-axis by inverting its color.
975: (8)                    blend
976: (12)                       Sets the :attr:`stroke_color` to :attr:`fill_color`, blending the rectangles without clear separation.
977: (8)                    bounded_graph
978: (12)                       If a secondary graph is specified, encloses the area between the two curves.
979: (8)                    width_scale_factor
980: (12)                       The factor by which the width of the rectangles is scaled.
981: (8)                    Returns
982: (8)                    -------
983: (8)                    :class:`~.VGroup`
984: (12)                       A :class:`~.VGroup` containing the Riemann Rectangles.
985: (8)                    Examples
986: (8)                    --------
987: (8)                    .. manim:: GetRiemannRectanglesExample
988: (12)                       :save_last_frame:
989: (12)                       class GetRiemannRectanglesExample(Scene):
990: (16)                           def construct(self):
991: (20)                               ax = Axes(y_range=[-2, 10])
992: (20)                               quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)
993: (20)                               # the rectangles are constructed from their top right corner.
994: (20)                               # passing an iterable to `color` produces a gradient
995: (20)                               rects_right = ax.get_riemann_rectangles(
996: (24)                                   quadratic,
997: (24)                                   x_range=[-4, -3],
998: (24)                                   dx=0.25,
999: (24)                                   color=(TEAL, BLUE_B, DARK_BLUE),
1000: (24)                                  input_sample_type="right",
1001: (20)                              )
1002: (20)                              # the colour of rectangles below the x-axis is inverted
1003: (20)                              # due to show_signed_area
1004: (20)                              rects_left = ax.get_riemann_rectangles(
1005: (24)                                  quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW
1006: (20)                              )
1007: (20)                              bounding_line = ax.plot(
1008: (24)                                  lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]
1009: (20)                              )
1010: (20)                              bounded_rects = ax.get_riemann_rectangles(
1011: (24)                                  bounding_line,
1012: (24)                                  bounded_graph=quadratic,
1013: (24)                                  dx=0.15,
1014: (24)                                  x_range=[4, 5],
1015: (24)                                  show_signed_area=False,
1016: (24)                                  color=(MAROON_A, RED_B, PURPLE_D),
1017: (20)                              )
1018: (20)                              self.add(
1019: (24)                                  ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects
1020: (20)                              )
1021: (8)                   """
1022: (8)                   # setting up x_range, overwrite user's third input
1023: (8)                   if x_range is None:
1024: (12)                      if bounded_graph is None:
1025: (16)                          x_range = [graph.t_min, graph.t_max]
1026: (12)                      else:
1027: (16)                          x_min = max(graph.t_min, bounded_graph.t_min)
1028: (16)                          x_max = min(graph.t_max, bounded_graph.t_max)
1029: (16)                          x_range = [x_min, x_max]
1030: (8)                   x_range = [*x_range[:2], dx]
1031: (8)                   rectangles = VGroup()
1032: (8)                   x_range = np.arange(*x_range)
1033: (8)                   if isinstance(color, (list, tuple)):
1034: (12)                      color = [ManimColor(c) for c in color]
1035: (8)                   else:
1036: (12)                      color = [ManimColor(color)]
1037: (8)                   colors = color_gradient(color, len(x_range))
1038: (8)                   for x, color in zip(x_range, colors):
1039: (12)                      if input_sample_type == "left":
1040: (16)                          sample_input = x
1041: (12)                      elif input_sample_type == "right":
1042: (16)                          sample_input = x + dx
1043: (12)                      elif input_sample_type == "center":
1044: (16)                          sample_input = x + 0.5 * dx
1045: (12)                      else:
1046: (16)                          raise ValueError("Invalid input sample type")
1047: (12)                      graph_point = self.input_to_graph_point(sample_input, graph)
1048: (12)                      if bounded_graph is None:
1049: (16)                          y_point = self._origin_shift(self.y_range)
1050: (12)                      else:
1051: (16)                          y_point = bounded_graph.underlying_function(x)
1052: (12)                      points = VGroup(
1053: (16)                          *list(
1054: (20)                              map(
1055: (24)                                  VectorizedPoint,
1056: (24)                                  [
1057: (28)                                      self.coords_to_point(x, y_point),
1058: (28)                                      self.coords_to_point(x + width_scale_factor * dx, y_point),
1059: (28)                                      graph_point,
1060: (24)                                  ],
1061: (20)                              ),
1062: (16)                          )
1063: (12)                      )
1064: (12)                      rect = Rectangle().replace(points, stretch=True)
1065: (12)                      rectangles.add(rect)
1066: (12)                      # checks if the rectangle is under the x-axis
1067: (12)                      if self.p2c(graph_point)[1] < y_point and show_signed_area:
1068: (16)                          color = invert_color(color)
1069: (12)                      # blends rectangles smoothly
1070: (12)                      if blend:
1071: (16)                          stroke_color = color
1072: (12)                      rect.set_style(
1073: (16)                          fill_color=color,
1074: (16)                          fill_opacity=fill_opacity,
1075: (16)                          stroke_color=stroke_color,
1076: (16)                          stroke_width=stroke_width,
1077: (12)                      )
1078: (8)                   return rectangles
1079: (4)               def get_area(
1080: (8)                   self,
1081: (8)                   graph: ParametricFunction,
1082: (8)                   x_range: tuple[float, float] | None = None,
1083: (8)                   color: ParsableManimColor | Iterable[ParsableManimColor] = (BLUE, GREEN),
1084: (8)                   opacity: float = 0.3,
1085: (8)                   bounded_graph: ParametricFunction = None,
1086: (8)                   **kwargs: Any,
1087: (4)               ) -> Polygon:
1088: (8)                   """Returns a :class:`~.Polygon` representing the area under the graph passed.
1089: (8)                   Parameters
1090: (8)                   ----------
1091: (8)                   graph
1092: (12)                      The graph/curve for which the area needs to be gotten.
1093: (8)                   x_range
1094: (12)                      The range of the minimum and maximum x-values of the area. ``x_range = [x_min, x_max]``.
1095: (8)                   color
1096: (12)                      The color of the area. Creates a gradient if a list of colors is provided.
1097: (8)                   opacity
1098: (12)                      The opacity of the area.
1099: (8)                   bounded_graph
1100: (12)                      If a secondary :attr:`graph` is specified, encloses the area between the two curves.
1101: (8)                   kwargs
1102: (12)                      Additional parameters passed to :class:`~.Polygon`.
1103: (8)                   Returns
1104: (8)                   -------
1105: (8)                   :class:`~.Polygon`
1106: (12)                      The :class:`~.Polygon` representing the area.
1107: (8)                   Raises
1108: (8)                   ------
1109: (8)                   :exc:`ValueError`
1110: (12)                      When x_ranges do not match (either area x_range, graph's x_range or bounded_graph's x_range).
1111: (8)                   Examples
1112: (8)                   --------
1113: (8)                   .. manim:: GetAreaExample
1114: (12)                      :save_last_frame:
1115: (12)                      class GetAreaExample(Scene):
1116: (16)                          def construct(self):
1117: (20)                              ax = Axes().add_coordinates()
1118: (20)                              curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)
1119: (20)                              area = ax.get_area(
1120: (24)                                  curve,
1121: (24)                                  x_range=(PI / 2, 3 * PI / 2),
1122: (24)                                  color=(GREEN_B, GREEN_D),
1123: (24)                                  opacity=1,
1124: (20)                              )
1125: (20)                              self.add(ax, curve, area)
1126: (8)                   """
1127: (8)                   if x_range is None:
1128: (12)                      a = graph.t_min
1129: (12)                      b = graph.t_max
1130: (8)                   else:
1131: (12)                      a, b = x_range
1132: (8)                   if bounded_graph is not None:
1133: (12)                      if bounded_graph.t_min > b:
1134: (16)                          raise ValueError(
1135: (20)                              f"Ranges not matching: {bounded_graph.t_min} < {b}",
1136: (16)                          )
1137: (12)                      if bounded_graph.t_max < a:
1138: (16)                          raise ValueError(
1139: (20)                              f"Ranges not matching: {bounded_graph.t_max} > {a}",
1140: (16)                          )
1141: (12)                      a = max(a, bounded_graph.t_min)
1142: (12)                      b = min(b, bounded_graph.t_max)
1143: (8)                   if bounded_graph is None:
1144: (12)                      points = (
1145: (16)                          [self.c2p(a), graph.function(a)]
1146: (16)                          + [p for p in graph.points if a <= self.p2c(p)[0] <= b]
1147: (16)                          + [graph.function(b), self.c2p(b)]
1148: (12)                      )
1149: (8)                   else:
1150: (12)                      graph_points, bounded_graph_points = (
1151: (16)                          [g.function(a)]
1152: (16)                          + [p for p in g.points if a <= self.p2c(p)[0] <= b]
1153: (16)                          + [g.function(b)]
1154: (16)                          for g in (graph, bounded_graph)
1155: (12)                      )
1156: (12)                      points = graph_points + bounded_graph_points[::-1]
1157: (8)                   return Polygon(*points, **kwargs).set_opacity(opacity).set_color(color)
1158: (4)               def angle_of_tangent(
1159: (8)                   self,
1160: (8)                   x: float,
1161: (8)                   graph: ParametricFunction,
1162: (8)                   dx: float = 1e-8,
1163: (4)               ) -> float:
1164: (8)                   """Returns the angle to the x-axis of the tangent
1165: (8)                   to the plotted curve at a particular x-value.
1166: (8)                   Parameters
1167: (8)                   ----------
1168: (8)                   x
1169: (12)                      The x-value at which the tangent must touch the curve.
1170: (8)                   graph
1171: (12)                      The :class:`~.ParametricFunction` for which to calculate the tangent.
1172: (8)                   dx
1173: (12)                      The change in `x` used to determine the angle of the tangent to the curve.
1174: (8)                   Returns
1175: (8)                   -------
1176: (8)                   :class:`float`
1177: (12)                      The angle of the tangent to the curve.
1178: (8)                   Examples
1179: (8)                   --------
1180: (8)                   .. code-block:: python
1181: (12)                      ax = Axes()
1182: (12)                      curve = ax.plot(lambda x: x**2)
1183: (12)                      ax.angle_of_tangent(x=3, graph=curve)
1184: (12)                      # 1.4056476493802699
1185: (8)                   """
1186: (8)                   p0 = np.array([*self.input_to_graph_coords(x, graph)])
1187: (8)                   p1 = np.array([*self.input_to_graph_coords(x + dx, graph)])
1188: (8)                   return angle_of_vector(p1 - p0)
1189: (4)               def slope_of_tangent(
1190: (8)                   self, x: float, graph: ParametricFunction, **kwargs: Any
1191: (4)               ) -> float:
1192: (8)                   """Returns the slope of the tangent to the plotted curve
1193: (8)                   at a particular x-value.
1194: (8)                   Parameters
1195: (8)                   ----------
1196: (8)                   x
1197: (12)                      The x-value at which the tangent must touch the curve.
1198: (8)                   graph
1199: (12)                      The :class:`~.ParametricFunction` for which to calculate the tangent.
1200: (8)                   Returns
1201: (8)                   -------
1202: (8)                   :class:`float`
1203: (12)                      The slope of the tangent with the x axis.
1204: (8)                   Examples
1205: (8)                   --------
1206: (8)                   .. code-block:: python
1207: (12)                      ax = Axes()
1208: (12)                      curve = ax.plot(lambda x: x**2)
1209: (12)                      ax.slope_of_tangent(x=-2, graph=curve)
1210: (12)                      # -3.5000000259052038
1211: (8)                   """
1212: (8)                   return np.tan(self.angle_of_tangent(x, graph, **kwargs))
1213: (4)               def plot_derivative_graph(
1214: (8)                   self, graph: ParametricFunction, color: ParsableManimColor = GREEN, **kwargs
1215: (4)               ) -> ParametricFunction:
1216: (8)                   """Returns the curve of the derivative of the passed graph.
1217: (8)                   Parameters
1218: (8)                   ----------
1219: (8)                   graph
1220: (12)                      The graph for which the derivative will be found.
1221: (8)                   color
1222: (12)                      The color of the derivative curve.
1223: (8)                   kwargs
1224: (12)                      Any valid keyword argument of :class:`~.ParametricFunction`.
1225: (8)                   Returns
1226: (8)                   -------
1227: (8)                   :class:`~.ParametricFunction`
1228: (12)                      The curve of the derivative.
1229: (8)                   Examples
1230: (8)                   --------
1231: (8)                   .. manim:: DerivativeGraphExample
1232: (12)                      :save_last_frame:
1233: (12)                      class DerivativeGraphExample(Scene):
1234: (16)                          def construct(self):
1235: (20)                              ax = NumberPlane(y_range=[-1, 7], background_line_style={"stroke_opacity": 0.4})
1236: (20)                              curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)
1237: (20)                              curve_2 = ax.plot_derivative_graph(curve_1)
1238: (20)                              curves = VGroup(curve_1, curve_2)
1239: (20)                              label_1 = ax.get_graph_label(curve_1, "x^2", x_val=-2, direction=DL)
1240: (20)                              label_2 = ax.get_graph_label(curve_2, "2x", x_val=3, direction=RIGHT)
1241: (20)                              labels = VGroup(label_1, label_2)
1242: (20)                              self.add(ax, curves, labels)
1243: (8)                   """
1244: (8)                   def deriv(x):
1245: (12)                      return self.slope_of_tangent(x, graph)
1246: (8)                   return self.plot(deriv, color=color, **kwargs)
1247: (4)               def plot_antiderivative_graph(
1248: (8)                   self,
1249: (8)                   graph: ParametricFunction,
1250: (8)                   y_intercept: float = 0,
1251: (8)                   samples: int = 50,
1252: (8)                   use_vectorized: bool = False,
1253: (8)                   **kwargs: Any,
1254: (4)               ) -> ParametricFunction:
1255: (8)                   """Plots an antiderivative graph.
1256: (8)                   Parameters
1257: (8)                   ----------
1258: (8)                   graph
1259: (12)                      The graph for which the antiderivative will be found.
1260: (8)                   y_intercept
1261: (12)                      The y-value at which the graph intercepts the y-axis.
1262: (8)                   samples
1263: (12)                      The number of points to take the area under the graph.
1264: (8)                   use_vectorized
1265: (12)                      Whether to use the vectorized version of the antiderivative. This means
1266: (12)                      to pass in the generated t value array to the function. Only use this if your function supports it.
1267: (12)                      Output should be a numpy array of shape ``[y_0, y_1, ...]``
1268: (8)                   kwargs
1269: (12)                      Any valid keyword argument of :class:`~.ParametricFunction`.
1270: (8)                   Returns
1271: (8)                   -------
1272: (8)                   :class:`~.ParametricFunction`
1273: (12)                      The curve of the antiderivative.
1274: (8)                   .. note::
1275: (12)                      This graph is plotted from the values of area under the reference graph.
1276: (12)                      The result might not be ideal if the reference graph contains uncalculatable
1277: (12)                      areas from x=0.
1278: (8)                   Examples
1279: (8)                   --------
1280: (8)                   .. manim:: AntiderivativeExample
1281: (12)                      :save_last_frame:
1282: (12)                      class AntiderivativeExample(Scene):
1283: (16)                          def construct(self):
1284: (20)                              ax = Axes()
1285: (20)                              graph1 = ax.plot(
1286: (24)                                  lambda x: (x ** 2 - 2) / 3,
1287: (24)                                  color=RED,
1288: (20)                              )
1289: (20)                              graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)
1290: (20)                              self.add(ax, graph1, graph2)
1291: (8)                   """
1292: (8)                   def antideriv(x):
1293: (12)                      x_vals = np.linspace(0, x, samples, axis=1 if use_vectorized else 0)
1294: (12)                      f_vec = np.vectorize(graph.underlying_function)
1295: (12)                      y_vals = f_vec(x_vals)
1296: (12)                      return np.trapz(y_vals, x_vals) + y_intercept
1297: (8)                   return self.plot(antideriv, use_vectorized=use_vectorized, **kwargs)
1298: (4)               def get_secant_slope_group(
1299: (8)                   self,
1300: (8)                   x: float,
1301: (8)                   graph: ParametricFunction,
1302: (8)                   dx: float | None = None,
1303: (8)                   dx_line_color: ParsableManimColor = YELLOW,
1304: (8)                   dy_line_color: ParsableManimColor | None = None,
1305: (8)                   dx_label: float | str | None = None,
1306: (8)                   dy_label: float | str | None = None,
1307: (8)                   include_secant_line: bool = True,
1308: (8)                   secant_line_color: ParsableManimColor = GREEN,
1309: (8)                   secant_line_length: float = 10,
1310: (4)               ) -> VGroup:
1311: (8)                   """Creates two lines representing `dx` and `df`, the labels for `dx` and `df`, and
1312: (9)                    the secant to the curve at a particular x-value.
1313: (8)                   Parameters
1314: (8)                   ----------
1315: (8)                   x
1316: (12)                      The x-value at which the secant intersects the graph for the first time.
1317: (8)                   graph
1318: (12)                      The curve for which the secant will be found.
1319: (8)                   dx
1320: (12)                      The change in `x` after which the secant exits.
1321: (8)                   dx_line_color
1322: (12)                      The color of the line that indicates the change in `x`.
1323: (8)                   dy_line_color
1324: (12)                      The color of the line that indicates the change in `y`. Defaults to the color of :attr:`graph`.
1325: (8)                   dx_label
1326: (12)                      The label for the `dx` line. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
1327: (8)                   dy_label
1328: (12)                      The label for the `dy` line. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
1329: (8)                   include_secant_line
1330: (12)                      Whether to include the secant line in the graph,
1331: (12)                      or just the df/dx lines and labels.
1332: (8)                   secant_line_color
1333: (12)                      The color of the secant line.
1334: (8)                   secant_line_length
1335: (12)                      The length of the secant line.
1336: (8)                   Returns
1337: (8)                   -------
1338: (8)                   :class:`~.VGroup`
1339: (12)                      A group containing the elements: `dx_line`, `df_line`, and
1340: (12)                      if applicable also :attr:`dx_label`, :attr:`df_label`, `secant_line`.
1341: (8)                   Examples
1342: (8)                   --------
1343: (9)                    .. manim:: GetSecantSlopeGroupExample
1344: (12)                      :save_last_frame:
1345: (12)                      class GetSecantSlopeGroupExample(Scene):
1346: (16)                          def construct(self):
1347: (20)                              ax = Axes(y_range=[-1, 7])
1348: (20)                              graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)
1349: (20)                              slopes = ax.get_secant_slope_group(
1350: (24)                                  x=2.0,
1351: (24)                                  graph=graph,
1352: (24)                                  dx=1.0,
1353: (24)                                  dx_label=Tex("dx = 1.0"),
1354: (24)                                  dy_label="dy",
1355: (24)                                  dx_line_color=GREEN_B,
1356: (24)                                  secant_line_length=4,
1357: (24)                                  secant_line_color=RED_D,
1358: (20)                              )
1359: (20)                              self.add(ax, graph, slopes)
1360: (8)                   """
1361: (8)                   group = VGroup()
1362: (8)                   dx = dx or float(self.x_range[1] - self.x_range[0]) / 10
1363: (8)                   dy_line_color = dy_line_color or graph.get_color()
1364: (8)                   p1 = self.input_to_graph_point(x, graph)
1365: (8)                   p2 = self.input_to_graph_point(x + dx, graph)
1366: (8)                   interim_point = p2[0] * RIGHT + p1[1] * UP
1367: (8)                   group.dx_line = Line(p1, interim_point, color=dx_line_color)
1368: (8)                   group.df_line = Line(interim_point, p2, color=dy_line_color)
1369: (8)                   group.add(group.dx_line, group.df_line)
1370: (8)                   labels = VGroup()
1371: (8)                   if dx_label is not None:
1372: (12)                      group.dx_label = self.x_axis._create_label_tex(dx_label)
1373: (12)                      labels.add(group.dx_label)
1374: (12)                      group.add(group.dx_label)
1375: (8)                   if dy_label is not None:
1376: (12)                      group.df_label = self.x_axis._create_label_tex(dy_label)
1377: (12)                      labels.add(group.df_label)
1378: (12)                      group.add(group.df_label)
1379: (8)                   if len(labels) > 0:
1380: (12)                      max_width = 0.8 * group.dx_line.width
1381: (12)                      max_height = 0.8 * group.df_line.height
1382: (12)                      if labels.width > max_width:
1383: (16)                          labels.width = max_width
1384: (12)                      if labels.height > max_height:
1385: (16)                          labels.height = max_height
1386: (8)                   if dx_label is not None:
1387: (12)                      group.dx_label.next_to(
1388: (16)                          group.dx_line,
1389: (16)                          np.sign(dx) * DOWN,
1390: (16)                          buff=group.dx_label.height / 2,
1391: (12)                      )
1392: (12)                      group.dx_label.set_color(group.dx_line.get_color())
1393: (8)                   if dy_label is not None:
1394: (12)                      group.df_label.next_to(
1395: (16)                          group.df_line,
1396: (16)                          np.sign(dx) * RIGHT,
1397: (16)                          buff=group.df_label.height / 2,
1398: (12)                      )
1399: (12)                      group.df_label.set_color(group.df_line.get_color())
1400: (8)                   if include_secant_line:
1401: (12)                      group.secant_line = Line(p1, p2, color=secant_line_color)
1402: (12)                      group.secant_line.scale(
1403: (16)                          secant_line_length / group.secant_line.get_length(),
1404: (12)                      )
1405: (12)                      group.add(group.secant_line)
1406: (8)                   return group
1407: (4)               def get_vertical_lines_to_graph(
1408: (8)                   self,
1409: (8)                   graph: ParametricFunction,
1410: (8)                   x_range: Sequence[float] | None = None,
1411: (8)                   num_lines: int = 20,
1412: (8)                   **kwargs: Any,
1413: (4)               ) -> VGroup:
1414: (8)                   """Obtains multiple lines from the x-axis to the curve.
1415: (8)                   Parameters
1416: (8)                   ----------
1417: (8)                   graph
1418: (12)                      The graph along which the lines are placed.
1419: (8)                   x_range
1420: (12)                      A list containing the lower and and upper bounds of the lines: ``x_range = [x_min, x_max]``.
1421: (8)                   num_lines
1422: (12)                      The number of evenly spaced lines.
1423: (8)                   kwargs
1424: (12)                      Additional arguments to be passed to :meth:`~.CoordinateSystem.get_vertical_line`.
1425: (8)                   Returns
1426: (8)                   -------
1427: (8)                   :class:`~.VGroup`
1428: (12)                      The :class:`~.VGroup` of the evenly spaced lines.
1429: (8)                   Examples
1430: (8)                   --------
1431: (8)                   .. manim:: GetVerticalLinesToGraph
1432: (12)                      :save_last_frame:
1433: (12)                      class GetVerticalLinesToGraph(Scene):
1434: (16)                          def construct(self):
1435: (20)                              ax = Axes(
1436: (24)                                  x_range=[0, 8.0, 1],
1437: (24)                                  y_range=[-1, 1, 0.2],
1438: (24)                                  axis_config={"font_size": 24},
1439: (20)                              ).add_coordinates()
1440: (20)                              curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)
1441: (20)                              lines = ax.get_vertical_lines_to_graph(
1442: (24)                                  curve, x_range=[0, 4], num_lines=30, color=BLUE
1443: (20)                              )
1444: (20)                              self.add(ax, curve, lines)
1445: (8)                   """
1446: (8)                   x_range = x_range if x_range is not None else self.x_range
1447: (8)                   return VGroup(
1448: (12)                      *(
1449: (16)                          self.get_vertical_line(self.i2gp(x, graph), **kwargs)
1450: (16)                          for x in np.linspace(x_range[0], x_range[1], num_lines)
1451: (12)                      )
1452: (8)                   )
1453: (4)               def get_T_label(
1454: (8)                   self,
1455: (8)                   x_val: float,
1456: (8)                   graph: ParametricFunction,
1457: (8)                   label: float | str | Mobject | None = None,
1458: (8)                   label_color: ParsableManimColor | None = None,
1459: (8)                   triangle_size: float = MED_SMALL_BUFF,
1460: (8)                   triangle_color: ParsableManimColor | None = WHITE,
1461: (8)                   line_func: type[Line] = Line,
1462: (8)                   line_color: ParsableManimColor = YELLOW,
1463: (4)               ) -> VGroup:
1464: (8)                   """Creates a labelled triangle marker with a vertical line from the x-axis
1465: (8)                   to a curve at a given x-value.
1466: (8)                   Parameters
1467: (8)                   ----------
1468: (8)                   x_val
1469: (12)                      The position along the curve at which the label, line and triangle will be constructed.
1470: (8)                   graph
1471: (12)                      The :class:`~.ParametricFunction` for which to construct the label.
1472: (8)                   label
1473: (12)                      The label of the vertical line and triangle.
1474: (8)                   label_color
1475: (12)                      The color of the label.
1476: (8)                   triangle_size
1477: (12)                      The size of the triangle.
1478: (8)                   triangle_color
1479: (12)                      The color of the triangle.
1480: (8)                   line_func
1481: (12)                      The function used to construct the vertical line.
1482: (8)                   line_color
1483: (12)                      The color of the vertical line.
1484: (8)                   Returns
1485: (8)                   -------
1486: (8)                   :class:`~.VGroup`
1487: (12)                      A :class:`~.VGroup` of the label, triangle and vertical line mobjects.
1488: (8)                   Examples
1489: (8)                   --------
1490: (8)                   .. manim:: TLabelExample
1491: (12)                      :save_last_frame:
1492: (12)                      class TLabelExample(Scene):
1493: (16)                          def construct(self):
1494: (20)                              # defines the axes and linear function
1495: (20)                              axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)
1496: (20)                              func = axes.plot(lambda x: x, color=BLUE)
1497: (20)                              # creates the T_label
1498: (20)                              t_label = axes.get_T_label(x_val=4, graph=func, label=Tex("x-value"))
1499: (20)                              self.add(axes, func, t_label)
1500: (8)                   """
1501: (8)                   T_label_group = VGroup()
1502: (8)                   triangle = RegularPolygon(n=3, start_angle=np.pi / 2, stroke_width=0).set_fill(
1503: (12)                      color=triangle_color,
1504: (12)                      opacity=1,
1505: (8)                   )
1506: (8)                   triangle.height = triangle_size
1507: (8)                   triangle.move_to(self.coords_to_point(x_val, 0), UP)
1508: (8)                   if label is not None:
1509: (12)                      t_label = self.x_axis._create_label_tex(label, color=label_color)
1510: (12)                      t_label.next_to(triangle, DOWN)
1511: (12)                      T_label_group.add(t_label)
1512: (8)                   v_line = self.get_vertical_line(
1513: (12)                      self.i2gp(x_val, graph),
1514: (12)                      color=line_color,
1515: (12)                      line_func=line_func,
1516: (8)                   )
1517: (8)                   T_label_group.add(triangle, v_line)
1518: (8)                   return T_label_group
1519: (0)           class Axes(VGroup, CoordinateSystem, metaclass=ConvertToOpenGL):
1520: (4)               """Creates a set of axes.
1521: (4)               Parameters
1522: (4)               ----------
1523: (4)               x_range
1524: (8)                   The ``(x_min, x_max, x_step)`` values of the x-axis.
1525: (4)               y_range
1526: (8)                   The ``(y_min, y_max, y_step)`` values of the y-axis.
1527: (4)               x_length
1528: (8)                   The length of the x-axis.
1529: (4)               y_length
1530: (8)                   The length of the y-axis.
1531: (4)               axis_config
1532: (8)                   Arguments to be passed to :class:`~.NumberLine` that influences both axes.
1533: (4)               x_axis_config
1534: (8)                   Arguments to be passed to :class:`~.NumberLine` that influence the x-axis.
1535: (4)               y_axis_config
1536: (8)                   Arguments to be passed to :class:`~.NumberLine` that influence the y-axis.
1537: (4)               tips
1538: (8)                   Whether or not to include the tips on both axes.
1539: (4)               kwargs
1540: (8)                   Additional arguments to be passed to :class:`CoordinateSystem` and :class:`~.VGroup`.
1541: (4)               Examples
1542: (4)               --------
1543: (4)               .. manim:: LogScalingExample
1544: (8)                   :save_last_frame:
1545: (8)                   class LogScalingExample(Scene):
1546: (12)                      def construct(self):
1547: (16)                          ax = Axes(
1548: (20)                              x_range=[0, 10, 1],
1549: (20)                              y_range=[-2, 6, 1],
1550: (20)                              tips=False,
1551: (20)                              axis_config={"include_numbers": True},
1552: (20)                              y_axis_config={"scaling": LogBase(custom_labels=True)},
1553: (16)                          )
1554: (16)                          # x_min must be > 0 because log is undefined at 0.
1555: (16)                          graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)
1556: (16)                          self.add(ax, graph)
1557: (4)               Styling arguments can be passed to the underlying :class:`.NumberLine`
1558: (4)               mobjects that represent the axes:
1559: (4)               .. manim:: AxesWithDifferentTips
1560: (8)                   :save_last_frame:
1561: (8)                   class AxesWithDifferentTips(Scene):
1562: (12)                      def construct(self):
1563: (16)                          ax = Axes(axis_config={'tip_shape': StealthTip})
1564: (16)                          self.add(ax)
1565: (4)               """
1566: (4)               def __init__(
1567: (8)                   self,
1568: (8)                   x_range: Sequence[float] | None = None,
1569: (8)                   y_range: Sequence[float] | None = None,
1570: (8)                   x_length: float | None = round(config.frame_width) - 2,
1571: (8)                   y_length: float | None = round(config.frame_height) - 2,
1572: (8)                   axis_config: dict | None = None,
1573: (8)                   x_axis_config: dict | None = None,
1574: (8)                   y_axis_config: dict | None = None,
1575: (8)                   tips: bool = True,
1576: (8)                   **kwargs: Any,
1577: (4)               ) -> None:
1578: (8)                   VGroup.__init__(self, **kwargs)
1579: (8)                   CoordinateSystem.__init__(self, x_range, y_range, x_length, y_length)
1580: (8)                   self.axis_config = {
1581: (12)                      "include_tip": tips,
1582: (12)                      "numbers_to_exclude": [0],
1583: (8)                   }
1584: (8)                   self.x_axis_config = {}
1585: (8)                   self.y_axis_config = {"rotation": 90 * DEGREES, "label_direction": LEFT}
1586: (8)                   self._update_default_configs(
1587: (12)                      (self.axis_config, self.x_axis_config, self.y_axis_config),
1588: (12)                      (axis_config, x_axis_config, y_axis_config),
1589: (8)                   )
1590: (8)                   self.x_axis_config = merge_dicts_recursively(
1591: (12)                      self.axis_config,
1592: (12)                      self.x_axis_config,
1593: (8)                   )
1594: (8)                   self.y_axis_config = merge_dicts_recursively(
1595: (12)                      self.axis_config,
1596: (12)                      self.y_axis_config,
1597: (8)                   )
1598: (8)                   # excluding the origin tick removes a tick at the 0-point of the axis
1599: (8)                   # This is desired for LinearBase because the 0 point is always the x-axis
1600: (8)                   # For non-LinearBase, the "0-point" does not have this quality, so it must be included.
1601: (8)                   # i.e. with LogBase range [-2, 4]:
1602: (8)                   # it would remove the "0" tick, which is actually 10^0,
1603: (8)                   # not the lowest tick on the graph (which is 10^-2).
1604: (8)                   if self.x_axis_config.get("scaling") is None or isinstance(
1605: (12)                      self.x_axis_config.get("scaling"), LinearBase
1606: (8)                   ):
1607: (12)                      self.x_axis_config["exclude_origin_tick"] = True
1608: (8)                   else:
1609: (12)                      self.x_axis_config["exclude_origin_tick"] = False
1610: (8)                   if self.y_axis_config.get("scaling") is None or isinstance(
1611: (12)                      self.y_axis_config.get("scaling"), LinearBase
1612: (8)                   ):
1613: (12)                      self.y_axis_config["exclude_origin_tick"] = True
1614: (8)                   else:
1615: (12)                      self.y_axis_config["exclude_origin_tick"] = False
1616: (8)                   self.x_axis = self._create_axis(self.x_range, self.x_axis_config, self.x_length)
1617: (8)                   self.y_axis = self._create_axis(self.y_range, self.y_axis_config, self.y_length)
1618: (8)                   # Add as a separate group in case various other
1619: (8)                   # mobjects are added to self, as for example in
1620: (8)                   # NumberPlane below
1621: (8)                   self.axes = VGroup(self.x_axis, self.y_axis)
1622: (8)                   self.add(*self.axes)
1623: (8)                   # finds the middle-point on each axis
1624: (8)                   lines_center_point = [
1625: (12)                      axis.scaling.function((axis.x_range[1] + axis.x_range[0]) / 2)
1626: (12)                      for axis in self.axes
1627: (8)                   ]
1628: (8)                   self.shift(-self.coords_to_point(*lines_center_point))
1629: (4)               @staticmethod
1630: (4)               def _update_default_configs(
1631: (8)                   default_configs: tuple[dict[Any, Any]], passed_configs: tuple[dict[Any, Any]]
1632: (4)               ) -> None:
1633: (8)                   """Takes in two tuples of dicts and return modifies the first such that values from
1634: (8)                   ``passed_configs`` overwrite values in ``default_configs``. If a key does not exist
1635: (8)                   in default_configs, it is added to the dict.
1636: (8)                   This method is useful for having defaults in a class and being able to overwrite
1637: (8)                   them with user-defined input.
1638: (8)                   Parameters
1639: (8)                   ----------
1640: (8)                   default_configs
1641: (12)                      The dict that will be updated.
1642: (8)                   passed_configs
1643: (12)                      The dict that will be used to update.
1644: (8)                   Examples
1645: (8)                   --------
1646: (8)                   To create a tuple with one dictionary, add a comma after the element:
1647: (8)                   .. code-block:: python
1648: (12)                      self._update_default_configs(
1649: (16)                          (dict_1,)(
1650: (20)                              dict_2,
1651: (16)                          )
1652: (12)                      )
1653: (8)                   """
1654: (8)                   for default_config, passed_config in zip(default_configs, passed_configs):
1655: (12)                      if passed_config is not None:
1656: (16)                          update_dict_recursively(default_config, passed_config)
1657: (4)               def _create_axis(
1658: (8)                   self,
1659: (8)                   range_terms: Sequence[float],
1660: (8)                   axis_config: dict[str, Any],
1661: (8)                   length: float,
1662: (4)               ) -> NumberLine:
1663: (8)                   """Creates an axis and dynamically adjusts its position depending on where 0 is located on the line.
1664: (8)                   Parameters
1665: (8)                   ----------
1666: (8)                   range_terms
1667: (12)                      The range of the the axis : ``(x_min, x_max, x_step)``.
1668: (8)                   axis_config
1669: (12)                      Additional parameters that are passed to :class:`~.NumberLine`.
1670: (8)                   length
1671: (12)                      The length of the axis.
1672: (8)                   Returns
1673: (8)                   -------
1674: (8)                   :class:`NumberLine`
1675: (12)                      Returns a number line based on ``range_terms``.
1676: (8)                   """
1677: (8)                   axis_config["length"] = length
1678: (8)                   axis = NumberLine(range_terms, **axis_config)
1679: (8)                   # without the call to _origin_shift, graph does not exist when min > 0 or max < 0
1680: (8)                   # shifts the axis so that 0 is centered
1681: (8)                   axis.shift(-axis.number_to_point(self._origin_shift([axis.x_min, axis.x_max])))
1682: (8)                   return axis
1683: (4)               def coords_to_point(
1684: (8)                   self, *coords: float | Sequence[float] | Sequence[Sequence[float]] | np.ndarray
1685: (4)               ) -> np.ndarray:
1686: (8)                   """Accepts coordinates from the axes and returns a point with respect to the scene.
1687: (8)                   Parameters
1688: (8)                   ----------
1689: (8)                   coords
1690: (12)                      The coordinates. Each coord is passed as a separate argument: ``ax.coords_to_point(1, 2, 3)``.
1691: (12)                      Also accepts a list of coordinates
1692: (12)                      ``ax.coords_to_point( [x_0, x_1, ...], [y_0, y_1, ...], ... )``
1693: (12)                      ``ax.coords_to_point( [[x_0, y_0, z_0], [x_1, y_1, z_1]] )``
1694: (8)                   Returns
1695: (8)                   -------
1696: (8)                   np.ndarray
1697: (12)                      A point with respect to the scene's coordinate system.
1698: (12)                      The shape of the array will be similar to the shape of the input.
1699: (8)                   Examples
1700: (8)                   --------
1701: (8)                   .. code-block:: pycon
1702: (12)                      >>> from manim import Axes
1703: (12)                      >>> import numpy as np
1704: (12)                      >>> ax = Axes()
1705: (12)                      >>> np.around(ax.coords_to_point(1, 0, 0), 2)
1706: (12)                      array([0.86, 0.  , 0.  ])
1707: (12)                      >>> np.around(ax.coords_to_point([[0, 1], [1, 1], [1, 0]]), 2)
1708: (12)                      array([[0.  , 0.75, 0.  ],
1709: (19)                             [0.86, 0.75, 0.  ],
1710: (19)                             [0.86, 0.  , 0.  ]])
1711: (12)                      >>> np.around(
1712: (12)                      ...     ax.coords_to_point([0, 1, 1], [1, 1, 0]), 2
1713: (12)                      ... )  # Transposed version of the above
1714: (12)                      array([[0.  , 0.86, 0.86],
1715: (19)                             [0.75, 0.75, 0.  ],
1716: (19)                             [0.  , 0.  , 0.  ]])
1717: (8)                   .. manim:: CoordsToPointExample
1718: (12)                      :save_last_frame:
1719: (12)                      class CoordsToPointExample(Scene):
1720: (16)                          def construct(self):
1721: (20)                              ax = Axes().add_coordinates()
1722: (20)                              # a dot with respect to the axes
1723: (20)                              dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)
1724: (20)                              lines = ax.get_lines_to_point(ax.c2p(2,2))
1725: (20)                              # a dot with respect to the scene
1726: (20)                              # the default plane corresponds to the coordinates of the scene.
1727: (20)                              plane = NumberPlane()
1728: (20)                              dot_scene = Dot((2,2,0), color=RED)
1729: (20)                              self.add(plane, dot_scene, ax, dot_axes, lines)
1730: (8)                   """
1731: (8)                   coords = np.asarray(coords)
1732: (8)                   origin = self.x_axis.number_to_point(
1733: (12)                      self._origin_shift([self.x_axis.x_min, self.x_axis.x_max]),
1734: (8)                   )
1735: (8)                   # Is coords in the format ([[x1 y1 z1] [x2 y2 z2] ...])? (True)
1736: (8)                   # Or is coords in the format (x, y, z) or ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...])? (False)
1737: (8)                   # The latter is preferred.
1738: (8)                   are_coordinates_transposed = False
1739: (8)                   # If coords is in the format ([[x1 y1 z1] [x2 y2 z2] ...]):
1740: (8)                   if coords.ndim == 3:
1741: (12)                      # Extract from original tuple: now coords looks like [[x y z]] or [[x1 y1 z1] [x2 y2 z2] ...].
1742: (12)                      coords = coords[0]
1743: (12)                      # If there's a single coord (coords = [[x y z]]), extract it so that
1744: (12)                      # coords = [x y z] and coords_to_point returns a single point.
1745: (12)                      if coords.shape[0] == 1:
1746: (16)                          coords = coords[0]
1747: (12)                      # Else, if coords looks more like [[x1 y1 z1] [x2 y2 z2] ...], transform them (by
1748: (12)                      # transposing) into the format [[x1 x2 ...] [y1 y2 ...] [z1 z2 ...]] for later processing.
1749: (12)                      else:
1750: (16)                          coords = coords.T
1751: (16)                          are_coordinates_transposed = True
1752: (8)                   # Otherwise, coords already looked like (x, y, z) or ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...]),
1753: (8)                   # so no further processing is needed.
1754: (8)                   # Now coords should either look like [x y z] or [[x1 x2 ...] [y1 y2 ...] [z1 z2 ...]],
1755: (8)                   # so it can be iterated directly. Each element is either a float representing a single
1756: (8)                   # coordinate, or a float ndarray of coordinates corresponding to a single axis.
1757: (8)                   # Although "points" and "nums" are in plural, there might be a single point or number.
1758: (8)                   points = self.x_axis.number_to_point(coords[0])
1759: (8)                   other_axes = self.axes.submobjects[1:]
1760: (8)                   for axis, nums in zip(other_axes, coords[1:]):
1761: (12)                      points += axis.number_to_point(nums) - origin
1762: (8)                   # Return points as is, except if coords originally looked like
1763: (8)                   # ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...]), which is determined by the conditions below. In
1764: (8)                   # that case, the current implementation requires that the results have to be transposed.
1765: (8)                   if are_coordinates_transposed or points.ndim == 1:
1766: (12)                      return points
1767: (8)                   return points.T
1768: (4)               def point_to_coords(self, point: Sequence[float]) -> np.ndarray:
1769: (8)                   """Accepts a point from the scene and returns its coordinates with respect to the axes.
1770: (8)                   Parameters
1771: (8)                   ----------
1772: (8)                   point
1773: (12)                      The point, i.e. ``RIGHT`` or ``[0, 1, 0]``.
1774: (12)                      Also accepts a list of points as ``[RIGHT, [0, 1, 0]]``.
1775: (8)                   Returns
1776: (8)                   -------
1777: (8)                   np.ndarray[float]
1778: (12)                      The coordinates on the axes, i.e. ``[4.0, 7.0]``.
1779: (12)                      Or a list of coordinates if `point` is a list of points.
1780: (8)                   Examples
1781: (8)                   --------
1782: (8)                   .. code-block:: pycon
1783: (12)                      >>> from manim import Axes, RIGHT
1784: (12)                      >>> import numpy as np
1785: (12)                      >>> ax = Axes(x_range=[0, 10, 2])
1786: (12)                      >>> np.around(ax.point_to_coords(RIGHT), 2)
1787: (12)                      array([5.83, 0.  ])
1788: (12)                      >>> np.around(ax.point_to_coords([[0, 0, 1], [1, 0, 0]]), 2)
1789: (12)                      array([[5.  , 0.  ],
1790: (19)                             [5.83, 0.  ]])
1791: (8)                   .. manim:: PointToCoordsExample
1792: (12)                      :save_last_frame:
1793: (12)                      class PointToCoordsExample(Scene):
1794: (16)                          def construct(self):
1795: (20)                              ax = Axes(x_range=[0, 10, 2]).add_coordinates()
1796: (20)                              circ = Circle(radius=0.5).shift(UR * 2)
1797: (20)                              # get the coordinates of the circle with respect to the axes
1798: (20)                              coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)
1799: (20)                              label = (
1800: (24)                                  Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)
1801: (20)                              )
1802: (20)                              self.add(ax, circ, label, Dot(circ.get_right()))
1803: (8)                   """
1804: (8)                   point = np.asarray(point)
1805: (8)                   result = np.asarray([axis.point_to_number(point) for axis in self.get_axes()])
1806: (8)                   if point.ndim == 2:
1807: (12)                      return result.T
1808: (8)                   return result
1809: (4)               def get_axes(self) -> VGroup:
1810: (8)                   """Gets the axes.
1811: (8)                   Returns
1812: (8)                   -------
1813: (8)                   :class:`~.VGroup`
1814: (12)                      A pair of axes.
1815: (8)                   """
1816: (8)                   return self.axes
1817: (4)               def get_axis_labels(
1818: (8)                   self,
1819: (8)                   x_label: float | str | Mobject = "x",
1820: (8)                   y_label: float | str | Mobject = "y",
1821: (4)               ) -> VGroup:
1822: (8)                   """Defines labels for the x-axis and y-axis of the graph.
1823: (8)                   For increased control over the position of the labels,
1824: (8)                   use :meth:`~.CoordinateSystem.get_x_axis_label` and
1825: (8)                   :meth:`~.CoordinateSystem.get_y_axis_label`.
1826: (8)                   Parameters
1827: (8)                   ----------
1828: (8)                   x_label
1829: (12)                      The label for the x_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
1830: (8)                   y_label
1831: (12)                      The label for the y_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
1832: (8)                   Returns
1833: (8)                   -------
1834: (8)                   :class:`~.VGroup`
1835: (12)                      A :class:`~.VGroup` of the labels for the x_axis and y_axis.
1836: (8)                   .. seealso::
1837: (12)                      :meth:`~.CoordinateSystem.get_x_axis_label`
1838: (12)                      :meth:`~.CoordinateSystem.get_y_axis_label`
1839: (8)                   Examples
1840: (8)                   --------
1841: (8)                   .. manim:: GetAxisLabelsExample
1842: (12)                      :save_last_frame:
1843: (12)                      class GetAxisLabelsExample(Scene):
1844: (16)                          def construct(self):
1845: (20)                              ax = Axes()
1846: (20)                              labels = ax.get_axis_labels(
1847: (24)                                  Tex("x-axis").scale(0.7), Text("y-axis").scale(0.45)
1848: (20)                              )
1849: (20)                              self.add(ax, labels)
1850: (8)                   """
1851: (8)                   self.axis_labels = VGroup(
1852: (12)                      self.get_x_axis_label(x_label),
1853: (12)                      self.get_y_axis_label(y_label),
1854: (8)                   )
1855: (8)                   return self.axis_labels
1856: (4)               def plot_line_graph(
1857: (8)                   self,
1858: (8)                   x_values: Iterable[float],
1859: (8)                   y_values: Iterable[float],
1860: (8)                   z_values: Iterable[float] | None = None,
1861: (8)                   line_color: ParsableManimColor = YELLOW,
1862: (8)                   add_vertex_dots: bool = True,
1863: (8)                   vertex_dot_radius: float = DEFAULT_DOT_RADIUS,
1864: (8)                   vertex_dot_style: dict[str, Any] | None = None,
1865: (8)                   **kwargs: Any,
1866: (4)               ) -> VDict:
1867: (8)                   """Draws a line graph.
1868: (8)                   The graph connects the vertices formed from zipping
1869: (8)                   ``x_values``, ``y_values`` and ``z_values``. Also adds :class:`Dots <.Dot>` at the
1870: (8)                   vertices if ``add_vertex_dots`` is set to ``True``.
1871: (8)                   Parameters
1872: (8)                   ----------
1873: (8)                   x_values
1874: (12)                      Iterable of values along the x-axis.
1875: (8)                   y_values
1876: (12)                      Iterable of values along the y-axis.
1877: (8)                   z_values
1878: (12)                      Iterable of values (zeros if z_values is None) along the z-axis.
1879: (8)                   line_color
1880: (12)                      Color for the line graph.
1881: (8)                   add_vertex_dots
1882: (12)                      Whether or not to add :class:`~.Dot` at each vertex.
1883: (8)                   vertex_dot_radius
1884: (12)                      Radius for the :class:`~.Dot` at each vertex.
1885: (8)                   vertex_dot_style
1886: (12)                      Style arguments to be passed into :class:`~.Dot` at each vertex.
1887: (8)                   kwargs
1888: (12)                      Additional arguments to be passed into :class:`~.VMobject`.
1889: (8)                   Returns
1890: (8)                   -------
1891: (8)                   :class:`~.VDict`
1892: (12)                      A VDict containing both the line and dots (if specified). The line can be accessed with: ``line_graph["line_graph"]``.
1893: (12)                      The dots can be accessed with: ``line_graph["vertex_dots"]``.
1894: (8)                   Examples
1895: (8)                   --------
1896: (8)                   .. manim:: LineGraphExample
1897: (12)                      :save_last_frame:
1898: (12)                      class LineGraphExample(Scene):
1899: (16)                          def construct(self):
1900: (20)                              plane = NumberPlane(
1901: (24)                                  x_range = (0, 7),
1902: (24)                                  y_range = (0, 5),
1903: (24)                                  x_length = 7,
1904: (24)                                  axis_config={"include_numbers": True},
1905: (20)                              )
1906: (20)                              plane.center()
1907: (20)                              line_graph = plane.plot_line_graph(
1908: (24)                                  x_values = [0, 1.5, 2, 2.8, 4, 6.25],
1909: (24)                                  y_values = [1, 3, 2.25, 4, 2.5, 1.75],
1910: (24)                                  line_color=GOLD_E,
1911: (24)                                  vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),
1912: (24)                                  stroke_width = 4,
1913: (20)                              )
1914: (20)                              self.add(plane, line_graph)
1915: (8)                   """
1916: (8)                   x_values, y_values = map(np.array, (x_values, y_values))
1917: (8)                   if z_values is None:
1918: (12)                      z_values = np.zeros(x_values.shape)
1919: (8)                   line_graph = VDict()
1920: (8)                   graph = VGroup(color=line_color, **kwargs)
1921: (8)                   vertices = [
1922: (12)                      self.coords_to_point(x, y, z)
1923: (12)                      for x, y, z in zip(x_values, y_values, z_values)
1924: (8)                   ]
1925: (8)                   graph.set_points_as_corners(vertices)
1926: (8)                   line_graph["line_graph"] = graph
1927: (8)                   if add_vertex_dots:
1928: (12)                      vertex_dot_style = vertex_dot_style or {}
1929: (12)                      vertex_dots = VGroup(
1930: (16)                          *(
1931: (20)                              Dot(point=vertex, radius=vertex_dot_radius, **vertex_dot_style)
1932: (20)                              for vertex in vertices
1933: (16)                          )
1934: (12)                      )
1935: (12)                      line_graph["vertex_dots"] = vertex_dots
1936: (8)                   return line_graph
1937: (4)               @staticmethod
1938: (4)               def _origin_shift(axis_range: Sequence[float]) -> float:
1939: (8)                   """Determines how to shift graph mobjects to compensate when 0 is not on the axis.
1940: (8)                   Parameters
1941: (8)                   ----------
1942: (8)                   axis_range
1943: (12)                      The range of the axis : ``(x_min, x_max, x_step)``.
1944: (8)                   """
1945: (8)                   if axis_range[0] > 0:
1946: (12)                      # min greater than 0
1947: (12)                      return axis_range[0]
1948: (8)                   if axis_range[1] < 0:
1949: (12)                      # max less than 0
1950: (12)                      return axis_range[1]
1951: (8)                   else:
1952: (12)                      return 0
1953: (0)           class ThreeDAxes(Axes):
1954: (4)               """A 3-dimensional set of axes.
1955: (4)               Parameters
1956: (4)               ----------
1957: (4)               x_range
1958: (8)                   The ``[x_min, x_max, x_step]`` values of the x-axis.
1959: (4)               y_range
1960: (8)                   The ``[y_min, y_max, y_step]`` values of the y-axis.
1961: (4)               z_range
1962: (8)                   The ``[z_min, z_max, z_step]`` values of the z-axis.
1963: (4)               x_length
1964: (8)                   The length of the x-axis.
1965: (4)               y_length
1966: (8)                   The length of the y-axis.
1967: (4)               z_length
1968: (8)                   The length of the z-axis.
1969: (4)               z_axis_config
1970: (8)                   Arguments to be passed to :class:`~.NumberLine` that influence the z-axis.
1971: (4)               z_normal
1972: (8)                   The direction of the normal.
1973: (4)               num_axis_pieces
1974: (8)                   The number of pieces used to construct the axes.
1975: (4)               light_source
1976: (8)                   The direction of the light source.
1977: (4)               depth
1978: (8)                   Currently non-functional.
1979: (4)               gloss
1980: (8)                   Currently non-functional.
1981: (4)               kwargs
1982: (8)                   Additional arguments to be passed to :class:`Axes`.
1983: (4)               """
1984: (4)               def __init__(
1985: (8)                   self,
1986: (8)                   x_range: Sequence[float] | None = (-6, 6, 1),
1987: (8)                   y_range: Sequence[float] | None = (-5, 5, 1),
1988: (8)                   z_range: Sequence[float] | None = (-4, 4, 1),
1989: (8)                   x_length: float | None = config.frame_height + 2.5,
1990: (8)                   y_length: float | None = config.frame_height + 2.5,
1991: (8)                   z_length: float | None = config.frame_height - 1.5,
1992: (8)                   z_axis_config: dict[str, Any] | None = None,
1993: (8)                   z_normal: Vector3D = DOWN,
1994: (8)                   num_axis_pieces: int = 20,
1995: (8)                   light_source: Sequence[float] = 9 * DOWN + 7 * LEFT + 10 * OUT,
1996: (8)                   # opengl stuff (?)
1997: (8)                   depth=None,
1998: (8)                   gloss=0.5,
1999: (8)                   **kwargs: dict[str, Any],
2000: (4)               ) -> None:
2001: (8)                   super().__init__(
2002: (12)                      x_range=x_range,
2003: (12)                      x_length=x_length,
2004: (12)                      y_range=y_range,
2005: (12)                      y_length=y_length,
2006: (12)                      **kwargs,
2007: (8)                   )
2008: (8)                   self.z_range = z_range
2009: (8)                   self.z_length = z_length
2010: (8)                   self.z_axis_config = {}
2011: (8)                   self._update_default_configs((self.z_axis_config,), (z_axis_config,))
2012: (8)                   self.z_axis_config = merge_dicts_recursively(
2013: (12)                      self.axis_config,
2014: (12)                      self.z_axis_config,
2015: (8)                   )
2016: (8)                   self.z_normal = z_normal
2017: (8)                   self.num_axis_pieces = num_axis_pieces
2018: (8)                   self.light_source = light_source
2019: (8)                   self.dimension = 3
2020: (8)                   if self.z_axis_config.get("scaling") is None or isinstance(
2021: (12)                      self.z_axis_config.get("scaling"), LinearBase
2022: (8)                   ):
2023: (12)                      self.z_axis_config["exclude_origin_tick"] = True
2024: (8)                   else:
2025: (12)                      self.z_axis_config["exclude_origin_tick"] = False
2026: (8)                   z_axis = self._create_axis(self.z_range, self.z_axis_config, self.z_length)
2027: (8)                   # [ax.x_min, ax.x_max] used to account for LogBase() scaling
2028: (8)                   # where ax.x_range[0] != ax.x_min
2029: (8)                   z_origin = self._origin_shift([z_axis.x_min, z_axis.x_max])
2030: (8)                   z_axis.rotate_about_number(z_origin, -PI / 2, UP)
2031: (8)                   z_axis.rotate_about_number(z_origin, angle_of_vector(self.z_normal))
2032: (8)                   z_axis.shift(-z_axis.number_to_point(z_origin))
2033: (8)                   z_axis.shift(
2034: (12)                      self.x_axis.number_to_point(
2035: (16)                          self._origin_shift([self.x_axis.x_min, self.x_axis.x_max]),
2036: (12)                      ),
2037: (8)                   )
2038: (8)                   self.axes.add(z_axis)
2039: (8)                   self.add(z_axis)
2040: (8)                   self.z_axis = z_axis
2041: (8)                   if config.renderer == RendererType.CAIRO:
2042: (12)                      self._add_3d_pieces()
2043: (12)                      self._set_axis_shading()
2044: (4)               def _add_3d_pieces(self) -> None:
2045: (8)                   for axis in self.axes:
2046: (12)                      axis.pieces = VGroup(*axis.get_pieces(self.num_axis_pieces))
2047: (12)                      axis.add(axis.pieces)
2048: (12)                      axis.set_stroke(width=0, family=False)
2049: (12)                      axis.set_shade_in_3d(True)
2050: (4)               def _set_axis_shading(self) -> None:
2051: (8)                   def make_func(axis):
2052: (12)                      vect = self.light_source
2053: (12)                      return lambda: (
2054: (16)                          axis.get_edge_center(-vect),
2055: (16)                          axis.get_edge_center(vect),
2056: (12)                      )
2057: (8)                   for axis in self:
2058: (12)                      for submob in axis.family_members_with_points():
2059: (16)                          submob.get_gradient_start_and_end_points = make_func(axis)
2060: (16)                          submob.get_unit_normal = lambda a: np.ones(3)
2061: (16)                          submob.set_sheen(0.2)
2062: (4)               def get_y_axis_label(
2063: (8)                   self,
2064: (8)                   label: float | str | Mobject,
2065: (8)                   edge: Sequence[float] = UR,
2066: (8)                   direction: Sequence[float] = UR,
2067: (8)                   buff: float = SMALL_BUFF,
2068: (8)                   rotation: float = PI / 2,
2069: (8)                   rotation_axis: Vector3D = OUT,
2070: (8)                   **kwargs,
2071: (4)               ) -> Mobject:
2072: (8)                   """Generate a y-axis label.
2073: (8)                   Parameters
2074: (8)                   ----------
2075: (8)                   label
2076: (12)                      The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
2077: (8)                   edge
2078: (12)                      The edge of the y-axis to which the label will be added, by default ``UR``.
2079: (8)                   direction
2080: (12)                      Allows for further positioning of the label from an edge, by default ``UR``.
2081: (8)                   buff
2082: (12)                      The distance of the label from the line, by default ``SMALL_BUFF``.
2083: (8)                   rotation
2084: (12)                      The angle at which to rotate the label, by default ``PI/2``.
2085: (8)                   rotation_axis
2086: (12)                      The axis about which to rotate the label, by default ``OUT``.
2087: (8)                   Returns
2088: (8)                   -------
2089: (8)                   :class:`~.Mobject`
2090: (12)                      The positioned label.
2091: (8)                   Examples
2092: (8)                   --------
2093: (8)                   .. manim:: GetYAxisLabelExample
2094: (12)                      :save_last_frame:
2095: (12)                      class GetYAxisLabelExample(ThreeDScene):
2096: (16)                          def construct(self):
2097: (20)                              ax = ThreeDAxes()
2098: (20)                              lab = ax.get_y_axis_label(Tex("$y$-label"))
2099: (20)                              self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
2100: (20)                              self.add(ax, lab)
2101: (8)                   """
2102: (8)                   positioned_label = self._get_axis_label(
2103: (12)                      label, self.get_y_axis(), edge, direction, buff=buff, **kwargs
2104: (8)                   )
2105: (8)                   positioned_label.rotate(rotation, axis=rotation_axis)
2106: (8)                   return positioned_label
2107: (4)               def get_z_axis_label(
2108: (8)                   self,
2109: (8)                   label: float | str | Mobject,
2110: (8)                   edge: Vector3D = OUT,
2111: (8)                   direction: Vector3D = RIGHT,
2112: (8)                   buff: float = SMALL_BUFF,
2113: (8)                   rotation: float = PI / 2,
2114: (8)                   rotation_axis: Vector3D = RIGHT,
2115: (8)                   **kwargs: Any,
2116: (4)               ) -> Mobject:
2117: (8)                   """Generate a z-axis label.
2118: (8)                   Parameters
2119: (8)                   ----------
2120: (8)                   label
2121: (12)                      The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
2122: (8)                   edge
2123: (12)                      The edge of the z-axis to which the label will be added, by default ``OUT``.
2124: (8)                   direction
2125: (12)                      Allows for further positioning of the label from an edge, by default ``RIGHT``.
2126: (8)                   buff
2127: (12)                      The distance of the label from the line, by default ``SMALL_BUFF``.
2128: (8)                   rotation
2129: (12)                      The angle at which to rotate the label, by default ``PI/2``.
2130: (8)                   rotation_axis
2131: (12)                      The axis about which to rotate the label, by default ``RIGHT``.
2132: (8)                   Returns
2133: (8)                   -------
2134: (8)                   :class:`~.Mobject`
2135: (12)                      The positioned label.
2136: (8)                   Examples
2137: (8)                   --------
2138: (8)                   .. manim:: GetZAxisLabelExample
2139: (12)                      :save_last_frame:
2140: (12)                      class GetZAxisLabelExample(ThreeDScene):
2141: (16)                          def construct(self):
2142: (20)                              ax = ThreeDAxes()
2143: (20)                              lab = ax.get_z_axis_label(Tex("$z$-label"))
2144: (20)                              self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
2145: (20)                              self.add(ax, lab)
2146: (8)                   """
2147: (8)                   positioned_label = self._get_axis_label(
2148: (12)                      label, self.get_z_axis(), edge, direction, buff=buff, **kwargs
2149: (8)                   )
2150: (8)                   positioned_label.rotate(rotation, axis=rotation_axis)
2151: (8)                   return positioned_label
2152: (4)               def get_axis_labels(
2153: (8)                   self,
2154: (8)                   x_label: float | str | Mobject = "x",
2155: (8)                   y_label: float | str | Mobject = "y",
2156: (8)                   z_label: float | str | Mobject = "z",
2157: (4)               ) -> VGroup:
2158: (8)                   """Defines labels for the x_axis and y_axis of the graph.
2159: (8)                   For increased control over the position of the labels,
2160: (8)                   use :meth:`~.CoordinateSystem.get_x_axis_label`,
2161: (8)                   :meth:`~.ThreeDAxes.get_y_axis_label`, and
2162: (8)                   :meth:`~.ThreeDAxes.get_z_axis_label`.
2163: (8)                   Parameters
2164: (8)                   ----------
2165: (8)                   x_label
2166: (12)                      The label for the x_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
2167: (8)                   y_label
2168: (12)                      The label for the y_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
2169: (8)                   z_label
2170: (12)                      The label for the z_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
2171: (8)                   Returns
2172: (8)                   -------
2173: (8)                   :class:`~.VGroup`
2174: (12)                      A :class:`~.VGroup` of the labels for the x_axis, y_axis, and z_axis.
2175: (8)                   .. seealso::
2176: (12)                      :meth:`~.CoordinateSystem.get_x_axis_label`
2177: (12)                      :meth:`~.ThreeDAxes.get_y_axis_label`
2178: (12)                      :meth:`~.ThreeDAxes.get_z_axis_label`
2179: (8)                   Examples
2180: (8)                   --------
2181: (8)                   .. manim:: GetAxisLabelsExample
2182: (12)                      :save_last_frame:
2183: (12)                      class GetAxisLabelsExample(ThreeDScene):
2184: (16)                          def construct(self):
2185: (20)                              self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
2186: (20)                              axes = ThreeDAxes()
2187: (20)                              labels = axes.get_axis_labels(
2188: (24)                                  Text("x-axis").scale(0.7), Text("y-axis").scale(0.45), Text("z-axis").scale(0.45)
2189: (20)                              )
2190: (20)                              self.add(axes, labels)
2191: (8)                   """
2192: (8)                   self.axis_labels = VGroup(
2193: (12)                      self.get_x_axis_label(x_label),
2194: (12)                      self.get_y_axis_label(y_label),
2195: (12)                      self.get_z_axis_label(z_label),
2196: (8)                   )
2197: (8)                   return self.axis_labels
2198: (0)           class NumberPlane(Axes):
2199: (4)               """Creates a cartesian plane with background lines.
2200: (4)               Parameters
2201: (4)               ----------
2202: (4)               x_range
2203: (8)                   The ``[x_min, x_max, x_step]`` values of the plane in the horizontal direction.
2204: (4)               y_range
2205: (8)                   The ``[y_min, y_max, y_step]`` values of the plane in the vertical direction.
2206: (4)               x_length
2207: (8)                   The width of the plane.
2208: (4)               y_length
2209: (8)                   The height of the plane.
2210: (4)               background_line_style
2211: (8)                   Arguments that influence the construction of the background lines of the plane.
2212: (4)               faded_line_style
2213: (8)                   Similar to :attr:`background_line_style`, affects the construction of the scene's background lines.
2214: (4)               faded_line_ratio
2215: (8)                   Determines the number of boxes within the background lines: :code:`2` = 4 boxes, :code:`3` = 9 boxes.
2216: (4)               make_smooth_after_applying_functions
2217: (8)                   Currently non-functional.
2218: (4)               kwargs
2219: (8)                   Additional arguments to be passed to :class:`Axes`.
2220: (4)               .. note::
2221: (8)                   If :attr:`x_length` or :attr:`y_length` are not defined, they are automatically calculated such that
2222: (8)                   one unit on each axis is one Manim unit long.
2223: (4)               Examples
2224: (4)               --------
2225: (4)               .. manim:: NumberPlaneExample
2226: (8)                   :save_last_frame:
2227: (8)                   class NumberPlaneExample(Scene):
2228: (12)                      def construct(self):
2229: (16)                          number_plane = NumberPlane(
2230: (20)                              background_line_style={
2231: (24)                                  "stroke_color": TEAL,
2232: (24)                                  "stroke_width": 4,
2233: (24)                                  "stroke_opacity": 0.6
2234: (20)                              }
2235: (16)                          )
2236: (16)                          self.add(number_plane)
2237: (4)               .. manim:: NumberPlaneScaled
2238: (8)                   :save_last_frame:
2239: (8)                   class NumberPlaneScaled(Scene):
2240: (12)                      def construct(self):
2241: (16)                          number_plane = NumberPlane(
2242: (20)                              x_range=(-4, 11, 1),
2243: (20)                              y_range=(-3, 3, 1),
2244: (20)                              x_length=5,
2245: (20)                              y_length=2,
2246: (16)                          ).move_to(LEFT*3)
2247: (16)                          number_plane_scaled_y = NumberPlane(
2248: (20)                              x_range=(-4, 11, 1),
2249: (20)                              x_length=5,
2250: (20)                              y_length=4,
2251: (16)                          ).move_to(RIGHT*3)
2252: (16)                          self.add(number_plane)
2253: (16)                          self.add(number_plane_scaled_y)
2254: (4)               """
2255: (4)               def __init__(
2256: (8)                   self,
2257: (8)                   x_range: Sequence[float] | None = (
2258: (12)                      -config["frame_x_radius"],
2259: (12)                      config["frame_x_radius"],
2260: (12)                      1,
2261: (8)                   ),
2262: (8)                   y_range: Sequence[float] | None = (
2263: (12)                      -config["frame_y_radius"],
2264: (12)                      config["frame_y_radius"],
2265: (12)                      1,
2266: (8)                   ),
2267: (8)                   x_length: float | None = None,
2268: (8)                   y_length: float | None = None,
2269: (8)                   background_line_style: dict[str, Any] | None = None,
2270: (8)                   faded_line_style: dict[str, Any] | None = None,
2271: (8)                   faded_line_ratio: int = 1,
2272: (8)                   make_smooth_after_applying_functions: bool = True,
2273: (8)                   **kwargs: dict[str, Any],
2274: (4)               ):
2275: (8)                   # configs
2276: (8)                   self.axis_config = {
2277: (12)                      "stroke_width": 2,
2278: (12)                      "include_ticks": False,
2279: (12)                      "include_tip": False,
2280: (12)                      "line_to_number_buff": SMALL_BUFF,
2281: (12)                      "label_direction": DR,
2282: (12)                      "font_size": 24,
2283: (8)                   }
2284: (8)                   self.y_axis_config = {"label_direction": DR}
2285: (8)                   self.background_line_style = {
2286: (12)                      "stroke_color": BLUE_D,
2287: (12)                      "stroke_width": 2,
2288: (12)                      "stroke_opacity": 1,
2289: (8)                   }
2290: (8)                   self._update_default_configs(
2291: (12)                      (self.axis_config, self.y_axis_config, self.background_line_style),
2292: (12)                      (
2293: (16)                          kwargs.pop("axis_config", None),
2294: (16)                          kwargs.pop("y_axis_config", None),
2295: (16)                          background_line_style,
2296: (12)                      ),
2297: (8)                   )
2298: (8)                   # Defaults to a faded version of line_config
2299: (8)                   self.faded_line_style = faded_line_style
2300: (8)                   self.faded_line_ratio = faded_line_ratio
2301: (8)                   self.make_smooth_after_applying_functions = make_smooth_after_applying_functions
2302: (8)                   # init
2303: (8)                   super().__init__(
2304: (12)                      x_range=x_range,
2305: (12)                      y_range=y_range,
2306: (12)                      x_length=x_length,
2307: (12)                      y_length=y_length,
2308: (12)                      axis_config=self.axis_config,
2309: (12)                      y_axis_config=self.y_axis_config,
2310: (12)                      **kwargs,
2311: (8)                   )
2312: (8)                   self._init_background_lines()
2313: (4)               def _init_background_lines(self) -> None:
2314: (8)                   """Will init all the lines of NumberPlanes (faded or not)"""
2315: (8)                   if self.faded_line_style is None:
2316: (12)                      style = dict(self.background_line_style)
2317: (12)                      # For anything numerical, like stroke_width
2318: (12)                      # and stroke_opacity, chop it in half
2319: (12)                      for key in style:
2320: (16)                          if isinstance(style[key], numbers.Number):
2321: (20)                              style[key] *= 0.5
2322: (12)                      self.faded_line_style = style
2323: (8)                   self.background_lines, self.faded_lines = self._get_lines()
2324: (8)                   self.background_lines.set_style(
2325: (12)                      **self.background_line_style,
2326: (8)                   )
2327: (8)                   self.faded_lines.set_style(
2328: (12)                      **self.faded_line_style,
2329: (8)                   )
2330: (8)                   self.add_to_back(
2331: (12)                      self.faded_lines,
2332: (12)                      self.background_lines,
2333: (8)                   )
2334: (4)               def _get_lines(self) -> tuple[VGroup, VGroup]:
2335: (8)                   """Generate all the lines, faded and not faded.
2336: (9)                    Two sets of lines are generated: one parallel to the X-axis, and parallel to the Y-axis.
2337: (8)                   Returns
2338: (8)                   -------
2339: (8)                   Tuple[:class:`~.VGroup`, :class:`~.VGroup`]
2340: (12)                      The first (i.e the non faded lines) and second (i.e the faded lines) sets of lines, respectively.
2341: (8)                   """
2342: (8)                   x_axis = self.get_x_axis()
2343: (8)                   y_axis = self.get_y_axis()
2344: (8)                   x_lines1, x_lines2 = self._get_lines_parallel_to_axis(
2345: (12)                      x_axis,
2346: (12)                      y_axis,
2347: (12)                      self.y_axis.x_range[2],
2348: (12)                      self.faded_line_ratio,
2349: (8)                   )
2350: (8)                   y_lines1, y_lines2 = self._get_lines_parallel_to_axis(
2351: (12)                      y_axis,
2352: (12)                      x_axis,
2353: (12)                      self.x_axis.x_range[2],
2354: (12)                      self.faded_line_ratio,
2355: (8)                   )
2356: (8)                   # TODO this was added so that we can run tests on NumberPlane
2357: (8)                   # In the future these attributes will be tacked onto self.background_lines
2358: (8)                   self.x_lines = x_lines1
2359: (8)                   self.y_lines = y_lines1
2360: (8)                   lines1 = VGroup(*x_lines1, *y_lines1)
2361: (8)                   lines2 = VGroup(*x_lines2, *y_lines2)
2362: (8)                   return lines1, lines2
2363: (4)               def _get_lines_parallel_to_axis(
2364: (8)                   self,
2365: (8)                   axis_parallel_to: NumberLine,
2366: (8)                   axis_perpendicular_to: NumberLine,
2367: (8)                   freq: float,
2368: (8)                   ratio_faded_lines: int,
2369: (4)               ) -> tuple[VGroup, VGroup]:
2370: (8)                   """Generate a set of lines parallel to an axis.
2371: (8)                   Parameters
2372: (8)                   ----------
2373: (8)                   axis_parallel_to
2374: (12)                      The axis with which the lines will be parallel.
2375: (8)                   axis_perpendicular_to
2376: (12)                      The axis with which the lines will be perpendicular.
2377: (8)                   ratio_faded_lines
2378: (12)                      The ratio between the space between faded lines and the space between non-faded lines.
2379: (8)                   freq
2380: (12)                      Frequency of non-faded lines (number of non-faded lines per graph unit).
2381: (8)                   Returns
2382: (8)                   -------
2383: (8)                   Tuple[:class:`~.VGroup`, :class:`~.VGroup`]
2384: (12)                      The first (i.e the non-faded lines parallel to `axis_parallel_to`) and second
2385: (13)                       (i.e the faded lines parallel to `axis_parallel_to`) sets of lines, respectively.
2386: (8)                   """
2387: (8)                   line = Line(axis_parallel_to.get_start(), axis_parallel_to.get_end())
2388: (8)                   if ratio_faded_lines == 0:  # don't show faded lines
2389: (12)                      ratio_faded_lines = 1  # i.e. set ratio to 1
2390: (8)                   step = (1 / ratio_faded_lines) * freq
2391: (8)                   lines1 = VGroup()
2392: (8)                   lines2 = VGroup()
2393: (8)                   unit_vector_axis_perp_to = axis_perpendicular_to.get_unit_vector()
2394: (8)                   # need to unpack all three values
2395: (8)                   x_min, x_max, _ = axis_perpendicular_to.x_range
2396: (8)                   # account for different axis scalings (logarithmic), where
2397: (8)                   # negative values do not exist and [-2 , 4] should output lines
2398: (8)                   # similar to [0, 6]
2399: (8)                   if axis_perpendicular_to.x_min > 0 and x_min < 0:
2400: (12)                      x_min, x_max = (0, np.abs(x_min) + np.abs(x_max))
2401: (8)                   # min/max used in case range does not include 0. i.e. if (2,6):
2402: (8)                   # the range becomes (0,4), not (0,6).
2403: (8)                   ranges = (
2404: (12)                      [0],
2405: (12)                      np.arange(step, min(x_max - x_min, x_max), step),
2406: (12)                      np.arange(-step, max(x_min - x_max, x_min), -step),
2407: (8)                   )
2408: (8)                   for inputs in ranges:
2409: (12)                      for k, x in enumerate(inputs):
2410: (16)                          new_line = line.copy()
2411: (16)                          new_line.shift(unit_vector_axis_perp_to * x)
2412: (16)                          if (k + 1) % ratio_faded_lines == 0:
2413: (20)                              lines1.add(new_line)
2414: (16)                          else:
2415: (20)                              lines2.add(new_line)
2416: (8)                   return lines1, lines2
2417: (4)               def get_vector(self, coords: Sequence[ManimFloat], **kwargs: Any) -> Arrow:
2418: (8)                   kwargs["buff"] = 0
2419: (8)                   return Arrow(
2420: (12)                      self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs
2421: (8)                   )
2422: (4)               def prepare_for_nonlinear_transform(self, num_inserted_curves: int = 50) -> Self:
2423: (8)                   for mob in self.family_members_with_points():
2424: (12)                      num_curves = mob.get_num_curves()
2425: (12)                      if num_inserted_curves > num_curves:
2426: (16)                          mob.insert_n_curves(num_inserted_curves - num_curves)
2427: (8)                   return self
2428: (0)           class PolarPlane(Axes):
2429: (4)               r"""Creates a polar plane with background lines.
2430: (4)               Parameters
2431: (4)               ----------
2432: (4)               azimuth_step
2433: (8)                   The number of divisions in the azimuth (also known as the `angular coordinate` or `polar angle`). If ``None`` is specified then it will use the default
2434: (8)                   specified by ``azimuth_units``:
2435: (8)                   - ``"PI radians"`` or ``"TAU radians"``: 20
2436: (8)                   - ``"degrees"``: 36
2437: (8)                   - ``"gradians"``: 40
2438: (8)                   - ``None``: 1
2439: (8)                   A non-integer value will result in a partial division at the end of the circle.
2440: (4)               size
2441: (8)                   The diameter of the plane.
2442: (4)               radius_step
2443: (8)                   The distance between faded radius lines.
2444: (4)               radius_max
2445: (8)                   The maximum value of the radius.
2446: (4)               azimuth_units
2447: (8)                   Specifies a default labelling system for the azimuth. Choices are:
2448: (8)                   - ``"PI radians"``: Fractional labels in the interval :math:`\left[0, 2\pi\right]` with :math:`\pi` as a constant.
2449: (8)                   - ``"TAU radians"``: Fractional labels in the interval :math:`\left[0, \tau\right]` (where :math:`\tau = 2\pi`) with :math:`\tau` as a constant.
2450: (8)                   - ``"degrees"``: Decimal labels in the interval :math:`\left[0, 360\right]` with a degree (:math:`^{\circ}`) symbol.
2451: (8)                   - ``"gradians"``: Decimal labels in the interval :math:`\left[0, 400\right]` with a superscript "g" (:math:`^{g}`).
2452: (8)                   - ``None``: Decimal labels in the interval :math:`\left[0, 1\right]`.
2453: (4)               azimuth_compact_fraction
2454: (8)                   If the ``azimuth_units`` choice has fractional labels, choose whether to
2455: (8)                   combine the constant in a compact form :math:`\tfrac{xu}{y}` as opposed to
2456: (8)                   :math:`\tfrac{x}{y}u`, where :math:`u` is the constant.
2457: (4)               azimuth_offset
2458: (8)                   The angle offset of the azimuth, expressed in radians.
2459: (4)               azimuth_direction
2460: (8)                   The direction of the azimuth.
2461: (8)                   - ``"CW"``: Clockwise.
2462: (8)                   - ``"CCW"``: Anti-clockwise.
2463: (4)               azimuth_label_buff
2464: (8)                   The buffer for the azimuth labels.
2465: (4)               azimuth_label_font_size
2466: (8)                   The font size of the azimuth labels.
2467: (4)               radius_config
2468: (8)                   The axis config for the radius.
2469: (4)               Examples
2470: (4)               --------
2471: (4)               .. manim:: PolarPlaneExample
2472: (8)                   :ref_classes: PolarPlane
2473: (8)                   :save_last_frame:
2474: (8)                   class PolarPlaneExample(Scene):
2475: (12)                      def construct(self):
2476: (16)                          polarplane_pi = PolarPlane(
2477: (20)                              azimuth_units="PI radians",
2478: (20)                              size=6,
2479: (20)                              azimuth_label_font_size=33.6,
2480: (20)                              radius_config={"font_size": 33.6},
2481: (16)                          ).add_coordinates()
2482: (16)                          self.add(polarplane_pi)
2483: (4)               """
2484: (4)               def __init__(
2485: (8)                   self,
2486: (8)                   radius_max: float = config["frame_y_radius"],
2487: (8)                   size: float | None = None,
2488: (8)                   radius_step: float = 1,
2489: (8)                   azimuth_step: float | None = None,
2490: (8)                   azimuth_units: str | None = "PI radians",
2491: (8)                   azimuth_compact_fraction: bool = True,
2492: (8)                   azimuth_offset: float = 0,
2493: (8)                   azimuth_direction: str = "CCW",
2494: (8)                   azimuth_label_buff: float = SMALL_BUFF,
2495: (8)                   azimuth_label_font_size: float = 24,
2496: (8)                   radius_config: dict[str, Any] | None = None,
2497: (8)                   background_line_style: dict[str, Any] | None = None,
2498: (8)                   faded_line_style: dict[str, Any] | None = None,
2499: (8)                   faded_line_ratio: int = 1,
2500: (8)                   make_smooth_after_applying_functions: bool = True,
2501: (8)                   **kwargs: Any,
2502: (4)               ) -> None:
2503: (8)                   # error catching
2504: (8)                   if azimuth_units in ["PI radians", "TAU radians", "degrees", "gradians", None]:
2505: (12)                      self.azimuth_units = azimuth_units
2506: (8)                   else:
2507: (12)                      raise ValueError(
2508: (16)                          "Invalid azimuth units. Expected one of: PI radians, TAU radians, degrees, gradians or None.",
2509: (12)                      )
2510: (8)                   if azimuth_direction in ["CW", "CCW"]:
2511: (12)                      self.azimuth_direction = azimuth_direction
2512: (8)                   else:
2513: (12)                      raise ValueError("Invalid azimuth units. Expected one of: CW, CCW.")
2514: (8)                   # configs
2515: (8)                   self.radius_config = {
2516: (12)                      "stroke_width": 2,
2517: (12)                      "include_ticks": False,
2518: (12)                      "include_tip": False,
2519: (12)                      "line_to_number_buff": SMALL_BUFF,
2520: (12)                      "label_direction": DL,
2521: (12)                      "font_size": 24,
2522: (8)                   }
2523: (8)                   self.background_line_style = {
2524: (12)                      "stroke_color": BLUE_D,
2525: (12)                      "stroke_width": 2,
2526: (12)                      "stroke_opacity": 1,
2527: (8)                   }
2528: (8)                   self.azimuth_step = (
2529: (12)                      (
2530: (16)                          {
2531: (20)                              "PI radians": 20,
2532: (20)                              "TAU radians": 20,
2533: (20)                              "degrees": 36,
2534: (20)                              "gradians": 40,
2535: (20)                              None: 1,
2536: (16)                          }[azimuth_units]
2537: (12)                      )
2538: (12)                      if azimuth_step is None
2539: (12)                      else azimuth_step
2540: (8)                   )
2541: (8)                   self._update_default_configs(
2542: (12)                      (self.radius_config, self.background_line_style),
2543: (12)                      (radius_config, background_line_style),
2544: (8)                   )
2545: (8)                   # Defaults to a faded version of line_config
2546: (8)                   self.faded_line_style = faded_line_style
2547: (8)                   self.faded_line_ratio = faded_line_ratio
2548: (8)                   self.make_smooth_after_applying_functions = make_smooth_after_applying_functions
2549: (8)                   self.azimuth_offset = azimuth_offset
2550: (8)                   self.azimuth_label_buff = azimuth_label_buff
2551: (8)                   self.azimuth_label_font_size = azimuth_label_font_size
2552: (8)                   self.azimuth_compact_fraction = azimuth_compact_fraction
2553: (8)                   # init
2554: (8)                   super().__init__(
2555: (12)                      x_range=np.array((-radius_max, radius_max, radius_step)),
2556: (12)                      y_range=np.array((-radius_max, radius_max, radius_step)),
2557: (12)                      x_length=size,
2558: (12)                      y_length=size,
2559: (12)                      axis_config=self.radius_config,
2560: (12)                      **kwargs,
2561: (8)                   )
2562: (8)                   self._init_background_lines()
2563: (4)               def _init_background_lines(self) -> None:
2564: (8)                   """Will init all the lines of NumberPlanes (faded or not)"""
2565: (8)                   if self.faded_line_style is None:
2566: (12)                      style = dict(self.background_line_style)
2567: (12)                      # For anything numerical, like stroke_width
2568: (12)                      # and stroke_opacity, chop it in half
2569: (12)                      for key in style:
2570: (16)                          if isinstance(style[key], numbers.Number):
2571: (20)                              style[key] *= 0.5
2572: (12)                      self.faded_line_style = style
2573: (8)                   self.background_lines, self.faded_lines = self._get_lines()
2574: (8)                   self.background_lines.set_style(
2575: (12)                      **self.background_line_style,
2576: (8)                   )
2577: (8)                   self.faded_lines.set_style(
2578: (12)                      **self.faded_line_style,
2579: (8)                   )
2580: (8)                   self.add_to_back(
2581: (12)                      self.faded_lines,
2582: (12)                      self.background_lines,
2583: (8)                   )
2584: (4)               def _get_lines(self) -> tuple[VGroup, VGroup]:
2585: (8)                   """Generate all the lines and circles, faded and not faded.
2586: (8)                   Returns
2587: (8)                   -------
2588: (8)                   Tuple[:class:`~.VGroup`, :class:`~.VGroup`]
2589: (12)                      The first (i.e the non faded lines and circles) and second (i.e the faded lines and circles) sets of lines and circles, respectively.
2590: (8)                   """
2591: (8)                   center = self.get_origin()
2592: (8)                   ratio_faded_lines = self.faded_line_ratio
2593: (8)                   offset = self.azimuth_offset
2594: (8)                   if ratio_faded_lines == 0:  # don't show faded lines
2595: (12)                      ratio_faded_lines = 1  # i.e. set ratio to 1
2596: (8)                   rstep = (1 / ratio_faded_lines) * self.x_axis.x_range[2]
2597: (8)                   astep = (1 / ratio_faded_lines) * (TAU * (1 / self.azimuth_step))
2598: (8)                   rlines1 = VGroup()
2599: (8)                   rlines2 = VGroup()
2600: (8)                   alines1 = VGroup()
2601: (8)                   alines2 = VGroup()
2602: (8)                   rinput = np.arange(0, self.x_axis.x_range[1] + rstep, rstep)
2603: (8)                   ainput = np.arange(0, TAU, astep)
2604: (8)                   unit_vector = self.x_axis.get_unit_vector()[0]
2605: (8)                   for k, x in enumerate(rinput):
2606: (12)                      new_line = Circle(radius=x * unit_vector)
2607: (12)                      if k % ratio_faded_lines == 0:
2608: (16)                          alines1.add(new_line)
2609: (12)                      else:
2610: (16)                          alines2.add(new_line)
2611: (8)                   line = Line(center, self.get_x_axis().get_end())
2612: (8)                   for k, x in enumerate(ainput):
2613: (12)                      new_line = line.copy()
2614: (12)                      new_line.rotate(x + offset, about_point=center)
2615: (12)                      if k % ratio_faded_lines == 0:
2616: (16)                          rlines1.add(new_line)
2617: (12)                      else:
2618: (16)                          rlines2.add(new_line)
2619: (8)                   lines1 = VGroup(*rlines1, *alines1)
2620: (8)                   lines2 = VGroup(*rlines2, *alines2)
2621: (8)                   return lines1, lines2
2622: (4)               def get_axes(self) -> VGroup:
2623: (8)                   """Gets the axes.
2624: (8)                   Returns
2625: (8)                   -------
2626: (8)                   :class:`~.VGroup`
2627: (12)                      A pair of axes.
2628: (8)                   """
2629: (8)                   return self.axes
2630: (4)               def get_vector(self, coords: Sequence[ManimFloat], **kwargs: Any) -> Arrow:
2631: (8)                   kwargs["buff"] = 0
2632: (8)                   return Arrow(
2633: (12)                      self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs
2634: (8)                   )
2635: (4)               def prepare_for_nonlinear_transform(self, num_inserted_curves: int = 50) -> Self:
2636: (8)                   for mob in self.family_members_with_points():
2637: (12)                      num_curves = mob.get_num_curves()
2638: (12)                      if num_inserted_curves > num_curves:
2639: (16)                          mob.insert_n_curves(num_inserted_curves - num_curves)
2640: (8)                   return self
2641: (4)               def get_coordinate_labels(
2642: (8)                   self,
2643: (8)                   r_values: Iterable[float] | None = None,
2644: (8)                   a_values: Iterable[float] | None = None,
2645: (8)                   **kwargs: Any,
2646: (4)               ) -> VDict:
2647: (8)                   """Gets labels for the coordinates
2648: (8)                   Parameters
2649: (8)                   ----------
2650: (8)                   r_values
2651: (12)                      Iterable of values along the radius, by default None.
2652: (8)                   a_values
2653: (12)                      Iterable of values along the azimuth, by default None.
2654: (8)                   Returns
2655: (8)                   -------
2656: (8)                   VDict
2657: (12)                      Labels for the radius and azimuth values.
2658: (8)                   """
2659: (8)                   if r_values is None:
2660: (12)                      r_values = [r for r in self.get_x_axis().get_tick_range() if r >= 0]
2661: (8)                   if a_values is None:
2662: (12)                      a_values = np.arange(0, 1, 1 / self.azimuth_step)
2663: (8)                   r_mobs = self.get_x_axis().add_numbers(r_values)
2664: (8)                   if self.azimuth_direction == "CCW":
2665: (12)                      d = 1
2666: (8)                   elif self.azimuth_direction == "CW":
2667: (12)                      d = -1
2668: (8)                   else:
2669: (12)                      raise ValueError("Invalid azimuth direction. Expected one of: CW, CCW")
2670: (8)                   a_points = [
2671: (12)                      {
2672: (16)                          "label": i,
2673: (16)                          "point": np.array(
2674: (20)                              [
2675: (24)                                  self.get_right()[0]
2676: (24)                                  * np.cos(d * (i * TAU) + self.azimuth_offset),
2677: (24)                                  self.get_right()[0]
2678: (24)                                  * np.sin(d * (i * TAU) + self.azimuth_offset),
2679: (24)                                  0,
2680: (20)                              ],
2681: (16)                          ),
2682: (12)                      }
2683: (12)                      for i in a_values
2684: (8)                   ]
2685: (8)                   if self.azimuth_units == "PI radians" or self.azimuth_units == "TAU radians":
2686: (12)                      a_tex = [
2687: (16)                          self.get_radian_label(
2688: (20)                              i["label"],
2689: (20)                              font_size=self.azimuth_label_font_size,
2690: (16)                          ).next_to(
2691: (20)                              i["point"],
2692: (20)                              direction=i["point"],
2693: (20)                              aligned_edge=i["point"],
2694: (20)                              buff=self.azimuth_label_buff,
2695: (16)                          )
2696: (16)                          for i in a_points
2697: (12)                      ]
2698: (8)                   elif self.azimuth_units == "degrees":
2699: (12)                      a_tex = [
2700: (16)                          MathTex(
2701: (20)                              f'{360 * i["label"]:g}' + r"^{\circ}",
2702: (20)                              font_size=self.azimuth_label_font_size,
2703: (16)                          ).next_to(
2704: (20)                              i["point"],
2705: (20)                              direction=i["point"],
2706: (20)                              aligned_edge=i["point"],
2707: (20)                              buff=self.azimuth_label_buff,
2708: (16)                          )
2709: (16)                          for i in a_points
2710: (12)                      ]
2711: (8)                   elif self.azimuth_units == "gradians":
2712: (12)                      a_tex = [
2713: (16)                          MathTex(
2714: (20)                              f'{400 * i["label"]:g}' + r"^{g}",
2715: (20)                              font_size=self.azimuth_label_font_size,
2716: (16)                          ).next_to(
2717: (20)                              i["point"],
2718: (20)                              direction=i["point"],
2719: (20)                              aligned_edge=i["point"],
2720: (20)                              buff=self.azimuth_label_buff,
2721: (16)                          )
2722: (16)                          for i in a_points
2723: (12)                      ]
2724: (8)                   elif self.azimuth_units is None:
2725: (12)                      a_tex = [
2726: (16)                          MathTex(
2727: (20)                              f'{i["label"]:g}',
2728: (20)                              font_size=self.azimuth_label_font_size,
2729: (16)                          ).next_to(
2730: (20)                              i["point"],
2731: (20)                              direction=i["point"],
2732: (20)                              aligned_edge=i["point"],
2733: (20)                              buff=self.azimuth_label_buff,
2734: (16)                          )
2735: (16)                          for i in a_points
2736: (12)                      ]
2737: (8)                   a_mobs = VGroup(*a_tex)
2738: (8)                   self.coordinate_labels = VGroup(r_mobs, a_mobs)
2739: (8)                   return self.coordinate_labels
2740: (4)               def add_coordinates(
2741: (8)                   self,
2742: (8)                   r_values: Iterable[float] | None = None,
2743: (8)                   a_values: Iterable[float] | None = None,
2744: (4)               ) -> Self:
2745: (8)                   """Adds the coordinates.
2746: (8)                   Parameters
2747: (8)                   ----------
2748: (8)                   r_values
2749: (12)                      Iterable of values along the radius, by default None.
2750: (8)                   a_values
2751: (12)                      Iterable of values along the azimuth, by default None.
2752: (8)                   """
2753: (8)                   self.add(self.get_coordinate_labels(r_values, a_values))
2754: (8)                   return self
2755: (4)               def get_radian_label(self, number, font_size: float = 24, **kwargs: Any) -> MathTex:
2756: (8)                   constant_label = {"PI radians": r"\pi", "TAU radians": r"\tau"}[
2757: (12)                      self.azimuth_units
2758: (8)                   ]
2759: (8)                   division = number * {"PI radians": 2, "TAU radians": 1}[self.azimuth_units]
2760: (8)                   frac = fr.Fraction(division).limit_denominator(max_denominator=100)
2761: (8)                   if frac.numerator == 0 & frac.denominator == 0:
2762: (12)                      string = r"0"
2763: (8)                   elif frac.numerator == 1 and frac.denominator == 1:
2764: (12)                      string = constant_label
2765: (8)                   elif frac.numerator == 1:
2766: (12)                      if self.azimuth_compact_fraction:
2767: (16)                          string = (
2768: (20)                              r"\tfrac{" + constant_label + r"}{" + str(frac.denominator) + "}"
2769: (16)                          )
2770: (12)                      else:
2771: (16)                          string = r"\tfrac{1}{" + str(frac.denominator) + "}" + constant_label
2772: (8)                   elif frac.denominator == 1:
2773: (12)                      string = str(frac.numerator) + constant_label
2774: (8)                   else:
2775: (12)                      if self.azimuth_compact_fraction:
2776: (16)                          string = (
2777: (20)                              r"\tfrac{"
2778: (20)                              + str(frac.numerator)
2779: (20)                              + constant_label
2780: (20)                              + r"}{"
2781: (20)                              + str(frac.denominator)
2782: (20)                              + r"}"
2783: (16)                          )
2784: (12)                      else:
2785: (16)                          string = (
2786: (20)                              r"\tfrac{"
2787: (20)                              + str(frac.numerator)
2788: (20)                              + r"}{"
2789: (20)                              + str(frac.denominator)
2790: (20)                              + r"}"
2791: (20)                              + constant_label
2792: (16)                          )
2793: (8)                   return MathTex(string, font_size=font_size, **kwargs)
2794: (0)           class ComplexPlane(NumberPlane):
2795: (4)               """A :class:`~.NumberPlane` specialized for use with complex numbers.
2796: (4)               Examples
2797: (4)               --------
2798: (4)               .. manim:: ComplexPlaneExample
2799: (8)                   :save_last_frame:
2800: (8)                   :ref_classes: Dot MathTex
2801: (8)                   class ComplexPlaneExample(Scene):
2802: (12)                      def construct(self):
2803: (16)                          plane = ComplexPlane().add_coordinates()
2804: (16)                          self.add(plane)
2805: (16)                          d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)
2806: (16)                          d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)
2807: (16)                          label1 = MathTex("2+i").next_to(d1, UR, 0.1)
2808: (16)                          label2 = MathTex("-3-2i").next_to(d2, UR, 0.1)
2809: (16)                          self.add(
2810: (20)                              d1,
2811: (20)                              label1,
2812: (20)                              d2,
2813: (20)                              label2,
2814: (16)                          )
2815: (4)               """
2816: (4)               def __init__(self, **kwargs: Any) -> None:
2817: (8)                   super().__init__(
2818: (12)                      **kwargs,
2819: (8)                   )
2820: (4)               def number_to_point(self, number: float | complex) -> np.ndarray:
2821: (8)                   """Accepts a float/complex number and returns the equivalent point on the plane.
2822: (8)                   Parameters
2823: (8)                   ----------
2824: (8)                   number
2825: (12)                      The number. Can be a float or a complex number.
2826: (8)                   Returns
2827: (8)                   -------
2828: (8)                   np.ndarray
2829: (12)                      The point on the plane.
2830: (8)                   """
2831: (8)                   number = complex(number)
2832: (8)                   return self.coords_to_point(number.real, number.imag)
2833: (4)               def n2p(self, number: float | complex) -> np.ndarray:
2834: (8)                   """Abbreviation for :meth:`number_to_point`."""
2835: (8)                   return self.number_to_point(number)
2836: (4)               def point_to_number(self, point: Point3D) -> complex:
2837: (8)                   """Accepts a point and returns a complex number equivalent to that point on the plane.
2838: (8)                   Parameters
2839: (8)                   ----------
2840: (8)                   point
2841: (12)                      The point in manim's coordinate-system
2842: (8)                   Returns
2843: (8)                   -------
2844: (8)                   complex
2845: (12)                      A complex number consisting of real and imaginary components.
2846: (8)                   """
2847: (8)                   x, y = self.point_to_coords(point)
2848: (8)                   return complex(x, y)
2849: (4)               def p2n(self, point: Point3D) -> complex:
2850: (8)                   """Abbreviation for :meth:`point_to_number`."""
2851: (8)                   return self.point_to_number(point)
2852: (4)               def _get_default_coordinate_values(self) -> list[float | complex]:
2853: (8)                   """Generate a list containing the numerical values of the plane's labels.
2854: (8)                   Returns
2855: (8)                   -------
2856: (8)                   List[float | complex]
2857: (12)                      A list of floats representing the x-axis and complex numbers representing the y-axis.
2858: (8)                   """
2859: (8)                   x_numbers = self.get_x_axis().get_tick_range()
2860: (8)                   y_numbers = self.get_y_axis().get_tick_range()
2861: (8)                   y_numbers = [complex(0, y) for y in y_numbers if y != 0]
2862: (8)                   return [*x_numbers, *y_numbers]
2863: (4)               def get_coordinate_labels(
2864: (8)                   self, *numbers: Iterable[float | complex], **kwargs: Any
2865: (4)               ) -> VGroup:
2866: (8)                   """Generates the :class:`~.DecimalNumber` mobjects for the coordinates of the plane.
2867: (8)                   Parameters
2868: (8)                   ----------
2869: (8)                   numbers
2870: (12)                      An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.
2871: (8)                   kwargs
2872: (12)                      Additional arguments to be passed to :meth:`~.NumberLine.get_number_mobject`, i.e. :class:`~.DecimalNumber`.
2873: (8)                   Returns
2874: (8)                   -------
2875: (8)                   :class:`~.VGroup`
2876: (12)                      A :class:`~.VGroup` containing the positioned label mobjects.
2877: (8)                   """
2878: (8)                   # TODO: Make this work the same as coord_sys.add_coordinates()
2879: (8)                   if len(numbers) == 0:
2880: (12)                      numbers = self._get_default_coordinate_values()
2881: (8)                   self.coordinate_labels = VGroup()
2882: (8)                   for number in numbers:
2883: (12)                      z = complex(number)
2884: (12)                      if abs(z.imag) > abs(z.real):
2885: (16)                          axis = self.get_y_axis()
2886: (16)                          value = z.imag
2887: (16)                          kwargs["unit"] = "i"
2888: (12)                      else:
2889: (16)                          axis = self.get_x_axis()
2890: (16)                          value = z.real
2891: (12)                      number_mob = axis.get_number_mobject(value, **kwargs)
2892: (12)                      self.coordinate_labels.add(number_mob)
2893: (8)                   return self.coordinate_labels
2894: (4)               def add_coordinates(
2895: (8)                   self, *numbers: Iterable[float | complex], **kwargs: Any
2896: (4)               ) -> Self:
2897: (8)                   """Adds the labels produced from :meth:`~.NumberPlane.get_coordinate_labels` to the plane.
2898: (8)                   Parameters
2899: (8)                   ----------
2900: (8)                   numbers
2901: (12)                      An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.
2902: (8)                   kwargs
2903: (12)                      Additional arguments to be passed to :meth:`~.NumberLine.get_number_mobject`, i.e. :class:`~.DecimalNumber`.
2904: (8)                   """
2905: (8)                   self.add(self.get_coordinate_labels(*numbers, **kwargs))
2906: (8)                   return self

----------------------------------------

File 23 - .\opengl \opengl_compatibility.py:

1: (0)              from __future__ import annotations
2: (0)              from abc import ABCMeta
3: (0)              from manim import config
4: (0)              from manim.mobject.opengl.opengl_mobject import OpenGLMobject
5: (0)              from manim.mobject.opengl.opengl_point_cloud_mobject import OpenGLPMobject
6: (0)              from manim.mobject.opengl.opengl_three_dimensions import OpenGLSurface
7: (0)              from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject
8: (0)              from ...constants import RendererType
9: (0)              __all__ = ["ConvertToOpenGL"]
10: (0)             class ConvertToOpenGL(ABCMeta):
11: (4)                 """Metaclass for swapping (V)Mobject with its OpenGL counterpart at runtime
12: (4)                 depending on config.renderer. This metaclass should only need to be inherited
13: (4)                 on the lowest order inheritance classes such as Mobject and VMobject.
14: (4)                 """
15: (4)                 _converted_classes = []
16: (4)                 def __new__(mcls, name, bases, namespace):  # noqa: B902
17: (8)                     if config.renderer == RendererType.OPENGL:
18: (12)                        # Must check class names to prevent
19: (12)                        # cyclic importing.
20: (12)                        base_names_to_opengl = {
21: (16)                            "Mobject": OpenGLMobject,
22: (16)                            "VMobject": OpenGLVMobject,
23: (16)                            "PMobject": OpenGLPMobject,
24: (16)                            "Mobject1D": OpenGLPMobject,
25: (16)                            "Mobject2D": OpenGLPMobject,
26: (16)                            "Surface": OpenGLSurface,
27: (12)                        }
28: (12)                        bases = tuple(
29: (16)                            base_names_to_opengl.get(base.__name__, base) for base in bases
30: (12)                        )
31: (8)                     return super().__new__(mcls, name, bases, namespace)
32: (4)                 def __init__(cls, name, bases, namespace):  # noqa: B902
33: (8)                     super().__init__(name, bases, namespace)
34: (8)                     cls._converted_classes.append(cls)

----------------------------------------

File 24 - . \table.py:

1: (0)              r"""Mobjects representing tables.
2: (0)              Examples
3: (0)              --------
4: (0)              .. manim:: TableExamples
5: (4)                  :save_last_frame:
6: (4)                  class TableExamples(Scene):
7: (8)                      def construct(self):
8: (12)                         t0 = Table(
9: (16)                             [["First", "Second"],
10: (16)                            ["Third","Fourth"]],
11: (16)                            row_labels=[Text("R1"), Text("R2")],
12: (16)                            col_labels=[Text("C1"), Text("C2")],
13: (16)                            top_left_entry=Text("TOP"))
14: (12)                        t0.add_highlighted_cell((2,2), color=GREEN)
15: (12)                        x_vals = np.linspace(-2,2,5)
16: (12)                        y_vals = np.exp(x_vals)
17: (12)                        t1 = DecimalTable(
18: (16)                            [x_vals, y_vals],
19: (16)                            row_labels=[MathTex("x"), MathTex("f(x)")],
20: (16)                            include_outer_lines=True)
21: (12)                        t1.add(t1.get_cell((2,2), color=RED))
22: (12)                        t2 = MathTable(
23: (16)                            [["+", 0, 5, 10],
24: (16)                            [0, 0, 5, 10],
25: (16)                            [2, 2, 7, 12],
26: (16)                            [4, 4, 9, 14]],
27: (16)                            include_outer_lines=True)
28: (12)                        t2.get_horizontal_lines()[:3].set_color(BLUE)
29: (12)                        t2.get_vertical_lines()[:3].set_color(BLUE)
30: (12)                        t2.get_horizontal_lines()[:3].set_z_index(1)
31: (12)                        cross = VGroup(
32: (16)                            Line(UP + LEFT, DOWN + RIGHT),
33: (16)                            Line(UP + RIGHT, DOWN + LEFT))
34: (12)                        a = Circle().set_color(RED).scale(0.5)
35: (12)                        b = cross.set_color(BLUE).scale(0.5)
36: (12)                        t3 = MobjectTable(
37: (16)                            [[a.copy(),b.copy(),a.copy()],
38: (16)                            [b.copy(),a.copy(),a.copy()],
39: (16)                            [a.copy(),b.copy(),b.copy()]])
40: (12)                        t3.add(Line(
41: (16)                            t3.get_corner(DL), t3.get_corner(UR)
42: (12)                        ).set_color(RED))
43: (12)                        vals = np.arange(1,21).reshape(5,4)
44: (12)                        t4 = IntegerTable(
45: (16)                            vals,
46: (16)                            include_outer_lines=True
47: (12)                        )
48: (12)                        g1 = Group(t0, t1).scale(0.5).arrange(buff=1).to_edge(UP, buff=1)
49: (12)                        g2 = Group(t2, t3, t4).scale(0.5).arrange(buff=1).to_edge(DOWN, buff=1)
50: (12)                        self.add(g1, g2)
51: (0)             """
52: (0)             from __future__ import annotations
53: (0)             __all__ = [
54: (4)                 "Table",
55: (4)                 "MathTable",
56: (4)                 "MobjectTable",
57: (4)                 "IntegerTable",
58: (4)                 "DecimalTable",
59: (0)             ]
60: (0)             import itertools as it
61: (0)             from typing import Callable, Iterable, Sequence
62: (0)             from manim.mobject.geometry.line import Line
63: (0)             from manim.mobject.geometry.polygram import Polygon
64: (0)             from manim.mobject.geometry.shape_matchers import BackgroundRectangle
65: (0)             from manim.mobject.text.numbers import DecimalNumber, Integer
66: (0)             from manim.mobject.text.tex_mobject import MathTex
67: (0)             from manim.mobject.text.text_mobject import Paragraph
68: (0)             from ..animation.animation import Animation
69: (0)             from ..animation.composition import AnimationGroup
70: (0)             from ..animation.creation import Create, Write
71: (0)             from ..animation.fading import FadeIn
72: (0)             from ..mobject.types.vectorized_mobject import VGroup, VMobject
73: (0)             from ..utils.color import BLACK, YELLOW, ManimColor, ParsableManimColor
74: (0)             from .utils import get_vectorized_mobject_class
75: (0)             class Table(VGroup):
76: (4)                 """A mobject that displays a table on the screen.
77: (4)                 Parameters
78: (4)                 ----------
79: (4)                 table
80: (8)                     A 2D array or list of lists. Content of the table has to be a valid input
81: (8)                     for the callable set in ``element_to_mobject``.
82: (4)                 row_labels
83: (8)                     List of :class:`~.VMobject` representing the labels of each row.
84: (4)                 col_labels
85: (8)                     List of :class:`~.VMobject` representing the labels of each column.
86: (4)                 top_left_entry
87: (8)                     The top-left entry of the table, can only be specified if row and
88: (8)                     column labels are given.
89: (4)                 v_buff
90: (8)                     Vertical buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 0.8.
91: (4)                 h_buff
92: (8)                     Horizontal buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 1.3.
93: (4)                 include_outer_lines
94: (8)                     ``True`` if the table should include outer lines, by default False.
95: (4)                 add_background_rectangles_to_entries
96: (8)                     ``True`` if background rectangles should be added to entries, by default ``False``.
97: (4)                 entries_background_color
98: (8)                     Background color of entries if ``add_background_rectangles_to_entries`` is ``True``.
99: (4)                 include_background_rectangle
100: (8)                    ``True`` if the table should have a background rectangle, by default ``False``.
101: (4)                background_rectangle_color
102: (8)                    Background color of table if ``include_background_rectangle`` is ``True``.
103: (4)                element_to_mobject
104: (8)                    The :class:`~.Mobject` class applied to the table entries. by default :class:`~.Paragraph`. For common choices, see :mod:`~.text_mobject`/:mod:`~.tex_mobject`.
105: (4)                element_to_mobject_config
106: (8)                    Custom configuration passed to :attr:`element_to_mobject`, by default {}.
107: (4)                arrange_in_grid_config
108: (8)                    Dict passed to :meth:`~.Mobject.arrange_in_grid`, customizes the arrangement of the table.
109: (4)                line_config
110: (8)                    Dict passed to :class:`~.Line`, customizes the lines of the table.
111: (4)                kwargs
112: (8)                    Additional arguments to be passed to :class:`~.VGroup`.
113: (4)                Examples
114: (4)                --------
115: (4)                .. manim:: TableExamples
116: (8)                    :save_last_frame:
117: (8)                    class TableExamples(Scene):
118: (12)                       def construct(self):
119: (16)                           t0 = Table(
120: (20)                               [["This", "is a"],
121: (20)                               ["simple", "Table in \\n Manim."]])
122: (16)                           t1 = Table(
123: (20)                               [["This", "is a"],
124: (20)                               ["simple", "Table."]],
125: (20)                               row_labels=[Text("R1"), Text("R2")],
126: (20)                               col_labels=[Text("C1"), Text("C2")])
127: (16)                           t1.add_highlighted_cell((2,2), color=YELLOW)
128: (16)                           t2 = Table(
129: (20)                               [["This", "is a"],
130: (20)                               ["simple", "Table."]],
131: (20)                               row_labels=[Text("R1"), Text("R2")],
132: (20)                               col_labels=[Text("C1"), Text("C2")],
133: (20)                               top_left_entry=Star().scale(0.3),
134: (20)                               include_outer_lines=True,
135: (20)                               arrange_in_grid_config={"cell_alignment": RIGHT})
136: (16)                           t2.add(t2.get_cell((2,2), color=RED))
137: (16)                           t3 = Table(
138: (20)                               [["This", "is a"],
139: (20)                               ["simple", "Table."]],
140: (20)                               row_labels=[Text("R1"), Text("R2")],
141: (20)                               col_labels=[Text("C1"), Text("C2")],
142: (20)                               top_left_entry=Star().scale(0.3),
143: (20)                               include_outer_lines=True,
144: (20)                               line_config={"stroke_width": 1, "color": YELLOW})
145: (16)                           t3.remove(*t3.get_vertical_lines())
146: (16)                           g = Group(
147: (20)                               t0,t1,t2,t3
148: (16)                           ).scale(0.7).arrange_in_grid(buff=1)
149: (16)                           self.add(g)
150: (4)                .. manim:: BackgroundRectanglesExample
151: (8)                    :save_last_frame:
152: (8)                    class BackgroundRectanglesExample(Scene):
153: (12)                       def construct(self):
154: (16)                           background = Rectangle(height=6.5, width=13)
155: (16)                           background.set_fill(opacity=.5)
156: (16)                           background.set_color([TEAL, RED, YELLOW])
157: (16)                           self.add(background)
158: (16)                           t0 = Table(
159: (20)                               [["This", "is a"],
160: (20)                               ["simple", "Table."]],
161: (20)                               add_background_rectangles_to_entries=True)
162: (16)                           t1 = Table(
163: (20)                               [["This", "is a"],
164: (20)                               ["simple", "Table."]],
165: (20)                               include_background_rectangle=True)
166: (16)                           g = Group(t0, t1).scale(0.7).arrange(buff=0.5)
167: (16)                           self.add(g)
168: (4)                """
169: (4)                def __init__(
170: (8)                    self,
171: (8)                    table: Iterable[Iterable[float | str | VMobject]],
172: (8)                    row_labels: Iterable[VMobject] | None = None,
173: (8)                    col_labels: Iterable[VMobject] | None = None,
174: (8)                    top_left_entry: VMobject | None = None,
175: (8)                    v_buff: float = 0.8,
176: (8)                    h_buff: float = 1.3,
177: (8)                    include_outer_lines: bool = False,
178: (8)                    add_background_rectangles_to_entries: bool = False,
179: (8)                    entries_background_color: ParsableManimColor = BLACK,
180: (8)                    include_background_rectangle: bool = False,
181: (8)                    background_rectangle_color: ParsableManimColor = BLACK,
182: (8)                    element_to_mobject: Callable[
183: (12)                       [float | str | VMobject],
184: (12)                       VMobject,
185: (8)                    ] = Paragraph,
186: (8)                    element_to_mobject_config: dict = {},
187: (8)                    arrange_in_grid_config: dict = {},
188: (8)                    line_config: dict = {},
189: (8)                    **kwargs,
190: (4)                ):
191: (8)                    self.row_labels = row_labels
192: (8)                    self.col_labels = col_labels
193: (8)                    self.top_left_entry = top_left_entry
194: (8)                    self.row_dim = len(table)
195: (8)                    self.col_dim = len(table[0])
196: (8)                    self.v_buff = v_buff
197: (8)                    self.h_buff = h_buff
198: (8)                    self.include_outer_lines = include_outer_lines
199: (8)                    self.add_background_rectangles_to_entries = add_background_rectangles_to_entries
200: (8)                    self.entries_background_color = ManimColor(entries_background_color)
201: (8)                    self.include_background_rectangle = include_background_rectangle
202: (8)                    self.background_rectangle_color = ManimColor(background_rectangle_color)
203: (8)                    self.element_to_mobject = element_to_mobject
204: (8)                    self.element_to_mobject_config = element_to_mobject_config
205: (8)                    self.arrange_in_grid_config = arrange_in_grid_config
206: (8)                    self.line_config = line_config
207: (8)                    for row in table:
208: (12)                       if len(row) == len(table[0]):
209: (16)                           pass
210: (12)                       else:
211: (16)                           raise ValueError("Not all rows in table have the same length.")
212: (8)                    super().__init__(**kwargs)
213: (8)                    mob_table = self._table_to_mob_table(table)
214: (8)                    self.elements_without_labels = VGroup(*it.chain(*mob_table))
215: (8)                    mob_table = self._add_labels(mob_table)
216: (8)                    self._organize_mob_table(mob_table)
217: (8)                    self.elements = VGroup(*it.chain(*mob_table))
218: (8)                    if len(self.elements[0].get_all_points()) == 0:
219: (12)                       self.elements.remove(self.elements[0])
220: (8)                    self.add(self.elements)
221: (8)                    self.center()
222: (8)                    self.mob_table = mob_table
223: (8)                    self._add_horizontal_lines()
224: (8)                    self._add_vertical_lines()
225: (8)                    if self.add_background_rectangles_to_entries:
226: (12)                       self.add_background_to_entries(color=self.entries_background_color)
227: (8)                    if self.include_background_rectangle:
228: (12)                       self.add_background_rectangle(color=self.background_rectangle_color)
229: (4)                def _table_to_mob_table(
230: (8)                    self,
231: (8)                    table: Iterable[Iterable[float | str | VMobject]],
232: (4)                ) -> list:
233: (8)                    """Initilaizes the entries of ``table`` as :class:`~.VMobject`.
234: (8)                    Parameters
235: (8)                    ----------
236: (8)                    table
237: (12)                       A 2D array or list of lists. Content of the table has to be a valid input
238: (12)                       for the callable set in ``element_to_mobject``.
239: (8)                    Returns
240: (8)                    --------
241: (8)                    List
242: (12)                       List of :class:`~.VMobject` from the entries of ``table``.
243: (8)                    """
244: (8)                    return [
245: (12)                       [
246: (16)                           self.element_to_mobject(item, **self.element_to_mobject_config)
247: (16)                           for item in row
248: (12)                       ]
249: (12)                       for row in table
250: (8)                    ]
251: (4)                def _organize_mob_table(self, table: Iterable[Iterable[VMobject]]) -> VGroup:
252: (8)                    """Arranges the :class:`~.VMobject` of ``table`` in a grid.
253: (8)                    Parameters
254: (8)                    ----------
255: (8)                    table
256: (12)                       A 2D iterable object with :class:`~.VMobject` entries.
257: (8)                    Returns
258: (8)                    --------
259: (8)                    :class:`~.VGroup`
260: (12)                       The :class:`~.VMobject` of the ``table`` in a :class:`~.VGroup` already
261: (12)                       arranged in a table-like grid.
262: (8)                    """
263: (8)                    help_table = VGroup()
264: (8)                    for i, row in enumerate(table):
265: (12)                       for j, _ in enumerate(row):
266: (16)                           help_table.add(table[i][j])
267: (8)                    help_table.arrange_in_grid(
268: (12)                       rows=len(table),
269: (12)                       cols=len(table[0]),
270: (12)                       buff=(self.h_buff, self.v_buff),
271: (12)                       **self.arrange_in_grid_config,
272: (8)                    )
273: (8)                    return help_table
274: (4)                def _add_labels(self, mob_table: VGroup) -> VGroup:
275: (8)                    """Adds labels to an in a grid arranged :class:`~.VGroup`.
276: (8)                    Parameters
277: (8)                    ----------
278: (8)                    mob_table
279: (12)                       An in a grid organized class:`~.VGroup`.
280: (8)                    Returns
281: (8)                    --------
282: (8)                    :class:`~.VGroup`
283: (12)                       Returns the ``mob_table`` with added labels.
284: (8)                    """
285: (8)                    if self.row_labels is not None:
286: (12)                       for k in range(len(self.row_labels)):
287: (16)                           mob_table[k] = [self.row_labels[k]] + mob_table[k]
288: (8)                    if self.col_labels is not None:
289: (12)                       if self.row_labels is not None:
290: (16)                           if self.top_left_entry is not None:
291: (20)                               col_labels = [self.top_left_entry] + self.col_labels
292: (20)                               mob_table.insert(0, col_labels)
293: (16)                           else:
294: (20)                               # Placeholder to use arrange_in_grid if top_left_entry is not set.
295: (20)                               # Import OpenGLVMobject to work with --renderer=opengl
296: (20)                               dummy_mobject = get_vectorized_mobject_class()()
297: (20)                               col_labels = [dummy_mobject] + self.col_labels
298: (20)                               mob_table.insert(0, col_labels)
299: (12)                       else:
300: (16)                           mob_table.insert(0, self.col_labels)
301: (8)                    return mob_table
302: (4)                def _add_horizontal_lines(self) -> Table:
303: (8)                    """Adds the horizontal lines to the table."""
304: (8)                    anchor_left = self.get_left()[0] - 0.5 * self.h_buff
305: (8)                    anchor_right = self.get_right()[0] + 0.5 * self.h_buff
306: (8)                    line_group = VGroup()
307: (8)                    if self.include_outer_lines:
308: (12)                       anchor = self.get_rows()[0].get_top()[1] + 0.5 * self.v_buff
309: (12)                       line = Line(
310: (16)                           [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config
311: (12)                       )
312: (12)                       line_group.add(line)
313: (12)                       self.add(line)
314: (12)                       anchor = self.get_rows()[-1].get_bottom()[1] - 0.5 * self.v_buff
315: (12)                       line = Line(
316: (16)                           [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config
317: (12)                       )
318: (12)                       line_group.add(line)
319: (12)                       self.add(line)
320: (8)                    for k in range(len(self.mob_table) - 1):
321: (12)                       anchor = self.get_rows()[k + 1].get_top()[1] + 0.5 * (
322: (16)                           self.get_rows()[k].get_bottom()[1] - self.get_rows()[k + 1].get_top()[1]
323: (12)                       )
324: (12)                       line = Line(
325: (16)                           [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config
326: (12)                       )
327: (12)                       line_group.add(line)
328: (12)                       self.add(line)
329: (8)                    self.horizontal_lines = line_group
330: (8)                    return self
331: (4)                def _add_vertical_lines(self) -> Table:
332: (8)                    """Adds the vertical lines to the table"""
333: (8)                    anchor_top = self.get_rows().get_top()[1] + 0.5 * self.v_buff
334: (8)                    anchor_bottom = self.get_rows().get_bottom()[1] - 0.5 * self.v_buff
335: (8)                    line_group = VGroup()
336: (8)                    if self.include_outer_lines:
337: (12)                       anchor = self.get_columns()[0].get_left()[0] - 0.5 * self.h_buff
338: (12)                       line = Line(
339: (16)                           [anchor, anchor_top, 0], [anchor, anchor_bottom, 0], **self.line_config
340: (12)                       )
341: (12)                       line_group.add(line)
342: (12)                       self.add(line)
343: (12)                       anchor = self.get_columns()[-1].get_right()[0] + 0.5 * self.h_buff
344: (12)                       line = Line(
345: (16)                           [anchor, anchor_top, 0], [anchor, anchor_bottom, 0], **self.line_config
346: (12)                       )
347: (12)                       line_group.add(line)
348: (12)                       self.add(line)
349: (8)                    for k in range(len(self.mob_table[0]) - 1):
350: (12)                       anchor = self.get_columns()[k + 1].get_left()[0] + 0.5 * (
351: (16)                           self.get_columns()[k].get_right()[0]
352: (16)                           - self.get_columns()[k + 1].get_left()[0]
353: (12)                       )
354: (12)                       line = Line(
355: (16)                           [anchor, anchor_bottom, 0], [anchor, anchor_top, 0], **self.line_config
356: (12)                       )
357: (12)                       line_group.add(line)
358: (12)                       self.add(line)
359: (8)                    self.vertical_lines = line_group
360: (8)                    return self
361: (4)                def get_horizontal_lines(self) -> VGroup:
362: (8)                    """Return the horizontal lines of the table.
363: (8)                    Returns
364: (8)                    --------
365: (8)                    :class:`~.VGroup`
366: (12)                       :class:`~.VGroup` containing all the horizontal lines of the table.
367: (8)                    Examples
368: (8)                    --------
369: (8)                    .. manim:: GetHorizontalLinesExample
370: (12)                       :save_last_frame:
371: (12)                       class GetHorizontalLinesExample(Scene):
372: (16)                           def construct(self):
373: (20)                               table = Table(
374: (24)                                   [["First", "Second"],
375: (24)                                   ["Third","Fourth"]],
376: (24)                                   row_labels=[Text("R1"), Text("R2")],
377: (24)                                   col_labels=[Text("C1"), Text("C2")])
378: (20)                               table.get_horizontal_lines().set_color(RED)
379: (20)                               self.add(table)
380: (8)                    """
381: (8)                    return self.horizontal_lines
382: (4)                def get_vertical_lines(self) -> VGroup:
383: (8)                    """Return the vertical lines of the table.
384: (8)                    Returns
385: (8)                    --------
386: (8)                    :class:`~.VGroup`
387: (12)                       :class:`~.VGroup` containing all the vertical lines of the table.
388: (8)                    Examples
389: (8)                    --------
390: (8)                    .. manim:: GetVerticalLinesExample
391: (12)                       :save_last_frame:
392: (12)                       class GetVerticalLinesExample(Scene):
393: (16)                           def construct(self):
394: (20)                               table = Table(
395: (24)                                   [["First", "Second"],
396: (24)                                   ["Third","Fourth"]],
397: (24)                                   row_labels=[Text("R1"), Text("R2")],
398: (24)                                   col_labels=[Text("C1"), Text("C2")])
399: (20)                               table.get_vertical_lines()[0].set_color(RED)
400: (20)                               self.add(table)
401: (8)                    """
402: (8)                    return self.vertical_lines
403: (4)                def get_columns(self) -> VGroup:
404: (8)                    """Return columns of the table as a :class:`~.VGroup` of :class:`~.VGroup`.
405: (8)                    Returns
406: (8)                    --------
407: (8)                    :class:`~.VGroup`
408: (12)                       :class:`~.VGroup` containing each column in a :class:`~.VGroup`.
409: (8)                    Examples
410: (8)                    --------
411: (8)                    .. manim:: GetColumnsExample
412: (12)                       :save_last_frame:
413: (12)                       class GetColumnsExample(Scene):
414: (16)                           def construct(self):
415: (20)                               table = Table(
416: (24)                                   [["First", "Second"],
417: (24)                                   ["Third","Fourth"]],
418: (24)                                   row_labels=[Text("R1"), Text("R2")],
419: (24)                                   col_labels=[Text("C1"), Text("C2")])
420: (20)                               table.add(SurroundingRectangle(table.get_columns()[1]))
421: (20)                               self.add(table)
422: (8)                    """
423: (8)                    return VGroup(
424: (12)                       *(
425: (16)                           VGroup(*(row[i] for row in self.mob_table))
426: (16)                           for i in range(len(self.mob_table[0]))
427: (12)                       )
428: (8)                    )
429: (4)                def get_rows(self) -> VGroup:
430: (8)                    """Return the rows of the table as a :class:`~.VGroup` of :class:`~.VGroup`.
431: (8)                    Returns
432: (8)                    --------
433: (8)                    :class:`~.VGroup`
434: (12)                       :class:`~.VGroup` containing each row in a :class:`~.VGroup`.
435: (8)                    Examples
436: (8)                    --------
437: (8)                    .. manim:: GetRowsExample
438: (12)                       :save_last_frame:
439: (12)                       class GetRowsExample(Scene):
440: (16)                           def construct(self):
441: (20)                               table = Table(
442: (24)                                   [["First", "Second"],
443: (24)                                   ["Third","Fourth"]],
444: (24)                                   row_labels=[Text("R1"), Text("R2")],
445: (24)                                   col_labels=[Text("C1"), Text("C2")])
446: (20)                               table.add(SurroundingRectangle(table.get_rows()[1]))
447: (20)                               self.add(table)
448: (8)                    """
449: (8)                    return VGroup(*(VGroup(*row) for row in self.mob_table))
450: (4)                def set_column_colors(self, *colors: Iterable[ParsableManimColor]) -> Table:
451: (8)                    """Set individual colors for each column of the table.
452: (8)                    Parameters
453: (8)                    ----------
454: (8)                    colors
455: (12)                       An iterable of colors; each color corresponds to a column.
456: (8)                    Examples
457: (8)                    --------
458: (8)                    .. manim:: SetColumnColorsExample
459: (12)                       :save_last_frame:
460: (12)                       class SetColumnColorsExample(Scene):
461: (16)                           def construct(self):
462: (20)                               table = Table(
463: (24)                                   [["First", "Second"],
464: (24)                                   ["Third","Fourth"]],
465: (24)                                   row_labels=[Text("R1"), Text("R2")],
466: (24)                                   col_labels=[Text("C1"), Text("C2")]
467: (20)                               ).set_column_colors([RED,BLUE], GREEN)
468: (20)                               self.add(table)
469: (8)                    """
470: (8)                    columns = self.get_columns()
471: (8)                    for color, column in zip(colors, columns):
472: (12)                       column.set_color(color)
473: (8)                    return self
474: (4)                def set_row_colors(self, *colors: Iterable[ParsableManimColor]) -> Table:
475: (8)                    """Set individual colors for each row of the table.
476: (8)                    Parameters
477: (8)                    ----------
478: (8)                    colors
479: (12)                       An iterable of colors; each color corresponds to a row.
480: (8)                    Examples
481: (8)                    --------
482: (8)                    .. manim:: SetRowColorsExample
483: (12)                       :save_last_frame:
484: (12)                       class SetRowColorsExample(Scene):
485: (16)                           def construct(self):
486: (20)                               table = Table(
487: (24)                                   [["First", "Second"],
488: (24)                                   ["Third","Fourth"]],
489: (24)                                   row_labels=[Text("R1"), Text("R2")],
490: (24)                                   col_labels=[Text("C1"), Text("C2")]
491: (20)                               ).set_row_colors([RED,BLUE], GREEN)
492: (20)                               self.add(table)
493: (8)                    """
494: (8)                    rows = self.get_rows()
495: (8)                    for color, row in zip(colors, rows):
496: (12)                       row.set_color(color)
497: (8)                    return self
498: (4)                def get_entries(
499: (8)                    self,
500: (8)                    pos: Sequence[int] | None = None,
501: (4)                ) -> VMobject | VGroup:
502: (8)                    """Return the individual entries of the table (including labels) or one specific entry
503: (8)                    if the parameter, ``pos``,  is set.
504: (8)                    Parameters
505: (8)                    ----------
506: (8)                    pos
507: (12)                       The position of a specific entry on the table. ``(1,1)`` being the top left entry
508: (12)                       of the table.
509: (8)                    Returns
510: (8)                    -------
511: (8)                    Union[:class:`~.VMobject`, :class:`~.VGroup`]
512: (12)                       :class:`~.VGroup` containing all entries of the table (including labels)
513: (12)                       or the :class:`~.VMobject` at the given position if ``pos`` is set.
514: (8)                    Examples
515: (8)                    --------
516: (8)                    .. manim:: GetEntriesExample
517: (12)                       :save_last_frame:
518: (12)                       class GetEntriesExample(Scene):
519: (16)                           def construct(self):
520: (20)                               table = Table(
521: (24)                                   [["First", "Second"],
522: (24)                                   ["Third","Fourth"]],
523: (24)                                   row_labels=[Text("R1"), Text("R2")],
524: (24)                                   col_labels=[Text("C1"), Text("C2")])
525: (20)                               ent = table.get_entries()
526: (20)                               for item in ent:
527: (24)                                   item.set_color(random_bright_color())
528: (20)                               table.get_entries((2,2)).rotate(PI)
529: (20)                               self.add(table)
530: (8)                    """
531: (8)                    if pos is not None:
532: (12)                       if (
533: (16)                           self.row_labels is not None
534: (16)                           and self.col_labels is not None
535: (16)                           and self.top_left_entry is None
536: (12)                       ):
537: (16)                           index = len(self.mob_table[0]) * (pos[0] - 1) + pos[1] - 2
538: (16)                           return self.elements[index]
539: (12)                       else:
540: (16)                           index = len(self.mob_table[0]) * (pos[0] - 1) + pos[1] - 1
541: (16)                           return self.elements[index]
542: (8)                    else:
543: (12)                       return self.elements
544: (4)                def get_entries_without_labels(
545: (8)                    self,
546: (8)                    pos: Sequence[int] | None = None,
547: (4)                ) -> VMobject | VGroup:
548: (8)                    """Return the individual entries of the table (without labels) or one specific entry
549: (8)                    if the parameter, ``pos``, is set.
550: (8)                    Parameters
551: (8)                    ----------
552: (8)                    pos
553: (12)                       The position of a specific entry on the table. ``(1,1)`` being the top left entry
554: (12)                       of the table (without labels).
555: (8)                    Returns
556: (8)                    -------
557: (8)                    Union[:class:`~.VMobject`, :class:`~.VGroup`]
558: (12)                       :class:`~.VGroup` containing all entries of the table (without labels)
559: (12)                       or the :class:`~.VMobject` at the given position if ``pos`` is set.
560: (8)                    Examples
561: (8)                    --------
562: (8)                    .. manim:: GetEntriesWithoutLabelsExample
563: (12)                       :save_last_frame:
564: (12)                       class GetEntriesWithoutLabelsExample(Scene):
565: (16)                           def construct(self):
566: (20)                               table = Table(
567: (24)                                   [["First", "Second"],
568: (24)                                   ["Third","Fourth"]],
569: (24)                                   row_labels=[Text("R1"), Text("R2")],
570: (24)                                   col_labels=[Text("C1"), Text("C2")])
571: (20)                               ent = table.get_entries_without_labels()
572: (20)                               colors = [BLUE, GREEN, YELLOW, RED]
573: (20)                               for k in range(len(colors)):
574: (24)                                   ent[k].set_color(colors[k])
575: (20)                               table.get_entries_without_labels((2,2)).rotate(PI)
576: (20)                               self.add(table)
577: (8)                    """
578: (8)                    if pos is not None:
579: (12)                       index = self.col_dim * (pos[0] - 1) + pos[1] - 1
580: (12)                       return self.elements_without_labels[index]
581: (8)                    else:
582: (12)                       return self.elements_without_labels
583: (4)                def get_row_labels(self) -> VGroup:
584: (8)                    """Return the row labels of the table.
585: (8)                    Returns
586: (8)                    -------
587: (8)                    :class:`~.VGroup`
588: (12)                       :class:`~.VGroup` containing the row labels of the table.
589: (8)                    Examples
590: (8)                    --------
591: (8)                    .. manim:: GetRowLabelsExample
592: (12)                       :save_last_frame:
593: (12)                       class GetRowLabelsExample(Scene):
594: (16)                           def construct(self):
595: (20)                               table = Table(
596: (24)                                   [["First", "Second"],
597: (24)                                   ["Third","Fourth"]],
598: (24)                                   row_labels=[Text("R1"), Text("R2")],
599: (24)                                   col_labels=[Text("C1"), Text("C2")])
600: (20)                               lab = table.get_row_labels()
601: (20)                               for item in lab:
602: (24)                                   item.set_color(random_bright_color())
603: (20)                               self.add(table)
604: (8)                    """
605: (8)                    return VGroup(*self.row_labels)
606: (4)                def get_col_labels(self) -> VGroup:
607: (8)                    """Return the column labels of the table.
608: (8)                    Returns
609: (8)                    --------
610: (8)                    :class:`~.VGroup`
611: (12)                       VGroup containing the column labels of the table.
612: (8)                    Examples
613: (8)                    --------
614: (8)                    .. manim:: GetColLabelsExample
615: (12)                       :save_last_frame:
616: (12)                       class GetColLabelsExample(Scene):
617: (16)                           def construct(self):
618: (20)                               table = Table(
619: (24)                                   [["First", "Second"],
620: (24)                                   ["Third","Fourth"]],
621: (24)                                   row_labels=[Text("R1"), Text("R2")],
622: (24)                                   col_labels=[Text("C1"), Text("C2")])
623: (20)                               lab = table.get_col_labels()
624: (20)                               for item in lab:
625: (24)                                   item.set_color(random_bright_color())
626: (20)                               self.add(table)
627: (8)                    """
628: (8)                    return VGroup(*self.col_labels)
629: (4)                def get_labels(self) -> VGroup:
630: (8)                    """Returns the labels of the table.
631: (8)                    Returns
632: (8)                    --------
633: (8)                    :class:`~.VGroup`
634: (12)                       :class:`~.VGroup` containing all the labels of the table.
635: (8)                    Examples
636: (8)                    --------
637: (8)                    .. manim:: GetLabelsExample
638: (12)                       :save_last_frame:
639: (12)                       class GetLabelsExample(Scene):
640: (16)                           def construct(self):
641: (20)                               table = Table(
642: (24)                                   [["First", "Second"],
643: (24)                                   ["Third","Fourth"]],
644: (24)                                   row_labels=[Text("R1"), Text("R2")],
645: (24)                                   col_labels=[Text("C1"), Text("C2")])
646: (20)                               lab = table.get_labels()
647: (20)                               colors = [BLUE, GREEN, YELLOW, RED]
648: (20)                               for k in range(len(colors)):
649: (24)                                   lab[k].set_color(colors[k])
650: (20)                               self.add(table)
651: (8)                    """
652: (8)                    label_group = VGroup()
653: (8)                    if self.top_left_entry is not None:
654: (12)                       label_group.add(self.top_left_entry)
655: (8)                    for label in (self.col_labels, self.row_labels):
656: (12)                       if label is not None:
657: (16)                           label_group.add(*label)
658: (8)                    return label_group
659: (4)                def add_background_to_entries(self, color: ParsableManimColor = BLACK) -> Table:
660: (8)                    """Adds a black :class:`~.BackgroundRectangle` to each entry of the table."""
661: (8)                    for mob in self.get_entries():
662: (12)                       mob.add_background_rectangle(color=ManimColor(color))
663: (8)                    return self
664: (4)                def get_cell(self, pos: Sequence[int] = (1, 1), **kwargs) -> Polygon:
665: (8)                    """Returns one specific cell as a rectangular :class:`~.Polygon` without the entry.
666: (8)                    Parameters
667: (8)                    ----------
668: (8)                    pos
669: (12)                       The position of a specific entry on the table. ``(1,1)`` being the top left entry
670: (12)                       of the table.
671: (8)                    kwargs
672: (12)                       Additional arguments to be passed to :class:`~.Polygon`.
673: (8)                    Returns
674: (8)                    -------
675: (8)                    :class:`~.Polygon`
676: (12)                       Polygon mimicking one specific cell of the Table.
677: (8)                    Examples
678: (8)                    --------
679: (8)                    .. manim:: GetCellExample
680: (12)                       :save_last_frame:
681: (12)                       class GetCellExample(Scene):
682: (16)                           def construct(self):
683: (20)                               table = Table(
684: (24)                                   [["First", "Second"],
685: (24)                                   ["Third","Fourth"]],
686: (24)                                   row_labels=[Text("R1"), Text("R2")],
687: (24)                                   col_labels=[Text("C1"), Text("C2")])
688: (20)                               cell = table.get_cell((2,2), color=RED)
689: (20)                               self.add(table, cell)
690: (8)                    """
691: (8)                    row = self.get_rows()[pos[0] - 1]
692: (8)                    col = self.get_columns()[pos[1] - 1]
693: (8)                    edge_UL = [
694: (12)                       col.get_left()[0] - self.h_buff / 2,
695: (12)                       row.get_top()[1] + self.v_buff / 2,
696: (12)                       0,
697: (8)                    ]
698: (8)                    edge_UR = [
699: (12)                       col.get_right()[0] + self.h_buff / 2,
700: (12)                       row.get_top()[1] + self.v_buff / 2,
701: (12)                       0,
702: (8)                    ]
703: (8)                    edge_DL = [
704: (12)                       col.get_left()[0] - self.h_buff / 2,
705: (12)                       row.get_bottom()[1] - self.v_buff / 2,
706: (12)                       0,
707: (8)                    ]
708: (8)                    edge_DR = [
709: (12)                       col.get_right()[0] + self.h_buff / 2,
710: (12)                       row.get_bottom()[1] - self.v_buff / 2,
711: (12)                       0,
712: (8)                    ]
713: (8)                    rec = Polygon(edge_UL, edge_UR, edge_DR, edge_DL, **kwargs)
714: (8)                    return rec
715: (4)                def get_highlighted_cell(
716: (8)                    self, pos: Sequence[int] = (1, 1), color: ParsableManimColor = YELLOW, **kwargs
717: (4)                ) -> BackgroundRectangle:
718: (8)                    """Returns a :class:`~.BackgroundRectangle` of the cell at the given position.
719: (8)                    Parameters
720: (8)                    ----------
721: (8)                    pos
722: (12)                       The position of a specific entry on the table. ``(1,1)`` being the top left entry
723: (12)                       of the table.
724: (8)                    color
725: (12)                       The color used to highlight the cell.
726: (8)                    kwargs
727: (12)                       Additional arguments to be passed to :class:`~.BackgroundRectangle`.
728: (8)                    Examples
729: (8)                    --------
730: (8)                    .. manim:: GetHighlightedCellExample
731: (12)                       :save_last_frame:
732: (12)                       class GetHighlightedCellExample(Scene):
733: (16)                           def construct(self):
734: (20)                               table = Table(
735: (24)                                   [["First", "Second"],
736: (24)                                   ["Third","Fourth"]],
737: (24)                                   row_labels=[Text("R1"), Text("R2")],
738: (24)                                   col_labels=[Text("C1"), Text("C2")])
739: (20)                               highlight = table.get_highlighted_cell((2,2), color=GREEN)
740: (20)                               table.add_to_back(highlight)
741: (20)                               self.add(table)
742: (8)                    """
743: (8)                    cell = self.get_cell(pos)
744: (8)                    bg_cell = BackgroundRectangle(cell, color=ManimColor(color), **kwargs)
745: (8)                    return bg_cell
746: (4)                def add_highlighted_cell(
747: (8)                    self, pos: Sequence[int] = (1, 1), color: ParsableManimColor = YELLOW, **kwargs
748: (4)                ) -> Table:
749: (8)                    """Highlights one cell at a specific position on the table by adding a :class:`~.BackgroundRectangle`.
750: (8)                    Parameters
751: (8)                    ----------
752: (8)                    pos
753: (12)                       The position of a specific entry on the table. ``(1,1)`` being the top left entry
754: (12)                       of the table.
755: (8)                    color
756: (12)                       The color used to highlight the cell.
757: (8)                    kwargs
758: (12)                       Additional arguments to be passed to :class:`~.BackgroundRectangle`.
759: (8)                    Examples
760: (8)                    --------
761: (8)                    .. manim:: AddHighlightedCellExample
762: (12)                       :save_last_frame:
763: (12)                       class AddHighlightedCellExample(Scene):
764: (16)                           def construct(self):
765: (20)                               table = Table(
766: (24)                                   [["First", "Second"],
767: (24)                                   ["Third","Fourth"]],
768: (24)                                   row_labels=[Text("R1"), Text("R2")],
769: (24)                                   col_labels=[Text("C1"), Text("C2")])
770: (20)                               table.add_highlighted_cell((2,2), color=GREEN)
771: (20)                               self.add(table)
772: (8)                    """
773: (8)                    bg_cell = self.get_highlighted_cell(pos, color=ManimColor(color), **kwargs)
774: (8)                    self.add_to_back(bg_cell)
775: (8)                    entry = self.get_entries(pos)
776: (8)                    entry.background_rectangle = bg_cell
777: (8)                    return self
778: (4)                def create(
779: (8)                    self,
780: (8)                    lag_ratio: float = 1,
781: (8)                    line_animation: Callable[[VMobject | VGroup], Animation] = Create,
782: (8)                    label_animation: Callable[[VMobject | VGroup], Animation] = Write,
783: (8)                    element_animation: Callable[[VMobject | VGroup], Animation] = Create,
784: (8)                    entry_animation: Callable[[VMobject | VGroup], Animation] = FadeIn,
785: (8)                    **kwargs,
786: (4)                ) -> AnimationGroup:
787: (8)                    """Customized create-type function for tables.
788: (8)                    Parameters
789: (8)                    ----------
790: (8)                    lag_ratio
791: (12)                       The lag ratio of the animation.
792: (8)                    line_animation
793: (12)                       The animation style of the table lines, see :mod:`~.creation` for examples.
794: (8)                    label_animation
795: (12)                       The animation style of the table labels, see :mod:`~.creation` for examples.
796: (8)                    element_animation
797: (12)                       The animation style of the table elements, see :mod:`~.creation` for examples.
798: (8)                    entry_animation
799: (12)                       The entry animation of the table background, see :mod:`~.creation` for examples.
800: (8)                    kwargs
801: (12)                       Further arguments passed to the creation animations.
802: (8)                    Returns
803: (8)                    -------
804: (8)                    :class:`~.AnimationGroup`
805: (12)                       AnimationGroup containing creation of the lines and of the elements.
806: (8)                    Examples
807: (8)                    --------
808: (8)                    .. manim:: CreateTableExample
809: (12)                       class CreateTableExample(Scene):
810: (16)                           def construct(self):
811: (20)                               table = Table(
812: (24)                                   [["First", "Second"],
813: (24)                                   ["Third","Fourth"]],
814: (24)                                   row_labels=[Text("R1"), Text("R2")],
815: (24)                                   col_labels=[Text("C1"), Text("C2")],
816: (24)                                   include_outer_lines=True)
817: (20)                               self.play(table.create())
818: (20)                               self.wait()
819: (8)                    """
820: (8)                    animations: Sequence[Animation] = [
821: (12)                       line_animation(
822: (16)                           VGroup(self.vertical_lines, self.horizontal_lines),
823: (16)                           **kwargs,
824: (12)                       ),
825: (12)                       element_animation(self.elements_without_labels.set_z_index(2), **kwargs),
826: (8)                    ]
827: (8)                    if self.get_labels():
828: (12)                       animations += [
829: (16)                           label_animation(self.get_labels(), **kwargs),
830: (12)                       ]
831: (8)                    if self.get_entries():
832: (12)                       for entry in self.elements_without_labels:
833: (16)                           try:
834: (20)                               animations += [
835: (24)                                   entry_animation(
836: (28)                                       entry.background_rectangle,
837: (28)                                       **kwargs,
838: (24)                                   )
839: (20)                               ]
840: (16)                           except AttributeError:
841: (20)                               continue
842: (8)                    return AnimationGroup(*animations, lag_ratio=lag_ratio)
843: (4)                def scale(self, scale_factor: float, **kwargs):
844: (8)                    # h_buff and v_buff must be adjusted so that Table.get_cell
845: (8)                    # can construct an accurate polygon for a cell.
846: (8)                    self.h_buff *= scale_factor
847: (8)                    self.v_buff *= scale_factor
848: (8)                    super().scale(scale_factor, **kwargs)
849: (8)                    return self
850: (0)            class MathTable(Table):
851: (4)                """A specialized :class:`~.Table` mobject for use with LaTeX.
852: (4)                Examples
853: (4)                --------
854: (4)                .. manim:: MathTableExample
855: (8)                    :save_last_frame:
856: (8)                    class MathTableExample(Scene):
857: (12)                       def construct(self):
858: (16)                           t0 = MathTable(
859: (20)                               [["+", 0, 5, 10],
860: (20)                               [0, 0, 5, 10],
861: (20)                               [2, 2, 7, 12],
862: (20)                               [4, 4, 9, 14]],
863: (20)                               include_outer_lines=True)
864: (16)                           self.add(t0)
865: (4)                """
866: (4)                def __init__(
867: (8)                    self,
868: (8)                    table: Iterable[Iterable[float | str]],
869: (8)                    element_to_mobject: Callable[[float | str], VMobject] = MathTex,
870: (8)                    **kwargs,
871: (4)                ):
872: (8)                    """
873: (8)                    Special case of :class:`~.Table` with `element_to_mobject` set to :class:`~.MathTex`.
874: (8)                    Every entry in `table` is set in a Latex `align` environment.
875: (8)                    Parameters
876: (8)                    ----------
877: (8)                    table
878: (12)                       A 2d array or list of lists. Content of the table have to be valid input
879: (12)                       for :class:`~.MathTex`.
880: (8)                    element_to_mobject
881: (12)                       The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.MathTex`.
882: (8)                    kwargs
883: (12)                       Additional arguments to be passed to :class:`~.Table`.
884: (8)                    """
885: (8)                    super().__init__(
886: (12)                       table,
887: (12)                       element_to_mobject=element_to_mobject,
888: (12)                       **kwargs,
889: (8)                    )
890: (0)            class MobjectTable(Table):
891: (4)                """A specialized :class:`~.Table` mobject for use with :class:`~.Mobject`.
892: (4)                Examples
893: (4)                --------
894: (4)                .. manim:: MobjectTableExample
895: (8)                    :save_last_frame:
896: (8)                    class MobjectTableExample(Scene):
897: (12)                       def construct(self):
898: (16)                           cross = VGroup(
899: (20)                               Line(UP + LEFT, DOWN + RIGHT),
900: (20)                               Line(UP + RIGHT, DOWN + LEFT),
901: (16)                           )
902: (16)                           a = Circle().set_color(RED).scale(0.5)
903: (16)                           b = cross.set_color(BLUE).scale(0.5)
904: (16)                           t0 = MobjectTable(
905: (20)                               [[a.copy(),b.copy(),a.copy()],
906: (20)                               [b.copy(),a.copy(),a.copy()],
907: (20)                               [a.copy(),b.copy(),b.copy()]]
908: (16)                           )
909: (16)                           line = Line(
910: (20)                               t0.get_corner(DL), t0.get_corner(UR)
911: (16)                           ).set_color(RED)
912: (16)                           self.add(t0, line)
913: (4)                """
914: (4)                def __init__(
915: (8)                    self,
916: (8)                    table: Iterable[Iterable[VMobject]],
917: (8)                    element_to_mobject: Callable[[VMobject], VMobject] = lambda m: m,
918: (8)                    **kwargs,
919: (4)                ):
920: (8)                    """
921: (8)                    Special case of :class:`~.Table` with ``element_to_mobject`` set to an identity function.
922: (8)                    Here, every item in ``table`` must already be of type :class:`~.Mobject`.
923: (8)                    Parameters
924: (8)                    ----------
925: (8)                    table
926: (12)                       A 2D array or list of lists. Content of the table must be of type :class:`~.Mobject`.
927: (8)                    element_to_mobject
928: (12)                       The :class:`~.Mobject` class applied to the table entries. Set as ``lambda m : m`` to return itself.
929: (8)                    kwargs
930: (12)                       Additional arguments to be passed to :class:`~.Table`.
931: (8)                    """
932: (8)                    super().__init__(table, element_to_mobject=element_to_mobject, **kwargs)
933: (0)            class IntegerTable(Table):
934: (4)                """A specialized :class:`~.Table` mobject for use with :class:`~.Integer`.
935: (4)                Examples
936: (4)                --------
937: (4)                .. manim:: IntegerTableExample
938: (8)                    :save_last_frame:
939: (8)                    class IntegerTableExample(Scene):
940: (12)                       def construct(self):
941: (16)                           t0 = IntegerTable(
942: (20)                               [[0,30,45,60,90],
943: (20)                               [90,60,45,30,0]],
944: (20)                               col_labels=[
945: (24)                                   MathTex("\\\\frac{\\sqrt{0}}{2}"),
946: (24)                                   MathTex("\\\\frac{\\sqrt{1}}{2}"),
947: (24)                                   MathTex("\\\\frac{\\sqrt{2}}{2}"),
948: (24)                                   MathTex("\\\\frac{\\sqrt{3}}{2}"),
949: (24)                                   MathTex("\\\\frac{\\sqrt{4}}{2}")],
950: (20)                               row_labels=[MathTex("\\sin"), MathTex("\\cos")],
951: (20)                               h_buff=1,
952: (20)                               element_to_mobject_config={"unit": "^{\\circ}"})
953: (16)                           self.add(t0)
954: (4)                """
955: (4)                def __init__(
956: (8)                    self,
957: (8)                    table: Iterable[Iterable[float | str]],
958: (8)                    element_to_mobject: Callable[[float | str], VMobject] = Integer,
959: (8)                    **kwargs,
960: (4)                ):
961: (8)                    """
962: (8)                    Special case of :class:`~.Table` with `element_to_mobject` set to :class:`~.Integer`.
963: (8)                    Will round if there are decimal entries in the table.
964: (8)                    Parameters
965: (8)                    ----------
966: (8)                    table
967: (12)                       A 2d array or list of lists. Content of the table has to be valid input
968: (12)                       for :class:`~.Integer`.
969: (8)                    element_to_mobject
970: (12)                       The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.Integer`.
971: (8)                    kwargs
972: (12)                       Additional arguments to be passed to :class:`~.Table`.
973: (8)                    """
974: (8)                    super().__init__(table, element_to_mobject=element_to_mobject, **kwargs)
975: (0)            class DecimalTable(Table):
976: (4)                """A specialized :class:`~.Table` mobject for use with :class:`~.DecimalNumber` to display decimal entries.
977: (4)                Examples
978: (4)                --------
979: (4)                .. manim:: DecimalTableExample
980: (8)                    :save_last_frame:
981: (8)                    class DecimalTableExample(Scene):
982: (12)                       def construct(self):
983: (16)                           x_vals = [-2,-1,0,1,2]
984: (16)                           y_vals = np.exp(x_vals)
985: (16)                           t0 = DecimalTable(
986: (20)                               [x_vals, y_vals],
987: (20)                               row_labels=[MathTex("x"), MathTex("f(x)=e^{x}")],
988: (20)                               h_buff=1,
989: (20)                               element_to_mobject_config={"num_decimal_places": 2})
990: (16)                           self.add(t0)
991: (4)                """
992: (4)                def __init__(
993: (8)                    self,
994: (8)                    table: Iterable[Iterable[float | str]],
995: (8)                    element_to_mobject: Callable[[float | str], VMobject] = DecimalNumber,
996: (8)                    element_to_mobject_config: dict = {"num_decimal_places": 1},
997: (8)                    **kwargs,
998: (4)                ):
999: (8)                    """
1000: (8)                   Special case of :class:`~.Table` with ``element_to_mobject`` set to :class:`~.DecimalNumber`.
1001: (8)                   By default, ``num_decimal_places`` is set to 1.
1002: (8)                   Will round/truncate the decimal places based on the provided ``element_to_mobject_config``.
1003: (8)                   Parameters
1004: (8)                   ----------
1005: (8)                   table
1006: (12)                      A 2D array, or a list of lists. Content of the table must be valid input
1007: (12)                      for :class:`~.DecimalNumber`.
1008: (8)                   element_to_mobject
1009: (12)                      The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.DecimalNumber`.
1010: (8)                   element_to_mobject_config
1011: (12)                      Element to mobject config, here set as {"num_decimal_places": 1}.
1012: (8)                   kwargs
1013: (12)                      Additional arguments to be passed to :class:`~.Table`.
1014: (8)                   """
1015: (8)                   super().__init__(
1016: (12)                      table,
1017: (12)                      element_to_mobject=element_to_mobject,
1018: (12)                      element_to_mobject_config=element_to_mobject_config,
1019: (12)                      **kwargs,
1020: (8)                   )

----------------------------------------

File 25 - .\svg \brace.py:

1: (0)              """Mobject representing curly braces."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["Brace", "BraceLabel", "ArcBrace", "BraceText", "BraceBetweenPoints"]
4: (0)              from typing import Sequence
5: (0)              import numpy as np
6: (0)              import svgelements as se
7: (0)              from manim._config import config
8: (0)              from manim.mobject.geometry.arc import Arc
9: (0)              from manim.mobject.geometry.line import Line
10: (0)             from manim.mobject.mobject import Mobject
11: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
12: (0)             from manim.mobject.text.tex_mobject import MathTex, Tex
13: (0)             from ...animation.composition import AnimationGroup
14: (0)             from ...animation.fading import FadeIn
15: (0)             from ...animation.growing import GrowFromCenter
16: (0)             from ...constants import *
17: (0)             from ...mobject.types.vectorized_mobject import VMobject
18: (0)             from ...utils.color import BLACK
19: (0)             from ..svg.svg_mobject import VMobjectFromSVGPath
20: (0)             __all__ = ["Brace", "BraceBetweenPoints", "BraceLabel", "ArcBrace"]
21: (0)             class Brace(VMobjectFromSVGPath):
22: (4)                 """Takes a mobject and draws a brace adjacent to it.
23: (4)                 Passing a direction vector determines the direction from which the
24: (4)                 brace is drawn. By default it is drawn from below.
25: (4)                 Parameters
26: (4)                 ----------
27: (4)                 mobject
28: (8)                     The mobject adjacent to which the brace is placed.
29: (4)                 direction :
30: (8)                     The direction from which the brace faces the mobject.
31: (4)                 See Also
32: (4)                 --------
33: (4)                 :class:`BraceBetweenPoints`
34: (4)                 Examples
35: (4)                 --------
36: (4)                 .. manim:: BraceExample
37: (8)                     :save_last_frame:
38: (8)                     class BraceExample(Scene):
39: (12)                        def construct(self):
40: (16)                            s = Square()
41: (16)                            self.add(s)
42: (16)                            for i in np.linspace(0.1,1.0,4):
43: (20)                                br = Brace(s, sharpness=i)
44: (20)                                t = Text(f"sharpness= {i}").next_to(br, RIGHT)
45: (20)                                self.add(t)
46: (20)                                self.add(br)
47: (16)                            VGroup(*self.mobjects).arrange(DOWN, buff=0.2)
48: (4)                 """
49: (4)                 def __init__(
50: (8)                     self,
51: (8)                     mobject: Mobject,
52: (8)                     direction: Sequence[float] | None = DOWN,
53: (8)                     buff=0.2,
54: (8)                     sharpness=2,
55: (8)                     stroke_width=0,
56: (8)                     fill_opacity=1.0,
57: (8)                     background_stroke_width=0,
58: (8)                     background_stroke_color=BLACK,
59: (8)                     **kwargs,
60: (4)                 ):
61: (8)                     path_string_template = (
62: (12)                        "m0.01216 0c-0.01152 0-0.01216 6.103e-4 -0.01216 0.01311v0.007762c0.06776 "
63: (12)                        "0.122 0.1799 0.1455 0.2307 0.1455h{0}c0.03046 3.899e-4 0.07964 0.00449 "
64: (12)                        "0.1246 0.02636 0.0537 0.02695 0.07418 0.05816 0.08648 0.07769 0.001562 "
65: (12)                        "0.002538 0.004539 0.002563 0.01098 0.002563 0.006444-2e-8 0.009421-2.47e-"
66: (12)                        "5 0.01098-0.002563 0.0123-0.01953 0.03278-0.05074 0.08648-0.07769 0.04491"
67: (12)                        "-0.02187 0.09409-0.02597 0.1246-0.02636h{0}c0.05077 0 0.1629-0.02346 "
68: (12)                        "0.2307-0.1455v-0.007762c-1.78e-6 -0.0125-6.365e-4 -0.01311-0.01216-0.0131"
69: (12)                        "1-0.006444-3.919e-8 -0.009348 2.448e-5 -0.01091 0.002563-0.0123 0.01953-"
70: (12)                        "0.03278 0.05074-0.08648 0.07769-0.04491 0.02187-0.09416 0.02597-0.1246 "
71: (12)                        "0.02636h{1}c-0.04786 0-0.1502 0.02094-0.2185 0.1256-0.06833-0.1046-0.1706"
72: (12)                        "-0.1256-0.2185-0.1256h{1}c-0.03046-3.899e-4 -0.07972-0.004491-0.1246-0.02"
73: (12)                        "636-0.0537-0.02695-0.07418-0.05816-0.08648-0.07769-0.001562-0.002538-"
74: (12)                        "0.004467-0.002563-0.01091-0.002563z"
75: (8)                     )
76: (8)                     default_min_width = 0.90552
77: (8)                     self.buff = buff
78: (8)                     angle = -np.arctan2(*direction[:2]) + np.pi
79: (8)                     mobject.rotate(-angle, about_point=ORIGIN)
80: (8)                     left = mobject.get_corner(DOWN + LEFT)
81: (8)                     right = mobject.get_corner(DOWN + RIGHT)
82: (8)                     target_width = right[0] - left[0]
83: (8)                     linear_section_length = max(
84: (12)                        0,
85: (12)                        (target_width * sharpness - default_min_width) / 2,
86: (8)                     )
87: (8)                     path = se.Path(
88: (12)                        path_string_template.format(
89: (16)                            linear_section_length,
90: (16)                            -linear_section_length,
91: (12)                        )
92: (8)                     )
93: (8)                     super().__init__(
94: (12)                        path_obj=path,
95: (12)                        stroke_width=stroke_width,
96: (12)                        fill_opacity=fill_opacity,
97: (12)                        background_stroke_width=background_stroke_width,
98: (12)                        background_stroke_color=background_stroke_color,
99: (12)                        **kwargs,
100: (8)                    )
101: (8)                    self.flip(RIGHT)
102: (8)                    self.stretch_to_fit_width(target_width)
103: (8)                    self.shift(left - self.get_corner(UP + LEFT) + self.buff * DOWN)
104: (8)                    for mob in mobject, self:
105: (12)                       mob.rotate(angle, about_point=ORIGIN)
106: (4)                def put_at_tip(self, mob, use_next_to=True, **kwargs):
107: (8)                    if use_next_to:
108: (12)                       mob.next_to(self.get_tip(), np.round(self.get_direction()), **kwargs)
109: (8)                    else:
110: (12)                       mob.move_to(self.get_tip())
111: (12)                       buff = kwargs.get("buff", DEFAULT_MOBJECT_TO_MOBJECT_BUFFER)
112: (12)                       shift_distance = mob.width / 2.0 + buff
113: (12)                       mob.shift(self.get_direction() * shift_distance)
114: (8)                    return self
115: (4)                def get_text(self, *text, **kwargs):
116: (8)                    text_mob = Tex(*text)
117: (8)                    self.put_at_tip(text_mob, **kwargs)
118: (8)                    return text_mob
119: (4)                def get_tex(self, *tex, **kwargs):
120: (8)                    tex_mob = MathTex(*tex)
121: (8)                    self.put_at_tip(tex_mob, **kwargs)
122: (8)                    return tex_mob
123: (4)                def get_tip(self):
124: (8)                    # Returns the position of the seventh point in the path, which is the tip.
125: (8)                    if config["renderer"] == "opengl":
126: (12)                       return self.points[34]
127: (8)                    return self.points[28]  # = 7*4
128: (4)                def get_direction(self):
129: (8)                    vect = self.get_tip() - self.get_center()
130: (8)                    return vect / np.linalg.norm(vect)
131: (0)            class BraceLabel(VMobject, metaclass=ConvertToOpenGL):
132: (4)                """Create a brace with a label attached.
133: (4)                Parameters
134: (4)                ----------
135: (4)                obj
136: (8)                    The mobject adjacent to which the brace is placed.
137: (4)                text
138: (8)                    The label text.
139: (4)                brace_direction
140: (8)                    The direction of the brace. By default ``DOWN``.
141: (4)                label_constructor
142: (8)                    A class or function used to construct a mobject representing
143: (8)                    the label. By default :class:`~.MathTex`.
144: (4)                font_size
145: (8)                    The font size of the label, passed to the ``label_constructor``.
146: (4)                buff
147: (8)                    The buffer between the mobject and the brace.
148: (4)                brace_config
149: (8)                    Arguments to be passed to :class:`.Brace`.
150: (4)                kwargs
151: (8)                    Additional arguments to be passed to :class:`~.VMobject`.
152: (4)                """
153: (4)                def __init__(
154: (8)                    self,
155: (8)                    obj: Mobject,
156: (8)                    text: str,
157: (8)                    brace_direction: np.ndarray = DOWN,
158: (8)                    label_constructor: type = MathTex,
159: (8)                    font_size: float = DEFAULT_FONT_SIZE,
160: (8)                    buff: float = 0.2,
161: (8)                    brace_config: dict | None = None,
162: (8)                    **kwargs,
163: (4)                ):
164: (8)                    self.label_constructor = label_constructor
165: (8)                    super().__init__(**kwargs)
166: (8)                    self.brace_direction = brace_direction
167: (8)                    if brace_config is None:
168: (12)                       brace_config = {}
169: (8)                    self.brace = Brace(obj, brace_direction, buff, **brace_config)
170: (8)                    if isinstance(text, (tuple, list)):
171: (12)                       self.label = self.label_constructor(font_size=font_size, *text, **kwargs)
172: (8)                    else:
173: (12)                       self.label = self.label_constructor(str(text), font_size=font_size)
174: (8)                    self.brace.put_at_tip(self.label)
175: (8)                    self.add(self.brace, self.label)
176: (4)                def creation_anim(self, label_anim=FadeIn, brace_anim=GrowFromCenter):
177: (8)                    return AnimationGroup(brace_anim(self.brace), label_anim(self.label))
178: (4)                def shift_brace(self, obj, **kwargs):
179: (8)                    if isinstance(obj, list):
180: (12)                       obj = self.get_group_class()(*obj)
181: (8)                    self.brace = Brace(obj, self.brace_direction, **kwargs)
182: (8)                    self.brace.put_at_tip(self.label)
183: (8)                    return self
184: (4)                def change_label(self, *text, **kwargs):
185: (8)                    self.label = self.label_constructor(*text, **kwargs)
186: (8)                    self.brace.put_at_tip(self.label)
187: (8)                    return self
188: (4)                def change_brace_label(self, obj, *text, **kwargs):
189: (8)                    self.shift_brace(obj)
190: (8)                    self.change_label(*text, **kwargs)
191: (8)                    return self
192: (0)            class BraceText(BraceLabel):
193: (4)                def __init__(self, obj, text, label_constructor=Tex, **kwargs):
194: (8)                    super().__init__(obj, text, label_constructor=label_constructor, **kwargs)
195: (0)            class BraceBetweenPoints(Brace):
196: (4)                """Similar to Brace, but instead of taking a mobject it uses 2
197: (4)                points to place the brace.
198: (4)                A fitting direction for the brace is
199: (4)                computed, but it still can be manually overridden.
200: (4)                If the points go from left to right, the brace is drawn from below.
201: (4)                Swapping the points places the brace on the opposite side.
202: (4)                Parameters
203: (4)                ----------
204: (4)                point_1 :
205: (8)                    The first point.
206: (4)                point_2 :
207: (8)                    The second point.
208: (4)                direction :
209: (8)                    The direction from which the brace faces towards the points.
210: (4)                Examples
211: (4)                --------
212: (8)                    .. manim:: BraceBPExample
213: (12)                       class BraceBPExample(Scene):
214: (16)                           def construct(self):
215: (20)                               p1 = [0,0,0]
216: (20)                               p2 = [1,2,0]
217: (20)                               brace = BraceBetweenPoints(p1,p2)
218: (20)                               self.play(Create(NumberPlane()))
219: (20)                               self.play(Create(brace))
220: (20)                               self.wait(2)
221: (4)                """
222: (4)                def __init__(
223: (8)                    self,
224: (8)                    point_1: Sequence[float] | None,
225: (8)                    point_2: Sequence[float] | None,
226: (8)                    direction: Sequence[float] | None = ORIGIN,
227: (8)                    **kwargs,
228: (4)                ):
229: (8)                    if all(direction == ORIGIN):
230: (12)                       line_vector = np.array(point_2) - np.array(point_1)
231: (12)                       direction = np.array([line_vector[1], -line_vector[0], 0])
232: (8)                    super().__init__(Line(point_1, point_2), direction=direction, **kwargs)
233: (0)            class ArcBrace(Brace):
234: (4)                """Creates a :class:`~Brace` that wraps around an :class:`~.Arc`.
235: (4)                The direction parameter allows the brace to be applied
236: (4)                from outside or inside the arc.
237: (4)                .. warning::
238: (8)                    The :class:`ArcBrace` is smaller for arcs with smaller radii.
239: (4)                .. note::
240: (8)                    The :class:`ArcBrace` is initially a vertical :class:`Brace` defined by the
241: (8)                    length of the :class:`~.Arc`, but is scaled down to match the start and end
242: (8)                    angles. An exponential function is then applied after it is shifted based on
243: (8)                    the radius of the arc.
244: (8)                    The scaling effect is not applied for arcs with radii smaller than 1 to prevent
245: (8)                    over-scaling.
246: (4)                Parameters
247: (4)                ----------
248: (4)                arc
249: (8)                    The :class:`~.Arc` that wraps around the :class:`Brace` mobject.
250: (4)                direction
251: (8)                    The direction from which the brace faces the arc.
252: (8)                    ``LEFT`` for inside the arc, and ``RIGHT`` for the outside.
253: (4)                Example
254: (4)                -------
255: (8)                    .. manim:: ArcBraceExample
256: (12)                       :save_last_frame:
257: (12)                       :ref_classes: Arc
258: (12)                       class ArcBraceExample(Scene):
259: (16)                           def construct(self):
260: (20)                               arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)
261: (20)                               brace_1 = ArcBrace(arc_1,LEFT)
262: (20)                               group_1 = VGroup(arc_1,brace_1)
263: (20)                               arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)
264: (20)                               brace_2 = ArcBrace(arc_2)
265: (20)                               group_2 = VGroup(arc_2,brace_2)
266: (20)                               arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)
267: (20)                               brace_3 = ArcBrace(arc_3)
268: (20)                               group_3 = VGroup(arc_3,brace_3)
269: (20)                               arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)
270: (20)                               brace_4 = ArcBrace(arc_4)
271: (20)                               group_4 = VGroup(arc_4,brace_4)
272: (20)                               arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)
273: (20)                               self.add(arc_group.center())
274: (4)                """
275: (4)                def __init__(
276: (8)                    self,
277: (8)                    arc: Arc | None = None,
278: (8)                    direction: Sequence[float] = RIGHT,
279: (8)                    **kwargs,
280: (4)                ):
281: (8)                    if arc is None:
282: (12)                       arc = Arc(start_angle=-1, angle=2, radius=1)
283: (8)                    arc_end_angle = arc.start_angle + arc.angle
284: (8)                    line = Line(UP * arc.start_angle, UP * arc_end_angle)
285: (8)                    scale_shift = RIGHT * np.log(arc.radius)
286: (8)                    if arc.radius >= 1:
287: (12)                       line.scale(arc.radius, about_point=ORIGIN)
288: (12)                       super().__init__(line, direction=direction, **kwargs)
289: (12)                       self.scale(1 / (arc.radius), about_point=ORIGIN)
290: (8)                    else:
291: (12)                       super().__init__(line, direction=direction, **kwargs)
292: (8)                    if arc.radius >= 0.3:
293: (12)                       self.shift(scale_shift)
294: (8)                    else:
295: (12)                       self.shift(RIGHT * np.log(0.3))
296: (8)                    self.apply_complex_function(np.exp)
297: (8)                    self.shift(arc.get_arc_center())

----------------------------------------

File 26 - .\text \numbers.py:

1: (0)              """Mobjects representing numbers."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["DecimalNumber", "Integer", "Variable"]
4: (0)              from typing import Sequence
5: (0)              import numpy as np
6: (0)              from manim import config
7: (0)              from manim.constants import *
8: (0)              from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
9: (0)              from manim.mobject.text.tex_mobject import MathTex, SingleStringMathTex, Tex
10: (0)             from manim.mobject.text.text_mobject import Text
11: (0)             from manim.mobject.types.vectorized_mobject import VMobject
12: (0)             from manim.mobject.value_tracker import ValueTracker
13: (0)             string_to_mob_map = {}
14: (0)             __all__ = ["DecimalNumber", "Integer", "Variable"]
15: (0)             class DecimalNumber(VMobject, metaclass=ConvertToOpenGL):
16: (4)                 """An mobject representing a decimal number.
17: (4)                 Parameters
18: (4)                 ----------
19: (4)                 number
20: (8)                     The numeric value to be displayed. It can later be modified using :meth:`.set_value`.
21: (4)                 num_decimal_places
22: (8)                     The number of decimal places after the decimal separator. Values are automatically rounded.
23: (4)                 mob_class
24: (8)                     The class for rendering digits and units, by default :class:`.MathTex`.
25: (4)                 include_sign
26: (8)                     Set to ``True`` to include a sign for positive numbers and zero.
27: (4)                 group_with_commas
28: (8)                     When ``True`` thousands groups are separated by commas for readability.
29: (4)                 digit_buff_per_font_unit
30: (8)                     Additional spacing between digits. Scales with font size.
31: (4)                 show_ellipsis
32: (8)                     When a number has been truncated by rounding, indicate with an ellipsis (``...``).
33: (4)                 unit
34: (8)                     A unit string which can be placed to the right of the numerical values.
35: (4)                 unit_buff_per_font_unit
36: (8)                     An additional spacing between the numerical values and the unit. A value
37: (8)                     of ``unit_buff_per_font_unit=0.003`` gives a decent spacing. Scales with font size.
38: (4)                 include_background_rectangle
39: (8)                     Adds a background rectangle to increase contrast on busy scenes.
40: (4)                 edge_to_fix
41: (8)                     Assuring right- or left-alignment of the full object.
42: (4)                 font_size
43: (8)                     Size of the font.
44: (4)                 Examples
45: (4)                 --------
46: (4)                 .. manim:: MovingSquareWithUpdaters
47: (8)                     class MovingSquareWithUpdaters(Scene):
48: (12)                        def construct(self):
49: (16)                            decimal = DecimalNumber(
50: (20)                                0,
51: (20)                                show_ellipsis=True,
52: (20)                                num_decimal_places=3,
53: (20)                                include_sign=True,
54: (20)                                unit=r"\text{M-Units}",
55: (20)                                unit_buff_per_font_unit=0.003
56: (16)                            )
57: (16)                            square = Square().to_edge(UP)
58: (16)                            decimal.add_updater(lambda d: d.next_to(square, RIGHT))
59: (16)                            decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))
60: (16)                            self.add(square, decimal)
61: (16)                            self.play(
62: (20)                                square.animate.to_edge(DOWN),
63: (20)                                rate_func=there_and_back,
64: (20)                                run_time=5,
65: (16)                            )
66: (16)                            self.wait()
67: (4)                 """
68: (4)                 def __init__(
69: (8)                     self,
70: (8)                     number: float = 0,
71: (8)                     num_decimal_places: int = 2,
72: (8)                     mob_class: VMobject = MathTex,
73: (8)                     include_sign: bool = False,
74: (8)                     group_with_commas: bool = True,
75: (8)                     digit_buff_per_font_unit: float = 0.001,
76: (8)                     show_ellipsis: bool = False,
77: (8)                     unit: str | None = None,  # Aligned to bottom unless it starts with "^"
78: (8)                     unit_buff_per_font_unit: float = 0,
79: (8)                     include_background_rectangle: bool = False,
80: (8)                     edge_to_fix: Sequence[float] = LEFT,
81: (8)                     font_size: float = DEFAULT_FONT_SIZE,
82: (8)                     stroke_width: float = 0,
83: (8)                     fill_opacity: float = 1.0,
84: (8)                     **kwargs,
85: (4)                 ):
86: (8)                     super().__init__(**kwargs, stroke_width=stroke_width)
87: (8)                     self.number = number
88: (8)                     self.num_decimal_places = num_decimal_places
89: (8)                     self.include_sign = include_sign
90: (8)                     self.mob_class = mob_class
91: (8)                     self.group_with_commas = group_with_commas
92: (8)                     self.digit_buff_per_font_unit = digit_buff_per_font_unit
93: (8)                     self.show_ellipsis = show_ellipsis
94: (8)                     self.unit = unit
95: (8)                     self.unit_buff_per_font_unit = unit_buff_per_font_unit
96: (8)                     self.include_background_rectangle = include_background_rectangle
97: (8)                     self.edge_to_fix = edge_to_fix
98: (8)                     self._font_size = font_size
99: (8)                     self.fill_opacity = fill_opacity
100: (8)                    self.initial_config = kwargs.copy()
101: (8)                    self.initial_config.update(
102: (12)                       {
103: (16)                           "num_decimal_places": num_decimal_places,
104: (16)                           "include_sign": include_sign,
105: (16)                           "group_with_commas": group_with_commas,
106: (16)                           "digit_buff_per_font_unit": digit_buff_per_font_unit,
107: (16)                           "show_ellipsis": show_ellipsis,
108: (16)                           "unit": unit,
109: (16)                           "unit_buff_per_font_unit": unit_buff_per_font_unit,
110: (16)                           "include_background_rectangle": include_background_rectangle,
111: (16)                           "edge_to_fix": edge_to_fix,
112: (16)                           "font_size": font_size,
113: (16)                           "stroke_width": stroke_width,
114: (16)                           "fill_opacity": fill_opacity,
115: (12)                       },
116: (8)                    )
117: (8)                    self._set_submobjects_from_number(number)
118: (8)                    self.init_colors()
119: (4)                @property
120: (4)                def font_size(self):
121: (8)                    """The font size of the tex mobject."""
122: (8)                    return self.height / self.initial_height * self._font_size
123: (4)                @font_size.setter
124: (4)                def font_size(self, font_val):
125: (8)                    if font_val <= 0:
126: (12)                       raise ValueError("font_size must be greater than 0.")
127: (8)                    elif self.height > 0:
128: (12)                       # sometimes manim generates a SingleStringMathex mobject with 0 height.
129: (12)                       # can't be scaled regardless and will error without the elif.
130: (12)                       # scale to a factor of the initial height so that setting
131: (12)                       # font_size does not depend on current size.
132: (12)                       self.scale(font_val / self.font_size)
133: (4)                def _set_submobjects_from_number(self, number):
134: (8)                    self.number = number
135: (8)                    self.submobjects = []
136: (8)                    num_string = self._get_num_string(number)
137: (8)                    self.add(*(map(self._string_to_mob, num_string)))
138: (8)                    # Add non-numerical bits
139: (8)                    if self.show_ellipsis:
140: (12)                       self.add(
141: (16)                           self._string_to_mob("\\dots", SingleStringMathTex, color=self.color),
142: (12)                       )
143: (8)                    self.arrange(
144: (12)                       buff=self.digit_buff_per_font_unit * self._font_size,
145: (12)                       aligned_edge=DOWN,
146: (8)                    )
147: (8)                    if self.unit is not None:
148: (12)                       self.unit_sign = self._string_to_mob(self.unit, SingleStringMathTex)
149: (12)                       self.add(
150: (16)                           self.unit_sign.next_to(
151: (20)                               self,
152: (20)                               direction=RIGHT,
153: (20)                               buff=(self.unit_buff_per_font_unit + self.digit_buff_per_font_unit)
154: (20)                               * self._font_size,
155: (20)                               aligned_edge=DOWN,
156: (16)                           )
157: (12)                       )
158: (8)                    self.move_to(ORIGIN)
159: (8)                    # Handle alignment of parts that should be aligned
160: (8)                    # to the bottom
161: (8)                    for i, c in enumerate(num_string):
162: (12)                       if c == "-" and len(num_string) > i + 1:
163: (16)                           self[i].align_to(self[i + 1], UP)
164: (16)                           self[i].shift(self[i + 1].height * DOWN / 2)
165: (12)                       elif c == ",":
166: (16)                           self[i].shift(self[i].height * DOWN / 2)
167: (8)                    if self.unit and self.unit.startswith("^"):
168: (12)                       self.unit_sign.align_to(self, UP)
169: (8)                    # track the initial height to enable scaling via font_size
170: (8)                    self.initial_height = self.height
171: (8)                    if self.include_background_rectangle:
172: (12)                       self.add_background_rectangle()
173: (4)                def _get_num_string(self, number):
174: (8)                    if isinstance(number, complex):
175: (12)                       formatter = self._get_complex_formatter()
176: (8)                    else:
177: (12)                       formatter = self._get_formatter()
178: (8)                    num_string = formatter.format(number)
179: (8)                    rounded_num = np.round(number, self.num_decimal_places)
180: (8)                    if num_string.startswith("-") and rounded_num == 0:
181: (12)                       if self.include_sign:
182: (16)                           num_string = "+" + num_string[1:]
183: (12)                       else:
184: (16)                           num_string = num_string[1:]
185: (8)                    return num_string
186: (4)                def _string_to_mob(self, string: str, mob_class: VMobject | None = None, **kwargs):
187: (8)                    if mob_class is None:
188: (12)                       mob_class = self.mob_class
189: (8)                    if string not in string_to_mob_map:
190: (12)                       string_to_mob_map[string] = mob_class(string, **kwargs)
191: (8)                    mob = string_to_mob_map[string].copy()
192: (8)                    mob.font_size = self._font_size
193: (8)                    return mob
194: (4)                def _get_formatter(self, **kwargs):
195: (8)                    """
196: (8)                    Configuration is based first off instance attributes,
197: (8)                    but overwritten by any kew word argument.  Relevant
198: (8)                    key words:
199: (8)                    - include_sign
200: (8)                    - group_with_commas
201: (8)                    - num_decimal_places
202: (8)                    - field_name (e.g. 0 or 0.real)
203: (8)                    """
204: (8)                    config = {
205: (12)                       attr: getattr(self, attr)
206: (12)                       for attr in [
207: (16)                           "include_sign",
208: (16)                           "group_with_commas",
209: (16)                           "num_decimal_places",
210: (12)                       ]
211: (8)                    }
212: (8)                    config.update(kwargs)
213: (8)                    return "".join(
214: (12)                       [
215: (16)                           "{",
216: (16)                           config.get("field_name", ""),
217: (16)                           ":",
218: (16)                           "+" if config["include_sign"] else "",
219: (16)                           "," if config["group_with_commas"] else "",
220: (16)                           ".",
221: (16)                           str(config["num_decimal_places"]),
222: (16)                           "f",
223: (16)                           "}",
224: (12)                       ],
225: (8)                    )
226: (4)                def _get_complex_formatter(self):
227: (8)                    return "".join(
228: (12)                       [
229: (16)                           self._get_formatter(field_name="0.real"),
230: (16)                           self._get_formatter(field_name="0.imag", include_sign=True),
231: (16)                           "i",
232: (12)                       ],
233: (8)                    )
234: (4)                def set_value(self, number: float):
235: (8)                    """Set the value of the :class:`~.DecimalNumber` to a new number.
236: (8)                    Parameters
237: (8)                    ----------
238: (8)                    number
239: (12)                       The value that will overwrite the current number of the :class:`~.DecimalNumber`.
240: (8)                    """
241: (8)                    # creates a new number mob via `set_submobjects_from_number`
242: (8)                    # then matches the properties (color, font_size, etc...)
243: (8)                    # of the previous mobject to the new one
244: (8)                    # old_family needed with cairo
245: (8)                    old_family = self.get_family()
246: (8)                    old_font_size = self.font_size
247: (8)                    move_to_point = self.get_edge_center(self.edge_to_fix)
248: (8)                    old_submobjects = self.submobjects
249: (8)                    self._set_submobjects_from_number(number)
250: (8)                    self.font_size = old_font_size
251: (8)                    self.move_to(move_to_point, self.edge_to_fix)
252: (8)                    for sm1, sm2 in zip(self.submobjects, old_submobjects):
253: (12)                       sm1.match_style(sm2)
254: (8)                    if config.renderer == RendererType.CAIRO:
255: (12)                       for mob in old_family:
256: (16)                           # Dumb hack...due to how scene handles families
257: (16)                           # of animated mobjects
258: (16)                           # for compatibility with updaters to not leave first number in place while updating,
259: (16)                           # not needed with opengl renderer
260: (16)                           mob.points[:] = 0
261: (8)                    self.init_colors()
262: (8)                    return self
263: (4)                def get_value(self):
264: (8)                    return self.number
265: (4)                def increment_value(self, delta_t=1):
266: (8)                    self.set_value(self.get_value() + delta_t)
267: (0)            class Integer(DecimalNumber):
268: (4)                """A class for displaying Integers.
269: (4)                Examples
270: (4)                --------
271: (4)                .. manim:: IntegerExample
272: (8)                    :save_last_frame:
273: (8)                    class IntegerExample(Scene):
274: (12)                       def construct(self):
275: (16)                           self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))
276: (16)                           self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))
277: (16)                           self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))
278: (16)                           self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))
279: (4)                """
280: (4)                def __init__(self, number=0, num_decimal_places=0, **kwargs):
281: (8)                    super().__init__(number=number, num_decimal_places=num_decimal_places, **kwargs)
282: (4)                def get_value(self):
283: (8)                    return int(np.round(super().get_value()))
284: (0)            class Variable(VMobject, metaclass=ConvertToOpenGL):
285: (4)                """A class for displaying text that shows "label = value" with
286: (4)                the value continuously updated from a :class:`~.ValueTracker`.
287: (4)                Parameters
288: (4)                ----------
289: (4)                var
290: (8)                    The initial value you need to keep track of and display.
291: (4)                label
292: (8)                    The label for your variable. Raw strings are convertex to :class:`~.MathTex` objects.
293: (4)                var_type
294: (8)                    The class used for displaying the number. Defaults to :class:`DecimalNumber`.
295: (4)                num_decimal_places
296: (8)                    The number of decimal places to display in your variable. Defaults to 2.
297: (8)                    If `var_type` is an :class:`Integer`, this parameter is ignored.
298: (4)                kwargs
299: (12)                       Other arguments to be passed to `~.Mobject`.
300: (4)                Attributes
301: (4)                ----------
302: (4)                label : Union[:class:`str`, :class:`~.Tex`, :class:`~.MathTex`, :class:`~.Text`, :class:`~.SingleStringMathTex`]
303: (8)                    The label for your variable, for example ``x = ...``.
304: (4)                tracker : :class:`~.ValueTracker`
305: (8)                    Useful in updating the value of your variable on-screen.
306: (4)                value : Union[:class:`DecimalNumber`, :class:`Integer`]
307: (8)                    The tex for the value of your variable.
308: (4)                Examples
309: (4)                --------
310: (4)                Normal usage::
311: (8)                    # DecimalNumber type
312: (8)                    var = 0.5
313: (8)                    on_screen_var = Variable(var, Text("var"), num_decimal_places=3)
314: (8)                    # Integer type
315: (8)                    int_var = 0
316: (8)                    on_screen_int_var = Variable(int_var, Text("int_var"), var_type=Integer)
317: (8)                    # Using math mode for the label
318: (8)                    on_screen_int_var = Variable(int_var, "{a}_{i}", var_type=Integer)
319: (4)                .. manim:: VariablesWithValueTracker
320: (8)                    class VariablesWithValueTracker(Scene):
321: (12)                       def construct(self):
322: (16)                           var = 0.5
323: (16)                           on_screen_var = Variable(var, Text("var"), num_decimal_places=3)
324: (16)                           # You can also change the colours for the label and value
325: (16)                           on_screen_var.label.set_color(RED)
326: (16)                           on_screen_var.value.set_color(GREEN)
327: (16)                           self.play(Write(on_screen_var))
328: (16)                           # The above line will just display the variable with
329: (16)                           # its initial value on the screen. If you also wish to
330: (16)                           # update it, you can do so by accessing the `tracker` attribute
331: (16)                           self.wait()
332: (16)                           var_tracker = on_screen_var.tracker
333: (16)                           var = 10.5
334: (16)                           self.play(var_tracker.animate.set_value(var))
335: (16)                           self.wait()
336: (16)                           int_var = 0
337: (16)                           on_screen_int_var = Variable(
338: (20)                               int_var, Text("int_var"), var_type=Integer
339: (16)                           ).next_to(on_screen_var, DOWN)
340: (16)                           on_screen_int_var.label.set_color(RED)
341: (16)                           on_screen_int_var.value.set_color(GREEN)
342: (16)                           self.play(Write(on_screen_int_var))
343: (16)                           self.wait()
344: (16)                           var_tracker = on_screen_int_var.tracker
345: (16)                           var = 10.5
346: (16)                           self.play(var_tracker.animate.set_value(var))
347: (16)                           self.wait()
348: (16)                           # If you wish to have a somewhat more complicated label for your
349: (16)                           # variable with subscripts, superscripts, etc. the default class
350: (16)                           # for the label is MathTex
351: (16)                           subscript_label_var = 10
352: (16)                           on_screen_subscript_var = Variable(subscript_label_var, "{a}_{i}").next_to(
353: (20)                               on_screen_int_var, DOWN
354: (16)                           )
355: (16)                           self.play(Write(on_screen_subscript_var))
356: (16)                           self.wait()
357: (4)                .. manim:: VariableExample
358: (8)                    class VariableExample(Scene):
359: (12)                       def construct(self):
360: (16)                           start = 2.0
361: (16)                           x_var = Variable(start, 'x', num_decimal_places=3)
362: (16)                           sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)
363: (16)                           Group(x_var, sqr_var).arrange(DOWN)
364: (16)                           sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))
365: (16)                           self.add(x_var, sqr_var)
366: (16)                           self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)
367: (16)                           self.wait(0.1)
368: (4)                """
369: (4)                def __init__(
370: (8)                    self,
371: (8)                    var: float,
372: (8)                    label: str | Tex | MathTex | Text | SingleStringMathTex,
373: (8)                    var_type: DecimalNumber | Integer = DecimalNumber,
374: (8)                    num_decimal_places: int = 2,
375: (8)                    **kwargs,
376: (4)                ):
377: (8)                    self.label = MathTex(label) if isinstance(label, str) else label
378: (8)                    equals = MathTex("=").next_to(self.label, RIGHT)
379: (8)                    self.label.add(equals)
380: (8)                    self.tracker = ValueTracker(var)
381: (8)                    if var_type == DecimalNumber:
382: (12)                       self.value = DecimalNumber(
383: (16)                           self.tracker.get_value(),
384: (16)                           num_decimal_places=num_decimal_places,
385: (12)                       )
386: (8)                    elif var_type == Integer:
387: (12)                       self.value = Integer(self.tracker.get_value())
388: (8)                    self.value.add_updater(lambda v: v.set_value(self.tracker.get_value())).next_to(
389: (12)                       self.label,
390: (12)                       RIGHT,
391: (8)                    )
392: (8)                    super().__init__(**kwargs)
393: (8)                    self.add(self.label, self.value)

----------------------------------------

File 27 - .\svg \__init__.py:

1: (0)              """Mobjects related to SVG images.
2: (0)              Modules
3: (0)              =======
4: (0)              .. autosummary::
5: (4)                  :toctree: ../reference
6: (4)                  ~brace
7: (4)                  ~svg_mobject
8: (0)              """

----------------------------------------

File 28 - .\text \__init__.py:

1: (0)              """Mobjects used to display Text using Pango or LaTeX.
2: (0)              Modules
3: (0)              =======
4: (0)              .. autosummary::
5: (4)                  :toctree: ../reference
6: (4)                  ~code_mobject
7: (4)                  ~numbers
8: (4)                  ~tex_mobject
9: (4)                  ~text_mobject
10: (0)             """

----------------------------------------

File 29 - .\three_d \__init__.py:

1: (0)              """Three-dimensional mobjects.
2: (0)              Modules
3: (0)              =======
4: (0)              .. autosummary::
5: (4)                  :toctree: ../reference
6: (4)                  ~polyhedra
7: (4)                  ~three_d_utils
8: (4)                  ~three_dimensions
9: (0)              """

----------------------------------------

File 30 - .\types \__init__.py:

1: (0)              """Specialized mobject base classes.
2: (0)              Modules
3: (0)              =======
4: (0)              .. autosummary::
5: (4)                  :toctree: ../reference
6: (4)                  ~image_mobject
7: (4)                  ~point_cloud_mobject
8: (4)                  ~vectorized_mobject
9: (0)              """

----------------------------------------

File 31 - .\three_d \polyhedra.py:

1: (0)              """General polyhedral class and platonic solids."""
2: (0)              from __future__ import annotations
3: (0)              from typing import TYPE_CHECKING
4: (0)              import numpy as np
5: (0)              from manim.mobject.geometry.polygram import Polygon
6: (0)              from manim.mobject.graph import Graph
7: (0)              from manim.mobject.three_d.three_dimensions import Dot3D
8: (0)              from manim.mobject.types.vectorized_mobject import VGroup
9: (0)              if TYPE_CHECKING:
10: (4)                 from manim.mobject.mobject import Mobject
11: (0)             __all__ = ["Polyhedron", "Tetrahedron", "Octahedron", "Icosahedron", "Dodecahedron"]
12: (0)             class Polyhedron(VGroup):
13: (4)                 """An abstract polyhedra class.
14: (4)                 In this implementation, polyhedra are defined with a list of vertex coordinates in space, and a list
15: (4)                 of faces. This implementation mirrors that of a standard polyhedral data format (OFF, object file format).
16: (4)                 Parameters
17: (4)                 ----------
18: (4)                 vertex_coords
19: (8)                     A list of coordinates of the corresponding vertices in the polyhedron. Each coordinate will correspond to
20: (8)                     a vertex. The vertices are indexed with the usual indexing of Python.
21: (4)                 faces_list
22: (8)                     A list of faces. Each face is a sublist containing the indices of the vertices that form the corners of that face.
23: (4)                 faces_config
24: (8)                     Configuration for the polygons representing the faces of the polyhedron.
25: (4)                 graph_config
26: (8)                     Configuration for the graph containing the vertices and edges of the polyhedron.
27: (4)                 Examples
28: (4)                 --------
29: (4)                 To understand how to create a custom polyhedra, let's use the example of a rather simple one - a square pyramid.
30: (4)                 .. manim:: SquarePyramidScene
31: (8)                     :save_last_frame:
32: (8)                     class SquarePyramidScene(ThreeDScene):
33: (12)                        def construct(self):
34: (16)                            self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
35: (16)                            vertex_coords = [
36: (20)                                [1, 1, 0],
37: (20)                                [1, -1, 0],
38: (20)                                [-1, -1, 0],
39: (20)                                [-1, 1, 0],
40: (20)                                [0, 0, 2]
41: (16)                            ]
42: (16)                            faces_list = [
43: (20)                                [0, 1, 4],
44: (20)                                [1, 2, 4],
45: (20)                                [2, 3, 4],
46: (20)                                [3, 0, 4],
47: (20)                                [0, 1, 2, 3]
48: (16)                            ]
49: (16)                            pyramid = Polyhedron(vertex_coords, faces_list)
50: (16)                            self.add(pyramid)
51: (4)                 In defining the polyhedron above, we first defined the coordinates of the vertices.
52: (4)                 These are the corners of the square base, given as the first four coordinates in the vertex list,
53: (4)                 and the apex, the last coordinate in the list.
54: (4)                 Next, we define the faces of the polyhedron. The triangular surfaces of the pyramid are polygons
55: (4)                 with two adjacent vertices in the base and the vertex at the apex as corners. We thus define these
56: (4)                 surfaces in the first four elements of our face list. The last element defines the base of the pyramid.
57: (4)                 The graph and faces of polyhedra can also be accessed and modified directly, after instantiation.
58: (4)                 They are stored in the `graph` and `faces` attributes respectively.
59: (4)                 .. manim:: PolyhedronSubMobjects
60: (8)                     :save_last_frame:
61: (8)                     class PolyhedronSubMobjects(ThreeDScene):
62: (12)                        def construct(self):
63: (16)                            self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
64: (16)                            octahedron = Octahedron(edge_length = 3)
65: (16)                            octahedron.graph[0].set_color(RED)
66: (16)                            octahedron.faces[2].set_color(YELLOW)
67: (16)                            self.add(octahedron)
68: (4)                 """
69: (4)                 def __init__(
70: (8)                     self,
71: (8)                     vertex_coords: list[list[float] | np.ndarray],
72: (8)                     faces_list: list[list[int]],
73: (8)                     faces_config: dict[str, str | int | float | bool] = {},
74: (8)                     graph_config: dict[str, str | int | float | bool] = {},
75: (4)                 ):
76: (8)                     super().__init__()
77: (8)                     self.faces_config = dict(
78: (12)                        {"fill_opacity": 0.5, "shade_in_3d": True}, **faces_config
79: (8)                     )
80: (8)                     self.graph_config = dict(
81: (12)                        {
82: (16)                            "vertex_type": Dot3D,
83: (16)                            "edge_config": {
84: (20)                                "stroke_opacity": 0,  # I find that having the edges visible makes the polyhedra look weird
85: (16)                            },
86: (12)                        },
87: (12)                        **graph_config,
88: (8)                     )
89: (8)                     self.vertex_coords = vertex_coords
90: (8)                     self.vertex_indices = list(range(len(self.vertex_coords)))
91: (8)                     self.layout = dict(enumerate(self.vertex_coords))
92: (8)                     self.faces_list = faces_list
93: (8)                     self.face_coords = [[self.layout[j] for j in i] for i in faces_list]
94: (8)                     self.edges = self.get_edges(self.faces_list)
95: (8)                     self.faces = self.create_faces(self.face_coords)
96: (8)                     self.graph = Graph(
97: (12)                        self.vertex_indices, self.edges, layout=self.layout, **self.graph_config
98: (8)                     )
99: (8)                     self.add(self.faces, self.graph)
100: (8)                    self.add_updater(self.update_faces)
101: (4)                def get_edges(self, faces_list: list[list[int]]) -> list[tuple[int, int]]:
102: (8)                    """Creates list of cyclic pairwise tuples."""
103: (8)                    edges = []
104: (8)                    for face in faces_list:
105: (12)                       edges += zip(face, face[1:] + face[:1])
106: (8)                    return edges
107: (4)                def create_faces(
108: (8)                    self,
109: (8)                    face_coords: list[list[list | np.ndarray]],
110: (4)                ) -> VGroup:
111: (8)                    """Creates VGroup of faces from a list of face coordinates."""
112: (8)                    face_group = VGroup()
113: (8)                    for face in face_coords:
114: (12)                       face_group.add(Polygon(*face, **self.faces_config))
115: (8)                    return face_group
116: (4)                def update_faces(self, m: Mobject):
117: (8)                    face_coords = self.extract_face_coords()
118: (8)                    new_faces = self.create_faces(face_coords)
119: (8)                    self.faces.match_points(new_faces)
120: (4)                def extract_face_coords(self) -> list[list[np.ndarray]]:
121: (8)                    """Extracts the coordinates of the vertices in the graph.
122: (8)                    Used for updating faces.
123: (8)                    """
124: (8)                    new_vertex_coords = []
125: (8)                    for v in self.graph.vertices:
126: (12)                       new_vertex_coords.append(self.graph[v].get_center())
127: (8)                    layout = dict(enumerate(new_vertex_coords))
128: (8)                    return [[layout[j] for j in i] for i in self.faces_list]
129: (0)            class Tetrahedron(Polyhedron):
130: (4)                """A tetrahedron, one of the five platonic solids. It has 4 faces, 6 edges, and 4 vertices.
131: (4)                Parameters
132: (4)                ----------
133: (4)                edge_length
134: (8)                    The length of an edge between any two vertices.
135: (4)                Examples
136: (4)                --------
137: (4)                .. manim:: TetrahedronScene
138: (8)                    :save_last_frame:
139: (8)                    class TetrahedronScene(ThreeDScene):
140: (12)                       def construct(self):
141: (16)                           self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
142: (16)                           obj = Tetrahedron()
143: (16)                           self.add(obj)
144: (4)                """
145: (4)                def __init__(self, edge_length: float = 1, **kwargs):
146: (8)                    unit = edge_length * np.sqrt(2) / 4
147: (8)                    super().__init__(
148: (12)                       vertex_coords=[
149: (16)                           np.array([unit, unit, unit]),
150: (16)                           np.array([unit, -unit, -unit]),
151: (16)                           np.array([-unit, unit, -unit]),
152: (16)                           np.array([-unit, -unit, unit]),
153: (12)                       ],
154: (12)                       faces_list=[[0, 1, 2], [3, 0, 2], [0, 1, 3], [3, 1, 2]],
155: (12)                       **kwargs,
156: (8)                    )
157: (0)            class Octahedron(Polyhedron):
158: (4)                """An octahedron, one of the five platonic solids. It has 8 faces, 12 edges and 6 vertices.
159: (4)                Parameters
160: (4)                ----------
161: (4)                edge_length
162: (8)                    The length of an edge between any two vertices.
163: (4)                Examples
164: (4)                --------
165: (4)                .. manim:: OctahedronScene
166: (8)                    :save_last_frame:
167: (8)                    class OctahedronScene(ThreeDScene):
168: (12)                       def construct(self):
169: (16)                           self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
170: (16)                           obj = Octahedron()
171: (16)                           self.add(obj)
172: (4)                """
173: (4)                def __init__(self, edge_length: float = 1, **kwargs):
174: (8)                    unit = edge_length * np.sqrt(2) / 2
175: (8)                    super().__init__(
176: (12)                       vertex_coords=[
177: (16)                           np.array([unit, 0, 0]),
178: (16)                           np.array([-unit, 0, 0]),
179: (16)                           np.array([0, unit, 0]),
180: (16)                           np.array([0, -unit, 0]),
181: (16)                           np.array([0, 0, unit]),
182: (16)                           np.array([0, 0, -unit]),
183: (12)                       ],
184: (12)                       faces_list=[
185: (16)                           [2, 4, 1],
186: (16)                           [0, 4, 2],
187: (16)                           [4, 3, 0],
188: (16)                           [1, 3, 4],
189: (16)                           [3, 5, 0],
190: (16)                           [1, 5, 3],
191: (16)                           [2, 5, 1],
192: (16)                           [0, 5, 2],
193: (12)                       ],
194: (12)                       **kwargs,
195: (8)                    )
196: (0)            class Icosahedron(Polyhedron):
197: (4)                """An icosahedron, one of the five platonic solids. It has 20 faces, 30 edges and 12 vertices.
198: (4)                Parameters
199: (4)                ----------
200: (4)                edge_length
201: (8)                    The length of an edge between any two vertices.
202: (4)                Examples
203: (4)                --------
204: (4)                .. manim:: IcosahedronScene
205: (8)                    :save_last_frame:
206: (8)                    class IcosahedronScene(ThreeDScene):
207: (12)                       def construct(self):
208: (16)                           self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
209: (16)                           obj = Icosahedron()
210: (16)                           self.add(obj)
211: (4)                """
212: (4)                def __init__(self, edge_length: float = 1, **kwargs):
213: (8)                    unit_a = edge_length * ((1 + np.sqrt(5)) / 4)
214: (8)                    unit_b = edge_length * (1 / 2)
215: (8)                    super().__init__(
216: (12)                       vertex_coords=[
217: (16)                           np.array([0, unit_b, unit_a]),
218: (16)                           np.array([0, -unit_b, unit_a]),
219: (16)                           np.array([0, unit_b, -unit_a]),
220: (16)                           np.array([0, -unit_b, -unit_a]),
221: (16)                           np.array([unit_b, unit_a, 0]),
222: (16)                           np.array([unit_b, -unit_a, 0]),
223: (16)                           np.array([-unit_b, unit_a, 0]),
224: (16)                           np.array([-unit_b, -unit_a, 0]),
225: (16)                           np.array([unit_a, 0, unit_b]),
226: (16)                           np.array([unit_a, 0, -unit_b]),
227: (16)                           np.array([-unit_a, 0, unit_b]),
228: (16)                           np.array([-unit_a, 0, -unit_b]),
229: (12)                       ],
230: (12)                       faces_list=[
231: (16)                           [1, 8, 0],
232: (16)                           [1, 5, 7],
233: (16)                           [8, 5, 1],
234: (16)                           [7, 3, 5],
235: (16)                           [5, 9, 3],
236: (16)                           [8, 9, 5],
237: (16)                           [3, 2, 9],
238: (16)                           [9, 4, 2],
239: (16)                           [8, 4, 9],
240: (16)                           [0, 4, 8],
241: (16)                           [6, 4, 0],
242: (16)                           [6, 2, 4],
243: (16)                           [11, 2, 6],
244: (16)                           [3, 11, 2],
245: (16)                           [0, 6, 10],
246: (16)                           [10, 1, 0],
247: (16)                           [10, 7, 1],
248: (16)                           [11, 7, 3],
249: (16)                           [10, 11, 7],
250: (16)                           [10, 11, 6],
251: (12)                       ],
252: (12)                       **kwargs,
253: (8)                    )
254: (0)            class Dodecahedron(Polyhedron):
255: (4)                """A dodecahedron, one of the five platonic solids. It has 12 faces, 30 edges and 20 vertices.
256: (4)                Parameters
257: (4)                ----------
258: (4)                edge_length
259: (8)                    The length of an edge between any two vertices.
260: (4)                Examples
261: (4)                --------
262: (4)                .. manim:: DodecahedronScene
263: (8)                    :save_last_frame:
264: (8)                    class DodecahedronScene(ThreeDScene):
265: (12)                       def construct(self):
266: (16)                           self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
267: (16)                           obj = Dodecahedron()
268: (16)                           self.add(obj)
269: (4)                """
270: (4)                def __init__(self, edge_length: float = 1, **kwargs):
271: (8)                    unit_a = edge_length * ((1 + np.sqrt(5)) / 4)
272: (8)                    unit_b = edge_length * ((3 + np.sqrt(5)) / 4)
273: (8)                    unit_c = edge_length * (1 / 2)
274: (8)                    super().__init__(
275: (12)                       vertex_coords=[
276: (16)                           np.array([unit_a, unit_a, unit_a]),
277: (16)                           np.array([unit_a, unit_a, -unit_a]),
278: (16)                           np.array([unit_a, -unit_a, unit_a]),
279: (16)                           np.array([unit_a, -unit_a, -unit_a]),
280: (16)                           np.array([-unit_a, unit_a, unit_a]),
281: (16)                           np.array([-unit_a, unit_a, -unit_a]),
282: (16)                           np.array([-unit_a, -unit_a, unit_a]),
283: (16)                           np.array([-unit_a, -unit_a, -unit_a]),
284: (16)                           np.array([0, unit_c, unit_b]),
285: (16)                           np.array([0, unit_c, -unit_b]),
286: (16)                           np.array([0, -unit_c, -unit_b]),
287: (16)                           np.array([0, -unit_c, unit_b]),
288: (16)                           np.array([unit_c, unit_b, 0]),
289: (16)                           np.array([-unit_c, unit_b, 0]),
290: (16)                           np.array([unit_c, -unit_b, 0]),
291: (16)                           np.array([-unit_c, -unit_b, 0]),
292: (16)                           np.array([unit_b, 0, unit_c]),
293: (16)                           np.array([-unit_b, 0, unit_c]),
294: (16)                           np.array([unit_b, 0, -unit_c]),
295: (16)                           np.array([-unit_b, 0, -unit_c]),
296: (12)                       ],
297: (12)                       faces_list=[
298: (16)                           [18, 16, 0, 12, 1],
299: (16)                           [3, 18, 16, 2, 14],
300: (16)                           [3, 10, 9, 1, 18],
301: (16)                           [1, 9, 5, 13, 12],
302: (16)                           [0, 8, 4, 13, 12],
303: (16)                           [2, 16, 0, 8, 11],
304: (16)                           [4, 17, 6, 11, 8],
305: (16)                           [17, 19, 5, 13, 4],
306: (16)                           [19, 7, 15, 6, 17],
307: (16)                           [6, 15, 14, 2, 11],
308: (16)                           [19, 5, 9, 10, 7],
309: (16)                           [7, 10, 3, 14, 15],
310: (12)                       ],
311: (12)                       **kwargs,
312: (8)                    )

----------------------------------------

File 32 - .\svg \svg_mobject.py:

1: (0)              """Mobjects generated from an SVG file."""
2: (0)              from __future__ import annotations
3: (0)              import os
4: (0)              from pathlib import Path
5: (0)              from xml.etree import ElementTree as ET
6: (0)              import numpy as np
7: (0)              import svgelements as se
8: (0)              from manim import config, logger
9: (0)              from ...constants import RIGHT
10: (0)             from ...utils.bezier import get_quadratic_approximation_of_cubic
11: (0)             from ...utils.images import get_full_vector_image_path
12: (0)             from ...utils.iterables import hash_obj
13: (0)             from ..geometry.arc import Circle
14: (0)             from ..geometry.line import Line
15: (0)             from ..geometry.polygram import Polygon, Rectangle, RoundedRectangle
16: (0)             from ..opengl.opengl_compatibility import ConvertToOpenGL
17: (0)             from ..types.vectorized_mobject import VMobject
18: (0)             __all__ = ["SVGMobject", "VMobjectFromSVGPath"]
19: (0)             SVG_HASH_TO_MOB_MAP: dict[int, VMobject] = {}
20: (0)             def _convert_point_to_3d(x: float, y: float) -> np.ndarray:
21: (4)                 return np.array([x, y, 0.0])
22: (0)             class SVGMobject(VMobject, metaclass=ConvertToOpenGL):
23: (4)                 """A vectorized mobject created from importing an SVG file.
24: (4)                 Parameters
25: (4)                 ----------
26: (4)                 file_name
27: (8)                     The path to the SVG file.
28: (4)                 should_center
29: (8)                     Whether or not the mobject should be centered after
30: (8)                     being imported.
31: (4)                 height
32: (8)                     The target height of the mobject, set to 2 Manim units by default.
33: (8)                     If the height and width are both set to ``None``, the mobject
34: (8)                     is imported without being scaled.
35: (4)                 width
36: (8)                     The target width of the mobject, set to ``None`` by default. If
37: (8)                     the height and the width are both set to ``None``, the mobject
38: (8)                     is imported without being scaled.
39: (4)                 color
40: (8)                     The color (both fill and stroke color) of the mobject. If
41: (8)                     ``None`` (the default), the colors set in the SVG file
42: (8)                     are used.
43: (4)                 opacity
44: (8)                     The opacity (both fill and stroke opacity) of the mobject.
45: (8)                     If ``None`` (the default), the opacity set in the SVG file
46: (8)                     is used.
47: (4)                 fill_color
48: (8)                     The fill color of the mobject. If ``None`` (the default),
49: (8)                     the fill colors set in the SVG file are used.
50: (4)                 fill_opacity
51: (8)                     The fill opacity of the mobject. If ``None`` (the default),
52: (8)                     the fill opacities set in the SVG file are used.
53: (4)                 stroke_color
54: (8)                     The stroke color of the mobject. If ``None`` (the default),
55: (8)                     the stroke colors set in the SVG file are used.
56: (4)                 stroke_opacity
57: (8)                     The stroke opacity of the mobject. If ``None`` (the default),
58: (8)                     the stroke opacities set in the SVG file are used.
59: (4)                 stroke_width
60: (8)                     The stroke width of the mobject. If ``None`` (the default),
61: (8)                     the stroke width values set in the SVG file are used.
62: (4)                 svg_default
63: (8)                     A dictionary in which fallback values for unspecified
64: (8)                     properties of elements in the SVG file are defined. If
65: (8)                     ``None`` (the default), ``color``, ``opacity``, ``fill_color``
66: (8)                     ``fill_opacity``, ``stroke_color``, and ``stroke_opacity``
67: (8)                     are set to ``None``, and ``stroke_width`` is set to 0.
68: (4)                 path_string_config
69: (8)                     A dictionary with keyword arguments passed to
70: (8)                     :class:`.VMobjectFromSVGPath` used for importing path elements.
71: (8)                     If ``None`` (the default), no additional arguments are passed.
72: (4)                 use_svg_cache
73: (8)                     If True (default), the svg inputs (e.g. file_name, settings)
74: (8)                     will be used as a key and a copy of the created mobject will
75: (8)                     be saved using that key to be quickly retrieved if the same
76: (8)                     inputs need be processed later. For large SVGs which are used
77: (8)                     only once, this can be omitted to improve performance.
78: (4)                 kwargs
79: (8)                     Further arguments passed to the parent class.
80: (4)                 """
81: (4)                 def __init__(
82: (8)                     self,
83: (8)                     file_name: str | os.PathLike | None = None,
84: (8)                     should_center: bool = True,
85: (8)                     height: float | None = 2,
86: (8)                     width: float | None = None,
87: (8)                     color: str | None = None,
88: (8)                     opacity: float | None = None,
89: (8)                     fill_color: str | None = None,
90: (8)                     fill_opacity: float | None = None,
91: (8)                     stroke_color: str | None = None,
92: (8)                     stroke_opacity: float | None = None,
93: (8)                     stroke_width: float | None = None,
94: (8)                     svg_default: dict | None = None,
95: (8)                     path_string_config: dict | None = None,
96: (8)                     use_svg_cache: bool = True,
97: (8)                     **kwargs,
98: (4)                 ):
99: (8)                     super().__init__(color=None, stroke_color=None, fill_color=None, **kwargs)
100: (8)                    # process keyword arguments
101: (8)                    self.file_name = Path(file_name) if file_name is not None else None
102: (8)                    self.should_center = should_center
103: (8)                    self.svg_height = height
104: (8)                    self.svg_width = width
105: (8)                    self.color = color
106: (8)                    self.opacity = opacity
107: (8)                    self.fill_color = fill_color
108: (8)                    self.fill_opacity = fill_opacity
109: (8)                    self.stroke_color = stroke_color
110: (8)                    self.stroke_opacity = stroke_opacity
111: (8)                    self.stroke_width = stroke_width
112: (8)                    if svg_default is None:
113: (12)                       svg_default = {
114: (16)                           "color": None,
115: (16)                           "opacity": None,
116: (16)                           "fill_color": None,
117: (16)                           "fill_opacity": None,
118: (16)                           "stroke_width": 0,
119: (16)                           "stroke_color": None,
120: (16)                           "stroke_opacity": None,
121: (12)                       }
122: (8)                    self.svg_default = svg_default
123: (8)                    if path_string_config is None:
124: (12)                       path_string_config = {}
125: (8)                    self.path_string_config = path_string_config
126: (8)                    self.init_svg_mobject(use_svg_cache=use_svg_cache)
127: (8)                    self.set_style(
128: (12)                       fill_color=fill_color,
129: (12)                       fill_opacity=fill_opacity,
130: (12)                       stroke_color=stroke_color,
131: (12)                       stroke_opacity=stroke_opacity,
132: (12)                       stroke_width=stroke_width,
133: (8)                    )
134: (8)                    self.move_into_position()
135: (4)                def init_svg_mobject(self, use_svg_cache: bool) -> None:
136: (8)                    """Checks whether the SVG has already been imported and
137: (8)                    generates it if not.
138: (8)                    See also
139: (8)                    --------
140: (8)                    :meth:`.SVGMobject.generate_mobject`
141: (8)                    """
142: (8)                    if use_svg_cache:
143: (12)                       hash_val = hash_obj(self.hash_seed)
144: (12)                       if hash_val in SVG_HASH_TO_MOB_MAP:
145: (16)                           mob = SVG_HASH_TO_MOB_MAP[hash_val].copy()
146: (16)                           self.add(*mob)
147: (16)                           return
148: (8)                    self.generate_mobject()
149: (8)                    if use_svg_cache:
150: (12)                       SVG_HASH_TO_MOB_MAP[hash_val] = self.copy()
151: (4)                @property
152: (4)                def hash_seed(self) -> tuple:
153: (8)                    """A unique hash representing the result of the generated
154: (8)                    mobject points.
155: (8)                    Used as keys in the ``SVG_HASH_TO_MOB_MAP`` caching dictionary.
156: (8)                    """
157: (8)                    return (
158: (12)                       self.__class__.__name__,
159: (12)                       self.svg_default,
160: (12)                       self.path_string_config,
161: (12)                       self.file_name,
162: (12)                       config.renderer,
163: (8)                    )
164: (4)                def generate_mobject(self) -> None:
165: (8)                    """Parse the SVG and translate its elements to submobjects."""
166: (8)                    file_path = self.get_file_path()
167: (8)                    element_tree = ET.parse(file_path)
168: (8)                    new_tree = self.modify_xml_tree(element_tree)
169: (8)                    # Create a temporary svg file to dump modified svg to be parsed
170: (8)                    modified_file_path = file_path.with_name(f"{file_path.stem}_{file_path.suffix}")
171: (8)                    new_tree.write(modified_file_path)
172: (8)                    svg = se.SVG.parse(modified_file_path)
173: (8)                    modified_file_path.unlink()
174: (8)                    mobjects = self.get_mobjects_from(svg)
175: (8)                    self.add(*mobjects)
176: (8)                    self.flip(RIGHT)  # Flip y
177: (4)                def get_file_path(self) -> Path:
178: (8)                    """Search for an existing file based on the specified file name."""
179: (8)                    if self.file_name is None:
180: (12)                       raise ValueError("Must specify file for SVGMobject")
181: (8)                    return get_full_vector_image_path(self.file_name)
182: (4)                def modify_xml_tree(self, element_tree: ET.ElementTree) -> ET.ElementTree:
183: (8)                    """Modifies the SVG element tree to include default
184: (8)                    style information.
185: (8)                    Parameters
186: (8)                    ----------
187: (8)                    element_tree
188: (12)                       The parsed element tree from the SVG file.
189: (8)                    """
190: (8)                    config_style_dict = self.generate_config_style_dict()
191: (8)                    style_keys = (
192: (12)                       "fill",
193: (12)                       "fill-opacity",
194: (12)                       "stroke",
195: (12)                       "stroke-opacity",
196: (12)                       "stroke-width",
197: (12)                       "style",
198: (8)                    )
199: (8)                    root = element_tree.getroot()
200: (8)                    root_style_dict = {k: v for k, v in root.attrib.items() if k in style_keys}
201: (8)                    new_root = ET.Element("svg", {})
202: (8)                    config_style_node = ET.SubElement(new_root, "g", config_style_dict)
203: (8)                    root_style_node = ET.SubElement(config_style_node, "g", root_style_dict)
204: (8)                    root_style_node.extend(root)
205: (8)                    return ET.ElementTree(new_root)
206: (4)                def generate_config_style_dict(self) -> dict[str, str]:
207: (8)                    """Generate a dictionary holding the default style information."""
208: (8)                    keys_converting_dict = {
209: (12)                       "fill": ("color", "fill_color"),
210: (12)                       "fill-opacity": ("opacity", "fill_opacity"),
211: (12)                       "stroke": ("color", "stroke_color"),
212: (12)                       "stroke-opacity": ("opacity", "stroke_opacity"),
213: (12)                       "stroke-width": ("stroke_width",),
214: (8)                    }
215: (8)                    svg_default_dict = self.svg_default
216: (8)                    result = {}
217: (8)                    for svg_key, style_keys in keys_converting_dict.items():
218: (12)                       for style_key in style_keys:
219: (16)                           if svg_default_dict[style_key] is None:
220: (20)                               continue
221: (16)                           result[svg_key] = str(svg_default_dict[style_key])
222: (8)                    return result
223: (4)                def get_mobjects_from(self, svg: se.SVG) -> list[VMobject]:
224: (8)                    """Convert the elements of the SVG to a list of mobjects.
225: (8)                    Parameters
226: (8)                    ----------
227: (8)                    svg
228: (12)                       The parsed SVG file.
229: (8)                    """
230: (8)                    result = []
231: (8)                    for shape in svg.elements():
232: (12)                       if isinstance(shape, se.Group):
233: (16)                           continue
234: (12)                       elif isinstance(shape, se.Path):
235: (16)                           mob = self.path_to_mobject(shape)
236: (12)                       elif isinstance(shape, se.SimpleLine):
237: (16)                           mob = self.line_to_mobject(shape)
238: (12)                       elif isinstance(shape, se.Rect):
239: (16)                           mob = self.rect_to_mobject(shape)
240: (12)                       elif isinstance(shape, (se.Circle, se.Ellipse)):
241: (16)                           mob = self.ellipse_to_mobject(shape)
242: (12)                       elif isinstance(shape, se.Polygon):
243: (16)                           mob = self.polygon_to_mobject(shape)
244: (12)                       elif isinstance(shape, se.Polyline):
245: (16)                           mob = self.polyline_to_mobject(shape)
246: (12)                       elif isinstance(shape, se.Text):
247: (16)                           mob = self.text_to_mobject(shape)
248: (12)                       elif isinstance(shape, se.Use) or type(shape) is se.SVGElement:
249: (16)                           continue
250: (12)                       else:
251: (16)                           logger.warning(f"Unsupported element type: {type(shape)}")
252: (16)                           continue
253: (12)                       if mob is None or not mob.has_points():
254: (16)                           continue
255: (12)                       self.apply_style_to_mobject(mob, shape)
256: (12)                       if isinstance(shape, se.Transformable) and shape.apply:
257: (16)                           self.handle_transform(mob, shape.transform)
258: (12)                       result.append(mob)
259: (8)                    return result
260: (4)                @staticmethod
261: (4)                def handle_transform(mob: VMobject, matrix: se.Matrix) -> VMobject:
262: (8)                    """Apply SVG transformations to the converted mobject.
263: (8)                    Parameters
264: (8)                    ----------
265: (8)                    mob
266: (12)                       The converted mobject.
267: (8)                    matrix
268: (12)                       The transformation matrix determined from the SVG
269: (12)                       transformation.
270: (8)                    """
271: (8)                    mat = np.array([[matrix.a, matrix.c], [matrix.b, matrix.d]])
272: (8)                    vec = np.array([matrix.e, matrix.f, 0.0])
273: (8)                    mob.apply_matrix(mat)
274: (8)                    mob.shift(vec)
275: (8)                    return mob
276: (4)                @staticmethod
277: (4)                def apply_style_to_mobject(mob: VMobject, shape: se.GraphicObject) -> VMobject:
278: (8)                    """Apply SVG style information to the converted mobject.
279: (8)                    Parameters
280: (8)                    ----------
281: (8)                    mob
282: (12)                       The converted mobject.
283: (8)                    shape
284: (12)                       The parsed SVG element.
285: (8)                    """
286: (8)                    mob.set_style(
287: (12)                       stroke_width=shape.stroke_width,
288: (12)                       stroke_color=shape.stroke.hexrgb,
289: (12)                       stroke_opacity=shape.stroke.opacity,
290: (12)                       fill_color=shape.fill.hexrgb,
291: (12)                       fill_opacity=shape.fill.opacity,
292: (8)                    )
293: (8)                    return mob
294: (4)                def path_to_mobject(self, path: se.Path) -> VMobjectFromSVGPath:
295: (8)                    """Convert a path element to a vectorized mobject.
296: (8)                    Parameters
297: (8)                    ----------
298: (8)                    path
299: (12)                       The parsed SVG path.
300: (8)                    """
301: (8)                    return VMobjectFromSVGPath(path, **self.path_string_config)
302: (4)                @staticmethod
303: (4)                def line_to_mobject(line: se.Line) -> Line:
304: (8)                    """Convert a line element to a vectorized mobject.
305: (8)                    Parameters
306: (8)                    ----------
307: (8)                    line
308: (12)                       The parsed SVG line.
309: (8)                    """
310: (8)                    return Line(
311: (12)                       start=_convert_point_to_3d(line.x1, line.y1),
312: (12)                       end=_convert_point_to_3d(line.x2, line.y2),
313: (8)                    )
314: (4)                @staticmethod
315: (4)                def rect_to_mobject(rect: se.Rect) -> Rectangle:
316: (8)                    """Convert a rectangle element to a vectorized mobject.
317: (8)                    Parameters
318: (8)                    ----------
319: (8)                    rect
320: (12)                       The parsed SVG rectangle.
321: (8)                    """
322: (8)                    if rect.rx == 0 or rect.ry == 0:
323: (12)                       mob = Rectangle(
324: (16)                           width=rect.width,
325: (16)                           height=rect.height,
326: (12)                       )
327: (8)                    else:
328: (12)                       mob = RoundedRectangle(
329: (16)                           width=rect.width,
330: (16)                           height=rect.height * rect.rx / rect.ry,
331: (16)                           corner_radius=rect.rx,
332: (12)                       )
333: (12)                       mob.stretch_to_fit_height(rect.height)
334: (8)                    mob.shift(
335: (12)                       _convert_point_to_3d(rect.x + rect.width / 2, rect.y + rect.height / 2)
336: (8)                    )
337: (8)                    return mob
338: (4)                @staticmethod
339: (4)                def ellipse_to_mobject(ellipse: se.Ellipse | se.Circle) -> Circle:
340: (8)                    """Convert an ellipse or circle element to a vectorized mobject.
341: (8)                    Parameters
342: (8)                    ----------
343: (8)                    ellipse
344: (12)                       The parsed SVG ellipse or circle.
345: (8)                    """
346: (8)                    mob = Circle(radius=ellipse.rx)
347: (8)                    if ellipse.rx != ellipse.ry:
348: (12)                       mob.stretch_to_fit_height(2 * ellipse.ry)
349: (8)                    mob.shift(_convert_point_to_3d(ellipse.cx, ellipse.cy))
350: (8)                    return mob
351: (4)                @staticmethod
352: (4)                def polygon_to_mobject(polygon: se.Polygon) -> Polygon:
353: (8)                    """Convert a polygon element to a vectorized mobject.
354: (8)                    Parameters
355: (8)                    ----------
356: (8)                    polygon
357: (12)                       The parsed SVG polygon.
358: (8)                    """
359: (8)                    points = [_convert_point_to_3d(*point) for point in polygon]
360: (8)                    return Polygon(*points)
361: (4)                def polyline_to_mobject(self, polyline: se.Polyline) -> VMobject:
362: (8)                    """Convert a polyline element to a vectorized mobject.
363: (8)                    Parameters
364: (8)                    ----------
365: (8)                    polyline
366: (12)                       The parsed SVG polyline.
367: (8)                    """
368: (8)                    points = [_convert_point_to_3d(*point) for point in polyline]
369: (8)                    vmobject_class = self.get_mobject_type_class()
370: (8)                    return vmobject_class().set_points_as_corners(points)
371: (4)                @staticmethod
372: (4)                def text_to_mobject(text: se.Text):
373: (8)                    """Convert a text element to a vectorized mobject.
374: (8)                    .. warning::
375: (12)                       Not yet implemented.
376: (8)                    Parameters
377: (8)                    ----------
378: (8)                    text
379: (12)                       The parsed SVG text.
380: (8)                    """
381: (8)                    logger.warning(f"Unsupported element type: {type(text)}")
382: (8)                    return
383: (4)                def move_into_position(self) -> None:
384: (8)                    """Scale and move the generated mobject into position."""
385: (8)                    if self.should_center:
386: (12)                       self.center()
387: (8)                    if self.svg_height is not None:
388: (12)                       self.set(height=self.svg_height)
389: (8)                    if self.svg_width is not None:
390: (12)                       self.set(width=self.svg_width)
391: (0)            class VMobjectFromSVGPath(VMobject, metaclass=ConvertToOpenGL):
392: (4)                """A vectorized mobject representing an SVG path.
393: (4)                .. note::
394: (8)                    The ``long_lines``, ``should_subdivide_sharp_curves``,
395: (8)                    and ``should_remove_null_curves`` keyword arguments are
396: (8)                    only respected with the OpenGL renderer.
397: (4)                Parameters
398: (4)                ----------
399: (4)                path_obj
400: (8)                    A parsed SVG path object.
401: (4)                long_lines
402: (8)                    Whether or not straight lines in the vectorized mobject
403: (8)                    are drawn in one or two segments.
404: (4)                should_subdivide_sharp_curves
405: (8)                    Whether or not to subdivide subcurves further in case
406: (8)                    two segments meet at an angle that is sharper than a
407: (8)                    given threshold.
408: (4)                should_remove_null_curves
409: (8)                    Whether or not to remove subcurves of length 0.
410: (4)                kwargs
411: (8)                    Further keyword arguments are passed to the parent
412: (8)                    class.
413: (4)                """
414: (4)                def __init__(
415: (8)                    self,
416: (8)                    path_obj: se.Path,
417: (8)                    long_lines: bool = False,
418: (8)                    should_subdivide_sharp_curves: bool = False,
419: (8)                    should_remove_null_curves: bool = False,
420: (8)                    **kwargs,
421: (4)                ):
422: (8)                    # Get rid of arcs
423: (8)                    path_obj.approximate_arcs_with_quads()
424: (8)                    self.path_obj = path_obj
425: (8)                    self.long_lines = long_lines
426: (8)                    self.should_subdivide_sharp_curves = should_subdivide_sharp_curves
427: (8)                    self.should_remove_null_curves = should_remove_null_curves
428: (8)                    super().__init__(**kwargs)
429: (4)                def init_points(self) -> None:
430: (8)                    # TODO: cache mobject in a re-importable way
431: (8)                    self.handle_commands()
432: (8)                    if config.renderer == "opengl":
433: (12)                       if self.should_subdivide_sharp_curves:
434: (16)                           # For a healthy triangulation later
435: (16)                           self.subdivide_sharp_curves()
436: (12)                       if self.should_remove_null_curves:
437: (16)                           # Get rid of any null curves
438: (16)                           self.set_points(self.get_points_without_null_curves())
439: (4)                generate_points = init_points
440: (4)                def handle_commands(self) -> None:
441: (8)                    all_points: list[np.ndarray] = []
442: (8)                    last_move = None
443: (8)                    curve_start = None
444: (8)                    last_true_move = None
445: (8)                    def move_pen(pt, *, true_move: bool = False):
446: (12)                       nonlocal last_move, curve_start, last_true_move
447: (12)                       last_move = pt
448: (12)                       if curve_start is None:
449: (16)                           curve_start = last_move
450: (12)                       if true_move:
451: (16)                           last_true_move = last_move
452: (8)                    if self.n_points_per_curve == 4:
453: (12)                       def add_cubic(start, cp1, cp2, end):
454: (16)                           nonlocal all_points
455: (16)                           assert len(all_points) % 4 == 0, len(all_points)
456: (16)                           all_points += [start, cp1, cp2, end]
457: (16)                           move_pen(end)
458: (12)                       def add_quad(start, cp, end):
459: (16)                           add_cubic(start, (start + cp + cp) / 3, (cp + cp + end) / 3, end)
460: (16)                           move_pen(end)
461: (12)                       def add_line(start, end):
462: (16)                           add_cubic(
463: (20)                               start, (start + start + end) / 3, (start + end + end) / 3, end
464: (16)                           )
465: (16)                           move_pen(end)
466: (8)                    else:
467: (12)                       def add_cubic(start, cp1, cp2, end):
468: (16)                           nonlocal all_points
469: (16)                           assert len(all_points) % 3 == 0, len(all_points)
470: (16)                           two_quads = get_quadratic_approximation_of_cubic(
471: (20)                               start,
472: (20)                               cp1,
473: (20)                               cp2,
474: (20)                               end,
475: (16)                           )
476: (16)                           all_points += two_quads[:3].tolist()
477: (16)                           all_points += two_quads[3:].tolist()
478: (16)                           move_pen(end)
479: (12)                       def add_quad(start, cp, end):
480: (16)                           nonlocal all_points
481: (16)                           assert len(all_points) % 3 == 0, len(all_points)
482: (16)                           all_points += [start, cp, end]
483: (16)                           move_pen(end)
484: (12)                       def add_line(start, end):
485: (16)                           add_quad(start, (start + end) / 2, end)
486: (16)                           move_pen(end)
487: (8)                    for segment in self.path_obj:
488: (12)                       segment_class = segment.__class__
489: (12)                       if segment_class == se.Move:
490: (16)                           move_pen(_convert_point_to_3d(*segment.end), true_move=True)
491: (12)                       elif segment_class == se.Line:
492: (16)                           add_line(last_move, _convert_point_to_3d(*segment.end))
493: (12)                       elif segment_class == se.QuadraticBezier:
494: (16)                           add_quad(
495: (20)                               last_move,
496: (20)                               _convert_point_to_3d(*segment.control),
497: (20)                               _convert_point_to_3d(*segment.end),
498: (16)                           )
499: (12)                       elif segment_class == se.CubicBezier:
500: (16)                           add_cubic(
501: (20)                               last_move,
502: (20)                               _convert_point_to_3d(*segment.control1),
503: (20)                               _convert_point_to_3d(*segment.control2),
504: (20)                               _convert_point_to_3d(*segment.end),
505: (16)                           )
506: (12)                       elif segment_class == se.Close:
507: (16)                           # If the SVG path naturally ends at the beginning of the curve,
508: (16)                           # we do *not* need to draw a closing line. To account for floating
509: (16)                           # point precision, we use a small value to compare the two points.
510: (16)                           if abs(np.linalg.norm(last_move - last_true_move)) > 0.0001:
511: (20)                               add_line(last_move, last_true_move)
512: (16)                           curve_start = None
513: (12)                       else:
514: (16)                           raise AssertionError(f"Not implemented: {segment_class}")
515: (8)                    self.points = np.array(all_points, ndmin=2, dtype="float64")
516: (8)                    # If we have no points, make sure the array is shaped properly
517: (8)                    # (0 rows tall by 3 columns wide) so future operations can
518: (8)                    # add or remove points correctly.
519: (8)                    if len(all_points) == 0:
520: (12)                       self.points = np.reshape(self.points, (0, 3))

----------------------------------------

File 33 - .\text \tex_mobject.py:

1: (0)              r"""Mobjects representing text rendered using LaTeX.
2: (0)              .. important::
3: (3)                 See the corresponding tutorial :ref:`rendering-with-latex`
4: (0)              .. note::
5: (3)                 Just as you can use :class:`~.Text` (from the module :mod:`~.text_mobject`) to add text to your videos, you can use :class:`~.Tex` and :class:`~.MathTex` to insert LaTeX.
6: (0)              """
7: (0)              from __future__ import annotations
8: (0)              from manim.utils.color import ManimColor
9: (0)              __all__ = [
10: (4)                 "SingleStringMathTex",
11: (4)                 "MathTex",
12: (4)                 "Tex",
13: (4)                 "BulletedList",
14: (4)                 "Title",
15: (0)             ]
16: (0)             import itertools as it
17: (0)             import operator as op
18: (0)             import re
19: (0)             from functools import reduce
20: (0)             from textwrap import dedent
21: (0)             from typing import Iterable
22: (0)             from manim import config, logger
23: (0)             from manim.constants import *
24: (0)             from manim.mobject.geometry.line import Line
25: (0)             from manim.mobject.svg.svg_mobject import SVGMobject
26: (0)             from manim.mobject.types.vectorized_mobject import VGroup, VMobject
27: (0)             from manim.utils.tex import TexTemplate
28: (0)             from manim.utils.tex_file_writing import tex_to_svg_file
29: (0)             tex_string_to_mob_map = {}
30: (0)             class SingleStringMathTex(SVGMobject):
31: (4)                 """Elementary building block for rendering text with LaTeX.
32: (4)                 Tests
33: (4)                 -----
34: (4)                 Check that creating a :class:`~.SingleStringMathTex` object works::
35: (8)                     >>> SingleStringMathTex('Test') # doctest: +SKIP
36: (8)                     SingleStringMathTex('Test')
37: (4)                 """
38: (4)                 def __init__(
39: (8)                     self,
40: (8)                     tex_string: str,
41: (8)                     stroke_width: float = 0,
42: (8)                     should_center: bool = True,
43: (8)                     height: float | None = None,
44: (8)                     organize_left_to_right: bool = False,
45: (8)                     tex_environment: str = "align*",
46: (8)                     tex_template: TexTemplate | None = None,
47: (8)                     font_size: float = DEFAULT_FONT_SIZE,
48: (8)                     **kwargs,
49: (4)                 ):
50: (8)                     if kwargs.get("color") is None:
51: (12)                        # makes it so that color isn't explicitly passed for these mobs,
52: (12)                        # and can instead inherit from the parent
53: (12)                        kwargs["color"] = VMobject().color
54: (8)                     self._font_size = font_size
55: (8)                     self.organize_left_to_right = organize_left_to_right
56: (8)                     self.tex_environment = tex_environment
57: (8)                     if tex_template is None:
58: (12)                        tex_template = config["tex_template"]
59: (8)                     self.tex_template = tex_template
60: (8)                     assert isinstance(tex_string, str)
61: (8)                     self.tex_string = tex_string
62: (8)                     file_name = tex_to_svg_file(
63: (12)                        self._get_modified_expression(tex_string),
64: (12)                        environment=self.tex_environment,
65: (12)                        tex_template=self.tex_template,
66: (8)                     )
67: (8)                     super().__init__(
68: (12)                        file_name=file_name,
69: (12)                        should_center=should_center,
70: (12)                        stroke_width=stroke_width,
71: (12)                        height=height,
72: (12)                        path_string_config={
73: (16)                            "should_subdivide_sharp_curves": True,
74: (16)                            "should_remove_null_curves": True,
75: (12)                        },
76: (12)                        **kwargs,
77: (8)                     )
78: (8)                     self.init_colors()
79: (8)                     # used for scaling via font_size.setter
80: (8)                     self.initial_height = self.height
81: (8)                     if height is None:
82: (12)                        self.font_size = self._font_size
83: (8)                     if self.organize_left_to_right:
84: (12)                        self._organize_submobjects_left_to_right()
85: (4)                 def __repr__(self):
86: (8)                     return f"{type(self).__name__}({repr(self.tex_string)})"
87: (4)                 @property
88: (4)                 def font_size(self):
89: (8)                     """The font size of the tex mobject."""
90: (8)                     return self.height / self.initial_height / SCALE_FACTOR_PER_FONT_POINT
91: (4)                 @font_size.setter
92: (4)                 def font_size(self, font_val):
93: (8)                     if font_val <= 0:
94: (12)                        raise ValueError("font_size must be greater than 0.")
95: (8)                     elif self.height > 0:
96: (12)                        # sometimes manim generates a SingleStringMathex mobject with 0 height.
97: (12)                        # can't be scaled regardless and will error without the elif.
98: (12)                        # scale to a factor of the initial height so that setting
99: (12)                        # font_size does not depend on current size.
100: (12)                       self.scale(font_val / self.font_size)
101: (4)                def _get_modified_expression(self, tex_string):
102: (8)                    result = tex_string
103: (8)                    result = result.strip()
104: (8)                    result = self._modify_special_strings(result)
105: (8)                    return result
106: (4)                def _modify_special_strings(self, tex):
107: (8)                    tex = tex.strip()
108: (8)                    should_add_filler = reduce(
109: (12)                       op.or_,
110: (12)                       [
111: (16)                           # Fraction line needs something to be over
112: (16)                           tex == "\\over",
113: (16)                           tex == "\\overline",
114: (16)                           # Make sure sqrt has overbar
115: (16)                           tex == "\\sqrt",
116: (16)                           tex == "\\sqrt{",
117: (16)                           # Need to add blank subscript or superscript
118: (16)                           tex.endswith("_"),
119: (16)                           tex.endswith("^"),
120: (16)                           tex.endswith("dot"),
121: (12)                       ],
122: (8)                    )
123: (8)                    if should_add_filler:
124: (12)                       filler = "{\\quad}"
125: (12)                       tex += filler
126: (8)                    if tex == "\\substack":
127: (12)                       tex = "\\quad"
128: (8)                    if tex == "":
129: (12)                       tex = "\\quad"
130: (8)                    # To keep files from starting with a line break
131: (8)                    if tex.startswith("\\\\"):
132: (12)                       tex = tex.replace("\\\\", "\\quad\\\\")
133: (8)                    # Handle imbalanced \left and \right
134: (8)                    num_lefts, num_rights = (
135: (12)                       len([s for s in tex.split(substr)[1:] if s and s[0] in "(){}[]|.\\"])
136: (12)                       for substr in ("\\left", "\\right")
137: (8)                    )
138: (8)                    if num_lefts != num_rights:
139: (12)                       tex = tex.replace("\\left", "\\big")
140: (12)                       tex = tex.replace("\\right", "\\big")
141: (8)                    tex = self._remove_stray_braces(tex)
142: (8)                    for context in ["array"]:
143: (12)                       begin_in = ("\\begin{%s}" % context) in tex
144: (12)                       end_in = ("\\end{%s}" % context) in tex
145: (12)                       if begin_in ^ end_in:
146: (16)                           # Just turn this into a blank string,
147: (16)                           # which means caller should leave a
148: (16)                           # stray \\begin{...} with other symbols
149: (16)                           tex = ""
150: (8)                    return tex
151: (4)                def _remove_stray_braces(self, tex):
152: (8)                    r"""
153: (8)                    Makes :class:`~.MathTex` resilient to unmatched braces.
154: (8)                    This is important when the braces in the TeX code are spread over
155: (8)                    multiple arguments as in, e.g., ``MathTex(r"e^{i", r"\tau} = 1")``.
156: (8)                    """
157: (8)                    # "\{" does not count (it's a brace literal), but "\\{" counts (it's a new line and then brace)
158: (8)                    num_lefts = tex.count("{") - tex.count("\\{") + tex.count("\\\\{")
159: (8)                    num_rights = tex.count("}") - tex.count("\\}") + tex.count("\\\\}")
160: (8)                    while num_rights > num_lefts:
161: (12)                       tex = "{" + tex
162: (12)                       num_lefts += 1
163: (8)                    while num_lefts > num_rights:
164: (12)                       tex = tex + "}"
165: (12)                       num_rights += 1
166: (8)                    return tex
167: (4)                def _organize_submobjects_left_to_right(self):
168: (8)                    self.sort(lambda p: p[0])
169: (8)                    return self
170: (4)                def get_tex_string(self):
171: (8)                    return self.tex_string
172: (4)                def init_colors(self, propagate_colors=True):
173: (8)                    if config.renderer == RendererType.OPENGL:
174: (12)                       super().init_colors()
175: (8)                    elif config.renderer == RendererType.CAIRO:
176: (12)                       super().init_colors(propagate_colors=propagate_colors)
177: (0)            class MathTex(SingleStringMathTex):
178: (4)                r"""A string compiled with LaTeX in math mode.
179: (4)                Examples
180: (4)                --------
181: (4)                .. manim:: Formula
182: (8)                    :save_last_frame:
183: (8)                    class Formula(Scene):
184: (12)                       def construct(self):
185: (16)                           t = MathTex(r"\int_a^b f'(x) dx = f(b)- f(a)")
186: (16)                           self.add(t)
187: (4)                Tests
188: (4)                -----
189: (4)                Check that creating a :class:`~.MathTex` works::
190: (8)                    >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP
191: (8)                    MathTex('a^2 + b^2 = c^2')
192: (4)                Check that double brace group splitting works correctly::
193: (8)                    >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP
194: (8)                    >>> len(t1.submobjects) # doctest: +SKIP
195: (8)                    5
196: (8)                    >>> t2 = MathTex(r"\frac{1}{a+b\sqrt{2}}") # doctest: +SKIP
197: (8)                    >>> len(t2.submobjects) # doctest: +SKIP
198: (8)                    1
199: (4)                """
200: (4)                def __init__(
201: (8)                    self,
202: (8)                    *tex_strings,
203: (8)                    arg_separator: str = " ",
204: (8)                    substrings_to_isolate: Iterable[str] | None = None,
205: (8)                    tex_to_color_map: dict[str, ManimColor] = None,
206: (8)                    tex_environment: str = "align*",
207: (8)                    **kwargs,
208: (4)                ):
209: (8)                    self.tex_template = kwargs.pop("tex_template", config["tex_template"])
210: (8)                    self.arg_separator = arg_separator
211: (8)                    self.substrings_to_isolate = (
212: (12)                       [] if substrings_to_isolate is None else substrings_to_isolate
213: (8)                    )
214: (8)                    self.tex_to_color_map = tex_to_color_map
215: (8)                    if self.tex_to_color_map is None:
216: (12)                       self.tex_to_color_map = {}
217: (8)                    self.tex_environment = tex_environment
218: (8)                    self.brace_notation_split_occurred = False
219: (8)                    self.tex_strings = self._break_up_tex_strings(tex_strings)
220: (8)                    try:
221: (12)                       super().__init__(
222: (16)                           self.arg_separator.join(self.tex_strings),
223: (16)                           tex_environment=self.tex_environment,
224: (16)                           tex_template=self.tex_template,
225: (16)                           **kwargs,
226: (12)                       )
227: (12)                       self._break_up_by_substrings()
228: (8)                    except ValueError as compilation_error:
229: (12)                       if self.brace_notation_split_occurred:
230: (16)                           logger.error(
231: (20)                               dedent(
232: (24)                                   """\
233: (24)                                   A group of double braces, {{ ... }}, was detected in
234: (24)                                   your string. Manim splits TeX strings at the double
235: (24)                                   braces, which might have caused the current
236: (24)                                   compilation error. If you didn't use the double brace
237: (24)                                   split intentionally, add spaces between the braces to
238: (24)                                   avoid the automatic splitting: {{ ... }} --> { { ... } }.
239: (24)                                   """,
240: (20)                               ),
241: (16)                           )
242: (12)                       raise compilation_error
243: (8)                    self.set_color_by_tex_to_color_map(self.tex_to_color_map)
244: (8)                    if self.organize_left_to_right:
245: (12)                       self._organize_submobjects_left_to_right()
246: (4)                def _break_up_tex_strings(self, tex_strings):
247: (8)                    # Separate out anything surrounded in double braces
248: (8)                    pre_split_length = len(tex_strings)
249: (8)                    tex_strings = [re.split("{{(.*?)}}", str(t)) for t in tex_strings]
250: (8)                    tex_strings = sum(tex_strings, [])
251: (8)                    if len(tex_strings) > pre_split_length:
252: (12)                       self.brace_notation_split_occurred = True
253: (8)                    # Separate out any strings specified in the isolate
254: (8)                    # or tex_to_color_map lists.
255: (8)                    patterns = []
256: (8)                    patterns.extend(
257: (12)                       [
258: (16)                           f"({re.escape(ss)})"
259: (16)                           for ss in it.chain(
260: (20)                               self.substrings_to_isolate,
261: (20)                               self.tex_to_color_map.keys(),
262: (16)                           )
263: (12)                       ],
264: (8)                    )
265: (8)                    pattern = "|".join(patterns)
266: (8)                    if pattern:
267: (12)                       pieces = []
268: (12)                       for s in tex_strings:
269: (16)                           pieces.extend(re.split(pattern, s))
270: (8)                    else:
271: (12)                       pieces = tex_strings
272: (8)                    return [p for p in pieces if p]
273: (4)                def _break_up_by_substrings(self):
274: (8)                    """
275: (8)                    Reorganize existing submobjects one layer
276: (8)                    deeper based on the structure of tex_strings (as a list
277: (8)                    of tex_strings)
278: (8)                    """
279: (8)                    new_submobjects = []
280: (8)                    curr_index = 0
281: (8)                    for tex_string in self.tex_strings:
282: (12)                       sub_tex_mob = SingleStringMathTex(
283: (16)                           tex_string,
284: (16)                           tex_environment=self.tex_environment,
285: (16)                           tex_template=self.tex_template,
286: (12)                       )
287: (12)                       num_submobs = len(sub_tex_mob.submobjects)
288: (12)                       new_index = (
289: (16)                           curr_index + num_submobs + len("".join(self.arg_separator.split()))
290: (12)                       )
291: (12)                       if num_submobs == 0:
292: (16)                           last_submob_index = min(curr_index, len(self.submobjects) - 1)
293: (16)                           sub_tex_mob.move_to(self.submobjects[last_submob_index], RIGHT)
294: (12)                       else:
295: (16)                           sub_tex_mob.submobjects = self.submobjects[curr_index:new_index]
296: (12)                       new_submobjects.append(sub_tex_mob)
297: (12)                       curr_index = new_index
298: (8)                    self.submobjects = new_submobjects
299: (8)                    return self
300: (4)                def get_parts_by_tex(self, tex, substring=True, case_sensitive=True):
301: (8)                    def test(tex1, tex2):
302: (12)                       if not case_sensitive:
303: (16)                           tex1 = tex1.lower()
304: (16)                           tex2 = tex2.lower()
305: (12)                       if substring:
306: (16)                           return tex1 in tex2
307: (12)                       else:
308: (16)                           return tex1 == tex2
309: (8)                    return VGroup(*(m for m in self.submobjects if test(tex, m.get_tex_string())))
310: (4)                def get_part_by_tex(self, tex, **kwargs):
311: (8)                    all_parts = self.get_parts_by_tex(tex, **kwargs)
312: (8)                    return all_parts[0] if all_parts else None
313: (4)                def set_color_by_tex(self, tex, color, **kwargs):
314: (8)                    parts_to_color = self.get_parts_by_tex(tex, **kwargs)
315: (8)                    for part in parts_to_color:
316: (12)                       part.set_color(color)
317: (8)                    return self
318: (4)                def set_opacity_by_tex(
319: (8)                    self, tex: str, opacity: float = 0.5, remaining_opacity: float = None, **kwargs
320: (4)                ):
321: (8)                    """
322: (8)                    Sets the opacity of the tex specified. If 'remaining_opacity' is specified,
323: (8)                    then the remaining tex will be set to that opacity.
324: (8)                    Parameters
325: (8)                    ----------
326: (8)                    tex
327: (12)                       The tex to set the opacity of.
328: (8)                    opacity
329: (12)                       Default 0.5. The opacity to set the tex to
330: (8)                    remaining_opacity
331: (12)                       Default None. The opacity to set the remaining tex to.
332: (12)                       If None, then the remaining tex will not be changed
333: (8)                    """
334: (8)                    if remaining_opacity is not None:
335: (12)                       self.set_opacity(opacity=remaining_opacity)
336: (8)                    for part in self.get_parts_by_tex(tex):
337: (12)                       part.set_opacity(opacity)
338: (8)                    return self
339: (4)                def set_color_by_tex_to_color_map(self, texs_to_color_map, **kwargs):
340: (8)                    for texs, color in list(texs_to_color_map.items()):
341: (12)                       try:
342: (16)                           # If the given key behaves like tex_strings
343: (16)                           texs + ""
344: (16)                           self.set_color_by_tex(texs, color, **kwargs)
345: (12)                       except TypeError:
346: (16)                           # If the given key is a tuple
347: (16)                           for tex in texs:
348: (20)                               self.set_color_by_tex(tex, color, **kwargs)
349: (8)                    return self
350: (4)                def index_of_part(self, part):
351: (8)                    split_self = self.split()
352: (8)                    if part not in split_self:
353: (12)                       raise ValueError("Trying to get index of part not in MathTex")
354: (8)                    return split_self.index(part)
355: (4)                def index_of_part_by_tex(self, tex, **kwargs):
356: (8)                    part = self.get_part_by_tex(tex, **kwargs)
357: (8)                    return self.index_of_part(part)
358: (4)                def sort_alphabetically(self):
359: (8)                    self.submobjects.sort(key=lambda m: m.get_tex_string())
360: (0)            class Tex(MathTex):
361: (4)                r"""A string compiled with LaTeX in normal mode.
362: (4)                Tests
363: (4)                -----
364: (4)                Check whether writing a LaTeX string works::
365: (8)                    >>> Tex('The horse does not eat cucumber salad.') # doctest: +SKIP
366: (8)                    Tex('The horse does not eat cucumber salad.')
367: (4)                """
368: (4)                def __init__(
369: (8)                    self, *tex_strings, arg_separator="", tex_environment="center", **kwargs
370: (4)                ):
371: (8)                    super().__init__(
372: (12)                       *tex_strings,
373: (12)                       arg_separator=arg_separator,
374: (12)                       tex_environment=tex_environment,
375: (12)                       **kwargs,
376: (8)                    )
377: (0)            class BulletedList(Tex):
378: (4)                """A bulleted list.
379: (4)                Examples
380: (4)                --------
381: (4)                .. manim:: BulletedListExample
382: (8)                    :save_last_frame:
383: (8)                    class BulletedListExample(Scene):
384: (12)                       def construct(self):
385: (16)                           blist = BulletedList("Item 1", "Item 2", "Item 3", height=2, width=2)
386: (16)                           blist.set_color_by_tex("Item 1", RED)
387: (16)                           blist.set_color_by_tex("Item 2", GREEN)
388: (16)                           blist.set_color_by_tex("Item 3", BLUE)
389: (16)                           self.add(blist)
390: (4)                """
391: (4)                def __init__(
392: (8)                    self,
393: (8)                    *items,
394: (8)                    buff=MED_LARGE_BUFF,
395: (8)                    dot_scale_factor=2,
396: (8)                    tex_environment=None,
397: (8)                    **kwargs,
398: (4)                ):
399: (8)                    self.buff = buff
400: (8)                    self.dot_scale_factor = dot_scale_factor
401: (8)                    self.tex_environment = tex_environment
402: (8)                    line_separated_items = [s + "\\\\" for s in items]
403: (8)                    super().__init__(
404: (12)                       *line_separated_items, tex_environment=tex_environment, **kwargs
405: (8)                    )
406: (8)                    for part in self:
407: (12)                       dot = MathTex("\\cdot").scale(self.dot_scale_factor)
408: (12)                       dot.next_to(part[0], LEFT, SMALL_BUFF)
409: (12)                       part.add_to_back(dot)
410: (8)                    self.arrange(DOWN, aligned_edge=LEFT, buff=self.buff)
411: (4)                def fade_all_but(self, index_or_string, opacity=0.5):
412: (8)                    arg = index_or_string
413: (8)                    if isinstance(arg, str):
414: (12)                       part = self.get_part_by_tex(arg)
415: (8)                    elif isinstance(arg, int):
416: (12)                       part = self.submobjects[arg]
417: (8)                    else:
418: (12)                       raise TypeError(f"Expected int or string, got {arg}")
419: (8)                    for other_part in self.submobjects:
420: (12)                       if other_part is part:
421: (16)                           other_part.set_fill(opacity=1)
422: (12)                       else:
423: (16)                           other_part.set_fill(opacity=opacity)
424: (0)            class Title(Tex):
425: (4)                """A mobject representing an underlined title.
426: (4)                Examples
427: (4)                --------
428: (4)                .. manim:: TitleExample
429: (8)                    :save_last_frame:
430: (8)                    import manim
431: (8)                    class TitleExample(Scene):
432: (12)                       def construct(self):
433: (16)                           banner = ManimBanner()
434: (16)                           title = Title(f"Manim version {manim.__version__}")
435: (16)                           self.add(banner, title)
436: (4)                """
437: (4)                def __init__(
438: (8)                    self,
439: (8)                    *text_parts,
440: (8)                    include_underline=True,
441: (8)                    match_underline_width_to_text=False,
442: (8)                    underline_buff=MED_SMALL_BUFF,
443: (8)                    **kwargs,
444: (4)                ):
445: (8)                    self.include_underline = include_underline
446: (8)                    self.match_underline_width_to_text = match_underline_width_to_text
447: (8)                    self.underline_buff = underline_buff
448: (8)                    super().__init__(*text_parts, **kwargs)
449: (8)                    self.to_edge(UP)
450: (8)                    if self.include_underline:
451: (12)                       underline_width = config["frame_width"] - 2
452: (12)                       underline = Line(LEFT, RIGHT)
453: (12)                       underline.next_to(self, DOWN, buff=self.underline_buff)
454: (12)                       if self.match_underline_width_to_text:
455: (16)                           underline.match_width(self)
456: (12)                       else:
457: (16)                           underline.width = underline_width
458: (12)                       self.add(underline)
459: (12)                       self.underline = underline

----------------------------------------

File 34 - .\text \code_mobject.py:

1: (0)              """Mobject representing highlighted source code listings."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "Code",
5: (0)              ]
6: (0)              import html
7: (0)              import os
8: (0)              import re
9: (0)              from pathlib import Path
10: (0)             import numpy as np
11: (0)             from pygments import highlight
12: (0)             from pygments.formatters.html import HtmlFormatter
13: (0)             from pygments.lexers import get_lexer_by_name, guess_lexer_for_filename
14: (0)             from pygments.styles import get_all_styles
15: (0)             from manim import logger
16: (0)             from manim.constants import *
17: (0)             from manim.mobject.geometry.arc import Dot
18: (0)             from manim.mobject.geometry.polygram import RoundedRectangle
19: (0)             from manim.mobject.geometry.shape_matchers import SurroundingRectangle
20: (0)             from manim.mobject.text.text_mobject import Paragraph
21: (0)             from manim.mobject.types.vectorized_mobject import VGroup
22: (0)             from manim.utils.color import WHITE
23: (0)             __all__ = ["Code"]
24: (0)             class Code(VGroup):
25: (4)                 """A highlighted source code listing.
26: (4)                 An object ``listing`` of :class:`.Code` is a :class:`.VGroup` consisting
27: (4)                 of three objects:
28: (4)                 - The background, ``listing.background_mobject``. This is either
29: (6)                   a :class:`.Rectangle` (if the listing has been initialized with
30: (6)                   ``background="rectangle"``, the default option) or a :class:`.VGroup`
31: (6)                   resembling a window (if ``background="window"`` has been passed).
32: (4)                 - The line numbers, ``listing.line_numbers`` (a :class:`.Paragraph`
33: (6)                   object).
34: (4)                 - The highlighted code itself, ``listing.code`` (a :class:`.Paragraph`
35: (6)                   object).
36: (4)                 .. WARNING::
37: (8)                     Using a :class:`.Transform` on text with leading whitespace (and in
38: (8)                     this particular case: code) can look
39: (8)                     `weird <https://github.com/3b1b/manim/issues/1067>`_. Consider using
40: (8)                     :meth:`remove_invisible_chars` to resolve this issue.
41: (4)                 Examples
42: (4)                 --------
43: (4)                 Normal usage::
44: (8)                     listing = Code(
45: (12)                        "helloworldcpp.cpp",
46: (12)                        tab_width=4,
47: (12)                        background_stroke_width=1,
48: (12)                        background_stroke_color=WHITE,
49: (12)                        insert_line_no=True,
50: (12)                        style=Code.styles_list[15],
51: (12)                        background="window",
52: (12)                        language="cpp",
53: (8)                     )
54: (4)                 We can also render code passed as a string (but note that
55: (4)                 the language has to be specified in this case):
56: (4)                 .. manim:: CodeFromString
57: (8)                     :save_last_frame:
58: (8)                     class CodeFromString(Scene):
59: (12)                        def construct(self):
60: (16)                            code = '''from manim import Scene, Square
61: (8)                     class FadeInSquare(Scene):
62: (12)                        def construct(self):
63: (16)                            s = Square()
64: (16)                            self.play(FadeIn(s))
65: (16)                            self.play(s.animate.scale(2))
66: (16)                            self.wait()
67: (8)                     '''
68: (16)                            rendered_code = Code(code=code, tab_width=4, background="window",
69: (36)                                                language="Python", font="Monospace")
70: (16)                            self.add(rendered_code)
71: (4)                 Parameters
72: (4)                 ----------
73: (4)                 file_name
74: (8)                     Name of the code file to display.
75: (4)                 code
76: (8)                     If ``file_name`` is not specified, a code string can be
77: (8)                     passed directly.
78: (4)                 tab_width
79: (8)                     Number of space characters corresponding to a tab character. Defaults to 3.
80: (4)                 line_spacing
81: (8)                     Amount of space between lines in relation to font size. Defaults to 0.3, which means 30% of font size.
82: (4)                 font_size
83: (8)                     A number which scales displayed code. Defaults to 24.
84: (4)                 font
85: (8)                     The name of the text font to be used. Defaults to ``"Monospace"``.
86: (8)                     This is either a system font or one loaded with `text.register_font()`. Note
87: (8)                     that font family names may be different across operating systems.
88: (4)                 stroke_width
89: (8)                     Stroke width for text. 0 is recommended, and the default.
90: (4)                 margin
91: (8)                     Inner margin of text from the background. Defaults to 0.3.
92: (4)                 indentation_chars
93: (8)                     "Indentation chars" refers to the spaces/tabs at the beginning of a given code line. Defaults to ``"    "`` (spaces).
94: (4)                 background
95: (8)                     Defines the background's type. Currently supports only ``"rectangle"`` (default) and ``"window"``.
96: (4)                 background_stroke_width
97: (8)                     Defines the stroke width of the background. Defaults to 1.
98: (4)                 background_stroke_color
99: (8)                     Defines the stroke color for the background. Defaults to ``WHITE``.
100: (4)                corner_radius
101: (8)                    Defines the corner radius for the background. Defaults to 0.2.
102: (4)                insert_line_no
103: (8)                    Defines whether line numbers should be inserted in displayed code. Defaults to ``True``.
104: (4)                line_no_from
105: (8)                    Defines the first line's number in the line count. Defaults to 1.
106: (4)                line_no_buff
107: (8)                    Defines the spacing between line numbers and displayed code. Defaults to 0.4.
108: (4)                style
109: (8)                    Defines the style type of displayed code. You can see possible names of styles in with :attr:`styles_list`. Defaults to ``"vim"``.
110: (4)                language
111: (8)                    Specifies the programming language the given code was written in. If ``None``
112: (8)                    (the default), the language will be automatically detected. For the list of
113: (8)                    possible options, visit https://pygments.org/docs/lexers/ and look for
114: (8)                    'aliases or short names'.
115: (4)                generate_html_file
116: (8)                    Defines whether to generate highlighted html code to the folder `assets/codes/generated_html_files`. Defaults to `False`.
117: (4)                warn_missing_font
118: (8)                    If True (default), Manim will issue a warning if the font does not exist in the
119: (8)                    (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.
120: (4)                Attributes
121: (4)                ----------
122: (4)                background_mobject : :class:`~.VGroup`
123: (8)                    The background of the code listing.
124: (4)                line_numbers : :class:`~.Paragraph`
125: (8)                    The line numbers for the code listing. Empty, if
126: (8)                    ``insert_line_no=False`` has been specified.
127: (4)                code : :class:`~.Paragraph`
128: (8)                    The highlighted code.
129: (4)                """
130: (4)                # tuples in the form (name, aliases, filetypes, mimetypes)
131: (4)                # 'language' is aliases or short names
132: (4)                # For more information about pygments.lexers visit https://pygments.org/docs/lexers/
133: (4)                # from pygments.lexers import get_all_lexers
134: (4)                # all_lexers = get_all_lexers()
135: (4)                styles_list = list(get_all_styles())
136: (4)                # For more information about pygments.styles visit https://pygments.org/docs/styles/
137: (4)                def __init__(
138: (8)                    self,
139: (8)                    file_name: str | os.PathLike | None = None,
140: (8)                    code: str | None = None,
141: (8)                    tab_width: int = 3,
142: (8)                    line_spacing: float = 0.3,
143: (8)                    font_size: float = 24,
144: (8)                    font: str = "Monospace",  # This should be in the font list on all platforms.
145: (8)                    stroke_width: float = 0,
146: (8)                    margin: float = 0.3,
147: (8)                    indentation_chars: str = "    ",
148: (8)                    background: str = "rectangle",  # or window
149: (8)                    background_stroke_width: float = 1,
150: (8)                    background_stroke_color: str = WHITE,
151: (8)                    corner_radius: float = 0.2,
152: (8)                    insert_line_no: bool = True,
153: (8)                    line_no_from: int = 1,
154: (8)                    line_no_buff: float = 0.4,
155: (8)                    style: str = "vim",
156: (8)                    language: str | None = None,
157: (8)                    generate_html_file: bool = False,
158: (8)                    warn_missing_font: bool = True,
159: (8)                    **kwargs,
160: (4)                ):
161: (8)                    super().__init__(
162: (12)                       stroke_width=stroke_width,
163: (12)                       **kwargs,
164: (8)                    )
165: (8)                    self.background_stroke_color = background_stroke_color
166: (8)                    self.background_stroke_width = background_stroke_width
167: (8)                    self.tab_width = tab_width
168: (8)                    self.line_spacing = line_spacing
169: (8)                    self.warn_missing_font = warn_missing_font
170: (8)                    self.font = font
171: (8)                    self.font_size = font_size
172: (8)                    self.margin = margin
173: (8)                    self.indentation_chars = indentation_chars
174: (8)                    self.background = background
175: (8)                    self.corner_radius = corner_radius
176: (8)                    self.insert_line_no = insert_line_no
177: (8)                    self.line_no_from = line_no_from
178: (8)                    self.line_no_buff = line_no_buff
179: (8)                    self.style = style
180: (8)                    self.language = language
181: (8)                    self.generate_html_file = generate_html_file
182: (8)                    self.file_path = None
183: (8)                    self.file_name = file_name
184: (8)                    if self.file_name:
185: (12)                       self._ensure_valid_file()
186: (12)                       self.code_string = self.file_path.read_text(encoding="utf-8")
187: (8)                    elif code:
188: (12)                       self.code_string = code
189: (8)                    else:
190: (12)                       raise ValueError(
191: (16)                           "Neither a code file nor a code string have been specified.",
192: (12)                       )
193: (8)                    if isinstance(self.style, str):
194: (12)                       self.style = self.style.lower()
195: (8)                    self._gen_html_string()
196: (8)                    strati = self.html_string.find("background:")
197: (8)                    self.background_color = self.html_string[strati + 12 : strati + 19]
198: (8)                    self._gen_code_json()
199: (8)                    self.code = self._gen_colored_lines()
200: (8)                    if self.insert_line_no:
201: (12)                       self.line_numbers = self._gen_line_numbers()
202: (12)                       self.line_numbers.next_to(self.code, direction=LEFT, buff=self.line_no_buff)
203: (8)                    if self.background == "rectangle":
204: (12)                       if self.insert_line_no:
205: (16)                           foreground = VGroup(self.code, self.line_numbers)
206: (12)                       else:
207: (16)                           foreground = self.code
208: (12)                       rect = SurroundingRectangle(
209: (16)                           foreground,
210: (16)                           buff=self.margin,
211: (16)                           color=self.background_color,
212: (16)                           fill_color=self.background_color,
213: (16)                           stroke_width=self.background_stroke_width,
214: (16)                           stroke_color=self.background_stroke_color,
215: (16)                           fill_opacity=1,
216: (12)                       )
217: (12)                       rect.round_corners(self.corner_radius)
218: (12)                       self.background_mobject = rect
219: (8)                    else:
220: (12)                       if self.insert_line_no:
221: (16)                           foreground = VGroup(self.code, self.line_numbers)
222: (12)                       else:
223: (16)                           foreground = self.code
224: (12)                       height = foreground.height + 0.1 * 3 + 2 * self.margin
225: (12)                       width = foreground.width + 0.1 * 3 + 2 * self.margin
226: (12)                       rect = RoundedRectangle(
227: (16)                           corner_radius=self.corner_radius,
228: (16)                           height=height,
229: (16)                           width=width,
230: (16)                           stroke_width=self.background_stroke_width,
231: (16)                           stroke_color=self.background_stroke_color,
232: (16)                           color=self.background_color,
233: (16)                           fill_opacity=1,
234: (12)                       )
235: (12)                       red_button = Dot(radius=0.1, stroke_width=0, color="#ff5f56")
236: (12)                       red_button.shift(LEFT * 0.1 * 3)
237: (12)                       yellow_button = Dot(radius=0.1, stroke_width=0, color="#ffbd2e")
238: (12)                       green_button = Dot(radius=0.1, stroke_width=0, color="#27c93f")
239: (12)                       green_button.shift(RIGHT * 0.1 * 3)
240: (12)                       buttons = VGroup(red_button, yellow_button, green_button)
241: (12)                       buttons.shift(
242: (16)                           UP * (height / 2 - 0.1 * 2 - 0.05)
243: (16)                           + LEFT * (width / 2 - 0.1 * 5 - self.corner_radius / 2 - 0.05),
244: (12)                       )
245: (12)                       self.background_mobject = VGroup(rect, buttons)
246: (12)                       x = (height - foreground.height) / 2 - 0.1 * 3
247: (12)                       self.background_mobject.shift(foreground.get_center())
248: (12)                       self.background_mobject.shift(UP * x)
249: (8)                    if self.insert_line_no:
250: (12)                       super().__init__(
251: (16)                           self.background_mobject, self.line_numbers, self.code, **kwargs
252: (12)                       )
253: (8)                    else:
254: (12)                       super().__init__(
255: (16)                           self.background_mobject,
256: (16)                           Dot(fill_opacity=0, stroke_opacity=0),
257: (16)                           self.code,
258: (16)                           **kwargs,
259: (12)                       )
260: (8)                    self.move_to(np.array([0, 0, 0]))
261: (4)                def _ensure_valid_file(self):
262: (8)                    """Function to validate file."""
263: (8)                    if self.file_name is None:
264: (12)                       raise Exception("Must specify file for Code")
265: (8)                    possible_paths = [
266: (12)                       Path() / "assets" / "codes" / self.file_name,
267: (12)                       Path(self.file_name).expanduser(),
268: (8)                    ]
269: (8)                    for path in possible_paths:
270: (12)                       if path.exists():
271: (16)                           self.file_path = path
272: (16)                           return
273: (8)                    error = (
274: (12)                       f"From: {Path.cwd()}, could not find {self.file_name} at either "
275: (12)                       + f"of these locations: {list(map(str, possible_paths))}"
276: (8)                    )
277: (8)                    raise OSError(error)
278: (4)                def _gen_line_numbers(self):
279: (8)                    """Function to generate line_numbers.
280: (8)                    Returns
281: (8)                    -------
282: (8)                    :class:`~.Paragraph`
283: (12)                       The generated line_numbers according to parameters.
284: (8)                    """
285: (8)                    line_numbers_array = []
286: (8)                    for line_no in range(0, self.code_json.__len__()):
287: (12)                       number = str(self.line_no_from + line_no)
288: (12)                       line_numbers_array.append(number)
289: (8)                    line_numbers = Paragraph(
290: (12)                       *list(line_numbers_array),
291: (12)                       line_spacing=self.line_spacing,
292: (12)                       alignment="right",
293: (12)                       font_size=self.font_size,
294: (12)                       font=self.font,
295: (12)                       disable_ligatures=True,
296: (12)                       stroke_width=self.stroke_width,
297: (12)                       warn_missing_font=self.warn_missing_font,
298: (8)                    )
299: (8)                    for i in line_numbers:
300: (12)                       i.set_color(self.default_color)
301: (8)                    return line_numbers
302: (4)                def _gen_colored_lines(self):
303: (8)                    """Function to generate code.
304: (8)                    Returns
305: (8)                    -------
306: (8)                    :class:`~.Paragraph`
307: (12)                       The generated code according to parameters.
308: (8)                    """
309: (8)                    lines_text = []
310: (8)                    for line_no in range(0, self.code_json.__len__()):
311: (12)                       line_str = ""
312: (12)                       for word_index in range(self.code_json[line_no].__len__()):
313: (16)                           line_str = line_str + self.code_json[line_no][word_index][0]
314: (12)                       lines_text.append(self.tab_spaces[line_no] * "\t" + line_str)
315: (8)                    code = Paragraph(
316: (12)                       *list(lines_text),
317: (12)                       line_spacing=self.line_spacing,
318: (12)                       tab_width=self.tab_width,
319: (12)                       font_size=self.font_size,
320: (12)                       font=self.font,
321: (12)                       disable_ligatures=True,
322: (12)                       stroke_width=self.stroke_width,
323: (12)                       warn_missing_font=self.warn_missing_font,
324: (8)                    )
325: (8)                    for line_no in range(code.__len__()):
326: (12)                       line = code.chars[line_no]
327: (12)                       line_char_index = self.tab_spaces[line_no]
328: (12)                       for word_index in range(self.code_json[line_no].__len__()):
329: (16)                           line[
330: (20)                               line_char_index : line_char_index
331: (20)                               + self.code_json[line_no][word_index][0].__len__()
332: (16)                           ].set_color(self.code_json[line_no][word_index][1])
333: (16)                           line_char_index += self.code_json[line_no][word_index][0].__len__()
334: (8)                    return code
335: (4)                def _gen_html_string(self):
336: (8)                    """Function to generate html string with code highlighted and stores in variable html_string."""
337: (8)                    self.html_string = _hilite_me(
338: (12)                       self.code_string,
339: (12)                       self.language,
340: (12)                       self.style,
341: (12)                       self.insert_line_no,
342: (12)                       "border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;",
343: (12)                       self.file_path,
344: (12)                       self.line_no_from,
345: (8)                    )
346: (8)                    if self.generate_html_file:
347: (12)                       output_folder = Path() / "assets" / "codes" / "generated_html_files"
348: (12)                       output_folder.mkdir(parents=True, exist_ok=True)
349: (12)                       (output_folder / f"{self.file_name}.html").write_text(self.html_string)
350: (4)                def _gen_code_json(self):
351: (8)                    """Function to background_color, generate code_json and tab_spaces from html_string.
352: (8)                    background_color is just background color of displayed code.
353: (8)                    code_json is 2d array with rows as line numbers
354: (8)                    and columns as a array with length 2 having text and text's color value.
355: (8)                    tab_spaces is 2d array with rows as line numbers
356: (8)                    and columns as corresponding number of indentation_chars in front of that line in code.
357: (8)                    """
358: (8)                    if (
359: (12)                       self.background_color == "#111111"
360: (12)                       or self.background_color == "#272822"
361: (12)                       or self.background_color == "#202020"
362: (12)                       or self.background_color == "#000000"
363: (8)                    ):
364: (12)                       self.default_color = "#ffffff"
365: (8)                    else:
366: (12)                       self.default_color = "#000000"
367: (8)                    # print(self.default_color,self.background_color)
368: (8)                    for i in range(3, -1, -1):
369: (12)                       self.html_string = self.html_string.replace("</" + " " * i, "</")
370: (8)                    # handle pygments bug
371: (8)                    # https://github.com/pygments/pygments/issues/961
372: (8)                    self.html_string = self.html_string.replace("<span></span>", "")
373: (8)                    for i in range(10, -1, -1):
374: (12)                       self.html_string = self.html_string.replace(
375: (16)                           "</span>" + " " * i,
376: (16)                           " " * i + "</span>",
377: (12)                       )
378: (8)                    self.html_string = self.html_string.replace("background-color:", "background:")
379: (8)                    if self.insert_line_no:
380: (12)                       start_point = self.html_string.find("</td><td><pre")
381: (12)                       start_point = start_point + 9
382: (8)                    else:
383: (12)                       start_point = self.html_string.find("<pre")
384: (8)                    self.html_string = self.html_string[start_point:]
385: (8)                    # print(self.html_string)
386: (8)                    lines = self.html_string.split("\n")
387: (8)                    lines = lines[0 : lines.__len__() - 2]
388: (8)                    start_point = lines[0].find(">")
389: (8)                    lines[0] = lines[0][start_point + 1 :]
390: (8)                    # print(lines)
391: (8)                    self.code_json = []
392: (8)                    self.tab_spaces = []
393: (8)                    code_json_line_index = -1
394: (8)                    for line_index in range(0, lines.__len__()):
395: (12)                       # print(lines[line_index])
396: (12)                       self.code_json.append([])
397: (12)                       code_json_line_index = code_json_line_index + 1
398: (12)                       if lines[line_index].startswith(self.indentation_chars):
399: (16)                           start_point = lines[line_index].find("<")
400: (16)                           starting_string = lines[line_index][:start_point]
401: (16)                           indentation_chars_count = lines[line_index][:start_point].count(
402: (20)                               self.indentation_chars,
403: (16)                           )
404: (16)                           if (
405: (20)                               starting_string.__len__()
406: (20)                               != indentation_chars_count * self.indentation_chars.__len__()
407: (16)                           ):
408: (20)                               lines[line_index] = (
409: (24)                                   "\t" * indentation_chars_count
410: (24)                                   + starting_string[
411: (28)                                       starting_string.rfind(self.indentation_chars)
412: (28)                                       + self.indentation_chars.__len__() :
413: (24)                                   ]
414: (24)                                   + lines[line_index][start_point:]
415: (20)                               )
416: (16)                           else:
417: (20)                               lines[line_index] = (
418: (24)                                   "\t" * indentation_chars_count + lines[line_index][start_point:]
419: (20)                               )
420: (12)                       indentation_chars_count = 0
421: (12)                       if lines[line_index]:
422: (16)                           while lines[line_index][indentation_chars_count] == "\t":
423: (20)                               indentation_chars_count = indentation_chars_count + 1
424: (12)                       self.tab_spaces.append(indentation_chars_count)
425: (12)                       # print(lines[line_index])
426: (12)                       lines[line_index] = self._correct_non_span(lines[line_index])
427: (12)                       # print(lines[line_index])
428: (12)                       words = lines[line_index].split("<span")
429: (12)                       for word_index in range(1, words.__len__()):
430: (16)                           color_index = words[word_index].find("color:")
431: (16)                           if color_index == -1:
432: (20)                               color = self.default_color
433: (16)                           else:
434: (20)                               starti = words[word_index][color_index:].find("#")
435: (20)                               color = words[word_index][
436: (24)                                   color_index + starti : color_index + starti + 7
437: (20)                               ]
438: (16)                           start_point = words[word_index].find(">")
439: (16)                           end_point = words[word_index].find("</span>")
440: (16)                           text = words[word_index][start_point + 1 : end_point]
441: (16)                           text = html.unescape(text)
442: (16)                           if text != "":
443: (20)                               # print(text, "'" + color + "'")
444: (20)                               self.code_json[code_json_line_index].append([text, color])
445: (8)                    # print(self.code_json)
446: (4)                def _correct_non_span(self, line_str: str):
447: (8)                    """Function put text color to those strings that don't have one according to background_color of displayed code.
448: (8)                    Parameters
449: (8)                    ---------
450: (8)                    line_str
451: (12)                       Takes a html element's string to put color to it according to background_color of displayed code.
452: (8)                    Returns
453: (8)                    -------
454: (8)                    :class:`str`
455: (12)                       The generated html element's string with having color attributes.
456: (8)                    """
457: (8)                    words = line_str.split("</span>")
458: (8)                    line_str = ""
459: (8)                    for i in range(0, words.__len__()):
460: (12)                       if i != words.__len__() - 1:
461: (16)                           j = words[i].find("<span")
462: (12)                       else:
463: (16)                           j = words[i].__len__()
464: (12)                       temp = ""
465: (12)                       starti = -1
466: (12)                       for k in range(0, j):
467: (16)                           if words[i][k] == "\t" and starti == -1:
468: (20)                               continue
469: (16)                           else:
470: (20)                               if starti == -1:
471: (24)                                   starti = k
472: (20)                               temp = temp + words[i][k]
473: (12)                       if temp != "":
474: (16)                           if i != words.__len__() - 1:
475: (20)                               temp = (
476: (24)                                   '<span style="color:'
477: (24)                                   + self.default_color
478: (24)                                   + '">'
479: (24)                                   + words[i][starti:j]
480: (24)                                   + "</span>"
481: (20)                               )
482: (16)                           else:
483: (20)                               temp = (
484: (24)                                   '<span style="color:'
485: (24)                                   + self.default_color
486: (24)                                   + '">'
487: (24)                                   + words[i][starti:j]
488: (20)                               )
489: (16)                           temp = temp + words[i][j:]
490: (16)                           words[i] = temp
491: (12)                       if words[i] != "":
492: (16)                           line_str = line_str + words[i] + "</span>"
493: (8)                    return line_str
494: (0)            def _hilite_me(
495: (4)                code: str,
496: (4)                language: str,
497: (4)                style: str,
498: (4)                insert_line_no: bool,
499: (4)                divstyles: str,
500: (4)                file_path: Path,
501: (4)                line_no_from: int,
502: (0)            ):
503: (4)                """Function to highlight code from string to html.
504: (4)                Parameters
505: (4)                ---------
506: (4)                code
507: (8)                    Code string.
508: (4)                language
509: (8)                    The name of the programming language the given code was written in.
510: (4)                style
511: (8)                    Code style name.
512: (4)                insert_line_no
513: (8)                    Defines whether line numbers should be inserted in the html file.
514: (4)                divstyles
515: (8)                    Some html css styles.
516: (4)                file_path
517: (8)                    Path of code file.
518: (4)                line_no_from
519: (8)                    Defines the first line's number in the line count.
520: (4)                """
521: (4)                style = style or "colorful"
522: (4)                defstyles = "overflow:auto;width:auto;"
523: (4)                formatter = HtmlFormatter(
524: (8)                    style=style,
525: (8)                    linenos=False,
526: (8)                    noclasses=True,
527: (8)                    cssclass="",
528: (8)                    cssstyles=defstyles + divstyles,
529: (8)                    prestyles="margin: 0",
530: (4)                )
531: (4)                if language is None and file_path:
532: (8)                    lexer = guess_lexer_for_filename(file_path, code)
533: (8)                    html = highlight(code, lexer, formatter)
534: (4)                elif language is None:
535: (8)                    raise ValueError(
536: (12)                       "The code language has to be specified when rendering a code string",
537: (8)                    )
538: (4)                else:
539: (8)                    html = highlight(code, get_lexer_by_name(language, **{}), formatter)
540: (4)                if insert_line_no:
541: (8)                    html = _insert_line_numbers_in_html(html, line_no_from)
542: (4)                html = "<!-- HTML generated by Code() -->" + html
543: (4)                return html
544: (0)            def _insert_line_numbers_in_html(html: str, line_no_from: int):
545: (4)                """Function that inserts line numbers in the highlighted HTML code.
546: (4)                Parameters
547: (4)                ---------
548: (4)                html
549: (8)                    html string of highlighted code.
550: (4)                line_no_from
551: (8)                    Defines the first line's number in the line count.
552: (4)                Returns
553: (4)                -------
554: (4)                :class:`str`
555: (8)                    The generated html string with having line numbers.
556: (4)                """
557: (4)                match = re.search("(<pre[^>]*>)(.*)(</pre>)", html, re.DOTALL)
558: (4)                if not match:
559: (8)                    return html
560: (4)                pre_open = match.group(1)
561: (4)                pre = match.group(2)
562: (4)                pre_close = match.group(3)
563: (4)                html = html.replace(pre_close, "</pre></td></tr></table>")
564: (4)                numbers = range(line_no_from, line_no_from + pre.count("\n") + 1)
565: (4)                format_lines = "%" + str(len(str(numbers[-1]))) + "i"
566: (4)                lines = "\n".join(format_lines % i for i in numbers)
567: (4)                html = html.replace(
568: (8)                    pre_open,
569: (8)                    "<table><tr><td>" + pre_open + lines + "</pre></td><td>" + pre_open,
570: (4)                )
571: (4)                return html

----------------------------------------

File 35 - .\text \text_mobject.py:

1: (0)              """Mobjects used for displaying (non-LaTeX) text.
2: (0)              .. note::
3: (3)                 Just as you can use :class:`~.Tex` and :class:`~.MathTex` (from the module :mod:`~.tex_mobject`)
4: (3)                 to insert LaTeX to your videos, you can use :class:`~.Text` to to add normal text.
5: (0)              .. important::
6: (3)                 See the corresponding tutorial :ref:`using-text-objects`, especially for information about fonts.
7: (0)              The simplest way to add text to your animations is to use the :class:`~.Text` class. It uses the Pango library to render text.
8: (0)              With Pango, you are also able to render non-English alphabets like `你好` or  `こんにちは` or `안녕하세요` or `مرحبا بالعالم`.
9: (0)              Examples
10: (0)             --------
11: (0)             .. manim:: HelloWorld
12: (4)                 :save_last_frame:
13: (4)                 class HelloWorld(Scene):
14: (8)                     def construct(self):
15: (12)                        text = Text('Hello world').scale(3)
16: (12)                        self.add(text)
17: (0)             .. manim:: TextAlignment
18: (4)                 :save_last_frame:
19: (4)                 class TextAlignment(Scene):
20: (8)                     def construct(self):
21: (12)                        title = Text("K-means clustering and Logistic Regression", color=WHITE)
22: (12)                        title.scale(0.75)
23: (12)                        self.add(title.to_edge(UP))
24: (12)                        t1 = Text("1. Measuring").set_color(WHITE)
25: (12)                        t2 = Text("2. Clustering").set_color(WHITE)
26: (12)                        t3 = Text("3. Regression").set_color(WHITE)
27: (12)                        t4 = Text("4. Prediction").set_color(WHITE)
28: (12)                        x = VGroup(t1, t2, t3, t4).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7).next_to(ORIGIN,DR)
29: (12)                        x.set_opacity(0.5)
30: (12)                        x.submobjects[1].set_opacity(1)
31: (12)                        self.add(x)
32: (0)             """
33: (0)             from __future__ import annotations
34: (0)             import functools
35: (0)             __all__ = ["Text", "Paragraph", "MarkupText", "register_font"]
36: (0)             import copy
37: (0)             import hashlib
38: (0)             import os
39: (0)             import re
40: (0)             from contextlib import contextmanager
41: (0)             from itertools import chain
42: (0)             from pathlib import Path
43: (0)             from typing import Iterable, Sequence
44: (0)             import manimpango
45: (0)             import numpy as np
46: (0)             from manimpango import MarkupUtils, PangoUtils, TextSetting
47: (0)             from manim import config, logger
48: (0)             from manim.constants import *
49: (0)             from manim.mobject.geometry.arc import Dot
50: (0)             from manim.mobject.svg.svg_mobject import SVGMobject
51: (0)             from manim.mobject.types.vectorized_mobject import VGroup, VMobject
52: (0)             from manim.utils.color import ManimColor, ParsableManimColor, color_gradient
53: (0)             from manim.utils.deprecation import deprecated
54: (0)             TEXT_MOB_SCALE_FACTOR = 0.05
55: (0)             DEFAULT_LINE_SPACING_SCALE = 0.3
56: (0)             TEXT2SVG_ADJUSTMENT_FACTOR = 4.8
57: (0)             __all__ = ["Text", "Paragraph", "MarkupText", "register_font"]
58: (0)             def remove_invisible_chars(mobject: SVGMobject) -> SVGMobject:
59: (4)                 """Function to remove unwanted invisible characters from some mobjects.
60: (4)                 Parameters
61: (4)                 ----------
62: (4)                 mobject
63: (8)                     Any SVGMobject from which we want to remove unwanted invisible characters.
64: (4)                 Returns
65: (4)                 -------
66: (4)                 :class:`~.SVGMobject`
67: (8)                     The SVGMobject without unwanted invisible characters.
68: (4)                 """
69: (4)                 # TODO: Refactor needed
70: (4)                 iscode = False
71: (4)                 if mobject.__class__.__name__ == "Text":
72: (8)                     mobject = mobject[:]
73: (4)                 elif mobject.__class__.__name__ == "Code":
74: (8)                     iscode = True
75: (8)                     code = mobject
76: (8)                     mobject = mobject.code
77: (4)                 mobject_without_dots = VGroup()
78: (4)                 if mobject[0].__class__ == VGroup:
79: (8)                     for i in range(len(mobject)):
80: (12)                        mobject_without_dots.add(VGroup())
81: (12)                        mobject_without_dots[i].add(*(k for k in mobject[i] if k.__class__ != Dot))
82: (4)                 else:
83: (8)                     mobject_without_dots.add(*(k for k in mobject if k.__class__ != Dot))
84: (4)                 if iscode:
85: (8)                     code.code = mobject_without_dots
86: (8)                     return code
87: (4)                 return mobject_without_dots
88: (0)             class Paragraph(VGroup):
89: (4)                 r"""Display a paragraph of text.
90: (4)                 For a given :class:`.Paragraph` ``par``, the attribute ``par.chars`` is a
91: (4)                 :class:`.VGroup` containing all the lines. In this context, every line is
92: (4)                 constructed as a :class:`.VGroup` of characters contained in the line.
93: (4)                 Parameters
94: (4)                 ----------
95: (4)                 line_spacing
96: (8)                     Represents the spacing between lines. Defaults to -1, which means auto.
97: (4)                 alignment
98: (8)                     Defines the alignment of paragraph. Defaults to None. Possible values are "left", "right" or "center".
99: (4)                 Examples
100: (4)                --------
101: (4)                Normal usage::
102: (8)                    paragraph = Paragraph('this is a awesome', 'paragraph',
103: (30)                                         'With \nNewlines', '\tWith Tabs',
104: (30)                                         '  With Spaces', 'With Alignments',
105: (30)                                         'center', 'left', 'right')
106: (4)                Remove unwanted invisible characters::
107: (8)                    self.play(Transform(remove_invisible_chars(paragraph.chars[0:2]),
108: (28)                                       remove_invisible_chars(paragraph.chars[3][0:3]))
109: (4)                """
110: (4)                def __init__(
111: (8)                    self,
112: (8)                    *text: Sequence[str],
113: (8)                    line_spacing: float = -1,
114: (8)                    alignment: str | None = None,
115: (8)                    **kwargs,
116: (4)                ) -> None:
117: (8)                    self.line_spacing = line_spacing
118: (8)                    self.alignment = alignment
119: (8)                    self.consider_spaces_as_chars = kwargs.get("disable_ligatures", False)
120: (8)                    super().__init__()
121: (8)                    lines_str = "\n".join(list(text))
122: (8)                    self.lines_text = Text(lines_str, line_spacing=line_spacing, **kwargs)
123: (8)                    lines_str_list = lines_str.split("\n")
124: (8)                    self.chars = self._gen_chars(lines_str_list)
125: (8)                    self.lines = [list(self.chars), [self.alignment] * len(self.chars)]
126: (8)                    self.lines_initial_positions = [line.get_center() for line in self.lines[0]]
127: (8)                    self.add(*self.lines[0])
128: (8)                    self.move_to(np.array([0, 0, 0]))
129: (8)                    if self.alignment:
130: (12)                       self._set_all_lines_alignments(self.alignment)
131: (4)                def _gen_chars(self, lines_str_list: list) -> VGroup:
132: (8)                    """Function to convert a list of plain strings to a VGroup of VGroups of chars.
133: (8)                    Parameters
134: (8)                    ----------
135: (8)                    lines_str_list
136: (12)                       List of plain text strings.
137: (8)                    Returns
138: (8)                    -------
139: (8)                    :class:`~.VGroup`
140: (12)                       The generated 2d-VGroup of chars.
141: (8)                    """
142: (8)                    char_index_counter = 0
143: (8)                    chars = self.get_group_class()()
144: (8)                    for line_no in range(len(lines_str_list)):
145: (12)                       line_str = lines_str_list[line_no]
146: (12)                       # Count all the characters in line_str
147: (12)                       # Spaces may or may not count as characters
148: (12)                       if self.consider_spaces_as_chars:
149: (16)                           char_count = len(line_str)
150: (12)                       else:
151: (16)                           char_count = 0
152: (16)                           for char in line_str:
153: (20)                               if not char.isspace():
154: (24)                                   char_count += 1
155: (12)                       chars.add(self.get_group_class()())
156: (12)                       chars[line_no].add(
157: (16)                           *self.lines_text.chars[
158: (20)                               char_index_counter : char_index_counter + char_count
159: (16)                           ]
160: (12)                       )
161: (12)                       char_index_counter += char_count
162: (12)                       if self.consider_spaces_as_chars:
163: (16)                           # If spaces count as characters, count the extra \n character
164: (16)                           # which separates Paragraph's lines to avoid issues
165: (16)                           char_index_counter += 1
166: (8)                    return chars
167: (4)                def _set_all_lines_alignments(self, alignment: str) -> Paragraph:
168: (8)                    """Function to set all line's alignment to a specific value.
169: (8)                    Parameters
170: (8)                    ----------
171: (8)                    alignment
172: (12)                       Defines the alignment of paragraph. Possible values are "left", "right", "center".
173: (8)                    """
174: (8)                    for line_no in range(len(self.lines[0])):
175: (12)                       self._change_alignment_for_a_line(alignment, line_no)
176: (8)                    return self
177: (4)                def _set_line_alignment(self, alignment: str, line_no: int) -> Paragraph:
178: (8)                    """Function to set one line's alignment to a specific value.
179: (8)                    Parameters
180: (8)                    ----------
181: (8)                    alignment
182: (12)                       Defines the alignment of paragraph. Possible values are "left", "right", "center".
183: (8)                    line_no
184: (12)                       Defines the line number for which we want to set given alignment.
185: (8)                    """
186: (8)                    self._change_alignment_for_a_line(alignment, line_no)
187: (8)                    return self
188: (4)                def _set_all_lines_to_initial_positions(self) -> Paragraph:
189: (8)                    """Set all lines to their initial positions."""
190: (8)                    self.lines[1] = [None] * len(self.lines[0])
191: (8)                    for line_no in range(len(self.lines[0])):
192: (12)                       self[line_no].move_to(
193: (16)                           self.get_center() + self.lines_initial_positions[line_no],
194: (12)                       )
195: (8)                    return self
196: (4)                def _set_line_to_initial_position(self, line_no: int) -> Paragraph:
197: (8)                    """Function to set one line to initial positions.
198: (8)                    Parameters
199: (8)                    ----------
200: (8)                    line_no
201: (12)                       Defines the line number for which we want to set given alignment.
202: (8)                    """
203: (8)                    self.lines[1][line_no] = None
204: (8)                    self[line_no].move_to(self.get_center() + self.lines_initial_positions[line_no])
205: (8)                    return self
206: (4)                def _change_alignment_for_a_line(self, alignment: str, line_no: int) -> None:
207: (8)                    """Function to change one line's alignment to a specific value.
208: (8)                    Parameters
209: (8)                    ----------
210: (8)                    alignment
211: (12)                       Defines the alignment of paragraph. Possible values are "left", "right", "center".
212: (8)                    line_no
213: (12)                       Defines the line number for which we want to set given alignment.
214: (8)                    """
215: (8)                    self.lines[1][line_no] = alignment
216: (8)                    if self.lines[1][line_no] == "center":
217: (12)                       self[line_no].move_to(
218: (16)                           np.array([self.get_center()[0], self[line_no].get_center()[1], 0]),
219: (12)                       )
220: (8)                    elif self.lines[1][line_no] == "right":
221: (12)                       self[line_no].move_to(
222: (16)                           np.array(
223: (20)                               [
224: (24)                                   self.get_right()[0] - self[line_no].width / 2,
225: (24)                                   self[line_no].get_center()[1],
226: (24)                                   0,
227: (20)                               ],
228: (16)                           ),
229: (12)                       )
230: (8)                    elif self.lines[1][line_no] == "left":
231: (12)                       self[line_no].move_to(
232: (16)                           np.array(
233: (20)                               [
234: (24)                                   self.get_left()[0] + self[line_no].width / 2,
235: (24)                                   self[line_no].get_center()[1],
236: (24)                                   0,
237: (20)                               ],
238: (16)                           ),
239: (12)                       )
240: (0)            class Text(SVGMobject):
241: (4)                r"""Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.
242: (4)                Text objects behave like a :class:`.VGroup`-like iterable of all characters
243: (4)                in the given text. In particular, slicing is possible.
244: (4)                Parameters
245: (4)                ----------
246: (4)                text
247: (8)                    The text that needs to be created as a mobject.
248: (4)                font
249: (8)                    The font family to be used to render the text. This is either a system font or
250: (8)                    one loaded with `register_font()`. Note that font family names may be different
251: (8)                    across operating systems.
252: (4)                warn_missing_font
253: (8)                    If True (default), Manim will issue a warning if the font does not exist in the
254: (8)                    (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.
255: (4)                Returns
256: (4)                -------
257: (4)                :class:`Text`
258: (8)                    The mobject-like :class:`.VGroup`.
259: (4)                Examples
260: (4)                ---------
261: (4)                .. manim:: Example1Text
262: (8)                    :save_last_frame:
263: (8)                    class Example1Text(Scene):
264: (12)                       def construct(self):
265: (16)                           text = Text('Hello world').scale(3)
266: (16)                           self.add(text)
267: (4)                .. manim:: TextColorExample
268: (8)                    :save_last_frame:
269: (8)                    class TextColorExample(Scene):
270: (12)                       def construct(self):
271: (16)                           text1 = Text('Hello world', color=BLUE).scale(3)
272: (16)                           text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)
273: (16)                           self.add(text1, text2)
274: (4)                .. manim:: TextItalicAndBoldExample
275: (8)                    :save_last_frame:
276: (8)                    class TextItalicAndBoldExample(Scene):
277: (12)                       def construct(self):
278: (16)                           text1 = Text("Hello world", slant=ITALIC)
279: (16)                           text2 = Text("Hello world", t2s={'world':ITALIC})
280: (16)                           text3 = Text("Hello world", weight=BOLD)
281: (16)                           text4 = Text("Hello world", t2w={'world':BOLD})
282: (16)                           text5 = Text("Hello world", t2c={'o':YELLOW}, disable_ligatures=True)
283: (16)                           text6 = Text(
284: (20)                               "Visit us at docs.manim.community",
285: (20)                               t2c={"docs.manim.community": YELLOW},
286: (20)                               disable_ligatures=True,
287: (15)                          )
288: (16)                           text6.scale(1.3).shift(DOWN)
289: (16)                           self.add(text1, text2, text3, text4, text5 , text6)
290: (16)                           Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)
291: (4)                .. manim:: TextMoreCustomization
292: (12)                       :save_last_frame:
293: (12)                       class TextMoreCustomization(Scene):
294: (16)                           def construct(self):
295: (20)                               text1 = Text(
296: (24)                                   'Google',
297: (24)                                   t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',
298: (29)                                        '[2:3]': '#fbb003', '[3:4]': '#3174f0',
299: (29)                                        '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)
300: (20)                               self.add(text1)
301: (4)                As :class:`Text` uses Pango to render text, rendering non-English
302: (4)                characters is easily possible:
303: (4)                .. manim:: MultipleFonts
304: (8)                    :save_last_frame:
305: (8)                    class MultipleFonts(Scene):
306: (12)                       def construct(self):
307: (16)                           morning = Text("வணக்கம்", font="sans-serif")
308: (16)                           japanese = Text(
309: (20)                               "日本へようこそ", t2c={"日本": BLUE}
310: (16)                           )  # works same as ``Text``.
311: (16)                           mess = Text("Multi-Language", weight=BOLD)
312: (16)                           russ = Text("Здравствуйте मस नम म ", font="sans-serif")
313: (16)                           hin = Text("नमस्ते", font="sans-serif")
314: (16)                           arb = Text(
315: (20)                               "صباح الخير \n تشرفت بمقابلتك", font="sans-serif"
316: (16)                           )  # don't mix RTL and LTR languages nothing shows up then ;-)
317: (16)                           chinese = Text("臂猿「黛比」帶著孩子", font="sans-serif")
318: (16)                           self.add(morning, japanese, mess, russ, hin, arb, chinese)
319: (16)                           for i,mobj in enumerate(self.mobjects):
320: (20)                               mobj.shift(DOWN*(i-3))
321: (4)                .. manim:: PangoRender
322: (8)                    :quality: low
323: (8)                    class PangoRender(Scene):
324: (12)                       def construct(self):
325: (16)                           morning = Text("வணக்கம்", font="sans-serif")
326: (16)                           self.play(Write(morning))
327: (16)                           self.wait(2)
328: (4)                Tests
329: (4)                -----
330: (4)                Check that the creation of :class:`~.Text` works::
331: (8)                    >>> Text('The horse does not eat cucumber salad.')
332: (8)                    Text('The horse does not eat cucumber salad.')
333: (4)                """
334: (4)                @staticmethod
335: (4)                @functools.lru_cache(maxsize=None)
336: (4)                def font_list() -> list[str]:
337: (8)                    return manimpango.list_fonts()
338: (4)                def __init__(
339: (8)                    self,
340: (8)                    text: str,
341: (8)                    fill_opacity: float = 1.0,
342: (8)                    stroke_width: float = 0,
343: (8)                    color: ParsableManimColor | None = None,
344: (8)                    font_size: float = DEFAULT_FONT_SIZE,
345: (8)                    line_spacing: float = -1,
346: (8)                    font: str = "",
347: (8)                    slant: str = NORMAL,
348: (8)                    weight: str = NORMAL,
349: (8)                    t2c: dict[str, str] = None,
350: (8)                    t2f: dict[str, str] = None,
351: (8)                    t2g: dict[str, tuple] = None,
352: (8)                    t2s: dict[str, str] = None,
353: (8)                    t2w: dict[str, str] = None,
354: (8)                    gradient: tuple = None,
355: (8)                    tab_width: int = 4,
356: (8)                    warn_missing_font: bool = True,
357: (8)                    # Mobject
358: (8)                    height: float = None,
359: (8)                    width: float = None,
360: (8)                    should_center: bool = True,
361: (8)                    disable_ligatures: bool = False,
362: (8)                    use_svg_cache: bool = False,
363: (8)                    **kwargs,
364: (4)                ) -> None:
365: (8)                    self.line_spacing = line_spacing
366: (8)                    if font and warn_missing_font:
367: (12)                       fonts_list = Text.font_list()
368: (12)                       # handle special case of sans/sans-serif
369: (12)                       if font.lower() == "sans-serif":
370: (16)                           font = "sans"
371: (12)                       if font not in fonts_list:
372: (16)                           # check if the capitalized version is in the supported fonts
373: (16)                           if font.capitalize() in fonts_list:
374: (20)                               font = font.capitalize()
375: (16)                           elif font.lower() in fonts_list:
376: (20)                               font = font.lower()
377: (16)                           elif font.title() in fonts_list:
378: (20)                               font = font.title()
379: (16)                           else:
380: (20)                               logger.warning(f"Font {font} not in {fonts_list}.")
381: (8)                    self.font = font
382: (8)                    self._font_size = float(font_size)
383: (8)                    # needs to be a float or else size is inflated when font_size = 24
384: (8)                    # (unknown cause)
385: (8)                    self.slant = slant
386: (8)                    self.weight = weight
387: (8)                    self.gradient = gradient
388: (8)                    self.tab_width = tab_width
389: (8)                    if t2c is None:
390: (12)                       t2c = {}
391: (8)                    if t2f is None:
392: (12)                       t2f = {}
393: (8)                    if t2g is None:
394: (12)                       t2g = {}
395: (8)                    if t2s is None:
396: (12)                       t2s = {}
397: (8)                    if t2w is None:
398: (12)                       t2w = {}
399: (8)                    # If long form arguments are present, they take precedence
400: (8)                    t2c = kwargs.pop("text2color", t2c)
401: (8)                    t2f = kwargs.pop("text2font", t2f)
402: (8)                    t2g = kwargs.pop("text2gradient", t2g)
403: (8)                    t2s = kwargs.pop("text2slant", t2s)
404: (8)                    t2w = kwargs.pop("text2weight", t2w)
405: (8)                    self.t2c = {k: ManimColor(v).to_hex() for k, v in t2c.items()}
406: (8)                    self.t2f = t2f
407: (8)                    self.t2g = t2g
408: (8)                    self.t2s = t2s
409: (8)                    self.t2w = t2w
410: (8)                    self.original_text = text
411: (8)                    self.disable_ligatures = disable_ligatures
412: (8)                    text_without_tabs = text
413: (8)                    if text.find("\t") != -1:
414: (12)                       text_without_tabs = text.replace("\t", " " * self.tab_width)
415: (8)                    self.text = text_without_tabs
416: (8)                    if self.line_spacing == -1:
417: (12)                       self.line_spacing = (
418: (16)                           self._font_size + self._font_size * DEFAULT_LINE_SPACING_SCALE
419: (12)                       )
420: (8)                    else:
421: (12)                       self.line_spacing = self._font_size + self._font_size * self.line_spacing
422: (8)                    color: ManimColor = ManimColor(color) if color else VMobject().color
423: (8)                    file_name = self._text2svg(color.to_hex())
424: (8)                    PangoUtils.remove_last_M(file_name)
425: (8)                    super().__init__(
426: (12)                       file_name,
427: (12)                       fill_opacity=fill_opacity,
428: (12)                       stroke_width=stroke_width,
429: (12)                       height=height,
430: (12)                       width=width,
431: (12)                       should_center=should_center,
432: (12)                       use_svg_cache=use_svg_cache,
433: (12)                       **kwargs,
434: (8)                    )
435: (8)                    self.text = text
436: (8)                    if self.disable_ligatures:
437: (12)                       self.submobjects = [*self._gen_chars()]
438: (8)                    self.chars = self.get_group_class()(*self.submobjects)
439: (8)                    self.text = text_without_tabs.replace(" ", "").replace("\n", "")
440: (8)                    nppc = self.n_points_per_curve
441: (8)                    for each in self:
442: (12)                       if len(each.points) == 0:
443: (16)                           continue
444: (12)                       points = each.points
445: (12)                       curve_start = points[0]
446: (12)                       assert len(curve_start) == self.dim, curve_start
447: (12)                       # Some of the glyphs in this text might not be closed,
448: (12)                       # so we close them by identifying when one curve ends
449: (12)                       # but it is not where the next curve starts.
450: (12)                       # It is more efficient to temporarily create a list
451: (12)                       # of points and add them one at a time, then turn them
452: (12)                       # into a numpy array at the end, rather than creating
453: (12)                       # new numpy arrays every time a point or fixing line
454: (12)                       # is added (which is O(n^2) for numpy arrays).
455: (12)                       closed_curve_points = []
456: (12)                       # OpenGL has points be part of quadratic Bezier curves;
457: (12)                       # Cairo uses cubic Bezier curves.
458: (12)                       if nppc == 3:  # RendererType.OPENGL
459: (16)                           def add_line_to(end):
460: (20)                               nonlocal closed_curve_points
461: (20)                               start = closed_curve_points[-1]
462: (20)                               closed_curve_points += [
463: (24)                                   start,
464: (24)                                   (start + end) / 2,
465: (24)                                   end,
466: (20)                               ]
467: (12)                       else:  # RendererType.CAIRO
468: (16)                           def add_line_to(end):
469: (20)                               nonlocal closed_curve_points
470: (20)                               start = closed_curve_points[-1]
471: (20)                               closed_curve_points += [
472: (24)                                   start,
473: (24)                                   (start + start + end) / 3,
474: (24)                                   (start + end + end) / 3,
475: (24)                                   end,
476: (20)                               ]
477: (12)                       for index, point in enumerate(points):
478: (16)                           closed_curve_points.append(point)
479: (16)                           if (
480: (20)                               index != len(points) - 1
481: (20)                               and (index + 1) % nppc == 0
482: (20)                               and any(point != points[index + 1])
483: (16)                           ):
484: (20)                               # Add straight line from last point on this curve to the
485: (20)                               # start point on the next curve. We represent the line
486: (20)                               # as a cubic bezier curve where the two control points
487: (20)                               # are half-way between the start and stop point.
488: (20)                               add_line_to(curve_start)
489: (20)                               curve_start = points[index + 1]
490: (12)                       # Make sure last curve is closed
491: (12)                       add_line_to(curve_start)
492: (12)                       each.points = np.array(closed_curve_points, ndmin=2)
493: (8)                    # anti-aliasing
494: (8)                    if height is None and width is None:
495: (12)                       self.scale(TEXT_MOB_SCALE_FACTOR)
496: (8)                    self.initial_height = self.height
497: (4)                def __repr__(self):
498: (8)                    return f"Text({repr(self.original_text)})"
499: (4)                @property
500: (4)                def font_size(self):
501: (8)                    return (
502: (12)                       self.height
503: (12)                       / self.initial_height
504: (12)                       / TEXT_MOB_SCALE_FACTOR
505: (12)                       * 2.4
506: (12)                       * self._font_size
507: (12)                       / DEFAULT_FONT_SIZE
508: (8)                    )
509: (4)                @font_size.setter
510: (4)                def font_size(self, font_val):
511: (8)                    # TODO: use pango's font size scaling.
512: (8)                    if font_val <= 0:
513: (12)                       raise ValueError("font_size must be greater than 0.")
514: (8)                    else:
515: (12)                       self.scale(font_val / self.font_size)
516: (4)                def _gen_chars(self):
517: (8)                    chars = self.get_group_class()()
518: (8)                    submobjects_char_index = 0
519: (8)                    for char_index in range(len(self.text)):
520: (12)                       if self.text[char_index].isspace():
521: (16)                           space = Dot(radius=0, fill_opacity=0, stroke_opacity=0)
522: (16)                           if char_index == 0:
523: (20)                               space.move_to(self.submobjects[submobjects_char_index].get_center())
524: (16)                           else:
525: (20)                               space.move_to(
526: (24)                                   self.submobjects[submobjects_char_index - 1].get_center(),
527: (20)                               )
528: (16)                           chars.add(space)
529: (12)                       else:
530: (16)                           chars.add(self.submobjects[submobjects_char_index])
531: (16)                           submobjects_char_index += 1
532: (8)                    return chars
533: (4)                def _find_indexes(self, word: str, text: str):
534: (8)                    """Finds the indexes of ``text`` in ``word``."""
535: (8)                    temp = re.match(r"\[([0-9\-]{0,}):([0-9\-]{0,})\]", word)
536: (8)                    if temp:
537: (12)                       start = int(temp.group(1)) if temp.group(1) != "" else 0
538: (12)                       end = int(temp.group(2)) if temp.group(2) != "" else len(text)
539: (12)                       start = len(text) + start if start < 0 else start
540: (12)                       end = len(text) + end if end < 0 else end
541: (12)                       return [(start, end)]
542: (8)                    indexes = []
543: (8)                    index = text.find(word)
544: (8)                    while index != -1:
545: (12)                       indexes.append((index, index + len(word)))
546: (12)                       index = text.find(word, index + len(word))
547: (8)                    return indexes
548: (4)                @deprecated(
549: (8)                    since="v0.14.0",
550: (8)                    until="v0.15.0",
551: (8)                    message="This was internal function, you shouldn't be using it anyway.",
552: (4)                )
553: (4)                def _set_color_by_t2c(self, t2c=None):
554: (8)                    """Sets color for specified strings."""
555: (8)                    t2c = t2c if t2c else self.t2c
556: (8)                    for word, color in list(t2c.items()):
557: (12)                       for start, end in self._find_indexes(word, self.text):
558: (16)                           self.chars[start:end].set_color(color)
559: (4)                @deprecated(
560: (8)                    since="v0.14.0",
561: (8)                    until="v0.15.0",
562: (8)                    message="This was internal function, you shouldn't be using it anyway.",
563: (4)                )
564: (4)                def _set_color_by_t2g(self, t2g=None):
565: (8)                    """Sets gradient colors for specified
566: (8)                    strings. Behaves similarly to ``set_color_by_t2c``."""
567: (8)                    t2g = t2g if t2g else self.t2g
568: (8)                    for word, gradient in list(t2g.items()):
569: (12)                       for start, end in self._find_indexes(word, self.text):
570: (16)                           self.chars[start:end].set_color_by_gradient(*gradient)
571: (4)                def _text2hash(self, color: ManimColor):
572: (8)                    """Generates ``sha256`` hash for file name."""
573: (8)                    settings = (
574: (12)                       "PANGO" + self.font + self.slant + self.weight + str(color)
575: (8)                    )  # to differentiate Text and CairoText
576: (8)                    settings += str(self.t2f) + str(self.t2s) + str(self.t2w) + str(self.t2c)
577: (8)                    settings += str(self.line_spacing) + str(self._font_size)
578: (8)                    settings += str(self.disable_ligatures)
579: (8)                    id_str = self.text + settings
580: (8)                    hasher = hashlib.sha256()
581: (8)                    hasher.update(id_str.encode())
582: (8)                    return hasher.hexdigest()[:16]
583: (4)                def _merge_settings(
584: (8)                    self,
585: (8)                    left_setting: TextSetting,
586: (8)                    right_setting: TextSetting,
587: (8)                    default_args: dict[str, Iterable[str]],
588: (4)                ) -> TextSetting:
589: (8)                    contained = right_setting.end < left_setting.end
590: (8)                    new_setting = copy.copy(left_setting) if contained else copy.copy(right_setting)
591: (8)                    new_setting.start = right_setting.end if contained else left_setting.end
592: (8)                    left_setting.end = right_setting.start
593: (8)                    if not contained:
594: (12)                       right_setting.end = new_setting.start
595: (8)                    for arg in default_args:
596: (12)                       left = getattr(left_setting, arg)
597: (12)                       right = getattr(right_setting, arg)
598: (12)                       default = default_args[arg]
599: (12)                       if left != default and getattr(right_setting, arg) != default:
600: (16)                           raise ValueError(
601: (20)                               f"Ambiguous style for text '{self.text[right_setting.start:right_setting.end]}':"
602: (20)                               + f"'{arg}' cannot be both '{left}' and '{right}'."
603: (16)                           )
604: (12)                       setattr(right_setting, arg, left if left != default else right)
605: (8)                    return new_setting
606: (4)                def _get_settings_from_t2xs(
607: (8)                    self,
608: (8)                    t2xs: Sequence[tuple[dict[str, str], str]],
609: (8)                    default_args: dict[str, Iterable[str]],
610: (4)                ) -> Sequence[TextSetting]:
611: (8)                    settings = []
612: (8)                    t2xwords = set(chain(*([*t2x.keys()] for t2x, _ in t2xs)))
613: (8)                    for word in t2xwords:
614: (12)                       setting_args = {
615: (16)                           arg: str(t2x[word]) if word in t2x else default_args[arg]
616: (16)                           # NOTE: when t2x[word] is a ManimColor, str will yield the
617: (16)                           # hex representation
618: (16)                           for t2x, arg in t2xs
619: (12)                       }
620: (12)                       for start, end in self._find_indexes(word, self.text):
621: (16)                           settings.append(TextSetting(start, end, **setting_args))
622: (8)                    return settings
623: (4)                def _get_settings_from_gradient(
624: (8)                    self, default_args: dict[str, Iterable[str]]
625: (4)                ) -> Sequence[TextSetting]:
626: (8)                    settings = []
627: (8)                    args = copy.copy(default_args)
628: (8)                    if self.gradient:
629: (12)                       colors = color_gradient(self.gradient, len(self.text))
630: (12)                       for i in range(len(self.text)):
631: (16)                           args["color"] = colors[i].to_hex()
632: (16)                           settings.append(TextSetting(i, i + 1, **args))
633: (8)                    for word, gradient in self.t2g.items():
634: (12)                       if isinstance(gradient, str) or len(gradient) == 1:
635: (16)                           color = gradient if isinstance(gradient, str) else gradient[0]
636: (16)                           gradient = [ManimColor(color)]
637: (12)                       colors = (
638: (16)                           color_gradient(gradient, len(word))
639: (16)                           if len(gradient) != 1
640: (16)                           else len(word) * gradient
641: (12)                       )
642: (12)                       for start, end in self._find_indexes(word, self.text):
643: (16)                           for i in range(start, end):
644: (20)                               args["color"] = colors[i - start].to_hex()
645: (20)                               settings.append(TextSetting(i, i + 1, **args))
646: (8)                    return settings
647: (4)                def _text2settings(self, color: str):
648: (8)                    """Converts the texts and styles to a setting for parsing."""
649: (8)                    t2xs = [
650: (12)                       (self.t2f, "font"),
651: (12)                       (self.t2s, "slant"),
652: (12)                       (self.t2w, "weight"),
653: (12)                       (self.t2c, "color"),
654: (8)                    ]
655: (8)                    # setting_args requires values to be strings
656: (8)                    default_args = {
657: (12)                       arg: getattr(self, arg) if arg != "color" else color for _, arg in t2xs
658: (8)                    }
659: (8)                    settings = self._get_settings_from_t2xs(t2xs, default_args)
660: (8)                    settings.extend(self._get_settings_from_gradient(default_args))
661: (8)                    # Handle overlaps
662: (8)                    settings.sort(key=lambda setting: setting.start)
663: (8)                    for index, setting in enumerate(settings):
664: (12)                       if index + 1 == len(settings):
665: (16)                           break
666: (12)                       next_setting = settings[index + 1]
667: (12)                       if setting.end > next_setting.start:
668: (16)                           new_setting = self._merge_settings(setting, next_setting, default_args)
669: (16)                           new_index = index + 1
670: (16)                           while (
671: (20)                               new_index < len(settings)
672: (20)                               and settings[new_index].start < new_setting.start
673: (16)                           ):
674: (20)                               new_index += 1
675: (16)                           settings.insert(new_index, new_setting)
676: (8)                    # Set all text settings (default font, slant, weight)
677: (8)                    temp_settings = settings.copy()
678: (8)                    start = 0
679: (8)                    for setting in settings:
680: (12)                       if setting.start != start:
681: (16)                           temp_settings.append(TextSetting(start, setting.start, **default_args))
682: (12)                       start = setting.end
683: (8)                    if start != len(self.text):
684: (12)                       temp_settings.append(TextSetting(start, len(self.text), **default_args))
685: (8)                    settings = sorted(temp_settings, key=lambda setting: setting.start)
686: (8)                    line_num = 0
687: (8)                    if re.search(r"\n", self.text):
688: (12)                       for start, end in self._find_indexes("\n", self.text):
689: (16)                           for setting in settings:
690: (20)                               if setting.line_num == -1:
691: (24)                                   setting.line_num = line_num
692: (20)                               if start < setting.end:
693: (24)                                   line_num += 1
694: (24)                                   new_setting = copy.copy(setting)
695: (24)                                   setting.end = end
696: (24)                                   new_setting.start = end
697: (24)                                   new_setting.line_num = line_num
698: (24)                                   settings.append(new_setting)
699: (24)                                   settings.sort(key=lambda setting: setting.start)
700: (24)                                   break
701: (8)                    for setting in settings:
702: (12)                       if setting.line_num == -1:
703: (16)                           setting.line_num = line_num
704: (8)                    return settings
705: (4)                def _text2svg(self, color: ManimColor):
706: (8)                    """Convert the text to SVG using Pango."""
707: (8)                    size = self._font_size
708: (8)                    line_spacing = self.line_spacing
709: (8)                    size /= TEXT2SVG_ADJUSTMENT_FACTOR
710: (8)                    line_spacing /= TEXT2SVG_ADJUSTMENT_FACTOR
711: (8)                    dir_name = config.get_dir("text_dir")
712: (8)                    if not dir_name.is_dir():
713: (12)                       dir_name.mkdir(parents=True)
714: (8)                    hash_name = self._text2hash(color)
715: (8)                    file_name = dir_name / (hash_name + ".svg")
716: (8)                    if file_name.exists():
717: (12)                       svg_file = str(file_name.resolve())
718: (8)                    else:
719: (12)                       settings = self._text2settings(color)
720: (12)                       width = config["pixel_width"]
721: (12)                       height = config["pixel_height"]
722: (12)                       svg_file = manimpango.text2svg(
723: (16)                           settings,
724: (16)                           size,
725: (16)                           line_spacing,
726: (16)                           self.disable_ligatures,
727: (16)                           str(file_name.resolve()),
728: (16)                           START_X,
729: (16)                           START_Y,
730: (16)                           width,
731: (16)                           height,
732: (16)                           self.text,
733: (12)                       )
734: (8)                    return svg_file
735: (4)                def init_colors(self, propagate_colors=True):
736: (8)                    if config.renderer == RendererType.OPENGL:
737: (12)                       super().init_colors()
738: (8)                    elif config.renderer == RendererType.CAIRO:
739: (12)                       super().init_colors(propagate_colors=propagate_colors)
740: (0)            class MarkupText(SVGMobject):
741: (4)                r"""Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.
742: (4)                Text objects behave like a :class:`.VGroup`-like iterable of all characters
743: (4)                in the given text. In particular, slicing is possible.
744: (4)                **What is PangoMarkup?**
745: (4)                PangoMarkup is a small markup language like html and it helps you avoid using
746: (4)                "range of characters" while coloring or styling a piece a Text. You can use
747: (4)                this language with :class:`~.MarkupText`.
748: (4)                A simple example of a marked-up string might be::
749: (8)                    <span foreground="blue" size="x-large">Blue text</span> is <i>cool</i>!"
750: (4)                and it can be used with :class:`~.MarkupText` as
751: (4)                .. manim:: MarkupExample
752: (8)                    :save_last_frame:
753: (8)                    class MarkupExample(Scene):
754: (12)                       def construct(self):
755: (16)                           text = MarkupText('<span foreground="blue" size="x-large">Blue text</span> is <i>cool</i>!"')
756: (16)                           self.add(text)
757: (4)                A more elaborate example would be:
758: (4)                .. manim:: MarkupElaborateExample
759: (8)                    :save_last_frame:
760: (8)                    class MarkupElaborateExample(Scene):
761: (12)                       def construct(self):
762: (16)                           text = MarkupText(
763: (20)                               '<span foreground="purple">ا</span><span foreground="red">َ</span>'
764: (20)                               'ل<span foreground="blue">ْ</span>ع<span foreground="red">َ</span>ر'
765: (20)                               '<span foreground="red">َ</span>ب<span foreground="red">ِ</span>ي'
766: (20)                               '<span foreground="green">ّ</span><span foreground="red">َ</span>ة'
767: (20)                               '<span foreground="blue">ُ</span>'
768: (16)                           )
769: (16)                           self.add(text)
770: (4)                PangoMarkup can also contain XML features such as numeric character
771: (4)                entities such as ``&#169;`` for © can be used too.
772: (4)                The most general markup tag is ``<span>``, then there are some
773: (4)                convenience tags.
774: (4)                Here is a list of supported tags:
775: (4)                - ``<b>bold</b>``, ``<i>italic</i>`` and ``<b><i>bold+italic</i></b>``
776: (4)                - ``<ul>underline</ul>`` and ``<s>strike through</s>``
777: (4)                - ``<tt>typewriter font</tt>``
778: (4)                - ``<big>bigger font</big>`` and ``<small>smaller font</small>``
779: (4)                - ``<sup>superscript</sup>`` and ``<sub>subscript</sub>``
780: (4)                - ``<span underline="double" underline_color="green">double underline</span>``
781: (4)                - ``<span underline="error">error underline</span>``
782: (4)                - ``<span overline="single" overline_color="green">overline</span>``
783: (4)                - ``<span strikethrough="true" strikethrough_color="red">strikethrough</span>``
784: (4)                - ``<span font_family="sans">temporary change of font</span>``
785: (4)                - ``<span foreground="red">temporary change of color</span>``
786: (4)                - ``<span fgcolor="red">temporary change of color</span>``
787: (4)                - ``<gradient from="YELLOW" to="RED">temporary gradient</gradient>``
788: (4)                For ``<span>`` markup, colors can be specified either as
789: (4)                hex triples like ``#aabbcc`` or as named CSS colors like
790: (4)                ``AliceBlue``.
791: (4)                The ``<gradient>`` tag is handled by Manim rather than
792: (4)                Pango, and supports hex triplets or Manim constants like
793: (4)                ``RED`` or ``RED_A``.
794: (4)                If you want to use Manim constants like ``RED_A`` together
795: (4)                with ``<span>``, you will need to use Python's f-String
796: (4)                syntax as follows::
797: (8)                    MarkupText(f'<span foreground="{RED_A}">here you go</span>')
798: (4)                If your text contains ligatures, the :class:`MarkupText` class may
799: (4)                incorrectly determine the first and last letter when creating the
800: (4)                gradient. This is due to the fact that ``fl`` are two separate characters,
801: (4)                but might be set as one single glyph - a ligature. If your language
802: (4)                does not depend on ligatures, consider setting ``disable_ligatures``
803: (4)                to ``True``. If you must use ligatures, the ``gradient`` tag supports an optional
804: (4)                attribute ``offset`` which can be used to compensate for that error.
805: (4)                For example:
806: (4)                - ``<gradient from="RED" to="YELLOW" offset="1">example</gradient>`` to *start* the gradient one letter earlier
807: (4)                - ``<gradient from="RED" to="YELLOW" offset=",1">example</gradient>`` to *end* the gradient one letter earlier
808: (4)                - ``<gradient from="RED" to="YELLOW" offset="2,1">example</gradient>`` to *start* the gradient two letters earlier and *end* it one letter earlier
809: (4)                Specifying a second offset may be necessary if the text to be colored does
810: (4)                itself contain ligatures. The same can happen when using HTML entities for
811: (4)                special chars.
812: (4)                When using ``underline``, ``overline`` or ``strikethrough`` together with
813: (4)                ``<gradient>`` tags, you will also need to use the offset, because
814: (4)                underlines are additional paths in the final :class:`SVGMobject`.
815: (4)                Check out the following example.
816: (4)                Escaping of special characters: ``>`` **should** be written as ``&gt;``
817: (4)                whereas ``<`` and ``&`` *must* be written as ``&lt;`` and
818: (4)                ``&amp;``.
819: (4)                You can find more information about Pango markup formatting at the
820: (4)                corresponding documentation page:
821: (4)                `Pango Markup <https://docs.gtk.org/Pango/pango_markup.html>`_.
822: (4)                Please be aware that not all features are supported by this class and that
823: (4)                the ``<gradient>`` tag mentioned above is not supported by Pango.
824: (4)                Parameters
825: (4)                ----------
826: (4)                text
827: (8)                    The text that needs to be created as mobject.
828: (4)                fill_opacity
829: (8)                    The fill opacity, with 1 meaning opaque and 0 meaning transparent.
830: (4)                stroke_width
831: (8)                    Stroke width.
832: (4)                font_size
833: (8)                    Font size.
834: (4)                line_spacing
835: (8)                    Line spacing.
836: (4)                font
837: (8)                    Global font setting for the entire text. Local overrides are possible.
838: (4)                slant
839: (8)                    Global slant setting, e.g. `NORMAL` or `ITALIC`. Local overrides are possible.
840: (4)                weight
841: (8)                    Global weight setting, e.g. `NORMAL` or `BOLD`. Local overrides are possible.
842: (4)                gradient
843: (8)                    Global gradient setting. Local overrides are possible.
844: (4)                warn_missing_font
845: (8)                    If True (default), Manim will issue a warning if the font does not exist in the
846: (8)                    (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.
847: (4)                Returns
848: (4)                -------
849: (4)                :class:`MarkupText`
850: (8)                    The text displayed in form of a :class:`.VGroup`-like mobject.
851: (4)                Examples
852: (4)                ---------
853: (4)                .. manim:: BasicMarkupExample
854: (8)                    :save_last_frame:
855: (8)                    class BasicMarkupExample(Scene):
856: (12)                       def construct(self):
857: (16)                           text1 = MarkupText("<b>foo</b> <i>bar</i> <b><i>foobar</i></b>")
858: (16)                           text2 = MarkupText("<s>foo</s> <u>bar</u> <big>big</big> <small>small</small>")
859: (16)                           text3 = MarkupText("H<sub>2</sub>O and H<sub>3</sub>O<sup>+</sup>")
860: (16)                           text4 = MarkupText("type <tt>help</tt> for help")
861: (16)                           text5 = MarkupText(
862: (20)                               '<span underline="double">foo</span> <span underline="error">bar</span>'
863: (16)                           )
864: (16)                           group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
865: (16)                           self.add(group)
866: (4)                .. manim:: ColorExample
867: (8)                    :save_last_frame:
868: (8)                    class ColorExample(Scene):
869: (12)                       def construct(self):
870: (16)                           text1 = MarkupText(
871: (20)                               f'all in red <span fgcolor="{YELLOW}">except this</span>', color=RED
872: (16)                           )
873: (16)                           text2 = MarkupText("nice gradient", gradient=(BLUE, GREEN))
874: (16)                           text3 = MarkupText(
875: (20)                               'nice <gradient from="RED" to="YELLOW">intermediate</gradient> gradient',
876: (20)                               gradient=(BLUE, GREEN),
877: (16)                           )
878: (16)                           text4 = MarkupText(
879: (20)                               'fl ligature <gradient from="RED" to="YELLOW">causing trouble</gradient> here'
880: (16)                           )
881: (16)                           text5 = MarkupText(
882: (20)                               'fl ligature <gradient from="RED" to="YELLOW" offset="1">defeated</gradient> with offset'
883: (16)                           )
884: (16)                           text6 = MarkupText(
885: (20)                               'fl ligature <gradient from="RED" to="YELLOW" offset="1">floating</gradient> inside'
886: (16)                           )
887: (16)                           text7 = MarkupText(
888: (20)                               'fl ligature <gradient from="RED" to="YELLOW" offset="1,1">floating</gradient> inside'
889: (16)                           )
890: (16)                           group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)
891: (16)                           self.add(group)
892: (4)                .. manim:: UnderlineExample
893: (8)                    :save_last_frame:
894: (8)                    class UnderlineExample(Scene):
895: (12)                       def construct(self):
896: (16)                           text1 = MarkupText(
897: (20)                               '<span underline="double" underline_color="green">bla</span>'
898: (16)                           )
899: (16)                           text2 = MarkupText(
900: (20)                               '<span underline="single" underline_color="green">xxx</span><gradient from="#ffff00" to="RED">aabb</gradient>y'
901: (16)                           )
902: (16)                           text3 = MarkupText(
903: (20)                               '<span underline="single" underline_color="green">xxx</span><gradient from="#ffff00" to="RED" offset="-1">aabb</gradient>y'
904: (16)                           )
905: (16)                           text4 = MarkupText(
906: (20)                               '<span underline="double" underline_color="green">xxx</span><gradient from="#ffff00" to="RED">aabb</gradient>y'
907: (16)                           )
908: (16)                           text5 = MarkupText(
909: (20)                               '<span underline="double" underline_color="green">xxx</span><gradient from="#ffff00" to="RED" offset="-2">aabb</gradient>y'
910: (16)                           )
911: (16)                           group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
912: (16)                           self.add(group)
913: (4)                .. manim:: FontExample
914: (8)                    :save_last_frame:
915: (8)                    class FontExample(Scene):
916: (12)                       def construct(self):
917: (16)                           text1 = MarkupText(
918: (20)                               'all in sans <span font_family="serif">except this</span>', font="sans"
919: (16)                           )
920: (16)                           text2 = MarkupText(
921: (20)                               '<span font_family="serif">mixing</span> <span font_family="sans">fonts</span> <span font_family="monospace">is ugly</span>'
922: (16)                           )
923: (16)                           text3 = MarkupText("special char > or &gt;")
924: (16)                           text4 = MarkupText("special char &lt; and &amp;")
925: (16)                           group = VGroup(text1, text2, text3, text4).arrange(DOWN)
926: (16)                           self.add(group)
927: (4)                .. manim:: NewlineExample
928: (8)                    :save_last_frame:
929: (8)                    class NewlineExample(Scene):
930: (12)                       def construct(self):
931: (16)                           text = MarkupText('foooo<span foreground="red">oo\nbaa</span>aar')
932: (16)                           self.add(text)
933: (4)                .. manim:: NoLigaturesExample
934: (8)                    :save_last_frame:
935: (8)                    class NoLigaturesExample(Scene):
936: (12)                       def construct(self):
937: (16)                           text1 = MarkupText('fl<gradient from="RED" to="GREEN">oat</gradient>ing')
938: (16)                           text2 = MarkupText('fl<gradient from="RED" to="GREEN">oat</gradient>ing', disable_ligatures=True)
939: (16)                           group = VGroup(text1, text2).arrange(DOWN)
940: (16)                           self.add(group)
941: (4)                As :class:`MarkupText` uses Pango to render text, rendering non-English
942: (4)                characters is easily possible:
943: (4)                .. manim:: MultiLanguage
944: (8)                    :save_last_frame:
945: (8)                    class MultiLanguage(Scene):
946: (12)                       def construct(self):
947: (16)                           morning = MarkupText("வணக்கம்", font="sans-serif")
948: (16)                           japanese = MarkupText(
949: (20)                               '<span fgcolor="blue">日本</span>へようこそ'
950: (16)                           )  # works as in ``Text``.
951: (16)                           mess = MarkupText("Multi-Language", weight=BOLD)
952: (16)                           russ = MarkupText("Здравствуйте मस नम म ", font="sans-serif")
953: (16)                           hin = MarkupText("नमस्ते", font="sans-serif")
954: (16)                           chinese = MarkupText("臂猿「黛比」帶著孩子", font="sans-serif")
955: (16)                           group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)
956: (16)                           self.add(group)
957: (4)                You can justify the text by passing :attr:`justify` parameter.
958: (4)                .. manim:: JustifyText
959: (8)                    class JustifyText(Scene):
960: (12)                       def construct(self):
961: (16)                           ipsum_text = (
962: (20)                               "Lorem ipsum dolor sit amet, consectetur adipiscing elit."
963: (20)                               "Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere "
964: (20)                               "quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam "
965: (20)                               "fermentum interdum justo, nec rutrum elit pretium ac. Nam quis "
966: (20)                               "leo pulvinar, dignissim est at, venenatis nisi."
967: (16)                           )
968: (16)                           justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)
969: (16)                           not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)
970: (16)                           just_title = Title("Justified")
971: (16)                           njust_title = Title("Not Justified")
972: (16)                           self.add(njust_title, not_justified_text)
973: (16)                           self.play(
974: (20)                               FadeOut(not_justified_text),
975: (20)                               FadeIn(justified_text),
976: (20)                               FadeOut(njust_title),
977: (20)                               FadeIn(just_title),
978: (16)                           )
979: (16)                           self.wait(1)
980: (4)                Tests
981: (4)                -----
982: (4)                Check that the creation of :class:`~.MarkupText` works::
983: (8)                    >>> MarkupText('The horse does not eat cucumber salad.')
984: (8)                    MarkupText('The horse does not eat cucumber salad.')
985: (4)                """
986: (4)                @staticmethod
987: (4)                @functools.lru_cache(maxsize=None)
988: (4)                def font_list() -> list[str]:
989: (8)                    return manimpango.list_fonts()
990: (4)                def __init__(
991: (8)                    self,
992: (8)                    text: str,
993: (8)                    fill_opacity: float = 1,
994: (8)                    stroke_width: float = 0,
995: (8)                    color: ParsableManimColor | None = None,
996: (8)                    font_size: float = DEFAULT_FONT_SIZE,
997: (8)                    line_spacing: int = -1,
998: (8)                    font: str = "",
999: (8)                    slant: str = NORMAL,
1000: (8)                   weight: str = NORMAL,
1001: (8)                   justify: bool = False,
1002: (8)                   gradient: tuple = None,
1003: (8)                   tab_width: int = 4,
1004: (8)                   height: int = None,
1005: (8)                   width: int = None,
1006: (8)                   should_center: bool = True,
1007: (8)                   disable_ligatures: bool = False,
1008: (8)                   warn_missing_font: bool = True,
1009: (8)                   **kwargs,
1010: (4)               ) -> None:
1011: (8)                   self.text = text
1012: (8)                   self.line_spacing = line_spacing
1013: (8)                   if font and warn_missing_font:
1014: (12)                      fonts_list = Text.font_list()
1015: (12)                      # handle special case of sans/sans-serif
1016: (12)                      if font.lower() == "sans-serif":
1017: (16)                          font = "sans"
1018: (12)                      if font not in fonts_list:
1019: (16)                          # check if the capitalized version is in the supported fonts
1020: (16)                          if font.capitalize() in fonts_list:
1021: (20)                              font = font.capitalize()
1022: (16)                          elif font.lower() in fonts_list:
1023: (20)                              font = font.lower()
1024: (16)                          elif font.title() in fonts_list:
1025: (20)                              font = font.title()
1026: (16)                          else:
1027: (20)                              logger.warning(f"Font {font} not in {fonts_list}.")
1028: (8)                   self.font = font
1029: (8)                   self._font_size = float(font_size)
1030: (8)                   self.slant = slant
1031: (8)                   self.weight = weight
1032: (8)                   self.gradient = gradient
1033: (8)                   self.tab_width = tab_width
1034: (8)                   self.justify = justify
1035: (8)                   self.original_text = text
1036: (8)                   self.disable_ligatures = disable_ligatures
1037: (8)                   text_without_tabs = text
1038: (8)                   if "\t" in text:
1039: (12)                      text_without_tabs = text.replace("\t", " " * self.tab_width)
1040: (8)                   colormap = self._extract_color_tags()
1041: (8)                   if len(colormap) > 0:
1042: (12)                      logger.warning(
1043: (16)                          'Using <color> tags in MarkupText is deprecated. Please use <span foreground="..."> instead.',
1044: (12)                      )
1045: (8)                   gradientmap = self._extract_gradient_tags()
1046: (8)                   validate_error = MarkupUtils.validate(self.text)
1047: (8)                   if validate_error:
1048: (12)                      raise ValueError(validate_error)
1049: (8)                   if self.line_spacing == -1:
1050: (12)                      self.line_spacing = (
1051: (16)                          self._font_size + self._font_size * DEFAULT_LINE_SPACING_SCALE
1052: (12)                      )
1053: (8)                   else:
1054: (12)                      self.line_spacing = self._font_size + self._font_size * self.line_spacing
1055: (8)                   color: ManimColor = ManimColor(color) if color else VMobject().color
1056: (8)                   file_name = self._text2svg(color)
1057: (8)                   PangoUtils.remove_last_M(file_name)
1058: (8)                   super().__init__(
1059: (12)                      file_name,
1060: (12)                      fill_opacity=fill_opacity,
1061: (12)                      stroke_width=stroke_width,
1062: (12)                      height=height,
1063: (12)                      width=width,
1064: (12)                      should_center=should_center,
1065: (12)                      **kwargs,
1066: (8)                   )
1067: (8)                   self.chars = self.get_group_class()(*self.submobjects)
1068: (8)                   self.text = text_without_tabs.replace(" ", "").replace("\n", "")
1069: (8)                   nppc = self.n_points_per_curve
1070: (8)                   for each in self:
1071: (12)                      if len(each.points) == 0:
1072: (16)                          continue
1073: (12)                      points = each.points
1074: (12)                      curve_start = points[0]
1075: (12)                      assert len(curve_start) == self.dim, curve_start
1076: (12)                      # Some of the glyphs in this text might not be closed,
1077: (12)                      # so we close them by identifying when one curve ends
1078: (12)                      # but it is not where the next curve starts.
1079: (12)                      # It is more efficient to temporarily create a list
1080: (12)                      # of points and add them one at a time, then turn them
1081: (12)                      # into a numpy array at the end, rather than creating
1082: (12)                      # new numpy arrays every time a point or fixing line
1083: (12)                      # is added (which is O(n^2) for numpy arrays).
1084: (12)                      closed_curve_points = []
1085: (12)                      # OpenGL has points be part of quadratic Bezier curves;
1086: (12)                      # Cairo uses cubic Bezier curves.
1087: (12)                      if nppc == 3:  # RendererType.OPENGL
1088: (16)                          def add_line_to(end):
1089: (20)                              nonlocal closed_curve_points
1090: (20)                              start = closed_curve_points[-1]
1091: (20)                              closed_curve_points += [
1092: (24)                                  start,
1093: (24)                                  (start + end) / 2,
1094: (24)                                  end,
1095: (20)                              ]
1096: (12)                      else:  # RendererType.CAIRO
1097: (16)                          def add_line_to(end):
1098: (20)                              nonlocal closed_curve_points
1099: (20)                              start = closed_curve_points[-1]
1100: (20)                              closed_curve_points += [
1101: (24)                                  start,
1102: (24)                                  (start + start + end) / 3,
1103: (24)                                  (start + end + end) / 3,
1104: (24)                                  end,
1105: (20)                              ]
1106: (12)                      for index, point in enumerate(points):
1107: (16)                          closed_curve_points.append(point)
1108: (16)                          if (
1109: (20)                              index != len(points) - 1
1110: (20)                              and (index + 1) % nppc == 0
1111: (20)                              and any(point != points[index + 1])
1112: (16)                          ):
1113: (20)                              # Add straight line from last point on this curve to the
1114: (20)                              # start point on the next curve.
1115: (20)                              add_line_to(curve_start)
1116: (20)                              curve_start = points[index + 1]
1117: (12)                      # Make sure last curve is closed
1118: (12)                      add_line_to(curve_start)
1119: (12)                      each.points = np.array(closed_curve_points, ndmin=2)
1120: (8)                   if self.gradient:
1121: (12)                      self.set_color_by_gradient(*self.gradient)
1122: (8)                   for col in colormap:
1123: (12)                      self.chars[
1124: (16)                          col["start"]
1125: (16)                          - col["start_offset"] : col["end"]
1126: (16)                          - col["start_offset"]
1127: (16)                          - col["end_offset"]
1128: (12)                      ].set_color(self._parse_color(col["color"]))
1129: (8)                   for grad in gradientmap:
1130: (12)                      self.chars[
1131: (16)                          grad["start"]
1132: (16)                          - grad["start_offset"] : grad["end"]
1133: (16)                          - grad["start_offset"]
1134: (16)                          - grad["end_offset"]
1135: (12)                      ].set_color_by_gradient(
1136: (16)                          *(self._parse_color(grad["from"]), self._parse_color(grad["to"]))
1137: (12)                      )
1138: (8)                   # anti-aliasing
1139: (8)                   if height is None and width is None:
1140: (12)                      self.scale(TEXT_MOB_SCALE_FACTOR)
1141: (8)                   self.initial_height = self.height
1142: (4)               @property
1143: (4)               def font_size(self):
1144: (8)                   return (
1145: (12)                      self.height
1146: (12)                      / self.initial_height
1147: (12)                      / TEXT_MOB_SCALE_FACTOR
1148: (12)                      * 2.4
1149: (12)                      * self._font_size
1150: (12)                      / DEFAULT_FONT_SIZE
1151: (8)                   )
1152: (4)               @font_size.setter
1153: (4)               def font_size(self, font_val):
1154: (8)                   # TODO: use pango's font size scaling.
1155: (8)                   if font_val <= 0:
1156: (12)                      raise ValueError("font_size must be greater than 0.")
1157: (8)                   else:
1158: (12)                      self.scale(font_val / self.font_size)
1159: (4)               def _text2hash(self, color: ParsableManimColor):
1160: (8)                   """Generates ``sha256`` hash for file name."""
1161: (8)                   settings = (
1162: (12)                      "MARKUPPANGO"
1163: (12)                      + self.font
1164: (12)                      + self.slant
1165: (12)                      + self.weight
1166: (12)                      + ManimColor(color).to_hex().lower()
1167: (8)                   )  # to differentiate from classical Pango Text
1168: (8)                   settings += str(self.line_spacing) + str(self._font_size)
1169: (8)                   settings += str(self.disable_ligatures)
1170: (8)                   settings += str(self.justify)
1171: (8)                   id_str = self.text + settings
1172: (8)                   hasher = hashlib.sha256()
1173: (8)                   hasher.update(id_str.encode())
1174: (8)                   return hasher.hexdigest()[:16]
1175: (4)               def _text2svg(self, color: ParsableManimColor | None):
1176: (8)                   """Convert the text to SVG using Pango."""
1177: (8)                   color = ManimColor(color)
1178: (8)                   size = self._font_size
1179: (8)                   line_spacing = self.line_spacing
1180: (8)                   size /= TEXT2SVG_ADJUSTMENT_FACTOR
1181: (8)                   line_spacing /= TEXT2SVG_ADJUSTMENT_FACTOR
1182: (8)                   dir_name = config.get_dir("text_dir")
1183: (8)                   if not dir_name.is_dir():
1184: (12)                      dir_name.mkdir(parents=True)
1185: (8)                   hash_name = self._text2hash(color)
1186: (8)                   file_name = dir_name / (hash_name + ".svg")
1187: (8)                   if file_name.exists():
1188: (12)                      svg_file = str(file_name.resolve())
1189: (8)                   else:
1190: (12)                      final_text = (
1191: (16)                          f'<span foreground="{color.to_hex()}">{self.text}</span>'
1192: (16)                          if color is not None
1193: (16)                          else self.text
1194: (12)                      )
1195: (12)                      logger.debug(f"Setting Text {self.text}")
1196: (12)                      svg_file = MarkupUtils.text2svg(
1197: (16)                          final_text,
1198: (16)                          self.font,
1199: (16)                          self.slant,
1200: (16)                          self.weight,
1201: (16)                          size,
1202: (16)                          line_spacing,
1203: (16)                          self.disable_ligatures,
1204: (16)                          str(file_name.resolve()),
1205: (16)                          START_X,
1206: (16)                          START_Y,
1207: (16)                          600,  # width
1208: (16)                          400,  # height
1209: (16)                          justify=self.justify,
1210: (16)                          pango_width=500,
1211: (12)                      )
1212: (8)                   return svg_file
1213: (4)               def _count_real_chars(self, s):
1214: (8)                   """Counts characters that will be displayed.
1215: (8)                   This is needed for partial coloring or gradients, because space
1216: (8)                   counts to the text's `len`, but has no corresponding character."""
1217: (8)                   count = 0
1218: (8)                   level = 0
1219: (8)                   # temporarily replace HTML entities by single char
1220: (8)                   s = re.sub("&[^;]+;", "x", s)
1221: (8)                   for c in s:
1222: (12)                      if c == "<":
1223: (16)                          level += 1
1224: (12)                      if c == ">" and level > 0:
1225: (16)                          level -= 1
1226: (12)                      elif c != " " and c != "\t" and level == 0:
1227: (16)                          count += 1
1228: (8)                   return count
1229: (4)               def _extract_gradient_tags(self):
1230: (8)                   """Used to determine which parts (if any) of the string should be formatted
1231: (8)                   with a gradient.
1232: (8)                   Removes the ``<gradient>`` tag, as it is not part of Pango's markup and would cause an error.
1233: (8)                   """
1234: (8)                   tags = re.finditer(
1235: (12)                      r'<gradient\s+from="([^"]+)"\s+to="([^"]+)"(\s+offset="([^"]+)")?>(.+?)</gradient>',
1236: (12)                      self.original_text,
1237: (12)                      re.S,
1238: (8)                   )
1239: (8)                   gradientmap = []
1240: (8)                   for tag in tags:
1241: (12)                      start = self._count_real_chars(self.original_text[: tag.start(0)])
1242: (12)                      end = start + self._count_real_chars(tag.group(5))
1243: (12)                      offsets = tag.group(4).split(",") if tag.group(4) else [0]
1244: (12)                      start_offset = int(offsets[0]) if offsets[0] else 0
1245: (12)                      end_offset = int(offsets[1]) if len(offsets) == 2 and offsets[1] else 0
1246: (12)                      gradientmap.append(
1247: (16)                          {
1248: (20)                              "start": start,
1249: (20)                              "end": end,
1250: (20)                              "from": tag.group(1),
1251: (20)                              "to": tag.group(2),
1252: (20)                              "start_offset": start_offset,
1253: (20)                              "end_offset": end_offset,
1254: (16)                          },
1255: (12)                      )
1256: (8)                   self.text = re.sub("<gradient[^>]+>(.+?)</gradient>", r"\1", self.text, 0, re.S)
1257: (8)                   return gradientmap
1258: (4)               def _parse_color(self, col):
1259: (8)                   """Parse color given in ``<color>`` or ``<gradient>`` tags."""
1260: (8)                   if re.match("#[0-9a-f]{6}", col):
1261: (12)                      return col
1262: (8)                   else:
1263: (12)                      return ManimColor(col).to_hex()
1264: (4)               def _extract_color_tags(self):
1265: (8)                   """Used to determine which parts (if any) of the string should be formatted
1266: (8)                   with a custom color.
1267: (8)                   Removes the ``<color>`` tag, as it is not part of Pango's markup and would cause an error.
1268: (8)                   Note: Using the ``<color>`` tags is deprecated. As soon as the legacy syntax is gone, this function
1269: (8)                   will be removed.
1270: (8)                   """
1271: (8)                   tags = re.finditer(
1272: (12)                      r'<color\s+col="([^"]+)"(\s+offset="([^"]+)")?>(.+?)</color>',
1273: (12)                      self.original_text,
1274: (12)                      re.S,
1275: (8)                   )
1276: (8)                   colormap = []
1277: (8)                   for tag in tags:
1278: (12)                      start = self._count_real_chars(self.original_text[: tag.start(0)])
1279: (12)                      end = start + self._count_real_chars(tag.group(4))
1280: (12)                      offsets = tag.group(3).split(",") if tag.group(3) else [0]
1281: (12)                      start_offset = int(offsets[0]) if offsets[0] else 0
1282: (12)                      end_offset = int(offsets[1]) if len(offsets) == 2 and offsets[1] else 0
1283: (12)                      colormap.append(
1284: (16)                          {
1285: (20)                              "start": start,
1286: (20)                              "end": end,
1287: (20)                              "color": tag.group(1),
1288: (20)                              "start_offset": start_offset,
1289: (20)                              "end_offset": end_offset,
1290: (16)                          },
1291: (12)                      )
1292: (8)                   self.text = re.sub("<color[^>]+>(.+?)</color>", r"\1", self.text, 0, re.S)
1293: (8)                   return colormap
1294: (4)               def __repr__(self):
1295: (8)                   return f"MarkupText({repr(self.original_text)})"
1296: (0)           @contextmanager
1297: (0)           def register_font(font_file: str | Path):
1298: (4)               """Temporarily add a font file to Pango's search path.
1299: (4)               This searches for the font_file at various places. The order it searches it described below.
1300: (4)               1. Absolute path.
1301: (4)               2. In ``assets/fonts`` folder.
1302: (4)               3. In ``font/`` folder.
1303: (4)               4. In the same directory.
1304: (4)               Parameters
1305: (4)               ----------
1306: (4)               font_file
1307: (8)                   The font file to add.
1308: (4)               Examples
1309: (4)               --------
1310: (4)               Use ``with register_font(...)`` to add a font file to search
1311: (4)               path.
1312: (4)               .. code-block:: python
1313: (8)                   with register_font("path/to/font_file.ttf"):
1314: (12)                      a = Text("Hello", font="Custom Font Name")
1315: (4)               Raises
1316: (4)               ------
1317: (4)               FileNotFoundError:
1318: (8)                   If the font doesn't exists.
1319: (4)               AttributeError:
1320: (8)                   If this method is used on macOS.
1321: (4)               .. important ::
1322: (8)                   This method is available for macOS for ``ManimPango>=v0.2.3``. Using this
1323: (8)                   method with previous releases will raise an :class:`AttributeError` on macOS.
1324: (4)               """
1325: (4)               input_folder = Path(config.input_file).parent.resolve()
1326: (4)               possible_paths = [
1327: (8)                   Path(font_file),
1328: (8)                   input_folder / "assets/fonts" / font_file,
1329: (8)                   input_folder / "fonts" / font_file,
1330: (8)                   input_folder / font_file,
1331: (4)               ]
1332: (4)               for path in possible_paths:
1333: (8)                   path = path.resolve()
1334: (8)                   if path.exists():
1335: (12)                      file_path = path
1336: (12)                      logger.debug("Found file at %s", file_path.absolute())
1337: (12)                      break
1338: (4)               else:
1339: (8)                   error = f"Can't find {font_file}." f"Tried these : {possible_paths}"
1340: (8)                   raise FileNotFoundError(error)
1341: (4)               try:
1342: (8)                   assert manimpango.register_font(str(file_path))
1343: (8)                   yield
1344: (4)               finally:
1345: (8)                   manimpango.unregister_font(str(file_path))

----------------------------------------

File 36 - .\three_d \three_d_utils.py:

1: (0)              """Utility functions for three-dimensional mobjects."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "get_3d_vmob_gradient_start_and_end_points",
5: (4)                  "get_3d_vmob_start_corner_index",
6: (4)                  "get_3d_vmob_end_corner_index",
7: (4)                  "get_3d_vmob_start_corner",
8: (4)                  "get_3d_vmob_end_corner",
9: (4)                  "get_3d_vmob_unit_normal",
10: (4)                 "get_3d_vmob_start_corner_unit_normal",
11: (4)                 "get_3d_vmob_end_corner_unit_normal",
12: (0)             ]
13: (0)             from typing import TYPE_CHECKING, Literal
14: (0)             import numpy as np
15: (0)             from manim.constants import ORIGIN, UP
16: (0)             from manim.utils.space_ops import get_unit_normal
17: (0)             if TYPE_CHECKING:
18: (4)                 from manim.typing import Point3D, Vector3D
19: (0)             def get_3d_vmob_gradient_start_and_end_points(vmob) -> tuple[Point3D, Point3D]:
20: (4)                 return (
21: (8)                     get_3d_vmob_start_corner(vmob),
22: (8)                     get_3d_vmob_end_corner(vmob),
23: (4)                 )
24: (0)             def get_3d_vmob_start_corner_index(vmob) -> Literal[0]:
25: (4)                 return 0
26: (0)             def get_3d_vmob_end_corner_index(vmob) -> int:
27: (4)                 return ((len(vmob.points) - 1) // 6) * 3
28: (0)             def get_3d_vmob_start_corner(vmob) -> Point3D:
29: (4)                 if vmob.get_num_points() == 0:
30: (8)                     return np.array(ORIGIN)
31: (4)                 return vmob.points[get_3d_vmob_start_corner_index(vmob)]
32: (0)             def get_3d_vmob_end_corner(vmob) -> Point3D:
33: (4)                 if vmob.get_num_points() == 0:
34: (8)                     return np.array(ORIGIN)
35: (4)                 return vmob.points[get_3d_vmob_end_corner_index(vmob)]
36: (0)             def get_3d_vmob_unit_normal(vmob, point_index: int) -> Vector3D:
37: (4)                 n_points = vmob.get_num_points()
38: (4)                 if len(vmob.get_anchors()) <= 2:
39: (8)                     return np.array(UP)
40: (4)                 i = point_index
41: (4)                 im3 = i - 3 if i > 2 else (n_points - 4)
42: (4)                 ip3 = i + 3 if i < (n_points - 3) else 3
43: (4)                 unit_normal = get_unit_normal(
44: (8)                     vmob.points[ip3] - vmob.points[i],
45: (8)                     vmob.points[im3] - vmob.points[i],
46: (4)                 )
47: (4)                 if np.linalg.norm(unit_normal) == 0:
48: (8)                     return np.array(UP)
49: (4)                 return unit_normal
50: (0)             def get_3d_vmob_start_corner_unit_normal(vmob) -> Vector3D:
51: (4)                 return get_3d_vmob_unit_normal(vmob, get_3d_vmob_start_corner_index(vmob))
52: (0)             def get_3d_vmob_end_corner_unit_normal(vmob) -> Vector3D:
53: (4)                 return get_3d_vmob_unit_normal(vmob, get_3d_vmob_end_corner_index(vmob))

----------------------------------------

File 37 - .\types \image_mobject.py:

1: (0)              """Mobjects representing raster images."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["AbstractImageMobject", "ImageMobject", "ImageMobjectFromCamera"]
4: (0)              import pathlib
5: (0)              import numpy as np
6: (0)              from PIL import Image
7: (0)              from PIL.Image import Resampling
8: (0)              from manim.mobject.geometry.shape_matchers import SurroundingRectangle
9: (0)              from ... import config
10: (0)             from ...constants import *
11: (0)             from ...mobject.mobject import Mobject
12: (0)             from ...utils.bezier import interpolate
13: (0)             from ...utils.color import WHITE, ManimColor, color_to_int_rgb
14: (0)             from ...utils.images import change_to_rgba_array, get_full_raster_image_path
15: (0)             __all__ = ["ImageMobject", "ImageMobjectFromCamera"]
16: (0)             class AbstractImageMobject(Mobject):
17: (4)                 """
18: (4)                 Automatically filters out black pixels
19: (4)                 Parameters
20: (4)                 ----------
21: (4)                 scale_to_resolution
22: (8)                     At this resolution the image is placed pixel by pixel onto the screen, so it
23: (8)                     will look the sharpest and best.
24: (8)                     This is a custom parameter of ImageMobject so that rendering a scene with
25: (8)                     e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering
26: (8)                     won't effect the position of the image on the screen.
27: (4)                 """
28: (4)                 def __init__(
29: (8)                     self,
30: (8)                     scale_to_resolution: int,
31: (8)                     pixel_array_dtype="uint8",
32: (8)                     resampling_algorithm=Resampling.BICUBIC,
33: (8)                     **kwargs,
34: (4)                 ):
35: (8)                     self.pixel_array_dtype = pixel_array_dtype
36: (8)                     self.scale_to_resolution = scale_to_resolution
37: (8)                     self.set_resampling_algorithm(resampling_algorithm)
38: (8)                     super().__init__(**kwargs)
39: (4)                 def get_pixel_array(self):
40: (8)                     raise NotImplementedError()
41: (4)                 def set_color(self, color, alpha=None, family=True):
42: (8)                     # Likely to be implemented in subclasses, but no obligation
43: (8)                     pass
44: (4)                 def set_resampling_algorithm(self, resampling_algorithm: int):
45: (8)                     """
46: (8)                     Sets the interpolation method for upscaling the image. By default the image is
47: (8)                     interpolated using bicubic algorithm. This method lets you change it.
48: (8)                     Interpolation is done internally using Pillow, and the function besides the
49: (8)                     string constants describing the algorithm accepts the Pillow integer constants.
50: (8)                     Parameters
51: (8)                     ----------
52: (8)                     resampling_algorithm
53: (12)                        An integer constant described in the Pillow library,
54: (12)                        or one from the RESAMPLING_ALGORITHMS global dictionary,
55: (12)                        under the following keys:
56: (12)                        * 'bicubic' or 'cubic'
57: (12)                        * 'nearest' or 'none'
58: (12)                        * 'box'
59: (12)                        * 'bilinear' or 'linear'
60: (12)                        * 'hamming'
61: (12)                        * 'lanczos' or 'antialias'
62: (8)                     """
63: (8)                     if isinstance(resampling_algorithm, int):
64: (12)                        self.resampling_algorithm = resampling_algorithm
65: (8)                     else:
66: (12)                        raise ValueError(
67: (16)                            "resampling_algorithm has to be an int, one of the values defined in "
68: (16)                            "RESAMPLING_ALGORITHMS or a Pillow resampling filter constant. "
69: (16)                            "Available algorithms: 'bicubic', 'nearest', 'box', 'bilinear', "
70: (16)                            "'hamming', 'lanczos'.",
71: (12)                        )
72: (8)                     return self
73: (4)                 def reset_points(self):
74: (8)                     """Sets :attr:`points` to be the four image corners."""
75: (8)                     self.points = np.array(
76: (12)                        [
77: (16)                            UP + LEFT,
78: (16)                            UP + RIGHT,
79: (16)                            DOWN + LEFT,
80: (16)                            DOWN + RIGHT,
81: (12)                        ],
82: (8)                     )
83: (8)                     self.center()
84: (8)                     h, w = self.get_pixel_array().shape[:2]
85: (8)                     if self.scale_to_resolution:
86: (12)                        height = h / self.scale_to_resolution * config["frame_height"]
87: (8)                     else:
88: (12)                        height = 3  # this is the case for ImageMobjectFromCamera
89: (8)                     self.stretch_to_fit_height(height)
90: (8)                     self.stretch_to_fit_width(height * w / h)
91: (0)             class ImageMobject(AbstractImageMobject):
92: (4)                 """Displays an Image from a numpy array or a file.
93: (4)                 Parameters
94: (4)                 ----------
95: (4)                 scale_to_resolution
96: (8)                     At this resolution the image is placed pixel by pixel onto the screen, so it
97: (8)                     will look the sharpest and best.
98: (8)                     This is a custom parameter of ImageMobject so that rendering a scene with
99: (8)                     e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering
100: (8)                    won't effect the position of the image on the screen.
101: (4)                Example
102: (4)                -------
103: (4)                .. manim:: ImageFromArray
104: (8)                    :save_last_frame:
105: (8)                    class ImageFromArray(Scene):
106: (12)                       def construct(self):
107: (16)                           image = ImageMobject(np.uint8([[0, 100, 30, 200],
108: (47)                                                          [255, 0, 5, 33]]))
109: (16)                           image.height = 7
110: (16)                           self.add(image)
111: (4)                Changing interpolation style:
112: (4)                .. manim:: ImageInterpolationEx
113: (8)                    :save_last_frame:
114: (8)                    class ImageInterpolationEx(Scene):
115: (12)                       def construct(self):
116: (16)                           img = ImageMobject(np.uint8([[63, 0, 0, 0],
117: (48)                                                           [0, 127, 0, 0],
118: (48)                                                           [0, 0, 191, 0],
119: (48)                                                           [0, 0, 0, 255]
120: (48)                                                           ]))
121: (16)                           img.height = 2
122: (16)                           img1 = img.copy()
123: (16)                           img2 = img.copy()
124: (16)                           img3 = img.copy()
125: (16)                           img4 = img.copy()
126: (16)                           img5 = img.copy()
127: (16)                           img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS["nearest"])
128: (16)                           img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS["lanczos"])
129: (16)                           img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS["linear"])
130: (16)                           img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS["cubic"])
131: (16)                           img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS["box"])
132: (16)                           img1.add(Text("nearest").scale(0.5).next_to(img1,UP))
133: (16)                           img2.add(Text("lanczos").scale(0.5).next_to(img2,UP))
134: (16)                           img3.add(Text("linear").scale(0.5).next_to(img3,UP))
135: (16)                           img4.add(Text("cubic").scale(0.5).next_to(img4,UP))
136: (16)                           img5.add(Text("box").scale(0.5).next_to(img5,UP))
137: (16)                           x= Group(img1,img2,img3,img4,img5)
138: (16)                           x.arrange()
139: (16)                           self.add(x)
140: (4)                """
141: (4)                def __init__(
142: (8)                    self,
143: (8)                    filename_or_array,
144: (8)                    scale_to_resolution: int = QUALITIES[DEFAULT_QUALITY]["pixel_height"],
145: (8)                    invert=False,
146: (8)                    image_mode="RGBA",
147: (8)                    **kwargs,
148: (4)                ):
149: (8)                    self.fill_opacity = 1
150: (8)                    self.stroke_opacity = 1
151: (8)                    self.invert = invert
152: (8)                    self.image_mode = image_mode
153: (8)                    if isinstance(filename_or_array, (str, pathlib.PurePath)):
154: (12)                       path = get_full_raster_image_path(filename_or_array)
155: (12)                       image = Image.open(path).convert(self.image_mode)
156: (12)                       self.pixel_array = np.array(image)
157: (12)                       self.path = path
158: (8)                    else:
159: (12)                       self.pixel_array = np.array(filename_or_array)
160: (8)                    self.pixel_array_dtype = kwargs.get("pixel_array_dtype", "uint8")
161: (8)                    self.pixel_array = change_to_rgba_array(
162: (12)                       self.pixel_array, self.pixel_array_dtype
163: (8)                    )
164: (8)                    if self.invert:
165: (12)                       self.pixel_array[:, :, :3] = (
166: (16)                           np.iinfo(self.pixel_array_dtype).max - self.pixel_array[:, :, :3]
167: (12)                       )
168: (8)                    super().__init__(scale_to_resolution, **kwargs)
169: (4)                def get_pixel_array(self):
170: (8)                    """A simple getter method."""
171: (8)                    return self.pixel_array
172: (4)                def set_color(self, color, alpha=None, family=True):
173: (8)                    rgb = color_to_int_rgb(color)
174: (8)                    self.pixel_array[:, :, :3] = rgb
175: (8)                    if alpha is not None:
176: (12)                       self.pixel_array[:, :, 3] = int(255 * alpha)
177: (8)                    for submob in self.submobjects:
178: (12)                       submob.set_color(color, alpha, family)
179: (8)                    self.color = color
180: (8)                    return self
181: (4)                def set_opacity(self, alpha: float):
182: (8)                    """Sets the image's opacity.
183: (8)                    Parameters
184: (8)                    ----------
185: (8)                    alpha
186: (12)                       The alpha value of the object, 1 being opaque and 0 being
187: (12)                       transparent.
188: (8)                    """
189: (8)                    self.pixel_array[:, :, 3] = int(255 * alpha)
190: (8)                    self.fill_opacity = alpha
191: (8)                    self.stroke_opacity = alpha
192: (8)                    return self
193: (4)                def fade(self, darkness: float = 0.5, family: bool = True):
194: (8)                    """Sets the image's opacity using a 1 - alpha relationship.
195: (8)                    Parameters
196: (8)                    ----------
197: (8)                    darkness
198: (12)                       The alpha value of the object, 1 being transparent and 0 being
199: (12)                       opaque.
200: (8)                    family
201: (12)                       Whether the submobjects of the ImageMobject should be affected.
202: (8)                    """
203: (8)                    self.set_opacity(1 - darkness)
204: (8)                    super().fade(darkness, family)
205: (8)                    return self
206: (4)                def interpolate_color(
207: (8)                    self, mobject1: ImageMobject, mobject2: ImageMobject, alpha: float
208: (4)                ):
209: (8)                    """Interpolates the array of pixel color values from one ImageMobject
210: (8)                    into an array of equal size in the target ImageMobject.
211: (8)                    Parameters
212: (8)                    ----------
213: (8)                    mobject1
214: (12)                       The ImageMobject to transform from.
215: (8)                    mobject2
216: (12)                       The ImageMobject to transform into.
217: (8)                    alpha
218: (12)                       Used to track the lerp relationship. Not opacity related.
219: (8)                    """
220: (8)                    assert mobject1.pixel_array.shape == mobject2.pixel_array.shape, (
221: (12)                       f"Mobject pixel array shapes incompatible for interpolation.\n"
222: (12)                       f"Mobject 1 ({mobject1}) : {mobject1.pixel_array.shape}\n"
223: (12)                       f"Mobject 2 ({mobject2}) : {mobject2.pixel_array.shape}"
224: (8)                    )
225: (8)                    self.fill_opacity = interpolate(
226: (12)                       mobject1.fill_opacity,
227: (12)                       mobject2.fill_opacity,
228: (12)                       alpha,
229: (8)                    )
230: (8)                    self.stroke_opacity = interpolate(
231: (12)                       mobject1.stroke_opacity,
232: (12)                       mobject2.stroke_opacity,
233: (12)                       alpha,
234: (8)                    )
235: (8)                    self.pixel_array = interpolate(
236: (12)                       mobject1.pixel_array,
237: (12)                       mobject2.pixel_array,
238: (12)                       alpha,
239: (8)                    ).astype(self.pixel_array_dtype)
240: (4)                def get_style(self):
241: (8)                    return {
242: (12)                       "fill_color": ManimColor(self.color.get_rgb()).to_hex(),
243: (12)                       "fill_opacity": self.fill_opacity,
244: (8)                    }
245: (0)            # TODO, add the ability to have the dimensions/orientation of this
246: (0)            # mobject more strongly tied to the frame of the camera it contains,
247: (0)            # in the case where that's a MovingCamera
248: (0)            class ImageMobjectFromCamera(AbstractImageMobject):
249: (4)                def __init__(self, camera, default_display_frame_config=None, **kwargs):
250: (8)                    self.camera = camera
251: (8)                    if default_display_frame_config is None:
252: (12)                       default_display_frame_config = {
253: (16)                           "stroke_width": 3,
254: (16)                           "stroke_color": WHITE,
255: (16)                           "buff": 0,
256: (12)                       }
257: (8)                    self.default_display_frame_config = default_display_frame_config
258: (8)                    self.pixel_array = self.camera.pixel_array
259: (8)                    super().__init__(scale_to_resolution=False, **kwargs)
260: (4)                # TODO: Get rid of this.
261: (4)                def get_pixel_array(self):
262: (8)                    self.pixel_array = self.camera.pixel_array
263: (8)                    return self.pixel_array
264: (4)                def add_display_frame(self, **kwargs):
265: (8)                    config = dict(self.default_display_frame_config)
266: (8)                    config.update(kwargs)
267: (8)                    self.display_frame = SurroundingRectangle(self, **config)
268: (8)                    self.add(self.display_frame)
269: (8)                    return self
270: (4)                def interpolate_color(self, mobject1, mobject2, alpha):
271: (8)                    assert mobject1.pixel_array.shape == mobject2.pixel_array.shape, (
272: (12)                       f"Mobject pixel array shapes incompatible for interpolation.\n"
273: (12)                       f"Mobject 1 ({mobject1}) : {mobject1.pixel_array.shape}\n"
274: (12)                       f"Mobject 2 ({mobject2}) : {mobject2.pixel_array.shape}"
275: (8)                    )
276: (8)                    self.pixel_array = interpolate(
277: (12)                       mobject1.pixel_array,
278: (12)                       mobject2.pixel_array,
279: (12)                       alpha,
280: (8)                    ).astype(self.pixel_array_dtype)

----------------------------------------

File 38 - .\opengl \opengl_mobject.py:

1: (0)              from __future__ import annotations
2: (0)              import copy
3: (0)              import inspect
4: (0)              import itertools as it
5: (0)              import random
6: (0)              import sys
7: (0)              from functools import partialmethod, wraps
8: (0)              from math import ceil
9: (0)              from typing import Iterable, Sequence
10: (0)             import moderngl
11: (0)             import numpy as np
12: (0)             from manim import config, logger
13: (0)             from manim.constants import *
14: (0)             from manim.renderer.shader_wrapper import get_colormap_code
15: (0)             from manim.utils.bezier import integer_interpolate, interpolate
16: (0)             from manim.utils.color import (
17: (4)                 WHITE,
18: (4)                 ManimColor,
19: (4)                 ParsableManimColor,
20: (4)                 color_gradient,
21: (4)                 color_to_rgb,
22: (4)                 rgb_to_hex,
23: (0)             )
24: (0)             from manim.utils.config_ops import _Data, _Uniforms
25: (0)             # from ..utils.iterables import batch_by_property
26: (0)             from manim.utils.iterables import (
27: (4)                 batch_by_property,
28: (4)                 list_update,
29: (4)                 listify,
30: (4)                 make_even,
31: (4)                 resize_array,
32: (4)                 resize_preserving_order,
33: (4)                 resize_with_interpolation,
34: (4)                 uniq_chain,
35: (0)             )
36: (0)             from manim.utils.paths import straight_path
37: (0)             from manim.utils.space_ops import (
38: (4)                 angle_between_vectors,
39: (4)                 normalize,
40: (4)                 rotation_matrix_transpose,
41: (0)             )
42: (0)             def affects_shader_info_id(func):
43: (4)                 @wraps(func)
44: (4)                 def wrapper(self):
45: (8)                     for mob in self.get_family():
46: (12)                        func(mob)
47: (12)                        mob.refresh_shader_wrapper_id()
48: (8)                     return self
49: (4)                 return wrapper
50: (0)             __all__ = ["OpenGLMobject", "OpenGLGroup", "OpenGLPoint", "_AnimationBuilder"]
51: (0)             class OpenGLMobject:
52: (4)                 """Mathematical Object: base class for objects that can be displayed on screen.
53: (4)                 Attributes
54: (4)                 ----------
55: (4)                 submobjects : List[:class:`OpenGLMobject`]
56: (8)                     The contained objects.
57: (4)                 points : :class:`numpy.ndarray`
58: (8)                     The points of the objects.
59: (8)                     .. seealso::
60: (12)                        :class:`~.OpenGLVMobject`
61: (4)                 """
62: (4)                 shader_dtype = [
63: (8)                     ("point", np.float32, (3,)),
64: (4)                 ]
65: (4)                 shader_folder = ""
66: (4)                 # _Data and _Uniforms are set as class variables to tell manim how to handle setting/getting these attributes later.
67: (4)                 points = _Data()
68: (4)                 bounding_box = _Data()
69: (4)                 rgbas = _Data()
70: (4)                 is_fixed_in_frame = _Uniforms()
71: (4)                 is_fixed_orientation = _Uniforms()
72: (4)                 fixed_orientation_center = _Uniforms()  # for fixed orientation reference
73: (4)                 gloss = _Uniforms()
74: (4)                 shadow = _Uniforms()
75: (4)                 def __init__(
76: (8)                     self,
77: (8)                     color=WHITE,
78: (8)                     opacity=1,
79: (8)                     dim=3,  # TODO, get rid of this
80: (8)                     # Lighting parameters
81: (8)                     # Positive gloss up to 1 makes it reflect the light.
82: (8)                     gloss=0.0,
83: (8)                     # Positive shadow up to 1 makes a side opposite the light darker
84: (8)                     shadow=0.0,
85: (8)                     # For shaders
86: (8)                     render_primitive=moderngl.TRIANGLES,
87: (8)                     texture_paths=None,
88: (8)                     depth_test=False,
89: (8)                     # If true, the mobject will not get rotated according to camera position
90: (8)                     is_fixed_in_frame=False,
91: (8)                     is_fixed_orientation=False,
92: (8)                     # Must match in attributes of vert shader
93: (8)                     # Event listener
94: (8)                     listen_to_events=False,
95: (8)                     model_matrix=None,
96: (8)                     should_render=True,
97: (8)                     name: str | None = None,
98: (8)                     **kwargs,
99: (4)                 ):
100: (8)                    self.name = self.__class__.__name__ if name is None else name
101: (8)                    # getattr in case data/uniforms are already defined in parent classes.
102: (8)                    self.data = getattr(self, "data", {})
103: (8)                    self.uniforms = getattr(self, "uniforms", {})
104: (8)                    self.opacity = opacity
105: (8)                    self.dim = dim  # TODO, get rid of this
106: (8)                    # Lighting parameters
107: (8)                    # Positive gloss up to 1 makes it reflect the light.
108: (8)                    self.gloss = gloss
109: (8)                    # Positive shadow up to 1 makes a side opposite the light darker
110: (8)                    self.shadow = shadow
111: (8)                    # For shaders
112: (8)                    self.render_primitive = render_primitive
113: (8)                    self.texture_paths = texture_paths
114: (8)                    self.depth_test = depth_test
115: (8)                    # If true, the mobject will not get rotated according to camera position
116: (8)                    self.is_fixed_in_frame = float(is_fixed_in_frame)
117: (8)                    self.is_fixed_orientation = float(is_fixed_orientation)
118: (8)                    self.fixed_orientation_center = (0, 0, 0)
119: (8)                    # Must match in attributes of vert shader
120: (8)                    # Event listener
121: (8)                    self.listen_to_events = listen_to_events
122: (8)                    self._submobjects = []
123: (8)                    self.parents = []
124: (8)                    self.parent = None
125: (8)                    self.family = [self]
126: (8)                    self.locked_data_keys = set()
127: (8)                    self.needs_new_bounding_box = True
128: (8)                    if model_matrix is None:
129: (12)                       self.model_matrix = np.eye(4)
130: (8)                    else:
131: (12)                       self.model_matrix = model_matrix
132: (8)                    self.init_data()
133: (8)                    self.init_updaters()
134: (8)                    # self.init_event_listners()
135: (8)                    self.init_points()
136: (8)                    self.color = ManimColor.parse(color)
137: (8)                    self.init_colors()
138: (8)                    self.shader_indices = None
139: (8)                    if self.depth_test:
140: (12)                       self.apply_depth_test()
141: (8)                    self.should_render = should_render
142: (4)                @classmethod
143: (4)                def __init_subclass__(cls, **kwargs):
144: (8)                    super().__init_subclass__(**kwargs)
145: (8)                    cls._original__init__ = cls.__init__
146: (4)                def __str__(self):
147: (8)                    return self.__class__.__name__
148: (4)                def __repr__(self):
149: (8)                    return str(self.name)
150: (4)                def __sub__(self, other):
151: (8)                    return NotImplemented
152: (4)                def __isub__(self, other):
153: (8)                    return NotImplemented
154: (4)                def __add__(self, mobject):
155: (8)                    return NotImplemented
156: (4)                def __iadd__(self, mobject):
157: (8)                    return NotImplemented
158: (4)                @classmethod
159: (4)                def set_default(cls, **kwargs):
160: (8)                    """Sets the default values of keyword arguments.
161: (8)                    If this method is called without any additional keyword
162: (8)                    arguments, the original default values of the initialization
163: (8)                    method of this class are restored.
164: (8)                    Parameters
165: (8)                    ----------
166: (8)                    kwargs
167: (12)                       Passing any keyword argument will update the default
168: (12)                       values of the keyword arguments of the initialization
169: (12)                       function of this class.
170: (8)                    Examples
171: (8)                    --------
172: (8)                    ::
173: (12)                       >>> from manim import Square, GREEN
174: (12)                       >>> Square.set_default(color=GREEN, fill_opacity=0.25)
175: (12)                       >>> s = Square(); s.color, s.fill_opacity
176: (12)                       (ManimColor('#83C167'), 0.25)
177: (12)                       >>> Square.set_default()
178: (12)                       >>> s = Square(); s.color, s.fill_opacity
179: (12)                       (ManimColor('#FFFFFF'), 0.0)
180: (8)                    .. manim:: ChangedDefaultTextcolor
181: (12)                       :save_last_frame:
182: (12)                       config.background_color = WHITE
183: (12)                       class ChangedDefaultTextcolor(Scene):
184: (16)                           def construct(self):
185: (20)                               Text.set_default(color=BLACK)
186: (20)                               self.add(Text("Changing default values is easy!"))
187: (20)                               # we revert the colour back to the default to prevent a bug in the docs.
188: (20)                               Text.set_default(color=WHITE)
189: (8)                    """
190: (8)                    if kwargs:
191: (12)                       cls.__init__ = partialmethod(cls.__init__, **kwargs)
192: (8)                    else:
193: (12)                       cls.__init__ = cls._original__init__
194: (4)                def init_data(self):
195: (8)                    """Initializes the ``points``, ``bounding_box`` and ``rgbas`` attributes and groups them into self.data.
196: (8)                    Subclasses can inherit and overwrite this method to extend `self.data`."""
197: (8)                    self.points = np.zeros((0, 3))
198: (8)                    self.bounding_box = np.zeros((3, 3))
199: (8)                    self.rgbas = np.zeros((1, 4))
200: (4)                def init_colors(self):
201: (8)                    """Initializes the colors.
202: (8)                    Gets called upon creation"""
203: (8)                    self.set_color(self.color, self.opacity)
204: (4)                def init_points(self):
205: (8)                    """Initializes :attr:`points` and therefore the shape.
206: (8)                    Gets called upon creation. This is an empty method that can be implemented by
207: (8)                    subclasses."""
208: (8)                    # Typically implemented in subclass, unless purposefully left blank
209: (8)                    pass
210: (4)                def set(self, **kwargs) -> OpenGLMobject:
211: (8)                    """Sets attributes.
212: (8)                    Mainly to be used along with :attr:`animate` to
213: (8)                    animate setting attributes.
214: (8)                    Examples
215: (8)                    --------
216: (8)                    ::
217: (12)                       >>> mob = OpenGLMobject()
218: (12)                       >>> mob.set(foo=0)
219: (12)                       OpenGLMobject
220: (12)                       >>> mob.foo
221: (12)                       0
222: (8)                    Parameters
223: (8)                    ----------
224: (8)                    **kwargs
225: (12)                       The attributes and corresponding values to set.
226: (8)                    Returns
227: (8)                    -------
228: (8)                    :class:`OpenGLMobject`
229: (12)                       ``self``
230: (8)                    """
231: (8)                    for attr, value in kwargs.items():
232: (12)                       setattr(self, attr, value)
233: (8)                    return self
234: (4)                def set_data(self, data):
235: (8)                    for key in data:
236: (12)                       self.data[key] = data[key].copy()
237: (8)                    return self
238: (4)                def set_uniforms(self, uniforms):
239: (8)                    for key in uniforms:
240: (12)                       self.uniforms[key] = uniforms[key]  # Copy?
241: (8)                    return self
242: (4)                @property
243: (4)                def animate(self):
244: (8)                    """Used to animate the application of a method.
245: (8)                    .. warning::
246: (12)                       Passing multiple animations for the same :class:`OpenGLMobject` in one
247: (12)                       call to :meth:`~.Scene.play` is discouraged and will most likely
248: (12)                       not work properly. Instead of writing an animation like
249: (12)                       ::
250: (16)                           self.play(my_mobject.animate.shift(RIGHT), my_mobject.animate.rotate(PI))
251: (12)                       make use of method chaining for ``animate``, meaning::
252: (16)                           self.play(my_mobject.animate.shift(RIGHT).rotate(PI))
253: (8)                    Keyword arguments that can be passed to :meth:`.Scene.play` can be passed
254: (8)                    directly after accessing ``.animate``, like so::
255: (12)                       self.play(my_mobject.animate(rate_func=linear).shift(RIGHT))
256: (8)                    This is especially useful when animating simultaneous ``.animate`` calls that
257: (8)                    you want to behave differently::
258: (12)                       self.play(
259: (16)                           mobject1.animate(run_time=2).rotate(PI),
260: (16)                           mobject2.animate(rate_func=there_and_back).shift(RIGHT),
261: (12)                       )
262: (8)                    .. seealso::
263: (12)                       :func:`override_animate`
264: (8)                    Examples
265: (8)                    --------
266: (8)                    .. manim:: AnimateExample
267: (12)                       class AnimateExample(Scene):
268: (16)                           def construct(self):
269: (20)                               s = Square()
270: (20)                               self.play(Create(s))
271: (20)                               self.play(s.animate.shift(RIGHT))
272: (20)                               self.play(s.animate.scale(2))
273: (20)                               self.play(s.animate.rotate(PI / 2))
274: (20)                               self.play(Uncreate(s))
275: (8)                    .. manim:: AnimateChainExample
276: (12)                       class AnimateChainExample(Scene):
277: (16)                           def construct(self):
278: (20)                               s = Square()
279: (20)                               self.play(Create(s))
280: (20)                               self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))
281: (20)                               self.play(Uncreate(s))
282: (8)                    .. manim:: AnimateWithArgsExample
283: (12)                       class AnimateWithArgsExample(Scene):
284: (16)                           def construct(self):
285: (20)                               s = Square()
286: (20)                               c = Circle()
287: (20)                               VGroup(s, c).arrange(RIGHT, buff=2)
288: (20)                               self.add(s, c)
289: (20)                               self.play(
290: (24)                                   s.animate(run_time=2).rotate(PI / 2),
291: (24)                                   c.animate(rate_func=there_and_back).shift(RIGHT),
292: (20)                               )
293: (8)                    .. warning::
294: (12)                       ``.animate``
295: (13)                        will interpolate the :class:`~.OpenGLMobject` between its points prior to
296: (13)                        ``.animate`` and its points after applying ``.animate`` to it. This may
297: (13)                        result in unexpected behavior when attempting to interpolate along paths,
298: (13)                        or rotations.
299: (13)                        If you want animations to consider the points between, consider using
300: (13)                        :class:`~.ValueTracker` with updaters instead.
301: (8)                    """
302: (8)                    return _AnimationBuilder(self)
303: (4)                @property
304: (4)                def width(self):
305: (8)                    """The width of the mobject.
306: (8)                    Returns
307: (8)                    -------
308: (8)                    :class:`float`
309: (8)                    Examples
310: (8)                    --------
311: (8)                    .. manim:: WidthExample
312: (12)                       class WidthExample(Scene):
313: (16)                           def construct(self):
314: (20)                               decimal = DecimalNumber().to_edge(UP)
315: (20)                               rect = Rectangle(color=BLUE)
316: (20)                               rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)
317: (20)                               decimal.add_updater(lambda d: d.set_value(rect.width))
318: (20)                               self.add(rect_copy, rect, decimal)
319: (20)                               self.play(rect.animate.set(width=7))
320: (20)                               self.wait()
321: (8)                    See also
322: (8)                    --------
323: (8)                    :meth:`length_over_dim`
324: (8)                    """
325: (8)                    # Get the length across the X dimension
326: (8)                    return self.length_over_dim(0)
327: (4)                # Only these methods should directly affect points
328: (4)                @width.setter
329: (4)                def width(self, value):
330: (8)                    self.rescale_to_fit(value, 0, stretch=False)
331: (4)                @property
332: (4)                def height(self):
333: (8)                    """The height of the mobject.
334: (8)                    Returns
335: (8)                    -------
336: (8)                    :class:`float`
337: (8)                    Examples
338: (8)                    --------
339: (8)                    .. manim:: HeightExample
340: (12)                       class HeightExample(Scene):
341: (16)                           def construct(self):
342: (20)                               decimal = DecimalNumber().to_edge(UP)
343: (20)                               rect = Rectangle(color=BLUE)
344: (20)                               rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)
345: (20)                               decimal.add_updater(lambda d: d.set_value(rect.height))
346: (20)                               self.add(rect_copy, rect, decimal)
347: (20)                               self.play(rect.animate.set(height=5))
348: (20)                               self.wait()
349: (8)                    See also
350: (8)                    --------
351: (8)                    :meth:`length_over_dim`
352: (8)                    """
353: (8)                    # Get the length across the Y dimension
354: (8)                    return self.length_over_dim(1)
355: (4)                @height.setter
356: (4)                def height(self, value):
357: (8)                    self.rescale_to_fit(value, 1, stretch=False)
358: (4)                @property
359: (4)                def depth(self):
360: (8)                    """The depth of the mobject.
361: (8)                    Returns
362: (8)                    -------
363: (8)                    :class:`float`
364: (8)                    See also
365: (8)                    --------
366: (8)                    :meth:`length_over_dim`
367: (8)                    """
368: (8)                    # Get the length across the Z dimension
369: (8)                    return self.length_over_dim(2)
370: (4)                @depth.setter
371: (4)                def depth(self, value):
372: (8)                    self.rescale_to_fit(value, 2, stretch=False)
373: (4)                def resize_points(self, new_length, resize_func=resize_array):
374: (8)                    if new_length != len(self.points):
375: (12)                       self.points = resize_func(self.points, new_length)
376: (8)                    self.refresh_bounding_box()
377: (8)                    return self
378: (4)                def set_points(self, points):
379: (8)                    if len(points) == len(self.points):
380: (12)                       self.points[:] = points
381: (8)                    elif isinstance(points, np.ndarray):
382: (12)                       self.points = points.copy()
383: (8)                    else:
384: (12)                       self.points = np.array(points)
385: (8)                    self.refresh_bounding_box()
386: (8)                    return self
387: (4)                def apply_over_attr_arrays(self, func):
388: (8)                    for attr in self.get_array_attrs():
389: (12)                       setattr(self, attr, func(getattr(self, attr)))
390: (8)                    return self
391: (4)                def append_points(self, new_points):
392: (8)                    self.points = np.vstack([self.points, new_points])
393: (8)                    self.refresh_bounding_box()
394: (8)                    return self
395: (4)                def reverse_points(self):
396: (8)                    for mob in self.get_family():
397: (12)                       for key in mob.data:
398: (16)                           mob.data[key] = mob.data[key][::-1]
399: (8)                    return self
400: (4)                def get_midpoint(self) -> np.ndarray:
401: (8)                    """Get coordinates of the middle of the path that forms the  :class:`~.OpenGLMobject`.
402: (8)                    Examples
403: (8)                    --------
404: (8)                    .. manim:: AngleMidPoint
405: (12)                       :save_last_frame:
406: (12)                       class AngleMidPoint(Scene):
407: (16)                           def construct(self):
408: (20)                               line1 = Line(ORIGIN, 2*RIGHT)
409: (20)                               line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)
410: (20)                               a = Angle(line1, line2, radius=1.5, other_angle=False)
411: (20)                               d = Dot(a.get_midpoint()).set_color(RED)
412: (20)                               self.add(line1, line2, a, d)
413: (20)                               self.wait()
414: (8)                    """
415: (8)                    return self.point_from_proportion(0.5)
416: (4)                def apply_points_function(
417: (8)                    self,
418: (8)                    func,
419: (8)                    about_point=None,
420: (8)                    about_edge=ORIGIN,
421: (8)                    works_on_bounding_box=False,
422: (4)                ):
423: (8)                    if about_point is None and about_edge is not None:
424: (12)                       about_point = self.get_bounding_box_point(about_edge)
425: (8)                    for mob in self.get_family():
426: (12)                       arrs = []
427: (12)                       if mob.has_points():
428: (16)                           arrs.append(mob.points)
429: (12)                       if works_on_bounding_box:
430: (16)                           arrs.append(mob.get_bounding_box())
431: (12)                       for arr in arrs:
432: (16)                           if about_point is None:
433: (20)                               arr[:] = func(arr)
434: (16)                           else:
435: (20)                               arr[:] = func(arr - about_point) + about_point
436: (8)                    if not works_on_bounding_box:
437: (12)                       self.refresh_bounding_box(recurse_down=True)
438: (8)                    else:
439: (12)                       for parent in self.parents:
440: (16)                           parent.refresh_bounding_box()
441: (8)                    return self
442: (4)                # Others related to points
443: (4)                def match_points(self, mobject):
444: (8)                    """Edit points, positions, and submobjects to be identical
445: (8)                    to another :class:`~.OpenGLMobject`, while keeping the style unchanged.
446: (8)                    Examples
447: (8)                    --------
448: (8)                    .. manim:: MatchPointsScene
449: (12)                       class MatchPointsScene(Scene):
450: (16)                           def construct(self):
451: (20)                               circ = Circle(fill_color=RED, fill_opacity=0.8)
452: (20)                               square = Square(fill_color=BLUE, fill_opacity=0.2)
453: (20)                               self.add(circ)
454: (20)                               self.wait(0.5)
455: (20)                               self.play(circ.animate.match_points(square))
456: (20)                               self.wait(0.5)
457: (8)                    """
458: (8)                    self.set_points(mobject.points)
459: (4)                def clear_points(self):
460: (8)                    self.points = np.empty((0, 3))
461: (4)                def get_num_points(self):
462: (8)                    return len(self.points)
463: (4)                def get_all_points(self):
464: (8)                    if self.submobjects:
465: (12)                       return np.vstack([sm.points for sm in self.get_family()])
466: (8)                    else:
467: (12)                       return self.points
468: (4)                def has_points(self):
469: (8)                    return self.get_num_points() > 0
470: (4)                def get_bounding_box(self):
471: (8)                    if self.needs_new_bounding_box:
472: (12)                       self.bounding_box = self.compute_bounding_box()
473: (12)                       self.needs_new_bounding_box = False
474: (8)                    return self.bounding_box
475: (4)                def compute_bounding_box(self):
476: (8)                    all_points = np.vstack(
477: (12)                       [
478: (16)                           self.points,
479: (16)                           *(
480: (20)                               mob.get_bounding_box()
481: (20)                               for mob in self.get_family()[1:]
482: (20)                               if mob.has_points()
483: (16)                           ),
484: (12)                       ],
485: (8)                    )
486: (8)                    if len(all_points) == 0:
487: (12)                       return np.zeros((3, self.dim))
488: (8)                    else:
489: (12)                       # Lower left and upper right corners
490: (12)                       mins = all_points.min(0)
491: (12)                       maxs = all_points.max(0)
492: (12)                       mids = (mins + maxs) / 2
493: (12)                       return np.array([mins, mids, maxs])
494: (4)                def refresh_bounding_box(self, recurse_down=False, recurse_up=True):
495: (8)                    for mob in self.get_family(recurse_down):
496: (12)                       mob.needs_new_bounding_box = True
497: (8)                    if recurse_up:
498: (12)                       for parent in self.parents:
499: (16)                           parent.refresh_bounding_box()
500: (8)                    return self
501: (4)                def is_point_touching(self, point, buff=MED_SMALL_BUFF):
502: (8)                    bb = self.get_bounding_box()
503: (8)                    mins = bb[0] - buff
504: (8)                    maxs = bb[2] + buff
505: (8)                    return (point >= mins).all() and (point <= maxs).all()
506: (4)                # Family matters
507: (4)                def __getitem__(self, value):
508: (8)                    if isinstance(value, slice):
509: (12)                       GroupClass = self.get_group_class()
510: (12)                       return GroupClass(*self.split().__getitem__(value))
511: (8)                    return self.split().__getitem__(value)
512: (4)                def __iter__(self):
513: (8)                    return iter(self.split())
514: (4)                def __len__(self):
515: (8)                    return len(self.split())
516: (4)                def split(self):
517: (8)                    return self.submobjects
518: (4)                def assemble_family(self):
519: (8)                    sub_families = (sm.get_family() for sm in self.submobjects)
520: (8)                    self.family = [self, *uniq_chain(*sub_families)]
521: (8)                    self.refresh_has_updater_status()
522: (8)                    self.refresh_bounding_box()
523: (8)                    for parent in self.parents:
524: (12)                       parent.assemble_family()
525: (8)                    return self
526: (4)                def get_family(self, recurse=True):
527: (8)                    if recurse and hasattr(self, "family"):
528: (12)                       return self.family
529: (8)                    else:
530: (12)                       return [self]
531: (4)                def family_members_with_points(self):
532: (8)                    return [m for m in self.get_family() if m.has_points()]
533: (4)                def add(
534: (8)                    self, *mobjects: OpenGLMobject, update_parent: bool = False
535: (4)                ) -> OpenGLMobject:
536: (8)                    """Add mobjects as submobjects.
537: (8)                    The mobjects are added to :attr:`submobjects`.
538: (8)                    Subclasses of mobject may implement ``+`` and ``+=`` dunder methods.
539: (8)                    Parameters
540: (8)                    ----------
541: (8)                    mobjects
542: (12)                       The mobjects to add.
543: (8)                    Returns
544: (8)                    -------
545: (8)                    :class:`OpenGLMobject`
546: (12)                       ``self``
547: (8)                    Raises
548: (8)                    ------
549: (8)                    :class:`ValueError`
550: (12)                       When a mobject tries to add itself.
551: (8)                    :class:`TypeError`
552: (12)                       When trying to add an object that is not an instance of :class:`OpenGLMobject`.
553: (8)                    Notes
554: (8)                    -----
555: (8)                    A mobject cannot contain itself, and it cannot contain a submobject
556: (8)                    more than once.  If the parent mobject is displayed, the newly-added
557: (8)                    submobjects will also be displayed (i.e. they are automatically added
558: (8)                    to the parent Scene).
559: (8)                    See Also
560: (8)                    --------
561: (8)                    :meth:`remove`
562: (8)                    :meth:`add_to_back`
563: (8)                    Examples
564: (8)                    --------
565: (8)                    ::
566: (12)                       >>> outer = OpenGLMobject()
567: (12)                       >>> inner = OpenGLMobject()
568: (12)                       >>> outer = outer.add(inner)
569: (8)                    Duplicates are not added again::
570: (12)                       >>> outer = outer.add(inner)
571: (12)                       >>> len(outer.submobjects)
572: (12)                       1
573: (8)                    Adding an object to itself raises an error::
574: (12)                       >>> outer.add(outer)
575: (12)                       Traceback (most recent call last):
576: (12)                       ...
577: (12)                       ValueError: OpenGLMobject cannot contain self
578: (8)                    """
579: (8)                    if update_parent:
580: (12)                       assert len(mobjects) == 1, "Can't set multiple parents."
581: (12)                       mobjects[0].parent = self
582: (8)                    if self in mobjects:
583: (12)                       raise ValueError("OpenGLMobject cannot contain self")
584: (8)                    if any(mobjects.count(elem) > 1 for elem in mobjects):
585: (12)                       logger.warning(
586: (16)                           "Attempted adding some Mobject as a child more than once, "
587: (16)                           "this is not possible. Repetitions are ignored.",
588: (12)                       )
589: (8)                    for mobject in mobjects:
590: (12)                       if not isinstance(mobject, OpenGLMobject):
591: (16)                           raise TypeError("All submobjects must be of type OpenGLMobject")
592: (12)                       if mobject not in self.submobjects:
593: (16)                           self.submobjects.append(mobject)
594: (12)                       if self not in mobject.parents:
595: (16)                           mobject.parents.append(self)
596: (8)                    self.assemble_family()
597: (8)                    return self
598: (4)                def insert(self, index: int, mobject: OpenGLMobject, update_parent: bool = False):
599: (8)                    """Inserts a mobject at a specific position into self.submobjects
600: (8)                    Effectively just calls  ``self.submobjects.insert(index, mobject)``,
601: (8)                    where ``self.submobjects`` is a list.
602: (8)                    Highly adapted from ``OpenGLMobject.add``.
603: (8)                    Parameters
604: (8)                    ----------
605: (8)                    index
606: (12)                       The index at which
607: (8)                    mobject
608: (12)                       The mobject to be inserted.
609: (8)                    update_parent
610: (12)                       Whether or not to set ``mobject.parent`` to ``self``.
611: (8)                    """
612: (8)                    if update_parent:
613: (12)                       mobject.parent = self
614: (8)                    if mobject is self:
615: (12)                       raise ValueError("OpenGLMobject cannot contain self")
616: (8)                    if not isinstance(mobject, OpenGLMobject):
617: (12)                       raise TypeError("All submobjects must be of type OpenGLMobject")
618: (8)                    if mobject not in self.submobjects:
619: (12)                       self.submobjects.insert(index, mobject)
620: (8)                    if self not in mobject.parents:
621: (12)                       mobject.parents.append(self)
622: (8)                    self.assemble_family()
623: (8)                    return self
624: (4)                def remove(
625: (8)                    self, *mobjects: OpenGLMobject, update_parent: bool = False
626: (4)                ) -> OpenGLMobject:
627: (8)                    """Remove :attr:`submobjects`.
628: (8)                    The mobjects are removed from :attr:`submobjects`, if they exist.
629: (8)                    Subclasses of mobject may implement ``-`` and ``-=`` dunder methods.
630: (8)                    Parameters
631: (8)                    ----------
632: (8)                    mobjects
633: (12)                       The mobjects to remove.
634: (8)                    Returns
635: (8)                    -------
636: (8)                    :class:`OpenGLMobject`
637: (12)                       ``self``
638: (8)                    See Also
639: (8)                    --------
640: (8)                    :meth:`add`
641: (8)                    """
642: (8)                    if update_parent:
643: (12)                       assert len(mobjects) == 1, "Can't remove multiple parents."
644: (12)                       mobjects[0].parent = None
645: (8)                    for mobject in mobjects:
646: (12)                       if mobject in self.submobjects:
647: (16)                           self.submobjects.remove(mobject)
648: (12)                       if self in mobject.parents:
649: (16)                           mobject.parents.remove(self)
650: (8)                    self.assemble_family()
651: (8)                    return self
652: (4)                def add_to_back(self, *mobjects: OpenGLMobject) -> OpenGLMobject:
653: (8)                    # NOTE: is the note true OpenGLMobjects?
654: (8)                    """Add all passed mobjects to the back of the submobjects.
655: (8)                    If :attr:`submobjects` already contains the given mobjects, they just get moved
656: (8)                    to the back instead.
657: (8)                    Parameters
658: (8)                    ----------
659: (8)                    mobjects
660: (12)                       The mobjects to add.
661: (8)                    Returns
662: (8)                    -------
663: (8)                    :class:`OpenGLMobject`
664: (12)                       ``self``
665: (8)                    .. note::
666: (12)                       Technically, this is done by adding (or moving) the mobjects to
667: (12)                       the head of :attr:`submobjects`. The head of this list is rendered
668: (12)                       first, which places the corresponding mobjects behind the
669: (12)                       subsequent list members.
670: (8)                    Raises
671: (8)                    ------
672: (8)                    :class:`ValueError`
673: (12)                       When a mobject tries to add itself.
674: (8)                    :class:`TypeError`
675: (12)                       When trying to add an object that is not an instance of :class:`OpenGLMobject`.
676: (8)                    Notes
677: (8)                    -----
678: (8)                    A mobject cannot contain itself, and it cannot contain a submobject
679: (8)                    more than once.  If the parent mobject is displayed, the newly-added
680: (8)                    submobjects will also be displayed (i.e. they are automatically added
681: (8)                    to the parent Scene).
682: (8)                    See Also
683: (8)                    --------
684: (8)                    :meth:`remove`
685: (8)                    :meth:`add`
686: (8)                    """
687: (8)                    self.submobjects = list_update(mobjects, self.submobjects)
688: (8)                    return self
689: (4)                def replace_submobject(self, index, new_submob):
690: (8)                    old_submob = self.submobjects[index]
691: (8)                    if self in old_submob.parents:
692: (12)                       old_submob.parents.remove(self)
693: (8)                    self.submobjects[index] = new_submob
694: (8)                    self.assemble_family()
695: (8)                    return self
696: (4)                def invert(self, recursive=False):
697: (8)                    """Inverts the list of :attr:`submobjects`.
698: (8)                    Parameters
699: (8)                    ----------
700: (8)                    recursive
701: (12)                       If ``True``, all submobject lists of this mobject's family are inverted.
702: (8)                    Examples
703: (8)                    --------
704: (8)                    .. manim:: InvertSumobjectsExample
705: (12)                       class InvertSumobjectsExample(Scene):
706: (16)                           def construct(self):
707: (20)                               s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
708: (20)                               s2 = s.copy()
709: (20)                               s2.invert()
710: (20)                               s2.shift(DOWN)
711: (20)                               self.play(Write(s), Write(s2))
712: (8)                    """
713: (8)                    if recursive:
714: (12)                       for submob in self.submobjects:
715: (16)                           submob.invert(recursive=True)
716: (8)                    list.reverse(self.submobjects)
717: (8)                    self.assemble_family()
718: (4)                # Submobject organization
719: (4)                def arrange(self, direction=RIGHT, center=True, **kwargs):
720: (8)                    """Sorts :class:`~.OpenGLMobject` next to each other on screen.
721: (8)                    Examples
722: (8)                    --------
723: (8)                    .. manim:: Example
724: (12)                       :save_last_frame:
725: (12)                       class Example(Scene):
726: (16)                           def construct(self):
727: (20)                               s1 = Square()
728: (20)                               s2 = Square()
729: (20)                               s3 = Square()
730: (20)                               s4 = Square()
731: (20)                               x = OpenGLVGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)
732: (20)                               self.add(x)
733: (8)                    """
734: (8)                    for m1, m2 in zip(self.submobjects, self.submobjects[1:]):
735: (12)                       m2.next_to(m1, direction, **kwargs)
736: (8)                    if center:
737: (12)                       self.center()
738: (8)                    return self
739: (4)                def arrange_in_grid(
740: (8)                    self,
741: (8)                    rows: int | None = None,
742: (8)                    cols: int | None = None,
743: (8)                    buff: float | tuple[float, float] = MED_SMALL_BUFF,
744: (8)                    cell_alignment: np.ndarray = ORIGIN,
745: (8)                    row_alignments: str | None = None,  # "ucd"
746: (8)                    col_alignments: str | None = None,  # "lcr"
747: (8)                    row_heights: Iterable[float | None] | None = None,
748: (8)                    col_widths: Iterable[float | None] | None = None,
749: (8)                    flow_order: str = "rd",
750: (8)                    **kwargs,
751: (4)                ) -> OpenGLMobject:
752: (8)                    """Arrange submobjects in a grid.
753: (8)                    Parameters
754: (8)                    ----------
755: (8)                    rows
756: (12)                       The number of rows in the grid.
757: (8)                    cols
758: (12)                       The number of columns in the grid.
759: (8)                    buff
760: (12)                       The gap between grid cells. To specify a different buffer in the horizontal and
761: (12)                       vertical directions, a tuple of two values can be given - ``(row, col)``.
762: (8)                    cell_alignment
763: (12)                       The way each submobject is aligned in its grid cell.
764: (8)                    row_alignments
765: (12)                       The vertical alignment for each row (top to bottom). Accepts the following characters: ``"u"`` -
766: (12)                       up, ``"c"`` - center, ``"d"`` - down.
767: (8)                    col_alignments
768: (12)                       The horizontal alignment for each column (left to right). Accepts the following characters ``"l"`` - left,
769: (12)                       ``"c"`` - center, ``"r"`` - right.
770: (8)                    row_heights
771: (12)                       Defines a list of heights for certain rows (top to bottom). If the list contains
772: (12)                       ``None``, the corresponding row will fit its height automatically based
773: (12)                       on the highest element in that row.
774: (8)                    col_widths
775: (12)                       Defines a list of widths for certain columns (left to right). If the list contains ``None``, the
776: (12)                       corresponding column will fit its width automatically based on the widest element in that column.
777: (8)                    flow_order
778: (12)                       The order in which submobjects fill the grid. Can be one of the following values:
779: (12)                       "rd", "dr", "ld", "dl", "ru", "ur", "lu", "ul". ("rd" -> fill rightwards then downwards)
780: (8)                    Returns
781: (8)                    -------
782: (8)                    OpenGLMobject
783: (12)                       The mobject.
784: (8)                    NOTES
785: (8)                    -----
786: (8)                    If only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big
787: (8)                    enough to fit all submobjects. If neither is set, they will be chosen to be about the same,
788: (8)                    tending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).
789: (8)                    If both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are
790: (8)                    defined, the latter has higher priority.
791: (8)                    Raises
792: (8)                    ------
793: (8)                    ValueError
794: (12)                       If ``rows`` and ``cols`` are too small to fit all submobjects.
795: (8)                    ValueError
796: (12)                       If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,
797: (12)                       :code:`row_alignments` and :code:`row_heights` have mismatching sizes.
798: (8)                    Examples
799: (8)                    --------
800: (8)                    .. manim:: ExampleBoxes
801: (12)                       :save_last_frame:
802: (12)                       class ExampleBoxes(Scene):
803: (16)                           def construct(self):
804: (20)                               boxes=VGroup(*[Square() for s in range(0,6)])
805: (20)                               boxes.arrange_in_grid(rows=2, buff=0.1)
806: (20)                               self.add(boxes)
807: (8)                    .. manim:: ArrangeInGrid
808: (12)                       :save_last_frame:
809: (12)                       class ArrangeInGrid(Scene):
810: (16)                           def construct(self):
811: (20)                               #Add some numbered boxes:
812: (20)                               np.random.seed(3)
813: (20)                               boxes = VGroup(*[
814: (24)                                   Rectangle(WHITE, np.random.random()+.5, np.random.random()+.5).add(Text(str(i+1)).scale(0.5))
815: (24)                                   for i in range(22)
816: (20)                               ])
817: (20)                               self.add(boxes)
818: (20)                               boxes.arrange_in_grid(
819: (24)                                   buff=(0.25,0.5),
820: (24)                                   col_alignments="lccccr",
821: (24)                                   row_alignments="uccd",
822: (24)                                   col_widths=[2, *[None]*4, 2],
823: (24)                                   flow_order="dr"
824: (20)                               )
825: (8)                    """
826: (8)                    from manim.mobject.geometry.line import Line
827: (8)                    mobs = self.submobjects.copy()
828: (8)                    start_pos = self.get_center()
829: (8)                    # get cols / rows values if given (implicitly)
830: (8)                    def init_size(num, alignments, sizes):
831: (12)                       if num is not None:
832: (16)                           return num
833: (12)                       if alignments is not None:
834: (16)                           return len(alignments)
835: (12)                       if sizes is not None:
836: (16)                           return len(sizes)
837: (8)                    cols = init_size(cols, col_alignments, col_widths)
838: (8)                    rows = init_size(rows, row_alignments, row_heights)
839: (8)                    # calculate rows cols
840: (8)                    if rows is None and cols is None:
841: (12)                       cols = ceil(np.sqrt(len(mobs)))
842: (12)                       # make the grid as close to quadratic as possible.
843: (12)                       # choosing cols first can results in cols>rows.
844: (12)                       # This is favored over rows>cols since in general
845: (12)                       # the sceene is wider than high.
846: (8)                    if rows is None:
847: (12)                       rows = ceil(len(mobs) / cols)
848: (8)                    if cols is None:
849: (12)                       cols = ceil(len(mobs) / rows)
850: (8)                    if rows * cols < len(mobs):
851: (12)                       raise ValueError("Too few rows and columns to fit all submobjetcs.")
852: (8)                    # rows and cols are now finally valid.
853: (8)                    if isinstance(buff, tuple):
854: (12)                       buff_x = buff[0]
855: (12)                       buff_y = buff[1]
856: (8)                    else:
857: (12)                       buff_x = buff_y = buff
858: (8)                    # Initialize alignments correctly
859: (8)                    def init_alignments(alignments, num, mapping, name, dir):
860: (12)                       if alignments is None:
861: (16)                           # Use cell_alignment as fallback
862: (16)                           return [cell_alignment * dir] * num
863: (12)                       if len(alignments) != num:
864: (16)                           raise ValueError(f"{name}_alignments has a mismatching size.")
865: (12)                       alignments = list(alignments)
866: (12)                       for i in range(num):
867: (16)                           alignments[i] = mapping[alignments[i]]
868: (12)                       return alignments
869: (8)                    row_alignments = init_alignments(
870: (12)                       row_alignments,
871: (12)                       rows,
872: (12)                       {"u": UP, "c": ORIGIN, "d": DOWN},
873: (12)                       "row",
874: (12)                       RIGHT,
875: (8)                    )
876: (8)                    col_alignments = init_alignments(
877: (12)                       col_alignments,
878: (12)                       cols,
879: (12)                       {"l": LEFT, "c": ORIGIN, "r": RIGHT},
880: (12)                       "col",
881: (12)                       UP,
882: (8)                    )
883: (8)                    # Now row_alignment[r] + col_alignment[c] is the alignment in cell [r][c]
884: (8)                    mapper = {
885: (12)                       "dr": lambda r, c: (rows - r - 1) + c * rows,
886: (12)                       "dl": lambda r, c: (rows - r - 1) + (cols - c - 1) * rows,
887: (12)                       "ur": lambda r, c: r + c * rows,
888: (12)                       "ul": lambda r, c: r + (cols - c - 1) * rows,
889: (12)                       "rd": lambda r, c: (rows - r - 1) * cols + c,
890: (12)                       "ld": lambda r, c: (rows - r - 1) * cols + (cols - c - 1),
891: (12)                       "ru": lambda r, c: r * cols + c,
892: (12)                       "lu": lambda r, c: r * cols + (cols - c - 1),
893: (8)                    }
894: (8)                    if flow_order not in mapper:
895: (12)                       raise ValueError(
896: (16)                           'flow_order must be one of the following values: "dr", "rd", "ld" "dl", "ru", "ur", "lu", "ul".',
897: (12)                       )
898: (8)                    flow_order = mapper[flow_order]
899: (8)                    # Reverse row_alignments and row_heights. Necessary since the
900: (8)                    # grid filling is handled bottom up for simplicity reasons.
901: (8)                    def reverse(maybe_list):
902: (12)                       if maybe_list is not None:
903: (16)                           maybe_list = list(maybe_list)
904: (16)                           maybe_list.reverse()
905: (16)                           return maybe_list
906: (8)                    row_alignments = reverse(row_alignments)
907: (8)                    row_heights = reverse(row_heights)
908: (8)                    placeholder = OpenGLMobject()
909: (8)                    # Used to fill up the grid temporarily, doesn't get added to the scene.
910: (8)                    # In this case a Mobject is better than None since it has width and height
911: (8)                    # properties of 0.
912: (8)                    mobs.extend([placeholder] * (rows * cols - len(mobs)))
913: (8)                    grid = [[mobs[flow_order(r, c)] for c in range(cols)] for r in range(rows)]
914: (8)                    measured_heigths = [
915: (12)                       max(grid[r][c].height for c in range(cols)) for r in range(rows)
916: (8)                    ]
917: (8)                    measured_widths = [
918: (12)                       max(grid[r][c].width for r in range(rows)) for c in range(cols)
919: (8)                    ]
920: (8)                    # Initialize row_heights / col_widths correctly using measurements as fallback
921: (8)                    def init_sizes(sizes, num, measures, name):
922: (12)                       if sizes is None:
923: (16)                           sizes = [None] * num
924: (12)                       if len(sizes) != num:
925: (16)                           raise ValueError(f"{name} has a mismatching size.")
926: (12)                       return [
927: (16)                           sizes[i] if sizes[i] is not None else measures[i] for i in range(num)
928: (12)                       ]
929: (8)                    heights = init_sizes(row_heights, rows, measured_heigths, "row_heights")
930: (8)                    widths = init_sizes(col_widths, cols, measured_widths, "col_widths")
931: (8)                    x, y = 0, 0
932: (8)                    for r in range(rows):
933: (12)                       x = 0
934: (12)                       for c in range(cols):
935: (16)                           if grid[r][c] is not placeholder:
936: (20)                               alignment = row_alignments[r] + col_alignments[c]
937: (20)                               line = Line(
938: (24)                                   x * RIGHT + y * UP,
939: (24)                                   (x + widths[c]) * RIGHT + (y + heights[r]) * UP,
940: (20)                               )
941: (20)                               # Use a mobject to avoid rewriting align inside
942: (20)                               # box code that Mobject.move_to(Mobject) already
943: (20)                               # includes.
944: (20)                               grid[r][c].move_to(line, alignment)
945: (16)                           x += widths[c] + buff_x
946: (12)                       y += heights[r] + buff_y
947: (8)                    self.move_to(start_pos)
948: (8)                    return self
949: (4)                def get_grid(self, n_rows, n_cols, height=None, **kwargs):
950: (8)                    """
951: (8)                    Returns a new mobject containing multiple copies of this one
952: (8)                    arranged in a grid
953: (8)                    """
954: (8)                    grid = self.duplicate(n_rows * n_cols)
955: (8)                    grid.arrange_in_grid(n_rows, n_cols, **kwargs)
956: (8)                    if height is not None:
957: (12)                       grid.set_height(height)
958: (8)                    return grid
959: (4)                def duplicate(self, n: int):
960: (8)                    """Returns an :class:`~.OpenGLVGroup` containing ``n`` copies of the mobject."""
961: (8)                    return self.get_group_class()(*[self.copy() for _ in range(n)])
962: (4)                def sort(self, point_to_num_func=lambda p: p[0], submob_func=None):
963: (8)                    """Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``."""
964: (8)                    if submob_func is not None:
965: (12)                       self.submobjects.sort(key=submob_func)
966: (8)                    else:
967: (12)                       self.submobjects.sort(key=lambda m: point_to_num_func(m.get_center()))
968: (8)                    return self
969: (4)                def shuffle(self, recurse=False):
970: (8)                    """Shuffles the order of :attr:`submobjects`
971: (8)                    Examples
972: (8)                    --------
973: (8)                    .. manim:: ShuffleSubmobjectsExample
974: (12)                       class ShuffleSubmobjectsExample(Scene):
975: (16)                           def construct(self):
976: (20)                               s= OpenGLVGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
977: (20)                               s2= s.copy()
978: (20)                               s2.shuffle()
979: (20)                               s2.shift(DOWN)
980: (20)                               self.play(Write(s), Write(s2))
981: (8)                    """
982: (8)                    if recurse:
983: (12)                       for submob in self.submobjects:
984: (16)                           submob.shuffle(recurse=True)
985: (8)                    random.shuffle(self.submobjects)
986: (8)                    self.assemble_family()
987: (8)                    return self
988: (4)                def invert(self, recursive=False):
989: (8)                    """Inverts the list of :attr:`submobjects`.
990: (8)                    Parameters
991: (8)                    ----------
992: (8)                    recursive
993: (12)                       If ``True``, all submobject lists of this mobject's family are inverted.
994: (8)                    Examples
995: (8)                    --------
996: (8)                    .. manim:: InvertSumobjectsExample
997: (12)                       class InvertSumobjectsExample(Scene):
998: (16)                           def construct(self):
999: (20)                               s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
1000: (20)                              s2 = s.copy()
1001: (20)                              s2.invert()
1002: (20)                              s2.shift(DOWN)
1003: (20)                              self.play(Write(s), Write(s2))
1004: (8)                   """
1005: (8)                   if recursive:
1006: (12)                      for submob in self.submobjects:
1007: (16)                          submob.invert(recursive=True)
1008: (8)                   list.reverse(self.submobjects)
1009: (4)               # Copying
1010: (4)               def copy(self, shallow: bool = False):
1011: (8)                   """Create and return an identical copy of the :class:`OpenGLMobject` including all
1012: (8)                   :attr:`submobjects`.
1013: (8)                   Returns
1014: (8)                   -------
1015: (8)                   :class:`OpenGLMobject`
1016: (12)                      The copy.
1017: (8)                   Parameters
1018: (8)                   ----------
1019: (8)                   shallow
1020: (12)                      Controls whether a shallow copy is returned.
1021: (8)                   Note
1022: (8)                   ----
1023: (8)                   The clone is initially not visible in the Scene, even if the original was.
1024: (8)                   """
1025: (8)                   if not shallow:
1026: (12)                      return self.deepcopy()
1027: (8)                   # TODO, either justify reason for shallow copy, or
1028: (8)                   # remove this redundancy everywhere
1029: (8)                   # return self.deepcopy()
1030: (8)                   parents = self.parents
1031: (8)                   self.parents = []
1032: (8)                   copy_mobject = copy.copy(self)
1033: (8)                   self.parents = parents
1034: (8)                   copy_mobject.data = dict(self.data)
1035: (8)                   for key in self.data:
1036: (12)                      copy_mobject.data[key] = self.data[key].copy()
1037: (8)                   # TODO, are uniforms ever numpy arrays?
1038: (8)                   copy_mobject.uniforms = dict(self.uniforms)
1039: (8)                   copy_mobject.submobjects = []
1040: (8)                   copy_mobject.add(*(sm.copy() for sm in self.submobjects))
1041: (8)                   copy_mobject.match_updaters(self)
1042: (8)                   copy_mobject.needs_new_bounding_box = self.needs_new_bounding_box
1043: (8)                   # Make sure any mobject or numpy array attributes are copied
1044: (8)                   family = self.get_family()
1045: (8)                   for attr, value in list(self.__dict__.items()):
1046: (12)                      if (
1047: (16)                          isinstance(value, OpenGLMobject)
1048: (16)                          and value in family
1049: (16)                          and value is not self
1050: (12)                      ):
1051: (16)                          setattr(copy_mobject, attr, value.copy())
1052: (12)                      if isinstance(value, np.ndarray):
1053: (16)                          setattr(copy_mobject, attr, value.copy())
1054: (12)                      # if isinstance(value, ShaderWrapper):
1055: (12)                      #     setattr(copy_mobject, attr, value.copy())
1056: (8)                   return copy_mobject
1057: (4)               def deepcopy(self):
1058: (8)                   parents = self.parents
1059: (8)                   self.parents = []
1060: (8)                   result = copy.deepcopy(self)
1061: (8)                   self.parents = parents
1062: (8)                   return result
1063: (4)               def generate_target(self, use_deepcopy: bool = False):
1064: (8)                   self.target = None  # Prevent exponential explosion
1065: (8)                   if use_deepcopy:
1066: (12)                      self.target = self.deepcopy()
1067: (8)                   else:
1068: (12)                      self.target = self.copy()
1069: (8)                   return self.target
1070: (4)               def save_state(self, use_deepcopy: bool = False):
1071: (8)                   """Save the current state (position, color & size). Can be restored with :meth:`~.OpenGLMobject.restore`."""
1072: (8)                   if hasattr(self, "saved_state"):
1073: (12)                      # Prevent exponential growth of data
1074: (12)                      self.saved_state = None
1075: (8)                   if use_deepcopy:
1076: (12)                      self.saved_state = self.deepcopy()
1077: (8)                   else:
1078: (12)                      self.saved_state = self.copy()
1079: (8)                   return self
1080: (4)               def restore(self):
1081: (8)                   """Restores the state that was previously saved with :meth:`~.OpenGLMobject.save_state`."""
1082: (8)                   if not hasattr(self, "saved_state") or self.save_state is None:
1083: (12)                      raise Exception("Trying to restore without having saved")
1084: (8)                   self.become(self.saved_state)
1085: (8)                   return self
1086: (4)               # Updating
1087: (4)               def init_updaters(self):
1088: (8)                   self.time_based_updaters = []
1089: (8)                   self.non_time_updaters = []
1090: (8)                   self.has_updaters = False
1091: (8)                   self.updating_suspended = False
1092: (4)               def update(self, dt=0, recurse=True):
1093: (8)                   if not self.has_updaters or self.updating_suspended:
1094: (12)                      return self
1095: (8)                   for updater in self.time_based_updaters:
1096: (12)                      updater(self, dt)
1097: (8)                   for updater in self.non_time_updaters:
1098: (12)                      updater(self)
1099: (8)                   if recurse:
1100: (12)                      for submob in self.submobjects:
1101: (16)                          submob.update(dt, recurse)
1102: (8)                   return self
1103: (4)               def get_time_based_updaters(self):
1104: (8)                   return self.time_based_updaters
1105: (4)               def has_time_based_updater(self):
1106: (8)                   return len(self.time_based_updaters) > 0
1107: (4)               def get_updaters(self):
1108: (8)                   return self.time_based_updaters + self.non_time_updaters
1109: (4)               def get_family_updaters(self):
1110: (8)                   return list(it.chain(*(sm.get_updaters() for sm in self.get_family())))
1111: (4)               def add_updater(self, update_function, index=None, call_updater=False):
1112: (8)                   if "dt" in inspect.signature(update_function).parameters:
1113: (12)                      updater_list = self.time_based_updaters
1114: (8)                   else:
1115: (12)                      updater_list = self.non_time_updaters
1116: (8)                   if index is None:
1117: (12)                      updater_list.append(update_function)
1118: (8)                   else:
1119: (12)                      updater_list.insert(index, update_function)
1120: (8)                   self.refresh_has_updater_status()
1121: (8)                   if call_updater:
1122: (12)                      self.update()
1123: (8)                   return self
1124: (4)               def remove_updater(self, update_function):
1125: (8)                   for updater_list in [self.time_based_updaters, self.non_time_updaters]:
1126: (12)                      while update_function in updater_list:
1127: (16)                          updater_list.remove(update_function)
1128: (8)                   self.refresh_has_updater_status()
1129: (8)                   return self
1130: (4)               def clear_updaters(self, recurse=True):
1131: (8)                   self.time_based_updaters = []
1132: (8)                   self.non_time_updaters = []
1133: (8)                   self.refresh_has_updater_status()
1134: (8)                   if recurse:
1135: (12)                      for submob in self.submobjects:
1136: (16)                          submob.clear_updaters()
1137: (8)                   return self
1138: (4)               def match_updaters(self, mobject):
1139: (8)                   self.clear_updaters()
1140: (8)                   for updater in mobject.get_updaters():
1141: (12)                      self.add_updater(updater)
1142: (8)                   return self
1143: (4)               def suspend_updating(self, recurse=True):
1144: (8)                   self.updating_suspended = True
1145: (8)                   if recurse:
1146: (12)                      for submob in self.submobjects:
1147: (16)                          submob.suspend_updating(recurse)
1148: (8)                   return self
1149: (4)               def resume_updating(self, recurse=True, call_updater=True):
1150: (8)                   self.updating_suspended = False
1151: (8)                   if recurse:
1152: (12)                      for submob in self.submobjects:
1153: (16)                          submob.resume_updating(recurse)
1154: (8)                   for parent in self.parents:
1155: (12)                      parent.resume_updating(recurse=False, call_updater=False)
1156: (8)                   if call_updater:
1157: (12)                      self.update(dt=0, recurse=recurse)
1158: (8)                   return self
1159: (4)               def refresh_has_updater_status(self):
1160: (8)                   self.has_updaters = any(mob.get_updaters() for mob in self.get_family())
1161: (8)                   return self
1162: (4)               # Transforming operations
1163: (4)               def shift(self, vector):
1164: (8)                   self.apply_points_function(
1165: (12)                      lambda points: points + vector,
1166: (12)                      about_edge=None,
1167: (12)                      works_on_bounding_box=True,
1168: (8)                   )
1169: (8)                   return self
1170: (4)               def scale(
1171: (8)                   self,
1172: (8)                   scale_factor: float,
1173: (8)                   about_point: Sequence[float] | None = None,
1174: (8)                   about_edge: Sequence[float] = ORIGIN,
1175: (8)                   **kwargs,
1176: (4)               ) -> OpenGLMobject:
1177: (8)                   r"""Scale the size by a factor.
1178: (8)                   Default behavior is to scale about the center of the mobject.
1179: (8)                   The argument about_edge can be a vector, indicating which side of
1180: (8)                   the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)
1181: (8)                   scales about mob.get_right().
1182: (8)                   Otherwise, if about_point is given a value, scaling is done with
1183: (8)                   respect to that point.
1184: (8)                   Parameters
1185: (8)                   ----------
1186: (8)                   scale_factor
1187: (12)                      The scaling factor :math:`\alpha`. If :math:`0 < |\alpha| < 1`, the mobject
1188: (12)                      will shrink, and for :math:`|\alpha| > 1` it will grow. Furthermore,
1189: (12)                      if :math:`\alpha < 0`, the mobject is also flipped.
1190: (8)                   kwargs
1191: (12)                      Additional keyword arguments passed to
1192: (12)                      :meth:`apply_points_function_about_point`.
1193: (8)                   Returns
1194: (8)                   -------
1195: (8)                   OpenGLMobject
1196: (12)                      The scaled mobject.
1197: (8)                   Examples
1198: (8)                   --------
1199: (8)                   .. manim:: MobjectScaleExample
1200: (12)                      :save_last_frame:
1201: (12)                      class MobjectScaleExample(Scene):
1202: (16)                          def construct(self):
1203: (20)                              f1 = Text("F")
1204: (20)                              f2 = Text("F").scale(2)
1205: (20)                              f3 = Text("F").scale(0.5)
1206: (20)                              f4 = Text("F").scale(-1)
1207: (20)                              vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)
1208: (20)                              self.add(vgroup)
1209: (8)                   See also
1210: (8)                   --------
1211: (8)                   :meth:`move_to`
1212: (8)                   """
1213: (8)                   self.apply_points_function(
1214: (12)                      lambda points: scale_factor * points,
1215: (12)                      about_point=about_point,
1216: (12)                      about_edge=about_edge,
1217: (12)                      works_on_bounding_box=True,
1218: (12)                      **kwargs,
1219: (8)                   )
1220: (8)                   return self
1221: (4)               def stretch(self, factor, dim, **kwargs):
1222: (8)                   def func(points):
1223: (12)                      points[:, dim] *= factor
1224: (12)                      return points
1225: (8)                   self.apply_points_function(func, works_on_bounding_box=True, **kwargs)
1226: (8)                   return self
1227: (4)               def rotate_about_origin(self, angle, axis=OUT):
1228: (8)                   return self.rotate(angle, axis, about_point=ORIGIN)
1229: (4)               def rotate(
1230: (8)                   self,
1231: (8)                   angle,
1232: (8)                   axis=OUT,
1233: (8)                   about_point: Sequence[float] | None = None,
1234: (8)                   **kwargs,
1235: (4)               ):
1236: (8)                   """Rotates the :class:`~.OpenGLMobject` about a certain point."""
1237: (8)                   rot_matrix_T = rotation_matrix_transpose(angle, axis)
1238: (8)                   self.apply_points_function(
1239: (12)                      lambda points: np.dot(points, rot_matrix_T),
1240: (12)                      about_point=about_point,
1241: (12)                      **kwargs,
1242: (8)                   )
1243: (8)                   return self
1244: (4)               def flip(self, axis=UP, **kwargs):
1245: (8)                   """Flips/Mirrors an mobject about its center.
1246: (8)                   Examples
1247: (8)                   --------
1248: (8)                   .. manim:: FlipExample
1249: (12)                      :save_last_frame:
1250: (12)                      class FlipExample(Scene):
1251: (16)                          def construct(self):
1252: (20)                              s= Line(LEFT, RIGHT+UP).shift(4*LEFT)
1253: (20)                              self.add(s)
1254: (20)                              s2= s.copy().flip()
1255: (20)                              self.add(s2)
1256: (8)                   """
1257: (8)                   return self.rotate(TAU / 2, axis, **kwargs)
1258: (4)               def apply_function(self, function, **kwargs):
1259: (8)                   # Default to applying matrix about the origin, not mobjects center
1260: (8)                   if len(kwargs) == 0:
1261: (12)                      kwargs["about_point"] = ORIGIN
1262: (8)                   self.apply_points_function(
1263: (12)                      lambda points: np.array([function(p) for p in points]), **kwargs
1264: (8)                   )
1265: (8)                   return self
1266: (4)               def apply_function_to_position(self, function):
1267: (8)                   self.move_to(function(self.get_center()))
1268: (8)                   return self
1269: (4)               def apply_function_to_submobject_positions(self, function):
1270: (8)                   for submob in self.submobjects:
1271: (12)                      submob.apply_function_to_position(function)
1272: (8)                   return self
1273: (4)               def apply_matrix(self, matrix, **kwargs):
1274: (8)                   # Default to applying matrix about the origin, not mobjects center
1275: (8)                   if ("about_point" not in kwargs) and ("about_edge" not in kwargs):
1276: (12)                      kwargs["about_point"] = ORIGIN
1277: (8)                   full_matrix = np.identity(self.dim)
1278: (8)                   matrix = np.array(matrix)
1279: (8)                   full_matrix[: matrix.shape[0], : matrix.shape[1]] = matrix
1280: (8)                   self.apply_points_function(
1281: (12)                      lambda points: np.dot(points, full_matrix.T), **kwargs
1282: (8)                   )
1283: (8)                   return self
1284: (4)               def apply_complex_function(self, function, **kwargs):
1285: (8)                   """Applies a complex function to a :class:`OpenGLMobject`.
1286: (8)                   The x and y coordinates correspond to the real and imaginary parts respectively.
1287: (8)                   Example
1288: (8)                   -------
1289: (8)                   .. manim:: ApplyFuncExample
1290: (12)                      class ApplyFuncExample(Scene):
1291: (16)                          def construct(self):
1292: (20)                              circ = Circle().scale(1.5)
1293: (20)                              circ_ref = circ.copy()
1294: (20)                              circ.apply_complex_function(
1295: (24)                                  lambda x: np.exp(x*1j)
1296: (20)                              )
1297: (20)                              t = ValueTracker(0)
1298: (20)                              circ.add_updater(
1299: (24)                                  lambda x: x.become(circ_ref.copy().apply_complex_function(
1300: (28)                                      lambda x: np.exp(x+t.get_value()*1j)
1301: (24)                                  )).set_color(BLUE)
1302: (20)                              )
1303: (20)                              self.add(circ_ref)
1304: (20)                              self.play(TransformFromCopy(circ_ref, circ))
1305: (20)                              self.play(t.animate.set_value(TAU), run_time=3)
1306: (8)                   """
1307: (8)                   def R3_func(point):
1308: (12)                      x, y, z = point
1309: (12)                      xy_complex = function(complex(x, y))
1310: (12)                      return [xy_complex.real, xy_complex.imag, z]
1311: (8)                   return self.apply_function(R3_func)
1312: (4)               def hierarchical_model_matrix(self):
1313: (8)                   if self.parent is None:
1314: (12)                      return self.model_matrix
1315: (8)                   model_matrices = [self.model_matrix]
1316: (8)                   current_object = self
1317: (8)                   while current_object.parent is not None:
1318: (12)                      model_matrices.append(current_object.parent.model_matrix)
1319: (12)                      current_object = current_object.parent
1320: (8)                   return np.linalg.multi_dot(list(reversed(model_matrices)))
1321: (4)               def wag(self, direction=RIGHT, axis=DOWN, wag_factor=1.0):
1322: (8)                   for mob in self.family_members_with_points():
1323: (12)                      alphas = np.dot(mob.points, np.transpose(axis))
1324: (12)                      alphas -= min(alphas)
1325: (12)                      alphas /= max(alphas)
1326: (12)                      alphas = alphas**wag_factor
1327: (12)                      mob.set_points(
1328: (16)                          mob.points
1329: (16)                          + np.dot(
1330: (20)                              alphas.reshape((len(alphas), 1)),
1331: (20)                              np.array(direction).reshape((1, mob.dim)),
1332: (16)                          ),
1333: (12)                      )
1334: (8)                   return self
1335: (4)               # Positioning methods
1336: (4)               def center(self):
1337: (8)                   """Moves the mobject to the center of the Scene."""
1338: (8)                   self.shift(-self.get_center())
1339: (8)                   return self
1340: (4)               def align_on_border(self, direction, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
1341: (8)                   """
1342: (8)                   Direction just needs to be a vector pointing towards side or
1343: (8)                   corner in the 2d plane.
1344: (8)                   """
1345: (8)                   target_point = np.sign(direction) * (
1346: (12)                      config["frame_x_radius"],
1347: (12)                      config["frame_y_radius"],
1348: (12)                      0,
1349: (8)                   )
1350: (8)                   point_to_align = self.get_bounding_box_point(direction)
1351: (8)                   shift_val = target_point - point_to_align - buff * np.array(direction)
1352: (8)                   shift_val = shift_val * abs(np.sign(direction))
1353: (8)                   self.shift(shift_val)
1354: (8)                   return self
1355: (4)               def to_corner(self, corner=LEFT + DOWN, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
1356: (8)                   return self.align_on_border(corner, buff)
1357: (4)               def to_edge(self, edge=LEFT, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):
1358: (8)                   return self.align_on_border(edge, buff)
1359: (4)               def next_to(
1360: (8)                   self,
1361: (8)                   mobject_or_point,
1362: (8)                   direction=RIGHT,
1363: (8)                   buff=DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,
1364: (8)                   aligned_edge=ORIGIN,
1365: (8)                   submobject_to_align=None,
1366: (8)                   index_of_submobject_to_align=None,
1367: (8)                   coor_mask=np.array([1, 1, 1]),
1368: (4)               ):
1369: (8)                   """Move this :class:`~.OpenGLMobject` next to another's :class:`~.OpenGLMobject` or coordinate.
1370: (8)                   Examples
1371: (8)                   --------
1372: (8)                   .. manim:: GeometricShapes
1373: (12)                      :save_last_frame:
1374: (12)                      class GeometricShapes(Scene):
1375: (16)                          def construct(self):
1376: (20)                              d = Dot()
1377: (20)                              c = Circle()
1378: (20)                              s = Square()
1379: (20)                              t = Triangle()
1380: (20)                              d.next_to(c, RIGHT)
1381: (20)                              s.next_to(c, LEFT)
1382: (20)                              t.next_to(c, DOWN)
1383: (20)                              self.add(d, c, s, t)
1384: (8)                   """
1385: (8)                   if isinstance(mobject_or_point, OpenGLMobject):
1386: (12)                      mob = mobject_or_point
1387: (12)                      if index_of_submobject_to_align is not None:
1388: (16)                          target_aligner = mob[index_of_submobject_to_align]
1389: (12)                      else:
1390: (16)                          target_aligner = mob
1391: (12)                      target_point = target_aligner.get_bounding_box_point(
1392: (16)                          aligned_edge + direction,
1393: (12)                      )
1394: (8)                   else:
1395: (12)                      target_point = mobject_or_point
1396: (8)                   if submobject_to_align is not None:
1397: (12)                      aligner = submobject_to_align
1398: (8)                   elif index_of_submobject_to_align is not None:
1399: (12)                      aligner = self[index_of_submobject_to_align]
1400: (8)                   else:
1401: (12)                      aligner = self
1402: (8)                   point_to_align = aligner.get_bounding_box_point(aligned_edge - direction)
1403: (8)                   self.shift((target_point - point_to_align + buff * direction) * coor_mask)
1404: (8)                   return self
1405: (4)               def shift_onto_screen(self, **kwargs):
1406: (8)                   space_lengths = [config["frame_x_radius"], config["frame_y_radius"]]
1407: (8)                   for vect in UP, DOWN, LEFT, RIGHT:
1408: (12)                      dim = np.argmax(np.abs(vect))
1409: (12)                      buff = kwargs.get("buff", DEFAULT_MOBJECT_TO_EDGE_BUFFER)
1410: (12)                      max_val = space_lengths[dim] - buff
1411: (12)                      edge_center = self.get_edge_center(vect)
1412: (12)                      if np.dot(edge_center, vect) > max_val:
1413: (16)                          self.to_edge(vect, **kwargs)
1414: (8)                   return self
1415: (4)               def is_off_screen(self):
1416: (8)                   if self.get_left()[0] > config.frame_x_radius:
1417: (12)                      return True
1418: (8)                   if self.get_right()[0] < config.frame_x_radius:
1419: (12)                      return True
1420: (8)                   if self.get_bottom()[1] > config.frame_y_radius:
1421: (12)                      return True
1422: (8)                   if self.get_top()[1] < -config.frame_y_radius:
1423: (12)                      return True
1424: (8)                   return False
1425: (4)               def stretch_about_point(self, factor, dim, point):
1426: (8)                   return self.stretch(factor, dim, about_point=point)
1427: (4)               def rescale_to_fit(self, length, dim, stretch=False, **kwargs):
1428: (8)                   old_length = self.length_over_dim(dim)
1429: (8)                   if old_length == 0:
1430: (12)                      return self
1431: (8)                   if stretch:
1432: (12)                      self.stretch(length / old_length, dim, **kwargs)
1433: (8)                   else:
1434: (12)                      self.scale(length / old_length, **kwargs)
1435: (8)                   return self
1436: (4)               def stretch_to_fit_width(self, width, **kwargs):
1437: (8)                   """Stretches the :class:`~.OpenGLMobject` to fit a width, not keeping height/depth proportional.
1438: (8)                   Returns
1439: (8)                   -------
1440: (8)                   :class:`OpenGLMobject`
1441: (12)                      ``self``
1442: (8)                   Examples
1443: (8)                   --------
1444: (8)                   ::
1445: (12)                      >>> from manim import *
1446: (12)                      >>> sq = Square()
1447: (12)                      >>> sq.height
1448: (12)                      2.0
1449: (12)                      >>> sq.stretch_to_fit_width(5)
1450: (12)                      Square
1451: (12)                      >>> sq.width
1452: (12)                      5.0
1453: (12)                      >>> sq.height
1454: (12)                      2.0
1455: (8)                   """
1456: (8)                   return self.rescale_to_fit(width, 0, stretch=True, **kwargs)
1457: (4)               def stretch_to_fit_height(self, height, **kwargs):
1458: (8)                   """Stretches the :class:`~.OpenGLMobject` to fit a height, not keeping width/height proportional."""
1459: (8)                   return self.rescale_to_fit(height, 1, stretch=True, **kwargs)
1460: (4)               def stretch_to_fit_depth(self, depth, **kwargs):
1461: (8)                   """Stretches the :class:`~.OpenGLMobject` to fit a depth, not keeping width/height proportional."""
1462: (8)                   return self.rescale_to_fit(depth, 1, stretch=True, **kwargs)
1463: (4)               def set_width(self, width, stretch=False, **kwargs):
1464: (8)                   """Scales the :class:`~.OpenGLMobject` to fit a width while keeping height/depth proportional.
1465: (8)                   Returns
1466: (8)                   -------
1467: (8)                   :class:`OpenGLMobject`
1468: (12)                      ``self``
1469: (8)                   Examples
1470: (8)                   --------
1471: (8)                   ::
1472: (12)                      >>> from manim import *
1473: (12)                      >>> sq = Square()
1474: (12)                      >>> sq.height
1475: (12)                      2.0
1476: (12)                      >>> sq.scale_to_fit_width(5)
1477: (12)                      Square
1478: (12)                      >>> sq.width
1479: (12)                      5.0
1480: (12)                      >>> sq.height
1481: (12)                      5.0
1482: (8)                   """
1483: (8)                   return self.rescale_to_fit(width, 0, stretch=stretch, **kwargs)
1484: (4)               scale_to_fit_width = set_width
1485: (4)               def set_height(self, height, stretch=False, **kwargs):
1486: (8)                   """Scales the :class:`~.OpenGLMobject` to fit a height while keeping width/depth proportional."""
1487: (8)                   return self.rescale_to_fit(height, 1, stretch=stretch, **kwargs)
1488: (4)               scale_to_fit_height = set_height
1489: (4)               def set_depth(self, depth, stretch=False, **kwargs):
1490: (8)                   """Scales the :class:`~.OpenGLMobject` to fit a depth while keeping width/height proportional."""
1491: (8)                   return self.rescale_to_fit(depth, 2, stretch=stretch, **kwargs)
1492: (4)               scale_to_fit_depth = set_depth
1493: (4)               def set_coord(self, value, dim, direction=ORIGIN):
1494: (8)                   curr = self.get_coord(dim, direction)
1495: (8)                   shift_vect = np.zeros(self.dim)
1496: (8)                   shift_vect[dim] = value - curr
1497: (8)                   self.shift(shift_vect)
1498: (8)                   return self
1499: (4)               def set_x(self, x, direction=ORIGIN):
1500: (8)                   """Set x value of the center of the :class:`~.OpenGLMobject` (``int`` or ``float``)"""
1501: (8)                   return self.set_coord(x, 0, direction)
1502: (4)               def set_y(self, y, direction=ORIGIN):
1503: (8)                   """Set y value of the center of the :class:`~.OpenGLMobject` (``int`` or ``float``)"""
1504: (8)                   return self.set_coord(y, 1, direction)
1505: (4)               def set_z(self, z, direction=ORIGIN):
1506: (8)                   """Set z value of the center of the :class:`~.OpenGLMobject` (``int`` or ``float``)"""
1507: (8)                   return self.set_coord(z, 2, direction)
1508: (4)               def space_out_submobjects(self, factor=1.5, **kwargs):
1509: (8)                   self.scale(factor, **kwargs)
1510: (8)                   for submob in self.submobjects:
1511: (12)                      submob.scale(1.0 / factor)
1512: (8)                   return self
1513: (4)               def move_to(
1514: (8)                   self,
1515: (8)                   point_or_mobject,
1516: (8)                   aligned_edge=ORIGIN,
1517: (8)                   coor_mask=np.array([1, 1, 1]),
1518: (4)               ):
1519: (8)                   """Move center of the :class:`~.OpenGLMobject` to certain coordinate."""
1520: (8)                   if isinstance(point_or_mobject, OpenGLMobject):
1521: (12)                      target = point_or_mobject.get_bounding_box_point(aligned_edge)
1522: (8)                   else:
1523: (12)                      target = point_or_mobject
1524: (8)                   point_to_align = self.get_bounding_box_point(aligned_edge)
1525: (8)                   self.shift((target - point_to_align) * coor_mask)
1526: (8)                   return self
1527: (4)               def replace(self, mobject, dim_to_match=0, stretch=False):
1528: (8)                   if not mobject.get_num_points() and not mobject.submobjects:
1529: (12)                      self.scale(0)
1530: (12)                      return self
1531: (8)                   if stretch:
1532: (12)                      for i in range(self.dim):
1533: (16)                          self.rescale_to_fit(mobject.length_over_dim(i), i, stretch=True)
1534: (8)                   else:
1535: (12)                      self.rescale_to_fit(
1536: (16)                          mobject.length_over_dim(dim_to_match),
1537: (16)                          dim_to_match,
1538: (16)                          stretch=False,
1539: (12)                      )
1540: (8)                   self.shift(mobject.get_center() - self.get_center())
1541: (8)                   return self
1542: (4)               def surround(
1543: (8)                   self,
1544: (8)                   mobject: OpenGLMobject,
1545: (8)                   dim_to_match: int = 0,
1546: (8)                   stretch: bool = False,
1547: (8)                   buff: float = MED_SMALL_BUFF,
1548: (4)               ):
1549: (8)                   self.replace(mobject, dim_to_match, stretch)
1550: (8)                   length = mobject.length_over_dim(dim_to_match)
1551: (8)                   self.scale((length + buff) / length)
1552: (8)                   return self
1553: (4)               def put_start_and_end_on(self, start, end):
1554: (8)                   curr_start, curr_end = self.get_start_and_end()
1555: (8)                   curr_vect = curr_end - curr_start
1556: (8)                   if np.all(curr_vect == 0):
1557: (12)                      raise Exception("Cannot position endpoints of closed loop")
1558: (8)                   target_vect = np.array(end) - np.array(start)
1559: (8)                   axis = (
1560: (12)                      normalize(np.cross(curr_vect, target_vect))
1561: (12)                      if np.linalg.norm(np.cross(curr_vect, target_vect)) != 0
1562: (12)                      else OUT
1563: (8)                   )
1564: (8)                   self.scale(
1565: (12)                      np.linalg.norm(target_vect) / np.linalg.norm(curr_vect),
1566: (12)                      about_point=curr_start,
1567: (8)                   )
1568: (8)                   self.rotate(
1569: (12)                      angle_between_vectors(curr_vect, target_vect),
1570: (12)                      about_point=curr_start,
1571: (12)                      axis=axis,
1572: (8)                   )
1573: (8)                   self.shift(start - curr_start)
1574: (8)                   return self
1575: (4)               # Color functions
1576: (4)               def set_rgba_array(self, color=None, opacity=None, name="rgbas", recurse=True):
1577: (8)                   if color is not None:
1578: (12)                      rgbs = np.array([color_to_rgb(c) for c in listify(color)])
1579: (8)                   if opacity is not None:
1580: (12)                      opacities = listify(opacity)
1581: (8)                   # Color only
1582: (8)                   if color is not None and opacity is None:
1583: (12)                      for mob in self.get_family(recurse):
1584: (16)                          mob.data[name] = resize_array(
1585: (20)                              mob.data[name] if name in mob.data else np.empty((1, 3)), len(rgbs)
1586: (16)                          )
1587: (16)                          mob.data[name][:, :3] = rgbs
1588: (8)                   # Opacity only
1589: (8)                   if color is None and opacity is not None:
1590: (12)                      for mob in self.get_family(recurse):
1591: (16)                          mob.data[name] = resize_array(
1592: (20)                              mob.data[name] if name in mob.data else np.empty((1, 3)),
1593: (20)                              len(opacities),
1594: (16)                          )
1595: (16)                          mob.data[name][:, 3] = opacities
1596: (8)                   # Color and opacity
1597: (8)                   if color is not None and opacity is not None:
1598: (12)                      rgbas = np.array([[*rgb, o] for rgb, o in zip(*make_even(rgbs, opacities))])
1599: (12)                      for mob in self.get_family(recurse):
1600: (16)                          mob.data[name] = rgbas.copy()
1601: (8)                   return self
1602: (4)               def set_rgba_array_direct(self, rgbas: np.ndarray, name="rgbas", recurse=True):
1603: (8)                   """Directly set rgba data from `rgbas` and optionally do the same recursively
1604: (8)                   with submobjects. This can be used if the `rgbas` have already been generated
1605: (8)                   with the correct shape and simply need to be set.
1606: (8)                   Parameters
1607: (8)                   ----------
1608: (8)                   rgbas
1609: (12)                      the rgba to be set as data
1610: (8)                   name
1611: (12)                      the name of the data attribute to be set
1612: (8)                   recurse
1613: (12)                      set to true to recursively apply this method to submobjects
1614: (8)                   """
1615: (8)                   for mob in self.get_family(recurse):
1616: (12)                      mob.data[name] = rgbas.copy()
1617: (4)               def set_color(self, color: ParsableManimColor | None, opacity=None, recurse=True):
1618: (8)                   self.set_rgba_array(color, opacity, recurse=False)
1619: (8)                   # Recurse to submobjects differently from how set_rgba_array
1620: (8)                   # in case they implement set_color differently
1621: (8)                   if color is not None:
1622: (12)                      self.color: ManimColor = ManimColor.parse(color)
1623: (8)                   if opacity is not None:
1624: (12)                      self.opacity = opacity
1625: (8)                   if recurse:
1626: (12)                      for submob in self.submobjects:
1627: (16)                          submob.set_color(color, recurse=True)
1628: (8)                   return self
1629: (4)               def set_opacity(self, opacity, recurse=True):
1630: (8)                   self.set_rgba_array(color=None, opacity=opacity, recurse=False)
1631: (8)                   if recurse:
1632: (12)                      for submob in self.submobjects:
1633: (16)                          submob.set_opacity(opacity, recurse=True)
1634: (8)                   return self
1635: (4)               def get_color(self):
1636: (8)                   return rgb_to_hex(self.rgbas[0, :3])
1637: (4)               def get_opacity(self):
1638: (8)                   return self.rgbas[0, 3]
1639: (4)               def set_color_by_gradient(self, *colors):
1640: (8)                   self.set_submobject_colors_by_gradient(*colors)
1641: (8)                   return self
1642: (4)               def set_submobject_colors_by_gradient(self, *colors):
1643: (8)                   if len(colors) == 0:
1644: (12)                      raise Exception("Need at least one color")
1645: (8)                   elif len(colors) == 1:
1646: (12)                      return self.set_color(*colors)
1647: (8)                   # mobs = self.family_members_with_points()
1648: (8)                   mobs = self.submobjects
1649: (8)                   new_colors = color_gradient(colors, len(mobs))
1650: (8)                   for mob, color in zip(mobs, new_colors):
1651: (12)                      mob.set_color(color)
1652: (8)                   return self
1653: (4)               def fade(self, darkness=0.5, recurse=True):
1654: (8)                   self.set_opacity(1.0 - darkness, recurse=recurse)
1655: (4)               def get_gloss(self):
1656: (8)                   return self.gloss
1657: (4)               def set_gloss(self, gloss, recurse=True):
1658: (8)                   for mob in self.get_family(recurse):
1659: (12)                      mob.gloss = gloss
1660: (8)                   return self
1661: (4)               def get_shadow(self):
1662: (8)                   return self.shadow
1663: (4)               def set_shadow(self, shadow, recurse=True):
1664: (8)                   for mob in self.get_family(recurse):
1665: (12)                      mob.shadow = shadow
1666: (8)                   return self
1667: (4)               # Background rectangle
1668: (4)               def add_background_rectangle(
1669: (8)                   self, color: ParsableManimColor | None = None, opacity: float = 0.75, **kwargs
1670: (4)               ):
1671: (8)                   # TODO, this does not behave well when the mobject has points,
1672: (8)                   # since it gets displayed on top
1673: (8)                   """Add a BackgroundRectangle as submobject.
1674: (8)                   The BackgroundRectangle is added behind other submobjects.
1675: (8)                   This can be used to increase the mobjects visibility in front of a noisy background.
1676: (8)                   Parameters
1677: (8)                   ----------
1678: (8)                   color
1679: (12)                      The color of the BackgroundRectangle
1680: (8)                   opacity
1681: (12)                      The opacity of the BackgroundRectangle
1682: (8)                   kwargs
1683: (12)                      Additional keyword arguments passed to the BackgroundRectangle constructor
1684: (8)                   Returns
1685: (8)                   -------
1686: (8)                   :class:`OpenGLMobject`
1687: (12)                      ``self``
1688: (8)                   See Also
1689: (8)                   --------
1690: (8)                   :meth:`add_to_back`
1691: (8)                   :class:`~.BackgroundRectangle`
1692: (8)                   """
1693: (8)                   from manim.mobject.geometry.shape_matchers import BackgroundRectangle
1694: (8)                   self.background_rectangle = BackgroundRectangle(
1695: (12)                      self, color=color, fill_opacity=opacity, **kwargs
1696: (8)                   )
1697: (8)                   self.add_to_back(self.background_rectangle)
1698: (8)                   return self
1699: (4)               def add_background_rectangle_to_submobjects(self, **kwargs):
1700: (8)                   for submobject in self.submobjects:
1701: (12)                      submobject.add_background_rectangle(**kwargs)
1702: (8)                   return self
1703: (4)               def add_background_rectangle_to_family_members_with_points(self, **kwargs):
1704: (8)                   for mob in self.family_members_with_points():
1705: (12)                      mob.add_background_rectangle(**kwargs)
1706: (8)                   return self
1707: (4)               # Getters
1708: (4)               def get_bounding_box_point(self, direction):
1709: (8)                   bb = self.get_bounding_box()
1710: (8)                   indices = (np.sign(direction) + 1).astype(int)
1711: (8)                   return np.array([bb[indices[i]][i] for i in range(3)])
1712: (4)               def get_edge_center(self, direction) -> np.ndarray:
1713: (8)                   """Get edge coordinates for certain direction."""
1714: (8)                   return self.get_bounding_box_point(direction)
1715: (4)               def get_corner(self, direction) -> np.ndarray:
1716: (8)                   """Get corner coordinates for certain direction."""
1717: (8)                   return self.get_bounding_box_point(direction)
1718: (4)               def get_center(self) -> np.ndarray:
1719: (8)                   """Get center coordinates."""
1720: (8)                   return self.get_bounding_box()[1]
1721: (4)               def get_center_of_mass(self):
1722: (8)                   return self.get_all_points().mean(0)
1723: (4)               def get_boundary_point(self, direction):
1724: (8)                   all_points = self.get_all_points()
1725: (8)                   boundary_directions = all_points - self.get_center()
1726: (8)                   norms = np.linalg.norm(boundary_directions, axis=1)
1727: (8)                   boundary_directions /= np.repeat(norms, 3).reshape((len(norms), 3))
1728: (8)                   index = np.argmax(np.dot(boundary_directions, np.array(direction).T))
1729: (8)                   return all_points[index]
1730: (4)               def get_continuous_bounding_box_point(self, direction):
1731: (8)                   dl, center, ur = self.get_bounding_box()
1732: (8)                   corner_vect = ur - center
1733: (8)                   return center + direction / np.max(
1734: (12)                      np.abs(
1735: (16)                          np.true_divide(
1736: (20)                              direction,
1737: (20)                              corner_vect,
1738: (20)                              out=np.zeros(len(direction)),
1739: (20)                              where=((corner_vect) != 0),
1740: (16)                          ),
1741: (12)                      ),
1742: (8)                   )
1743: (4)               def get_top(self) -> np.ndarray:
1744: (8)                   """Get top coordinates of a box bounding the :class:`~.OpenGLMobject`"""
1745: (8)                   return self.get_edge_center(UP)
1746: (4)               def get_bottom(self) -> np.ndarray:
1747: (8)                   """Get bottom coordinates of a box bounding the :class:`~.OpenGLMobject`"""
1748: (8)                   return self.get_edge_center(DOWN)
1749: (4)               def get_right(self) -> np.ndarray:
1750: (8)                   """Get right coordinates of a box bounding the :class:`~.OpenGLMobject`"""
1751: (8)                   return self.get_edge_center(RIGHT)
1752: (4)               def get_left(self) -> np.ndarray:
1753: (8)                   """Get left coordinates of a box bounding the :class:`~.OpenGLMobject`"""
1754: (8)                   return self.get_edge_center(LEFT)
1755: (4)               def get_zenith(self) -> np.ndarray:
1756: (8)                   """Get zenith coordinates of a box bounding a 3D :class:`~.OpenGLMobject`."""
1757: (8)                   return self.get_edge_center(OUT)
1758: (4)               def get_nadir(self) -> np.ndarray:
1759: (8)                   """Get nadir (opposite the zenith) coordinates of a box bounding a 3D :class:`~.OpenGLMobject`."""
1760: (8)                   return self.get_edge_center(IN)
1761: (4)               def length_over_dim(self, dim):
1762: (8)                   bb = self.get_bounding_box()
1763: (8)                   return abs((bb[2] - bb[0])[dim])
1764: (4)               def get_width(self):
1765: (8)                   """Returns the width of the mobject."""
1766: (8)                   return self.length_over_dim(0)
1767: (4)               def get_height(self):
1768: (8)                   """Returns the height of the mobject."""
1769: (8)                   return self.length_over_dim(1)
1770: (4)               def get_depth(self):
1771: (8)                   """Returns the depth of the mobject."""
1772: (8)                   return self.length_over_dim(2)
1773: (4)               def get_coord(self, dim: int, direction=ORIGIN):
1774: (8)                   """Meant to generalize ``get_x``, ``get_y`` and ``get_z``"""
1775: (8)                   return self.get_bounding_box_point(direction)[dim]
1776: (4)               def get_x(self, direction=ORIGIN) -> np.float64:
1777: (8)                   """Returns x coordinate of the center of the :class:`~.OpenGLMobject` as ``float``"""
1778: (8)                   return self.get_coord(0, direction)
1779: (4)               def get_y(self, direction=ORIGIN) -> np.float64:
1780: (8)                   """Returns y coordinate of the center of the :class:`~.OpenGLMobject` as ``float``"""
1781: (8)                   return self.get_coord(1, direction)
1782: (4)               def get_z(self, direction=ORIGIN) -> np.float64:
1783: (8)                   """Returns z coordinate of the center of the :class:`~.OpenGLMobject` as ``float``"""
1784: (8)                   return self.get_coord(2, direction)
1785: (4)               def get_start(self):
1786: (8)                   """Returns the point, where the stroke that surrounds the :class:`~.OpenGLMobject` starts."""
1787: (8)                   self.throw_error_if_no_points()
1788: (8)                   return np.array(self.points[0])
1789: (4)               def get_end(self):
1790: (8)                   """Returns the point, where the stroke that surrounds the :class:`~.OpenGLMobject` ends."""
1791: (8)                   self.throw_error_if_no_points()
1792: (8)                   return np.array(self.points[-1])
1793: (4)               def get_start_and_end(self):
1794: (8)                   """Returns starting and ending point of a stroke as a ``tuple``."""
1795: (8)                   return self.get_start(), self.get_end()
1796: (4)               def point_from_proportion(self, alpha):
1797: (8)                   points = self.points
1798: (8)                   i, subalpha = integer_interpolate(0, len(points) - 1, alpha)
1799: (8)                   return interpolate(points[i], points[i + 1], subalpha)
1800: (4)               def pfp(self, alpha):
1801: (8)                   """Abbreviation for point_from_proportion"""
1802: (8)                   return self.point_from_proportion(alpha)
1803: (4)               def get_pieces(self, n_pieces):
1804: (8)                   template = self.copy()
1805: (8)                   template.submobjects = []
1806: (8)                   alphas = np.linspace(0, 1, n_pieces + 1)
1807: (8)                   return OpenGLGroup(
1808: (12)                      *(
1809: (16)                          template.copy().pointwise_become_partial(self, a1, a2)
1810: (16)                          for a1, a2 in zip(alphas[:-1], alphas[1:])
1811: (12)                      )
1812: (8)                   )
1813: (4)               def get_z_index_reference_point(self):
1814: (8)                   # TODO, better place to define default z_index_group?
1815: (8)                   z_index_group = getattr(self, "z_index_group", self)
1816: (8)                   return z_index_group.get_center()
1817: (4)               # Match other mobject properties
1818: (4)               def match_color(self, mobject: OpenGLMobject):
1819: (8)                   """Match the color with the color of another :class:`~.OpenGLMobject`."""
1820: (8)                   return self.set_color(mobject.get_color())
1821: (4)               def match_dim_size(self, mobject: OpenGLMobject, dim, **kwargs):
1822: (8)                   """Match the specified dimension with the dimension of another :class:`~.OpenGLMobject`."""
1823: (8)                   return self.rescale_to_fit(mobject.length_over_dim(dim), dim, **kwargs)
1824: (4)               def match_width(self, mobject: OpenGLMobject, **kwargs):
1825: (8)                   """Match the width with the width of another :class:`~.OpenGLMobject`."""
1826: (8)                   return self.match_dim_size(mobject, 0, **kwargs)
1827: (4)               def match_height(self, mobject: OpenGLMobject, **kwargs):
1828: (8)                   """Match the height with the height of another :class:`~.OpenGLMobject`."""
1829: (8)                   return self.match_dim_size(mobject, 1, **kwargs)
1830: (4)               def match_depth(self, mobject: OpenGLMobject, **kwargs):
1831: (8)                   """Match the depth with the depth of another :class:`~.OpenGLMobject`."""
1832: (8)                   return self.match_dim_size(mobject, 2, **kwargs)
1833: (4)               def match_coord(self, mobject: OpenGLMobject, dim, direction=ORIGIN):
1834: (8)                   """Match the coordinates with the coordinates of another :class:`~.OpenGLMobject`."""
1835: (8)                   return self.set_coord(
1836: (12)                      mobject.get_coord(dim, direction),
1837: (12)                      dim=dim,
1838: (12)                      direction=direction,
1839: (8)                   )
1840: (4)               def match_x(self, mobject, direction=ORIGIN):
1841: (8)                   """Match x coord. to the x coord. of another :class:`~.OpenGLMobject`."""
1842: (8)                   return self.match_coord(mobject, 0, direction)
1843: (4)               def match_y(self, mobject, direction=ORIGIN):
1844: (8)                   """Match y coord. to the x coord. of another :class:`~.OpenGLMobject`."""
1845: (8)                   return self.match_coord(mobject, 1, direction)
1846: (4)               def match_z(self, mobject, direction=ORIGIN):
1847: (8)                   """Match z coord. to the x coord. of another :class:`~.OpenGLMobject`."""
1848: (8)                   return self.match_coord(mobject, 2, direction)
1849: (4)               def align_to(
1850: (8)                   self,
1851: (8)                   mobject_or_point: OpenGLMobject | Sequence[float],
1852: (8)                   direction=ORIGIN,
1853: (4)               ):
1854: (8)                   """
1855: (8)                   Examples:
1856: (8)                   mob1.align_to(mob2, UP) moves mob1 vertically so that its
1857: (8)                   top edge lines ups with mob2's top edge.
1858: (8)                   mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1
1859: (8)                   horizontally so that it's center is directly above/below
1860: (8)                   the center of mob2
1861: (8)                   """
1862: (8)                   if isinstance(mobject_or_point, OpenGLMobject):
1863: (12)                      point = mobject_or_point.get_bounding_box_point(direction)
1864: (8)                   else:
1865: (12)                      point = mobject_or_point
1866: (8)                   for dim in range(self.dim):
1867: (12)                      if direction[dim] != 0:
1868: (16)                          self.set_coord(point[dim], dim, direction)
1869: (8)                   return self
1870: (4)               def get_group_class(self):
1871: (8)                   return OpenGLGroup
1872: (4)               @staticmethod
1873: (4)               def get_mobject_type_class():
1874: (8)                   """Return the base class of this mobject type."""
1875: (8)                   return OpenGLMobject
1876: (4)               # Alignment
1877: (4)               def align_data_and_family(self, mobject):
1878: (8)                   self.align_family(mobject)
1879: (8)                   self.align_data(mobject)
1880: (4)               def align_data(self, mobject):
1881: (8)                   # In case any data arrays get resized when aligned to shader data
1882: (8)                   # self.refresh_shader_data()
1883: (8)                   for mob1, mob2 in zip(self.get_family(), mobject.get_family()):
1884: (12)                      # Separate out how points are treated so that subclasses
1885: (12)                      # can handle that case differently if they choose
1886: (12)                      mob1.align_points(mob2)
1887: (12)                      for key in mob1.data.keys() & mob2.data.keys():
1888: (16)                          if key == "points":
1889: (20)                              continue
1890: (16)                          arr1 = mob1.data[key]
1891: (16)                          arr2 = mob2.data[key]
1892: (16)                          if len(arr2) > len(arr1):
1893: (20)                              mob1.data[key] = resize_preserving_order(arr1, len(arr2))
1894: (16)                          elif len(arr1) > len(arr2):
1895: (20)                              mob2.data[key] = resize_preserving_order(arr2, len(arr1))
1896: (4)               def align_points(self, mobject):
1897: (8)                   max_len = max(self.get_num_points(), mobject.get_num_points())
1898: (8)                   for mob in (self, mobject):
1899: (12)                      mob.resize_points(max_len, resize_func=resize_preserving_order)
1900: (8)                   return self
1901: (4)               def align_family(self, mobject):
1902: (8)                   mob1 = self
1903: (8)                   mob2 = mobject
1904: (8)                   n1 = len(mob1)
1905: (8)                   n2 = len(mob2)
1906: (8)                   if n1 != n2:
1907: (12)                      mob1.add_n_more_submobjects(max(0, n2 - n1))
1908: (12)                      mob2.add_n_more_submobjects(max(0, n1 - n2))
1909: (8)                   # Recurse
1910: (8)                   for sm1, sm2 in zip(mob1.submobjects, mob2.submobjects):
1911: (12)                      sm1.align_family(sm2)
1912: (8)                   return self
1913: (4)               def push_self_into_submobjects(self):
1914: (8)                   copy = self.deepcopy()
1915: (8)                   copy.submobjects = []
1916: (8)                   self.resize_points(0)
1917: (8)                   self.add(copy)
1918: (8)                   return self
1919: (4)               def add_n_more_submobjects(self, n):
1920: (8)                   if n == 0:
1921: (12)                      return self
1922: (8)                   curr = len(self.submobjects)
1923: (8)                   if curr == 0:
1924: (12)                      # If empty, simply add n point mobjects
1925: (12)                      null_mob = self.copy()
1926: (12)                      null_mob.set_points([self.get_center()])
1927: (12)                      self.submobjects = [null_mob.copy() for k in range(n)]
1928: (12)                      return self
1929: (8)                   target = curr + n
1930: (8)                   repeat_indices = (np.arange(target) * curr) // target
1931: (8)                   split_factors = [(repeat_indices == i).sum() for i in range(curr)]
1932: (8)                   new_submobs = []
1933: (8)                   for submob, sf in zip(self.submobjects, split_factors):
1934: (12)                      new_submobs.append(submob)
1935: (12)                      for _ in range(1, sf):
1936: (16)                          new_submob = submob.copy()
1937: (16)                          # If the submobject is at all transparent, then
1938: (16)                          # make the copy completely transparent
1939: (16)                          if submob.get_opacity() < 1:
1940: (20)                              new_submob.set_opacity(0)
1941: (16)                          new_submobs.append(new_submob)
1942: (8)                   self.submobjects = new_submobs
1943: (8)                   return self
1944: (4)               # Interpolate
1945: (4)               def interpolate(self, mobject1, mobject2, alpha, path_func=straight_path()):
1946: (8)                   """Turns this :class:`~.OpenGLMobject` into an interpolation between ``mobject1``
1947: (8)                   and ``mobject2``.
1948: (8)                   Examples
1949: (8)                   --------
1950: (8)                   .. manim:: DotInterpolation
1951: (12)                      :save_last_frame:
1952: (12)                      class DotInterpolation(Scene):
1953: (16)                          def construct(self):
1954: (20)                              dotR = Dot(color=DARK_GREY)
1955: (20)                              dotR.shift(2 * RIGHT)
1956: (20)                              dotL = Dot(color=WHITE)
1957: (20)                              dotL.shift(2 * LEFT)
1958: (20)                              dotMiddle = OpenGLVMobject().interpolate(dotL, dotR, alpha=0.3)
1959: (20)                              self.add(dotL, dotR, dotMiddle)
1960: (8)                   """
1961: (8)                   for key in self.data:
1962: (12)                      if key in self.locked_data_keys:
1963: (16)                          continue
1964: (12)                      if len(self.data[key]) == 0:
1965: (16)                          continue
1966: (12)                      if key not in mobject1.data or key not in mobject2.data:
1967: (16)                          continue
1968: (12)                      if key in ("points", "bounding_box"):
1969: (16)                          func = path_func
1970: (12)                      else:
1971: (16)                          func = interpolate
1972: (12)                      self.data[key][:] = func(mobject1.data[key], mobject2.data[key], alpha)
1973: (8)                   for key in self.uniforms:
1974: (12)                      if key != "fixed_orientation_center":
1975: (16)                          self.uniforms[key] = interpolate(
1976: (20)                              mobject1.uniforms[key],
1977: (20)                              mobject2.uniforms[key],
1978: (20)                              alpha,
1979: (16)                          )
1980: (12)                      else:
1981: (16)                          self.uniforms["fixed_orientation_center"] = tuple(
1982: (20)                              interpolate(
1983: (24)                                  np.array(mobject1.uniforms["fixed_orientation_center"]),
1984: (24)                                  np.array(mobject2.uniforms["fixed_orientation_center"]),
1985: (24)                                  alpha,
1986: (20)                              )
1987: (16)                          )
1988: (8)                   return self
1989: (4)               def pointwise_become_partial(self, mobject, a, b):
1990: (8)                   """
1991: (8)                   Set points in such a way as to become only
1992: (8)                   part of mobject.
1993: (8)                   Inputs 0 <= a < b <= 1 determine what portion
1994: (8)                   of mobject to become.
1995: (8)                   """
1996: (8)                   pass  # To implement in subclass
1997: (4)               def become(
1998: (8)                   self,
1999: (8)                   mobject: OpenGLMobject,
2000: (8)                   match_height: bool = False,
2001: (8)                   match_width: bool = False,
2002: (8)                   match_depth: bool = False,
2003: (8)                   match_center: bool = False,
2004: (8)                   stretch: bool = False,
2005: (4)               ):
2006: (8)                   """Edit all data and submobjects to be identical
2007: (8)                   to another :class:`~.OpenGLMobject`
2008: (8)                   .. note::
2009: (12)                      If both match_height and match_width are ``True`` then the transformed :class:`~.OpenGLMobject`
2010: (12)                      will match the height first and then the width
2011: (8)                   Parameters
2012: (8)                   ----------
2013: (8)                   match_height
2014: (12)                      If ``True``, then the transformed :class:`~.OpenGLMobject` will match the height of the original
2015: (8)                   match_width
2016: (12)                      If ``True``, then the transformed :class:`~.OpenGLMobject` will match the width of the original
2017: (8)                   match_depth
2018: (12)                      If ``True``, then the transformed :class:`~.OpenGLMobject` will match the depth of the original
2019: (8)                   match_center
2020: (12)                      If ``True``, then the transformed :class:`~.OpenGLMobject` will match the center of the original
2021: (8)                   stretch
2022: (12)                      If ``True``, then the transformed :class:`~.OpenGLMobject` will stretch to fit the proportions of the original
2023: (8)                   Examples
2024: (8)                   --------
2025: (8)                   .. manim:: BecomeScene
2026: (12)                      class BecomeScene(Scene):
2027: (16)                          def construct(self):
2028: (20)                              circ = Circle(fill_color=RED, fill_opacity=0.8)
2029: (20)                              square = Square(fill_color=BLUE, fill_opacity=0.2)
2030: (20)                              self.add(circ)
2031: (20)                              self.wait(0.5)
2032: (20)                              circ.become(square)
2033: (20)                              self.wait(0.5)
2034: (8)                   """
2035: (8)                   if stretch:
2036: (12)                      mobject.stretch_to_fit_height(self.height)
2037: (12)                      mobject.stretch_to_fit_width(self.width)
2038: (12)                      mobject.stretch_to_fit_depth(self.depth)
2039: (8)                   else:
2040: (12)                      if match_height:
2041: (16)                          mobject.match_height(self)
2042: (12)                      if match_width:
2043: (16)                          mobject.match_width(self)
2044: (12)                      if match_depth:
2045: (16)                          mobject.match_depth(self)
2046: (8)                   if match_center:
2047: (12)                      mobject.move_to(self.get_center())
2048: (8)                   self.align_family(mobject)
2049: (8)                   for sm1, sm2 in zip(self.get_family(), mobject.get_family()):
2050: (12)                      sm1.set_data(sm2.data)
2051: (12)                      sm1.set_uniforms(sm2.uniforms)
2052: (8)                   self.refresh_bounding_box(recurse_down=True)
2053: (8)                   return self
2054: (4)               # Locking data
2055: (4)               def lock_data(self, keys):
2056: (8)                   """
2057: (8)                   To speed up some animations, particularly transformations,
2058: (8)                   it can be handy to acknowledge which pieces of data
2059: (8)                   won't change during the animation so that calls to
2060: (8)                   interpolate can skip this, and so that it's not
2061: (8)                   read into the shader_wrapper objects needlessly
2062: (8)                   """
2063: (8)                   if self.has_updaters:
2064: (12)                      return
2065: (8)                   # Be sure shader data has most up to date information
2066: (8)                   self.refresh_shader_data()
2067: (8)                   self.locked_data_keys = set(keys)
2068: (4)               def lock_matching_data(self, mobject1, mobject2):
2069: (8)                   for sm, sm1, sm2 in zip(
2070: (12)                      self.get_family(),
2071: (12)                      mobject1.get_family(),
2072: (12)                      mobject2.get_family(),
2073: (8)                   ):
2074: (12)                      keys = sm.data.keys() & sm1.data.keys() & sm2.data.keys()
2075: (12)                      sm.lock_data(
2076: (16)                          list(
2077: (20)                              filter(
2078: (24)                                  lambda key: np.all(sm1.data[key] == sm2.data[key]),
2079: (24)                                  keys,
2080: (20)                              ),
2081: (16)                          ),
2082: (12)                      )
2083: (8)                   return self
2084: (4)               def unlock_data(self):
2085: (8)                   for mob in self.get_family():
2086: (12)                      mob.locked_data_keys = set()
2087: (4)               # Operations touching shader uniforms
2088: (4)               @affects_shader_info_id
2089: (4)               def fix_in_frame(self):
2090: (8)                   self.is_fixed_in_frame = 1.0
2091: (8)                   return self
2092: (4)               @affects_shader_info_id
2093: (4)               def fix_orientation(self):
2094: (8)                   self.is_fixed_orientation = 1.0
2095: (8)                   self.fixed_orientation_center = tuple(self.get_center())
2096: (8)                   self.depth_test = True
2097: (8)                   return self
2098: (4)               @affects_shader_info_id
2099: (4)               def unfix_from_frame(self):
2100: (8)                   self.is_fixed_in_frame = 0.0
2101: (8)                   return self
2102: (4)               @affects_shader_info_id
2103: (4)               def unfix_orientation(self):
2104: (8)                   self.is_fixed_orientation = 0.0
2105: (8)                   self.fixed_orientation_center = (0, 0, 0)
2106: (8)                   self.depth_test = False
2107: (8)                   return self
2108: (4)               @affects_shader_info_id
2109: (4)               def apply_depth_test(self):
2110: (8)                   self.depth_test = True
2111: (8)                   return self
2112: (4)               @affects_shader_info_id
2113: (4)               def deactivate_depth_test(self):
2114: (8)                   self.depth_test = False
2115: (8)                   return self
2116: (4)               # Shader code manipulation
2117: (4)               def replace_shader_code(self, old, new):
2118: (8)                   # TODO, will this work with VMobject structure, given
2119: (8)                   # that it does not simpler return shader_wrappers of
2120: (8)                   # family?
2121: (8)                   for wrapper in self.get_shader_wrapper_list():
2122: (12)                      wrapper.replace_code(old, new)
2123: (8)                   return self
2124: (4)               def set_color_by_code(self, glsl_code):
2125: (8)                   """
2126: (8)                   Takes a snippet of code and inserts it into a
2127: (8)                   context which has the following variables:
2128: (8)                   vec4 color, vec3 point, vec3 unit_normal.
2129: (8)                   The code should change the color variable
2130: (8)                   """
2131: (8)                   self.replace_shader_code("///// INSERT COLOR FUNCTION HERE /////", glsl_code)
2132: (8)                   return self
2133: (4)               def set_color_by_xyz_func(
2134: (8)                   self,
2135: (8)                   glsl_snippet,
2136: (8)                   min_value=-5.0,
2137: (8)                   max_value=5.0,
2138: (8)                   colormap="viridis",
2139: (4)               ):
2140: (8)                   """
2141: (8)                   Pass in a glsl expression in terms of x, y and z which returns
2142: (8)                   a float.
2143: (8)                   """
2144: (8)                   # TODO, add a version of this which changes the point data instead
2145: (8)                   # of the shader code
2146: (8)                   for char in "xyz":
2147: (12)                      glsl_snippet = glsl_snippet.replace(char, "point." + char)
2148: (8)                   rgb_list = get_colormap_list(colormap)
2149: (8)                   self.set_color_by_code(
2150: (12)                      "color.rgb = float_to_color({}, {}, {}, {});".format(
2151: (16)                          glsl_snippet,
2152: (16)                          float(min_value),
2153: (16)                          float(max_value),
2154: (16)                          get_colormap_code(rgb_list),
2155: (12)                      ),
2156: (8)                   )
2157: (8)                   return self
2158: (4)               # For shader data
2159: (4)               def refresh_shader_wrapper_id(self):
2160: (8)                   self.get_shader_wrapper().refresh_id()
2161: (8)                   return self
2162: (4)               def get_shader_wrapper(self):
2163: (8)                   from manim.renderer.shader_wrapper import ShaderWrapper
2164: (8)                   # if hasattr(self, "__shader_wrapper"):
2165: (8)                   # return self.__shader_wrapper
2166: (8)                   self.shader_wrapper = ShaderWrapper(
2167: (12)                      vert_data=self.get_shader_data(),
2168: (12)                      vert_indices=self.get_shader_vert_indices(),
2169: (12)                      uniforms=self.get_shader_uniforms(),
2170: (12)                      depth_test=self.depth_test,
2171: (12)                      texture_paths=self.texture_paths,
2172: (12)                      render_primitive=self.render_primitive,
2173: (12)                      shader_folder=self.__class__.shader_folder,
2174: (8)                   )
2175: (8)                   return self.shader_wrapper
2176: (4)               def get_shader_wrapper_list(self):
2177: (8)                   shader_wrappers = it.chain(
2178: (12)                      [self.get_shader_wrapper()],
2179: (12)                      *(sm.get_shader_wrapper_list() for sm in self.submobjects),
2180: (8)                   )
2181: (8)                   batches = batch_by_property(shader_wrappers, lambda sw: sw.get_id())
2182: (8)                   result = []
2183: (8)                   for wrapper_group, _ in batches:
2184: (12)                      shader_wrapper = wrapper_group[0]
2185: (12)                      if not shader_wrapper.is_valid():
2186: (16)                          continue
2187: (12)                      shader_wrapper.combine_with(*wrapper_group[1:])
2188: (12)                      if len(shader_wrapper.vert_data) > 0:
2189: (16)                          result.append(shader_wrapper)
2190: (8)                   return result
2191: (4)               def check_data_alignment(self, array, data_key):
2192: (8)                   # Makes sure that self.data[key] can be broadcast into
2193: (8)                   # the given array, meaning its length has to be either 1
2194: (8)                   # or the length of the array
2195: (8)                   d_len = len(self.data[data_key])
2196: (8)                   if d_len != 1 and d_len != len(array):
2197: (12)                      self.data[data_key] = resize_with_interpolation(
2198: (16)                          self.data[data_key],
2199: (16)                          len(array),
2200: (12)                      )
2201: (8)                   return self
2202: (4)               def get_resized_shader_data_array(self, length):
2203: (8)                   # If possible, try to populate an existing array, rather
2204: (8)                   # than recreating it each frame
2205: (8)                   points = self.points
2206: (8)                   shader_data = np.zeros(len(points), dtype=self.shader_dtype)
2207: (8)                   return shader_data
2208: (4)               def read_data_to_shader(self, shader_data, shader_data_key, data_key):
2209: (8)                   if data_key in self.locked_data_keys:
2210: (12)                      return
2211: (8)                   self.check_data_alignment(shader_data, data_key)
2212: (8)                   shader_data[shader_data_key] = self.data[data_key]
2213: (4)               def get_shader_data(self):
2214: (8)                   shader_data = self.get_resized_shader_data_array(self.get_num_points())
2215: (8)                   self.read_data_to_shader(shader_data, "point", "points")
2216: (8)                   return shader_data
2217: (4)               def refresh_shader_data(self):
2218: (8)                   self.get_shader_data()
2219: (4)               def get_shader_uniforms(self):
2220: (8)                   return self.uniforms
2221: (4)               def get_shader_vert_indices(self):
2222: (8)                   return self.shader_indices
2223: (4)               @property
2224: (4)               def submobjects(self):
2225: (8)                   return self._submobjects if hasattr(self, "_submobjects") else []
2226: (4)               @submobjects.setter
2227: (4)               def submobjects(self, submobject_list):
2228: (8)                   self.remove(*self.submobjects)
2229: (8)                   self.add(*submobject_list)
2230: (4)               # Errors
2231: (4)               def throw_error_if_no_points(self):
2232: (8)                   if not self.has_points():
2233: (12)                      message = (
2234: (16)                          "Cannot call OpenGLMobject.{} " + "for a OpenGLMobject with no points"
2235: (12)                      )
2236: (12)                      caller_name = sys._getframe(1).f_code.co_name
2237: (12)                      raise Exception(message.format(caller_name))
2238: (0)           class OpenGLGroup(OpenGLMobject):
2239: (4)               def __init__(self, *mobjects, **kwargs):
2240: (8)                   if not all(isinstance(m, OpenGLMobject) for m in mobjects):
2241: (12)                      raise Exception("All submobjects must be of type OpenGLMobject")
2242: (8)                   super().__init__(**kwargs)
2243: (8)                   self.add(*mobjects)
2244: (0)           class OpenGLPoint(OpenGLMobject):
2245: (4)               def __init__(
2246: (8)                   self, location=ORIGIN, artificial_width=1e-6, artificial_height=1e-6, **kwargs
2247: (4)               ):
2248: (8)                   self.artificial_width = artificial_width
2249: (8)                   self.artificial_height = artificial_height
2250: (8)                   super().__init__(**kwargs)
2251: (8)                   self.set_location(location)
2252: (4)               def get_width(self):
2253: (8)                   return self.artificial_width
2254: (4)               def get_height(self):
2255: (8)                   return self.artificial_height
2256: (4)               def get_location(self):
2257: (8)                   return self.points[0].copy()
2258: (4)               def get_bounding_box_point(self, *args, **kwargs):
2259: (8)                   return self.get_location()
2260: (4)               def set_location(self, new_loc):
2261: (8)                   self.set_points(np.array(new_loc, ndmin=2, dtype=float))
2262: (0)           class _AnimationBuilder:
2263: (4)               def __init__(self, mobject):
2264: (8)                   self.mobject = mobject
2265: (8)                   self.mobject.generate_target()
2266: (8)                   self.overridden_animation = None
2267: (8)                   self.is_chaining = False
2268: (8)                   self.methods = []
2269: (8)                   # Whether animation args can be passed
2270: (8)                   self.cannot_pass_args = False
2271: (8)                   self.anim_args = {}
2272: (4)               def __call__(self, **kwargs):
2273: (8)                   if self.cannot_pass_args:
2274: (12)                      raise ValueError(
2275: (16)                          "Animation arguments must be passed before accessing methods and can only be passed once",
2276: (12)                      )
2277: (8)                   self.anim_args = kwargs
2278: (8)                   self.cannot_pass_args = True
2279: (8)                   return self
2280: (4)               def __getattr__(self, method_name):
2281: (8)                   method = getattr(self.mobject.target, method_name)
2282: (8)                   has_overridden_animation = hasattr(method, "_override_animate")
2283: (8)                   if (self.is_chaining and has_overridden_animation) or self.overridden_animation:
2284: (12)                      raise NotImplementedError(
2285: (16)                          "Method chaining is currently not supported for "
2286: (16)                          "overridden animations",
2287: (12)                      )
2288: (8)                   def update_target(*method_args, **method_kwargs):
2289: (12)                      if has_overridden_animation:
2290: (16)                          self.overridden_animation = method._override_animate(
2291: (20)                              self.mobject,
2292: (20)                              *method_args,
2293: (20)                              anim_args=self.anim_args,
2294: (20)                              **method_kwargs,
2295: (16)                          )
2296: (12)                      else:
2297: (16)                          self.methods.append([method, method_args, method_kwargs])
2298: (16)                          method(*method_args, **method_kwargs)
2299: (12)                      return self
2300: (8)                   self.is_chaining = True
2301: (8)                   self.cannot_pass_args = True
2302: (8)                   return update_target
2303: (4)               def build(self):
2304: (8)                   from manim.animation.transform import _MethodAnimation
2305: (8)                   if self.overridden_animation:
2306: (12)                      anim = self.overridden_animation
2307: (8)                   else:
2308: (12)                      anim = _MethodAnimation(self.mobject, self.methods)
2309: (8)                   for attr, value in self.anim_args.items():
2310: (12)                      setattr(anim, attr, value)
2311: (8)                   return anim
2312: (0)           def override_animate(method):
2313: (4)               r"""Decorator for overriding method animations.
2314: (4)               This allows to specify a method (returning an :class:`~.Animation`)
2315: (4)               which is called when the decorated method is used with the ``.animate`` syntax
2316: (4)               for animating the application of a method.
2317: (4)               .. seealso::
2318: (8)                   :attr:`OpenGLMobject.animate`
2319: (4)               .. note::
2320: (8)                   Overridden methods cannot be combined with normal or other overridden
2321: (8)                   methods using method chaining with the ``.animate`` syntax.
2322: (4)               Examples
2323: (4)               --------
2324: (4)               .. manim:: AnimationOverrideExample
2325: (8)                   class CircleWithContent(VGroup):
2326: (12)                      def __init__(self, content):
2327: (16)                          super().__init__()
2328: (16)                          self.circle = Circle()
2329: (16)                          self.content = content
2330: (16)                          self.add(self.circle, content)
2331: (16)                          content.move_to(self.circle.get_center())
2332: (12)                      def clear_content(self):
2333: (16)                          self.remove(self.content)
2334: (16)                          self.content = None
2335: (12)                      @override_animate(clear_content)
2336: (12)                      def _clear_content_animation(self, anim_args=None):
2337: (16)                          if anim_args is None:
2338: (20)                              anim_args = {}
2339: (16)                          anim = Uncreate(self.content, **anim_args)
2340: (16)                          self.clear_content()
2341: (16)                          return anim
2342: (8)                   class AnimationOverrideExample(Scene):
2343: (12)                      def construct(self):
2344: (16)                          t = Text("hello!")
2345: (16)                          my_mobject = CircleWithContent(t)
2346: (16)                          self.play(Create(my_mobject))
2347: (16)                          self.play(my_mobject.animate.clear_content())
2348: (16)                          self.wait()
2349: (4)               """
2350: (4)               def decorator(animation_method):
2351: (8)                   method._override_animate = animation_method
2352: (8)                   return animation_method
2353: (4)               return decorator

----------------------------------------

File 39 - .\opengl \opengl_surface.py:

1: (0)              from __future__ import annotations
2: (0)              from pathlib import Path
3: (0)              from typing import Iterable
4: (0)              import moderngl
5: (0)              import numpy as np
6: (0)              from PIL import Image
7: (0)              from manim.constants import *
8: (0)              from manim.mobject.opengl.opengl_mobject import OpenGLMobject
9: (0)              from manim.utils.bezier import integer_interpolate, interpolate
10: (0)             from manim.utils.color import *
11: (0)             from manim.utils.config_ops import _Data, _Uniforms
12: (0)             from manim.utils.deprecation import deprecated
13: (0)             from manim.utils.images import change_to_rgba_array, get_full_raster_image_path
14: (0)             from manim.utils.iterables import listify
15: (0)             from manim.utils.space_ops import normalize_along_axis
16: (0)             __all__ = ["OpenGLSurface", "OpenGLTexturedSurface"]
17: (0)             class OpenGLSurface(OpenGLMobject):
18: (4)                 r"""Creates a Surface.
19: (4)                 Parameters
20: (4)                 ----------
21: (4)                 uv_func
22: (8)                     The function that defines the surface.
23: (4)                 u_range
24: (8)                     The range of the ``u`` variable: ``(u_min, u_max)``.
25: (4)                 v_range
26: (8)                     The range of the ``v`` variable: ``(v_min, v_max)``.
27: (4)                 resolution
28: (8)                     The number of samples taken of the surface.
29: (4)                 axes
30: (8)                     Axes on which the surface is to be drawn. Optional
31: (8)                     parameter used when coloring a surface by z-value.
32: (4)                 color
33: (8)                     Color of the surface. Defaults to grey.
34: (4)                 colorscale
35: (8)                     Colors of the surface. Optional parameter used when
36: (8)                     coloring a surface by values. Passing a list of
37: (8)                     colors and an axes will color the surface by z-value.
38: (8)                     Passing a list of tuples in the form ``(color, pivot)``
39: (8)                     allows user-defined pivots where the color transitions.
40: (4)                 colorscale_axis
41: (8)                     Defines the axis on which the colorscale is applied
42: (8)                     (0 = x, 1 = y, 2 = z), default is z-axis (2).
43: (4)                 opacity
44: (8)                     Opacity of the surface from 0 being fully transparent
45: (8)                     to 1 being fully opaque. Defaults to 1.
46: (4)                 """
47: (4)                 shader_dtype = [
48: (8)                     ("point", np.float32, (3,)),
49: (8)                     ("du_point", np.float32, (3,)),
50: (8)                     ("dv_point", np.float32, (3,)),
51: (8)                     ("color", np.float32, (4,)),
52: (4)                 ]
53: (4)                 shader_folder = "surface"
54: (4)                 def __init__(
55: (8)                     self,
56: (8)                     uv_func=None,
57: (8)                     u_range=None,
58: (8)                     v_range=None,
59: (8)                     # Resolution counts number of points sampled, which for
60: (8)                     # each coordinate is one more than the the number of
61: (8)                     # rows/columns of approximating squares
62: (8)                     resolution=None,
63: (8)                     axes=None,
64: (8)                     color=GREY,
65: (8)                     colorscale=None,
66: (8)                     colorscale_axis=2,
67: (8)                     opacity=1.0,
68: (8)                     gloss=0.3,
69: (8)                     shadow=0.4,
70: (8)                     prefered_creation_axis=1,
71: (8)                     # For du and dv steps.  Much smaller and numerical error
72: (8)                     # can crop up in the shaders.
73: (8)                     epsilon=1e-5,
74: (8)                     render_primitive=moderngl.TRIANGLES,
75: (8)                     depth_test=True,
76: (8)                     shader_folder=None,
77: (8)                     **kwargs,
78: (4)                 ):
79: (8)                     self.passed_uv_func = uv_func
80: (8)                     self.u_range = u_range if u_range is not None else (0, 1)
81: (8)                     self.v_range = v_range if v_range is not None else (0, 1)
82: (8)                     # Resolution counts number of points sampled, which for
83: (8)                     # each coordinate is one more than the the number of
84: (8)                     # rows/columns of approximating squares
85: (8)                     self.resolution = resolution if resolution is not None else (101, 101)
86: (8)                     self.axes = axes
87: (8)                     self.colorscale = colorscale
88: (8)                     self.colorscale_axis = colorscale_axis
89: (8)                     self.prefered_creation_axis = prefered_creation_axis
90: (8)                     # For du and dv steps.  Much smaller and numerical error
91: (8)                     # can crop up in the shaders.
92: (8)                     self.epsilon = epsilon
93: (8)                     self.triangle_indices = None
94: (8)                     super().__init__(
95: (12)                        color=color,
96: (12)                        opacity=opacity,
97: (12)                        gloss=gloss,
98: (12)                        shadow=shadow,
99: (12)                        shader_folder=shader_folder if shader_folder is not None else "surface",
100: (12)                       render_primitive=render_primitive,
101: (12)                       depth_test=depth_test,
102: (12)                       **kwargs,
103: (8)                    )
104: (8)                    self.compute_triangle_indices()
105: (4)                def uv_func(self, u, v):
106: (8)                    # To be implemented in subclasses
107: (8)                    if self.passed_uv_func:
108: (12)                       return self.passed_uv_func(u, v)
109: (8)                    return (u, v, 0.0)
110: (4)                def init_points(self):
111: (8)                    dim = self.dim
112: (8)                    nu, nv = self.resolution
113: (8)                    u_range = np.linspace(*self.u_range, nu)
114: (8)                    v_range = np.linspace(*self.v_range, nv)
115: (8)                    # Get three lists:
116: (8)                    # - Points generated by pure uv values
117: (8)                    # - Those generated by values nudged by du
118: (8)                    # - Those generated by values nudged by dv
119: (8)                    point_lists = []
120: (8)                    for du, dv in [(0, 0), (self.epsilon, 0), (0, self.epsilon)]:
121: (12)                       uv_grid = np.array([[[u + du, v + dv] for v in v_range] for u in u_range])
122: (12)                       point_grid = np.apply_along_axis(lambda p: self.uv_func(*p), 2, uv_grid)
123: (12)                       point_lists.append(point_grid.reshape((nu * nv, dim)))
124: (8)                    # Rather than tracking normal vectors, the points list will hold on to the
125: (8)                    # infinitesimal nudged values alongside the original values.  This way, one
126: (8)                    # can perform all the manipulations they'd like to the surface, and normals
127: (8)                    # are still easily recoverable.
128: (8)                    self.set_points(np.vstack(point_lists))
129: (4)                def compute_triangle_indices(self):
130: (8)                    # TODO, if there is an event which changes
131: (8)                    # the resolution of the surface, make sure
132: (8)                    # this is called.
133: (8)                    nu, nv = self.resolution
134: (8)                    if nu == 0 or nv == 0:
135: (12)                       self.triangle_indices = np.zeros(0, dtype=int)
136: (12)                       return
137: (8)                    index_grid = np.arange(nu * nv).reshape((nu, nv))
138: (8)                    indices = np.zeros(6 * (nu - 1) * (nv - 1), dtype=int)
139: (8)                    indices[0::6] = index_grid[:-1, :-1].flatten()  # Top left
140: (8)                    indices[1::6] = index_grid[+1:, :-1].flatten()  # Bottom left
141: (8)                    indices[2::6] = index_grid[:-1, +1:].flatten()  # Top right
142: (8)                    indices[3::6] = index_grid[:-1, +1:].flatten()  # Top right
143: (8)                    indices[4::6] = index_grid[+1:, :-1].flatten()  # Bottom left
144: (8)                    indices[5::6] = index_grid[+1:, +1:].flatten()  # Bottom right
145: (8)                    self.triangle_indices = indices
146: (4)                def get_triangle_indices(self):
147: (8)                    return self.triangle_indices
148: (4)                def get_surface_points_and_nudged_points(self):
149: (8)                    points = self.points
150: (8)                    k = len(points) // 3
151: (8)                    return points[:k], points[k : 2 * k], points[2 * k :]
152: (4)                def get_unit_normals(self):
153: (8)                    s_points, du_points, dv_points = self.get_surface_points_and_nudged_points()
154: (8)                    normals = np.cross(
155: (12)                       (du_points - s_points) / self.epsilon,
156: (12)                       (dv_points - s_points) / self.epsilon,
157: (8)                    )
158: (8)                    return normalize_along_axis(normals, 1)
159: (4)                def pointwise_become_partial(self, smobject, a, b, axis=None):
160: (8)                    assert isinstance(smobject, OpenGLSurface)
161: (8)                    if axis is None:
162: (12)                       axis = self.prefered_creation_axis
163: (8)                    if a <= 0 and b >= 1:
164: (12)                       self.match_points(smobject)
165: (12)                       return self
166: (8)                    nu, nv = smobject.resolution
167: (8)                    self.set_points(
168: (12)                       np.vstack(
169: (16)                           [
170: (20)                               self.get_partial_points_array(
171: (24)                                   arr.copy(),
172: (24)                                   a,
173: (24)                                   b,
174: (24)                                   (nu, nv, 3),
175: (24)                                   axis=axis,
176: (20)                               )
177: (20)                               for arr in smobject.get_surface_points_and_nudged_points()
178: (16)                           ],
179: (12)                       ),
180: (8)                    )
181: (8)                    return self
182: (4)                def get_partial_points_array(self, points, a, b, resolution, axis):
183: (8)                    if len(points) == 0:
184: (12)                       return points
185: (8)                    nu, nv = resolution[:2]
186: (8)                    points = points.reshape(resolution)
187: (8)                    max_index = resolution[axis] - 1
188: (8)                    lower_index, lower_residue = integer_interpolate(0, max_index, a)
189: (8)                    upper_index, upper_residue = integer_interpolate(0, max_index, b)
190: (8)                    if axis == 0:
191: (12)                       points[:lower_index] = interpolate(
192: (16)                           points[lower_index],
193: (16)                           points[lower_index + 1],
194: (16)                           lower_residue,
195: (12)                       )
196: (12)                       points[upper_index + 1 :] = interpolate(
197: (16)                           points[upper_index],
198: (16)                           points[upper_index + 1],
199: (16)                           upper_residue,
200: (12)                       )
201: (8)                    else:
202: (12)                       shape = (nu, 1, resolution[2])
203: (12)                       points[:, :lower_index] = interpolate(
204: (16)                           points[:, lower_index],
205: (16)                           points[:, lower_index + 1],
206: (16)                           lower_residue,
207: (12)                       ).reshape(shape)
208: (12)                       points[:, upper_index + 1 :] = interpolate(
209: (16)                           points[:, upper_index],
210: (16)                           points[:, upper_index + 1],
211: (16)                           upper_residue,
212: (12)                       ).reshape(shape)
213: (8)                    return points.reshape((nu * nv, *resolution[2:]))
214: (4)                def sort_faces_back_to_front(self, vect=OUT):
215: (8)                    tri_is = self.triangle_indices
216: (8)                    indices = list(range(len(tri_is) // 3))
217: (8)                    points = self.points
218: (8)                    def index_dot(index):
219: (12)                       return np.dot(points[tri_is[3 * index]], vect)
220: (8)                    indices.sort(key=index_dot)
221: (8)                    for k in range(3):
222: (12)                       tri_is[k::3] = tri_is[k::3][indices]
223: (8)                    return self
224: (4)                # For shaders
225: (4)                def get_shader_data(self):
226: (8)                    """Called by parent Mobject to calculate and return
227: (8)                    the shader data.
228: (8)                    Returns
229: (8)                    -------
230: (8)                    shader_dtype
231: (12)                       An array containing the shader data (vertices and
232: (12)                       color of each vertex)
233: (8)                    """
234: (8)                    s_points, du_points, dv_points = self.get_surface_points_and_nudged_points()
235: (8)                    shader_data = np.zeros(len(s_points), dtype=self.shader_dtype)
236: (8)                    if "points" not in self.locked_data_keys:
237: (12)                       shader_data["point"] = s_points
238: (12)                       shader_data["du_point"] = du_points
239: (12)                       shader_data["dv_point"] = dv_points
240: (12)                       if self.colorscale:
241: (16)                           if not hasattr(self, "color_by_val"):
242: (20)                               self.color_by_val = self._get_color_by_value(s_points)
243: (16)                           shader_data["color"] = self.color_by_val
244: (12)                       else:
245: (16)                           self.fill_in_shader_color_info(shader_data)
246: (8)                    return shader_data
247: (4)                def fill_in_shader_color_info(self, shader_data):
248: (8)                    """Fills in the shader color data when the surface
249: (8)                    is all one color.
250: (8)                    Parameters
251: (8)                    ----------
252: (8)                    shader_data
253: (12)                       The vertices of the surface.
254: (8)                    Returns
255: (8)                    -------
256: (8)                    shader_dtype
257: (12)                       An array containing the shader data (vertices and
258: (12)                       color of each vertex)
259: (8)                    """
260: (8)                    self.read_data_to_shader(shader_data, "color", "rgbas")
261: (8)                    return shader_data
262: (4)                def _get_color_by_value(self, s_points):
263: (8)                    """Matches each vertex to a color associated to it's z-value.
264: (8)                    Parameters
265: (8)                    ----------
266: (8)                    s_points
267: (11)                      The vertices of the surface.
268: (8)                    Returns
269: (8)                    -------
270: (8)                    List
271: (12)                       A list of colors matching the vertex inputs.
272: (8)                    """
273: (8)                    if type(self.colorscale[0]) in (list, tuple):
274: (12)                       new_colors, pivots = [
275: (16)                           [i for i, j in self.colorscale],
276: (16)                           [j for i, j in self.colorscale],
277: (12)                       ]
278: (8)                    else:
279: (12)                       new_colors = self.colorscale
280: (12)                       pivot_min = self.axes.z_range[0]
281: (12)                       pivot_max = self.axes.z_range[1]
282: (12)                       pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)
283: (12)                       pivots = np.arange(
284: (16)                           start=pivot_min,
285: (16)                           stop=pivot_max + pivot_frequency,
286: (16)                           step=pivot_frequency,
287: (12)                       )
288: (8)                    return_colors = []
289: (8)                    for point in s_points:
290: (12)                       axis_value = self.axes.point_to_coords(point)[self.colorscale_axis]
291: (12)                       if axis_value <= pivots[0]:
292: (16)                           return_colors.append(color_to_rgba(new_colors[0], self.opacity))
293: (12)                       elif axis_value >= pivots[-1]:
294: (16)                           return_colors.append(color_to_rgba(new_colors[-1], self.opacity))
295: (12)                       else:
296: (16)                           for i, pivot in enumerate(pivots):
297: (20)                               if pivot > axis_value:
298: (24)                                   color_index = (axis_value - pivots[i - 1]) / (
299: (28)                                       pivots[i] - pivots[i - 1]
300: (24)                                   )
301: (24)                                   color_index = max(min(color_index, 1), 0)
302: (24)                                   temp_color = interpolate_color(
303: (28)                                       new_colors[i - 1],
304: (28)                                       new_colors[i],
305: (28)                                       color_index,
306: (24)                                   )
307: (24)                                   break
308: (16)                           return_colors.append(color_to_rgba(temp_color, self.opacity))
309: (8)                    return return_colors
310: (4)                def get_shader_vert_indices(self):
311: (8)                    return self.get_triangle_indices()
312: (0)            class OpenGLSurfaceGroup(OpenGLSurface):
313: (4)                def __init__(self, *parametric_surfaces, resolution=None, **kwargs):
314: (8)                    self.resolution = (0, 0) if resolution is None else resolution
315: (8)                    super().__init__(uv_func=None, **kwargs)
316: (8)                    self.add(*parametric_surfaces)
317: (4)                def init_points(self):
318: (8)                    pass  # Needed?
319: (0)            class OpenGLTexturedSurface(OpenGLSurface):
320: (4)                shader_dtype = [
321: (8)                    ("point", np.float32, (3,)),
322: (8)                    ("du_point", np.float32, (3,)),
323: (8)                    ("dv_point", np.float32, (3,)),
324: (8)                    ("im_coords", np.float32, (2,)),
325: (8)                    ("opacity", np.float32, (1,)),
326: (4)                ]
327: (4)                shader_folder = "textured_surface"
328: (4)                im_coords = _Data()
329: (4)                opacity = _Data()
330: (4)                num_textures = _Uniforms()
331: (4)                def __init__(
332: (8)                    self,
333: (8)                    uv_surface: OpenGLSurface,
334: (8)                    image_file: str | Path,
335: (8)                    dark_image_file: str | Path = None,
336: (8)                    image_mode: str | Iterable[str] = "RGBA",
337: (8)                    shader_folder: str | Path = None,
338: (8)                    **kwargs,
339: (4)                ):
340: (8)                    self.uniforms = {}
341: (8)                    if not isinstance(uv_surface, OpenGLSurface):
342: (12)                       raise Exception("uv_surface must be of type OpenGLSurface")
343: (8)                    if isinstance(image_file, np.ndarray):
344: (12)                       image_file = change_to_rgba_array(image_file)
345: (8)                    # Set texture information
346: (8)                    if isinstance(image_mode, (str, Path)):
347: (12)                       image_mode = [image_mode] * 2
348: (8)                    image_mode_light, image_mode_dark = image_mode
349: (8)                    texture_paths = {
350: (12)                       "LightTexture": self.get_image_from_file(
351: (16)                           image_file,
352: (16)                           image_mode_light,
353: (12)                       ),
354: (12)                       "DarkTexture": self.get_image_from_file(
355: (16)                           dark_image_file or image_file,
356: (16)                           image_mode_dark,
357: (12)                       ),
358: (8)                    }
359: (8)                    if dark_image_file:
360: (12)                       self.num_textures = 2
361: (8)                    self.uv_surface = uv_surface
362: (8)                    self.uv_func = uv_surface.uv_func
363: (8)                    self.u_range = uv_surface.u_range
364: (8)                    self.v_range = uv_surface.v_range
365: (8)                    self.resolution = uv_surface.resolution
366: (8)                    self.gloss = self.uv_surface.gloss
367: (8)                    super().__init__(texture_paths=texture_paths, **kwargs)
368: (4)                def get_image_from_file(
369: (8)                    self,
370: (8)                    image_file: str | Path,
371: (8)                    image_mode: str,
372: (4)                ):
373: (8)                    image_file = get_full_raster_image_path(image_file)
374: (8)                    return Image.open(image_file).convert(image_mode)
375: (4)                def init_data(self):
376: (8)                    super().init_data()
377: (8)                    self.im_coords = np.zeros((0, 2))
378: (8)                    self.opacity = np.zeros((0, 1))
379: (4)                def init_points(self):
380: (8)                    nu, nv = self.uv_surface.resolution
381: (8)                    self.set_points(self.uv_surface.points)
382: (8)                    self.im_coords = np.array(
383: (12)                       [
384: (16)                           [u, v]
385: (16)                           for u in np.linspace(0, 1, nu)
386: (16)                           for v in np.linspace(1, 0, nv)  # Reverse y-direction
387: (12)                       ],
388: (8)                    )
389: (4)                def init_colors(self):
390: (8)                    self.opacity = np.array([self.uv_surface.rgbas[:, 3]])
391: (4)                def set_opacity(self, opacity, recurse=True):
392: (8)                    for mob in self.get_family(recurse):
393: (12)                       mob.opacity = np.array([[o] for o in listify(opacity)])
394: (8)                    return self
395: (4)                def pointwise_become_partial(self, tsmobject, a, b, axis=1):
396: (8)                    super().pointwise_become_partial(tsmobject, a, b, axis)
397: (8)                    im_coords = self.im_coords
398: (8)                    im_coords[:] = tsmobject.im_coords
399: (8)                    if a <= 0 and b >= 1:
400: (12)                       return self
401: (8)                    nu, nv = tsmobject.resolution
402: (8)                    im_coords[:] = self.get_partial_points_array(im_coords, a, b, (nu, nv, 2), axis)
403: (8)                    return self
404: (4)                def fill_in_shader_color_info(self, shader_data):
405: (8)                    self.read_data_to_shader(shader_data, "opacity", "opacity")
406: (8)                    self.read_data_to_shader(shader_data, "im_coords", "im_coords")
407: (8)                    return shader_data

----------------------------------------

File 40 - .\opengl \opengl_geometry.py:

1: (0)              from __future__ import annotations
2: (0)              import numpy as np
3: (0)              from manim.constants import *
4: (0)              from manim.mobject.mobject import Mobject
5: (0)              from manim.mobject.opengl.opengl_vectorized_mobject import (
6: (4)                  OpenGLDashedVMobject,
7: (4)                  OpenGLVGroup,
8: (4)                  OpenGLVMobject,
9: (0)              )
10: (0)             from manim.utils.color import *
11: (0)             from manim.utils.iterables import adjacent_n_tuples, adjacent_pairs
12: (0)             from manim.utils.simple_functions import clip
13: (0)             from manim.utils.space_ops import (
14: (4)                 angle_between_vectors,
15: (4)                 angle_of_vector,
16: (4)                 compass_directions,
17: (4)                 find_intersection,
18: (4)                 normalize,
19: (4)                 rotate_vector,
20: (4)                 rotation_matrix_transpose,
21: (0)             )
22: (0)             DEFAULT_DOT_RADIUS = 0.08
23: (0)             DEFAULT_DASH_LENGTH = 0.05
24: (0)             DEFAULT_ARROW_TIP_LENGTH = 0.35
25: (0)             DEFAULT_ARROW_TIP_WIDTH = 0.35
26: (0)             __all__ = [
27: (4)                 "OpenGLTipableVMobject",
28: (4)                 "OpenGLArc",
29: (4)                 "OpenGLArcBetweenPoints",
30: (4)                 "OpenGLCurvedArrow",
31: (4)                 "OpenGLCurvedDoubleArrow",
32: (4)                 "OpenGLCircle",
33: (4)                 "OpenGLDot",
34: (4)                 "OpenGLEllipse",
35: (4)                 "OpenGLAnnularSector",
36: (4)                 "OpenGLSector",
37: (4)                 "OpenGLAnnulus",
38: (4)                 "OpenGLLine",
39: (4)                 "OpenGLDashedLine",
40: (4)                 "OpenGLTangentLine",
41: (4)                 "OpenGLElbow",
42: (4)                 "OpenGLArrow",
43: (4)                 "OpenGLVector",
44: (4)                 "OpenGLDoubleArrow",
45: (4)                 "OpenGLCubicBezier",
46: (4)                 "OpenGLPolygon",
47: (4)                 "OpenGLRegularPolygon",
48: (4)                 "OpenGLTriangle",
49: (4)                 "OpenGLArrowTip",
50: (0)             ]
51: (0)             class OpenGLTipableVMobject(OpenGLVMobject):
52: (4)                 """
53: (4)                 Meant for shared functionality between Arc and Line.
54: (4)                 Functionality can be classified broadly into these groups:
55: (8)                     * Adding, Creating, Modifying tips
56: (12)                        - add_tip calls create_tip, before pushing the new tip
57: (16)                            into the TipableVMobject's list of submobjects
58: (12)                        - stylistic and positional configuration
59: (8)                     * Checking for tips
60: (12)                        - Boolean checks for whether the TipableVMobject has a tip
61: (16)                            and a starting tip
62: (8)                     * Getters
63: (12)                        - Straightforward accessors, returning information pertaining
64: (16)                            to the TipableVMobject instance's tip(s), its length etc
65: (4)                 """
66: (4)                 # Adding, Creating, Modifying tips
67: (4)                 def __init__(
68: (8)                     self,
69: (8)                     tip_length=DEFAULT_ARROW_TIP_LENGTH,
70: (8)                     normal_vector=OUT,
71: (8)                     tip_config={},
72: (8)                     **kwargs,
73: (4)                 ):
74: (8)                     self.tip_length = tip_length
75: (8)                     self.normal_vector = normal_vector
76: (8)                     self.tip_config = tip_config
77: (8)                     super().__init__(**kwargs)
78: (4)                 def add_tip(self, at_start=False, **kwargs):
79: (8)                     """
80: (8)                     Adds a tip to the TipableVMobject instance, recognising
81: (8)                     that the endpoints might need to be switched if it's
82: (8)                     a 'starting tip' or not.
83: (8)                     """
84: (8)                     tip = self.create_tip(at_start, **kwargs)
85: (8)                     self.reset_endpoints_based_on_tip(tip, at_start)
86: (8)                     self.asign_tip_attr(tip, at_start)
87: (8)                     self.add(tip)
88: (8)                     return self
89: (4)                 def create_tip(self, at_start=False, **kwargs):
90: (8)                     """
91: (8)                     Stylises the tip, positions it spacially, and returns
92: (8)                     the newly instantiated tip to the caller.
93: (8)                     """
94: (8)                     tip = self.get_unpositioned_tip(**kwargs)
95: (8)                     self.position_tip(tip, at_start)
96: (8)                     return tip
97: (4)                 def get_unpositioned_tip(self, **kwargs):
98: (8)                     """
99: (8)                     Returns a tip that has been stylistically configured,
100: (8)                    but has not yet been given a position in space.
101: (8)                    """
102: (8)                    config = {}
103: (8)                    config.update(self.tip_config)
104: (8)                    config.update(kwargs)
105: (8)                    return OpenGLArrowTip(**config)
106: (4)                def position_tip(self, tip, at_start=False):
107: (8)                    # Last two control points, defining both
108: (8)                    # the end, and the tangency direction
109: (8)                    if at_start:
110: (12)                       anchor = self.get_start()
111: (12)                       handle = self.get_first_handle()
112: (8)                    else:
113: (12)                       handle = self.get_last_handle()
114: (12)                       anchor = self.get_end()
115: (8)                    tip.rotate(angle_of_vector(handle - anchor) - PI - tip.get_angle())
116: (8)                    tip.shift(anchor - tip.get_tip_point())
117: (8)                    return tip
118: (4)                def reset_endpoints_based_on_tip(self, tip, at_start):
119: (8)                    if self.get_length() == 0:
120: (12)                       # Zero length, put_start_and_end_on wouldn't
121: (12)                       # work
122: (12)                       return self
123: (8)                    if at_start:
124: (12)                       start = tip.get_base()
125: (12)                       end = self.get_end()
126: (8)                    else:
127: (12)                       start = self.get_start()
128: (12)                       end = tip.get_base()
129: (8)                    self.put_start_and_end_on(start, end)
130: (8)                    return self
131: (4)                def asign_tip_attr(self, tip, at_start):
132: (8)                    if at_start:
133: (12)                       self.start_tip = tip
134: (8)                    else:
135: (12)                       self.tip = tip
136: (8)                    return self
137: (4)                # Checking for tips
138: (4)                def has_tip(self):
139: (8)                    return hasattr(self, "tip") and self.tip in self
140: (4)                def has_start_tip(self):
141: (8)                    return hasattr(self, "start_tip") and self.start_tip in self
142: (4)                # Getters
143: (4)                def pop_tips(self):
144: (8)                    start, end = self.get_start_and_end()
145: (8)                    result = OpenGLVGroup()
146: (8)                    if self.has_tip():
147: (12)                       result.add(self.tip)
148: (12)                       self.remove(self.tip)
149: (8)                    if self.has_start_tip():
150: (12)                       result.add(self.start_tip)
151: (12)                       self.remove(self.start_tip)
152: (8)                    self.put_start_and_end_on(start, end)
153: (8)                    return result
154: (4)                def get_tips(self):
155: (8)                    """
156: (8)                    Returns a VGroup (collection of VMobjects) containing
157: (8)                    the TipableVMObject instance's tips.
158: (8)                    """
159: (8)                    result = OpenGLVGroup()
160: (8)                    if hasattr(self, "tip"):
161: (12)                       result.add(self.tip)
162: (8)                    if hasattr(self, "start_tip"):
163: (12)                       result.add(self.start_tip)
164: (8)                    return result
165: (4)                def get_tip(self):
166: (8)                    """Returns the TipableVMobject instance's (first) tip,
167: (8)                    otherwise throws an exception."""
168: (8)                    tips = self.get_tips()
169: (8)                    if len(tips) == 0:
170: (12)                       raise Exception("tip not found")
171: (8)                    else:
172: (12)                       return tips[0]
173: (4)                def get_default_tip_length(self):
174: (8)                    return self.tip_length
175: (4)                def get_first_handle(self):
176: (8)                    return self.points[1]
177: (4)                def get_last_handle(self):
178: (8)                    return self.points[-2]
179: (4)                def get_end(self):
180: (8)                    if self.has_tip():
181: (12)                       return self.tip.get_start()
182: (8)                    else:
183: (12)                       return super().get_end()
184: (4)                def get_start(self):
185: (8)                    if self.has_start_tip():
186: (12)                       return self.start_tip.get_start()
187: (8)                    else:
188: (12)                       return super().get_start()
189: (4)                def get_length(self):
190: (8)                    start, end = self.get_start_and_end()
191: (8)                    return np.linalg.norm(start - end)
192: (0)            class OpenGLArc(OpenGLTipableVMobject):
193: (4)                def __init__(
194: (8)                    self,
195: (8)                    start_angle=0,
196: (8)                    angle=TAU / 4,
197: (8)                    radius=1.0,
198: (8)                    n_components=8,
199: (8)                    arc_center=ORIGIN,
200: (8)                    **kwargs,
201: (4)                ):
202: (8)                    self.start_angle = start_angle
203: (8)                    self.angle = angle
204: (8)                    self.radius = radius
205: (8)                    self.n_components = n_components
206: (8)                    self.arc_center = arc_center
207: (8)                    super().__init__(self, **kwargs)
208: (8)                    self.orientation = -1
209: (4)                def init_points(self):
210: (8)                    self.set_points(
211: (12)                       OpenGLArc.create_quadratic_bezier_points(
212: (16)                           angle=self.angle,
213: (16)                           start_angle=self.start_angle,
214: (16)                           n_components=self.n_components,
215: (12)                       ),
216: (8)                    )
217: (8)                    # To maintain proper orientation for fill shaders.
218: (8)                    self.scale(self.radius, about_point=ORIGIN)
219: (8)                    self.shift(self.arc_center)
220: (4)                @staticmethod
221: (4)                def create_quadratic_bezier_points(angle, start_angle=0, n_components=8):
222: (8)                    samples = np.array(
223: (12)                       [
224: (16)                           [np.cos(a), np.sin(a), 0]
225: (16)                           for a in np.linspace(
226: (20)                               start_angle,
227: (20)                               start_angle + angle,
228: (20)                               2 * n_components + 1,
229: (16)                           )
230: (12)                       ],
231: (8)                    )
232: (8)                    theta = angle / n_components
233: (8)                    samples[1::2] /= np.cos(theta / 2)
234: (8)                    points = np.zeros((3 * n_components, 3))
235: (8)                    points[0::3] = samples[0:-1:2]
236: (8)                    points[1::3] = samples[1::2]
237: (8)                    points[2::3] = samples[2::2]
238: (8)                    return points
239: (4)                def get_arc_center(self):
240: (8)                    """
241: (8)                    Looks at the normals to the first two
242: (8)                    anchors, and finds their intersection points
243: (8)                    """
244: (8)                    # First two anchors and handles
245: (8)                    a1, h, a2 = self.points[:3]
246: (8)                    # Tangent vectors
247: (8)                    t1 = h - a1
248: (8)                    t2 = h - a2
249: (8)                    # Normals
250: (8)                    n1 = rotate_vector(t1, TAU / 4)
251: (8)                    n2 = rotate_vector(t2, TAU / 4)
252: (8)                    return find_intersection(a1, n1, a2, n2)
253: (4)                def get_start_angle(self):
254: (8)                    angle = angle_of_vector(self.get_start() - self.get_arc_center())
255: (8)                    return angle % TAU
256: (4)                def get_stop_angle(self):
257: (8)                    angle = angle_of_vector(self.get_end() - self.get_arc_center())
258: (8)                    return angle % TAU
259: (4)                def move_arc_center_to(self, point):
260: (8)                    self.shift(point - self.get_arc_center())
261: (8)                    return self
262: (0)            class OpenGLArcBetweenPoints(OpenGLArc):
263: (4)                def __init__(self, start, end, angle=TAU / 4, **kwargs):
264: (8)                    super().__init__(angle=angle, **kwargs)
265: (8)                    if angle == 0:
266: (12)                       self.set_points_as_corners([LEFT, RIGHT])
267: (8)                    self.put_start_and_end_on(start, end)
268: (0)            class OpenGLCurvedArrow(OpenGLArcBetweenPoints):
269: (4)                def __init__(self, start_point, end_point, **kwargs):
270: (8)                    super().__init__(start_point, end_point, **kwargs)
271: (8)                    self.add_tip()
272: (0)            class OpenGLCurvedDoubleArrow(OpenGLCurvedArrow):
273: (4)                def __init__(self, start_point, end_point, **kwargs):
274: (8)                    super().__init__(start_point, end_point, **kwargs)
275: (8)                    self.add_tip(at_start=True)
276: (0)            class OpenGLCircle(OpenGLArc):
277: (4)                def __init__(self, color=RED, **kwargs):
278: (8)                    super().__init__(0, TAU, color=color, **kwargs)
279: (4)                def surround(self, mobject, dim_to_match=0, stretch=False, buff=MED_SMALL_BUFF):
280: (8)                    # Ignores dim_to_match and stretch; result will always be a circle
281: (8)                    # TODO: Perhaps create an ellipse class to handle singele-dimension stretching
282: (8)                    self.replace(mobject, dim_to_match, stretch)
283: (8)                    self.stretch((self.get_width() + 2 * buff) / self.get_width(), 0)
284: (8)                    self.stretch((self.get_height() + 2 * buff) / self.get_height(), 1)
285: (4)                def point_at_angle(self, angle):
286: (8)                    start_angle = self.get_start_angle()
287: (8)                    return self.point_from_proportion((angle - start_angle) / TAU)
288: (0)            class OpenGLDot(OpenGLCircle):
289: (4)                def __init__(
290: (8)                    self,
291: (8)                    point=ORIGIN,
292: (8)                    radius=DEFAULT_DOT_RADIUS,
293: (8)                    stroke_width=0,
294: (8)                    fill_opacity=1.0,
295: (8)                    color=WHITE,
296: (8)                    **kwargs,
297: (4)                ):
298: (8)                    super().__init__(
299: (12)                       arc_center=point,
300: (12)                       radius=radius,
301: (12)                       stroke_width=stroke_width,
302: (12)                       fill_opacity=fill_opacity,
303: (12)                       color=color,
304: (12)                       **kwargs,
305: (8)                    )
306: (0)            class OpenGLEllipse(OpenGLCircle):
307: (4)                def __init__(self, width=2, height=1, **kwargs):
308: (8)                    super().__init__(**kwargs)
309: (8)                    self.set_width(width, stretch=True)
310: (8)                    self.set_height(height, stretch=True)
311: (0)            class OpenGLAnnularSector(OpenGLArc):
312: (4)                def __init__(
313: (8)                    self,
314: (8)                    inner_radius=1,
315: (8)                    outer_radius=2,
316: (8)                    angle=TAU / 4,
317: (8)                    start_angle=0,
318: (8)                    fill_opacity=1,
319: (8)                    stroke_width=0,
320: (8)                    color=WHITE,
321: (8)                    **kwargs,
322: (4)                ):
323: (8)                    self.inner_radius = inner_radius
324: (8)                    self.outer_radius = outer_radius
325: (8)                    super().__init__(
326: (12)                       start_angle=start_angle,
327: (12)                       angle=angle,
328: (12)                       fill_opacity=fill_opacity,
329: (12)                       stroke_width=stroke_width,
330: (12)                       color=color,
331: (12)                       **kwargs,
332: (8)                    )
333: (4)                def init_points(self):
334: (8)                    inner_arc, outer_arc = (
335: (12)                       OpenGLArc(
336: (16)                           start_angle=self.start_angle,
337: (16)                           angle=self.angle,
338: (16)                           radius=radius,
339: (16)                           arc_center=self.arc_center,
340: (12)                       )
341: (12)                       for radius in (self.inner_radius, self.outer_radius)
342: (8)                    )
343: (8)                    outer_arc.reverse_points()
344: (8)                    self.append_points(inner_arc.points)
345: (8)                    self.add_line_to(outer_arc.points[0])
346: (8)                    self.append_points(outer_arc.points)
347: (8)                    self.add_line_to(inner_arc.points[0])
348: (0)            class OpenGLSector(OpenGLAnnularSector):
349: (4)                def __init__(self, outer_radius=1, inner_radius=0, **kwargs):
350: (8)                    super().__init__(inner_radius=inner_radius, outer_radius=outer_radius, **kwargs)
351: (0)            class OpenGLAnnulus(OpenGLCircle):
352: (4)                def __init__(
353: (8)                    self,
354: (8)                    inner_radius=1,
355: (8)                    outer_radius=2,
356: (8)                    fill_opacity=1,
357: (8)                    stroke_width=0,
358: (8)                    color=WHITE,
359: (8)                    mark_paths_closed=False,
360: (8)                    **kwargs,
361: (4)                ):
362: (8)                    self.mark_paths_closed = mark_paths_closed  # is this even used?
363: (8)                    self.inner_radius = inner_radius
364: (8)                    self.outer_radius = outer_radius
365: (8)                    super().__init__(
366: (12)                       fill_opacity=fill_opacity, stroke_width=stroke_width, color=color, **kwargs
367: (8)                    )
368: (4)                def init_points(self):
369: (8)                    self.radius = self.outer_radius
370: (8)                    outer_circle = OpenGLCircle(radius=self.outer_radius)
371: (8)                    inner_circle = OpenGLCircle(radius=self.inner_radius)
372: (8)                    inner_circle.reverse_points()
373: (8)                    self.append_points(outer_circle.points)
374: (8)                    self.append_points(inner_circle.points)
375: (8)                    self.shift(self.arc_center)
376: (0)            class OpenGLLine(OpenGLTipableVMobject):
377: (4)                def __init__(self, start=LEFT, end=RIGHT, buff=0, path_arc=0, **kwargs):
378: (8)                    self.dim = 3
379: (8)                    self.buff = buff
380: (8)                    self.path_arc = path_arc
381: (8)                    self.set_start_and_end_attrs(start, end)
382: (8)                    super().__init__(**kwargs)
383: (4)                def init_points(self):
384: (8)                    self.set_points_by_ends(self.start, self.end, self.buff, self.path_arc)
385: (4)                def set_points_by_ends(self, start, end, buff=0, path_arc=0):
386: (8)                    if path_arc:
387: (12)                       self.set_points(OpenGLArc.create_quadratic_bezier_points(path_arc))
388: (12)                       self.put_start_and_end_on(start, end)
389: (8)                    else:
390: (12)                       self.set_points_as_corners([start, end])
391: (8)                    self.account_for_buff(self.buff)
392: (4)                def set_path_arc(self, new_value):
393: (8)                    self.path_arc = new_value
394: (8)                    self.init_points()
395: (4)                def account_for_buff(self, buff):
396: (8)                    if buff == 0:
397: (12)                       return
398: (8)                    #
399: (8)                    if self.path_arc == 0:
400: (12)                       length = self.get_length()
401: (8)                    else:
402: (12)                       length = self.get_arc_length()
403: (8)                    #
404: (8)                    if length < 2 * buff:
405: (12)                       return
406: (8)                    buff_prop = buff / length
407: (8)                    self.pointwise_become_partial(self, buff_prop, 1 - buff_prop)
408: (8)                    return self
409: (4)                def set_start_and_end_attrs(self, start, end):
410: (8)                    # If either start or end are Mobjects, this
411: (8)                    # gives their centers
412: (8)                    rough_start = self.pointify(start)
413: (8)                    rough_end = self.pointify(end)
414: (8)                    vect = normalize(rough_end - rough_start)
415: (8)                    # Now that we know the direction between them,
416: (8)                    # we can find the appropriate boundary point from
417: (8)                    # start and end, if they're mobjects
418: (8)                    self.start = self.pointify(start, vect) + self.buff * vect
419: (8)                    self.end = self.pointify(end, -vect) - self.buff * vect
420: (4)                def pointify(self, mob_or_point, direction=None):
421: (8)                    """
422: (8)                    Take an argument passed into Line (or subclass) and turn
423: (8)                    it into a 3d point.
424: (8)                    """
425: (8)                    if isinstance(mob_or_point, Mobject):
426: (12)                       mob = mob_or_point
427: (12)                       if direction is None:
428: (16)                           return mob.get_center()
429: (12)                       else:
430: (16)                           return mob.get_continuous_bounding_box_point(direction)
431: (8)                    else:
432: (12)                       point = mob_or_point
433: (12)                       result = np.zeros(self.dim)
434: (12)                       result[: len(point)] = point
435: (12)                       return result
436: (4)                def put_start_and_end_on(self, start, end):
437: (8)                    curr_start, curr_end = self.get_start_and_end()
438: (8)                    if (curr_start == curr_end).all():
439: (12)                       self.set_points_by_ends(start, end, self.path_arc)
440: (8)                    return super().put_start_and_end_on(start, end)
441: (4)                def get_vector(self):
442: (8)                    return self.get_end() - self.get_start()
443: (4)                def get_unit_vector(self):
444: (8)                    return normalize(self.get_vector())
445: (4)                def get_angle(self):
446: (8)                    return angle_of_vector(self.get_vector())
447: (4)                def get_projection(self, point):
448: (8)                    """
449: (8)                    Return projection of a point onto the line
450: (8)                    """
451: (8)                    unit_vect = self.get_unit_vector()
452: (8)                    start = self.get_start()
453: (8)                    return start + np.dot(point - start, unit_vect) * unit_vect
454: (4)                def get_slope(self):
455: (8)                    return np.tan(self.get_angle())
456: (4)                def set_angle(self, angle, about_point=None):
457: (8)                    if about_point is None:
458: (12)                       about_point = self.get_start()
459: (8)                    self.rotate(
460: (12)                       angle - self.get_angle(),
461: (12)                       about_point=about_point,
462: (8)                    )
463: (8)                    return self
464: (4)                def set_length(self, length):
465: (8)                    self.scale(length / self.get_length())
466: (0)            class OpenGLDashedLine(OpenGLLine):
467: (4)                def __init__(
468: (8)                    self, *args, dash_length=DEFAULT_DASH_LENGTH, dashed_ratio=0.5, **kwargs
469: (4)                ):
470: (8)                    self.dashed_ratio = dashed_ratio
471: (8)                    self.dash_length = dash_length
472: (8)                    super().__init__(*args, **kwargs)
473: (8)                    dashed_ratio = self.dashed_ratio
474: (8)                    num_dashes = self.calculate_num_dashes(dashed_ratio)
475: (8)                    dashes = OpenGLDashedVMobject(
476: (12)                       self,
477: (12)                       num_dashes=num_dashes,
478: (12)                       dashed_ratio=dashed_ratio,
479: (8)                    )
480: (8)                    self.clear_points()
481: (8)                    self.add(*dashes)
482: (4)                def calculate_num_dashes(self, dashed_ratio):
483: (8)                    return max(
484: (12)                       2,
485: (12)                       int(np.ceil((self.get_length() / self.dash_length) * dashed_ratio)),
486: (8)                    )
487: (4)                def get_start(self):
488: (8)                    if len(self.submobjects) > 0:
489: (12)                       return self.submobjects[0].get_start()
490: (8)                    else:
491: (12)                       return super().get_start()
492: (4)                def get_end(self):
493: (8)                    if len(self.submobjects) > 0:
494: (12)                       return self.submobjects[-1].get_end()
495: (8)                    else:
496: (12)                       return super().get_end()
497: (4)                def get_first_handle(self):
498: (8)                    return self.submobjects[0].points[1]
499: (4)                def get_last_handle(self):
500: (8)                    return self.submobjects[-1].points[-2]
501: (0)            class OpenGLTangentLine(OpenGLLine):
502: (4)                def __init__(self, vmob, alpha, length=1, d_alpha=1e-6, **kwargs):
503: (8)                    self.length = length
504: (8)                    self.d_alpha = d_alpha
505: (8)                    da = self.d_alpha
506: (8)                    a1 = clip(alpha - da, 0, 1)
507: (8)                    a2 = clip(alpha + da, 0, 1)
508: (8)                    super().__init__(vmob.pfp(a1), vmob.pfp(a2), **kwargs)
509: (8)                    self.scale(self.length / self.get_length())
510: (0)            class OpenGLElbow(OpenGLVMobject):
511: (4)                def __init__(self, width=0.2, angle=0, **kwargs):
512: (8)                    self.angle = angle
513: (8)                    super().__init__(self, **kwargs)
514: (8)                    self.set_points_as_corners([UP, UP + RIGHT, RIGHT])
515: (8)                    self.set_width(width, about_point=ORIGIN)
516: (8)                    self.rotate(self.angle, about_point=ORIGIN)
517: (0)            class OpenGLArrow(OpenGLLine):
518: (4)                def __init__(
519: (8)                    self,
520: (8)                    start=LEFT,
521: (8)                    end=RIGHT,
522: (8)                    path_arc=0,
523: (8)                    fill_color=GREY_A,
524: (8)                    fill_opacity=1,
525: (8)                    stroke_width=0,
526: (8)                    buff=MED_SMALL_BUFF,
527: (8)                    thickness=0.05,
528: (8)                    tip_width_ratio=5,
529: (8)                    tip_angle=PI / 3,
530: (8)                    max_tip_length_to_length_ratio=0.5,
531: (8)                    max_width_to_length_ratio=0.1,
532: (8)                    **kwargs,
533: (4)                ):
534: (8)                    self.thickness = thickness
535: (8)                    self.tip_width_ratio = tip_width_ratio
536: (8)                    self.tip_angle = tip_angle
537: (8)                    self.max_tip_length_to_length_ratio = max_tip_length_to_length_ratio
538: (8)                    self.max_width_to_length_ratio = max_width_to_length_ratio
539: (8)                    super().__init__(
540: (12)                       start=start,
541: (12)                       end=end,
542: (12)                       buff=buff,
543: (12)                       path_arc=path_arc,
544: (12)                       fill_color=fill_color,
545: (12)                       fill_opacity=fill_opacity,
546: (12)                       stroke_width=stroke_width,
547: (12)                       **kwargs,
548: (8)                    )
549: (4)                def set_points_by_ends(self, start, end, buff=0, path_arc=0):
550: (8)                    # Find the right tip length and thickness
551: (8)                    vect = end - start
552: (8)                    length = max(np.linalg.norm(vect), 1e-8)
553: (8)                    thickness = self.thickness
554: (8)                    w_ratio = self.max_width_to_length_ratio / (thickness / length)
555: (8)                    if w_ratio < 1:
556: (12)                       thickness *= w_ratio
557: (8)                    tip_width = self.tip_width_ratio * thickness
558: (8)                    tip_length = tip_width / (2 * np.tan(self.tip_angle / 2))
559: (8)                    t_ratio = self.max_tip_length_to_length_ratio / (tip_length / length)
560: (8)                    if t_ratio < 1:
561: (12)                       tip_length *= t_ratio
562: (12)                       tip_width *= t_ratio
563: (8)                    # Find points for the stem
564: (8)                    if path_arc == 0:
565: (12)                       points1 = (length - tip_length) * np.array([RIGHT, 0.5 * RIGHT, ORIGIN])
566: (12)                       points1 += thickness * UP / 2
567: (12)                       points2 = points1[::-1] + thickness * DOWN
568: (8)                    else:
569: (12)                       # Solve for radius so that the tip-to-tail length matches |end - start|
570: (12)                       a = 2 * (1 - np.cos(path_arc))
571: (12)                       b = -2 * tip_length * np.sin(path_arc)
572: (12)                       c = tip_length**2 - length**2
573: (12)                       R = (-b + np.sqrt(b**2 - 4 * a * c)) / (2 * a)
574: (12)                       # Find arc points
575: (12)                       points1 = OpenGLArc.create_quadratic_bezier_points(path_arc)
576: (12)                       points2 = np.array(points1[::-1])
577: (12)                       points1 *= R + thickness / 2
578: (12)                       points2 *= R - thickness / 2
579: (12)                       if path_arc < 0:
580: (16)                           tip_length *= -1
581: (12)                       rot_T = rotation_matrix_transpose(PI / 2 - path_arc, OUT)
582: (12)                       for points in points1, points2:
583: (16)                           points[:] = np.dot(points, rot_T)
584: (16)                           points += R * DOWN
585: (8)                    self.set_points(points1)
586: (8)                    # Tip
587: (8)                    self.add_line_to(tip_width * UP / 2)
588: (8)                    self.add_line_to(tip_length * LEFT)
589: (8)                    self.tip_index = len(self.points) - 1
590: (8)                    self.add_line_to(tip_width * DOWN / 2)
591: (8)                    self.add_line_to(points2[0])
592: (8)                    # Close it out
593: (8)                    self.append_points(points2)
594: (8)                    self.add_line_to(points1[0])
595: (8)                    if length > 0:
596: (12)                       # Final correction
597: (12)                       super().scale(length / self.get_length())
598: (8)                    self.rotate(angle_of_vector(vect) - self.get_angle())
599: (8)                    self.rotate(
600: (12)                       PI / 2 - np.arccos(normalize(vect)[2]),
601: (12)                       axis=rotate_vector(self.get_unit_vector(), -PI / 2),
602: (8)                    )
603: (8)                    self.shift(start - self.get_start())
604: (8)                    self.refresh_triangulation()
605: (4)                def reset_points_around_ends(self):
606: (8)                    self.set_points_by_ends(
607: (12)                       self.get_start(),
608: (12)                       self.get_end(),
609: (12)                       path_arc=self.path_arc,
610: (8)                    )
611: (8)                    return self
612: (4)                def get_start(self):
613: (8)                    nppc = self.n_points_per_curve
614: (8)                    points = self.points
615: (8)                    return (points[0] + points[-nppc]) / 2
616: (4)                def get_end(self):
617: (8)                    return self.points[self.tip_index]
618: (4)                def put_start_and_end_on(self, start, end):
619: (8)                    self.set_points_by_ends(start, end, buff=0, path_arc=self.path_arc)
620: (8)                    return self
621: (4)                def scale(self, *args, **kwargs):
622: (8)                    super().scale(*args, **kwargs)
623: (8)                    self.reset_points_around_ends()
624: (8)                    return self
625: (4)                def set_thickness(self, thickness):
626: (8)                    self.thickness = thickness
627: (8)                    self.reset_points_around_ends()
628: (8)                    return self
629: (4)                def set_path_arc(self, path_arc):
630: (8)                    self.path_arc = path_arc
631: (8)                    self.reset_points_around_ends()
632: (8)                    return self
633: (0)            class OpenGLVector(OpenGLArrow):
634: (4)                def __init__(self, direction=RIGHT, buff=0, **kwargs):
635: (8)                    self.buff = buff
636: (8)                    if len(direction) == 2:
637: (12)                       direction = np.hstack([direction, 0])
638: (8)                    super().__init__(ORIGIN, direction, buff=buff, **kwargs)
639: (0)            class OpenGLDoubleArrow(OpenGLArrow):
640: (4)                def __init__(self, *args, **kwargs):
641: (8)                    super().__init__(*args, **kwargs)
642: (8)                    self.add_tip(at_start=True)
643: (0)            class OpenGLCubicBezier(OpenGLVMobject):
644: (4)                def __init__(self, a0, h0, h1, a1, **kwargs):
645: (8)                    super().__init__(**kwargs)
646: (8)                    self.add_cubic_bezier_curve(a0, h0, h1, a1)
647: (0)            class OpenGLPolygon(OpenGLVMobject):
648: (4)                def __init__(self, *vertices, **kwargs):
649: (8)                    self.vertices = vertices
650: (8)                    super().__init__(**kwargs)
651: (4)                def init_points(self):
652: (8)                    verts = self.vertices
653: (8)                    self.set_points_as_corners([*verts, verts[0]])
654: (4)                def get_vertices(self):
655: (8)                    return self.get_start_anchors()
656: (4)                def round_corners(self, radius=0.5):
657: (8)                    vertices = self.get_vertices()
658: (8)                    arcs = []
659: (8)                    for v1, v2, v3 in adjacent_n_tuples(vertices, 3):
660: (12)                       vect1 = v2 - v1
661: (12)                       vect2 = v3 - v2
662: (12)                       unit_vect1 = normalize(vect1)
663: (12)                       unit_vect2 = normalize(vect2)
664: (12)                       angle = angle_between_vectors(vect1, vect2)
665: (12)                       # Negative radius gives concave curves
666: (12)                       angle *= np.sign(radius)
667: (12)                       # Distance between vertex and start of the arc
668: (12)                       cut_off_length = radius * np.tan(angle / 2)
669: (12)                       # Determines counterclockwise vs. clockwise
670: (12)                       sign = np.sign(np.cross(vect1, vect2)[2])
671: (12)                       arc = OpenGLArcBetweenPoints(
672: (16)                           v2 - unit_vect1 * cut_off_length,
673: (16)                           v2 + unit_vect2 * cut_off_length,
674: (16)                           angle=sign * angle,
675: (16)                           n_components=2,
676: (12)                       )
677: (12)                       arcs.append(arc)
678: (8)                    self.clear_points()
679: (8)                    # To ensure that we loop through starting with last
680: (8)                    arcs = [arcs[-1], *arcs[:-1]]
681: (8)                    for arc1, arc2 in adjacent_pairs(arcs):
682: (12)                       self.append_points(arc1.points)
683: (12)                       line = OpenGLLine(arc1.get_end(), arc2.get_start())
684: (12)                       # Make sure anchors are evenly distributed
685: (12)                       len_ratio = line.get_length() / arc1.get_arc_length()
686: (12)                       line.insert_n_curves(int(arc1.get_num_curves() * len_ratio))
687: (12)                       self.append_points(line.points)
688: (8)                    return self
689: (0)            class OpenGLRegularPolygon(OpenGLPolygon):
690: (4)                def __init__(self, n=6, start_angle=None, **kwargs):
691: (8)                    self.start_angle = start_angle
692: (8)                    if self.start_angle is None:
693: (12)                       if n % 2 == 0:
694: (16)                           self.start_angle = 0
695: (12)                       else:
696: (16)                           self.start_angle = 90 * DEGREES
697: (8)                    start_vect = rotate_vector(RIGHT, self.start_angle)
698: (8)                    vertices = compass_directions(n, start_vect)
699: (8)                    super().__init__(*vertices, **kwargs)
700: (0)            class OpenGLTriangle(OpenGLRegularPolygon):
701: (4)                def __init__(self, **kwargs):
702: (8)                    super().__init__(n=3, **kwargs)
703: (0)            class OpenGLArrowTip(OpenGLTriangle):
704: (4)                def __init__(
705: (8)                    self,
706: (8)                    fill_opacity=1,
707: (8)                    fill_color=WHITE,
708: (8)                    stroke_width=0,
709: (8)                    width=DEFAULT_ARROW_TIP_WIDTH,
710: (8)                    length=DEFAULT_ARROW_TIP_LENGTH,
711: (8)                    angle=0,
712: (8)                    **kwargs,
713: (4)                ):
714: (8)                    super().__init__(
715: (12)                       start_angle=0,
716: (12)                       fill_opacity=fill_opacity,
717: (12)                       fill_color=fill_color,
718: (12)                       stroke_width=stroke_width,
719: (12)                       **kwargs,
720: (8)                    )
721: (8)                    self.set_width(width, stretch=True)
722: (8)                    self.set_height(length, stretch=True)
723: (4)                def get_base(self):
724: (8)                    return self.point_from_proportion(0.5)
725: (4)                def get_tip_point(self):
726: (8)                    return self.points[0]
727: (4)                def get_vector(self):
728: (8)                    return self.get_tip_point() - self.get_base()
729: (4)                def get_angle(self):
730: (8)                    return angle_of_vector(self.get_vector())
731: (4)                def get_length(self):
732: (8)                    return np.linalg.norm(self.get_vector())
733: (0)            class OpenGLRectangle(OpenGLPolygon):
734: (4)                def __init__(self, color=WHITE, width=4.0, height=2.0, **kwargs):
735: (8)                    super().__init__(UR, UL, DL, DR, color=color, **kwargs)
736: (8)                    self.set_width(width, stretch=True)
737: (8)                    self.set_height(height, stretch=True)
738: (0)            class OpenGLSquare(OpenGLRectangle):
739: (4)                def __init__(self, side_length=2.0, **kwargs):
740: (8)                    self.side_length = side_length
741: (8)                    super().__init__(height=side_length, width=side_length, **kwargs)
742: (0)            class OpenGLRoundedRectangle(OpenGLRectangle):
743: (4)                def __init__(self, corner_radius=0.5, **kwargs):
744: (8)                    self.corner_radius = corner_radius
745: (8)                    super().__init__(**kwargs)
746: (8)                    self.round_corners(self.corner_radius)

----------------------------------------

File 41 - .\three_d \three_dimensions.py:

1: (0)              """Three-dimensional mobjects."""
2: (0)              from __future__ import annotations
3: (0)              from manim.typing import Point3D, Vector3D
4: (0)              from manim.utils.color import BLUE, BLUE_D, BLUE_E, LIGHT_GREY, WHITE, interpolate_color
5: (0)              __all__ = [
6: (4)                  "ThreeDVMobject",
7: (4)                  "Surface",
8: (4)                  "Sphere",
9: (4)                  "Dot3D",
10: (4)                 "Cube",
11: (4)                 "Prism",
12: (4)                 "Cone",
13: (4)                 "Arrow3D",
14: (4)                 "Cylinder",
15: (4)                 "Line3D",
16: (4)                 "Torus",
17: (0)             ]
18: (0)             from typing import Any, Callable, Iterable, Sequence
19: (0)             import numpy as np
20: (0)             from typing_extensions import Self
21: (0)             from manim import config, logger
22: (0)             from manim.constants import *
23: (0)             from manim.mobject.geometry.arc import Circle
24: (0)             from manim.mobject.geometry.polygram import Square
25: (0)             from manim.mobject.mobject import *
26: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
27: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLMobject
28: (0)             from manim.mobject.types.vectorized_mobject import VGroup, VMobject
29: (0)             from manim.utils.color import (
30: (4)                 BLUE,
31: (4)                 BLUE_D,
32: (4)                 BLUE_E,
33: (4)                 LIGHT_GREY,
34: (4)                 WHITE,
35: (4)                 ManimColor,
36: (4)                 ParsableManimColor,
37: (4)                 interpolate_color,
38: (0)             )
39: (0)             from manim.utils.iterables import tuplify
40: (0)             from manim.utils.space_ops import normalize, perpendicular_bisector, z_to_vector
41: (0)             class ThreeDVMobject(VMobject, metaclass=ConvertToOpenGL):
42: (4)                 def __init__(self, shade_in_3d: bool = True, **kwargs):
43: (8)                     super().__init__(shade_in_3d=shade_in_3d, **kwargs)
44: (0)             class Surface(VGroup, metaclass=ConvertToOpenGL):
45: (4)                 """Creates a Parametric Surface using a checkerboard pattern.
46: (4)                 Parameters
47: (4)                 ----------
48: (4)                 func
49: (8)                     The function defining the :class:`Surface`.
50: (4)                 u_range
51: (8)                     The range of the ``u`` variable: ``(u_min, u_max)``.
52: (4)                 v_range
53: (8)                     The range of the ``v`` variable: ``(v_min, v_max)``.
54: (4)                 resolution
55: (8)                     The number of samples taken of the :class:`Surface`. A tuple can be
56: (8)                     used to define different resolutions for ``u`` and ``v`` respectively.
57: (4)                 fill_color
58: (8)                     The color of the :class:`Surface`. Ignored if ``checkerboard_colors``
59: (8)                     is set.
60: (4)                 fill_opacity
61: (8)                     The opacity of the :class:`Surface`, from 0 being fully transparent
62: (8)                     to 1 being fully opaque. Defaults to 1.
63: (4)                 checkerboard_colors
64: (8)                     ng individual faces alternating colors. Overrides ``fill_color``.
65: (4)                 stroke_color
66: (8)                     Color of the stroke surrounding each face of :class:`Surface`.
67: (4)                 stroke_width
68: (8)                     Width of the stroke surrounding each face of :class:`Surface`.
69: (8)                     Defaults to 0.5.
70: (4)                 should_make_jagged
71: (8)                     Changes the anchor mode of the Bézier curves from smooth to jagged.
72: (8)                     Defaults to ``False``.
73: (4)                 Examples
74: (4)                 --------
75: (4)                 .. manim:: ParaSurface
76: (8)                     :save_last_frame:
77: (8)                     class ParaSurface(ThreeDScene):
78: (12)                        def func(self, u, v):
79: (16)                            return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])
80: (12)                        def construct(self):
81: (16)                            axes = ThreeDAxes(x_range=[-4,4], x_length=8)
82: (16)                            surface = Surface(
83: (20)                                lambda u, v: axes.c2p(*self.func(u, v)),
84: (20)                                u_range=[-PI, PI],
85: (20)                                v_range=[0, TAU],
86: (20)                                resolution=8,
87: (16)                            )
88: (16)                            self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)
89: (16)                            self.add(axes, surface)
90: (4)                 """
91: (4)                 def __init__(
92: (8)                     self,
93: (8)                     func: Callable[[float, float], np.ndarray],
94: (8)                     u_range: Sequence[float] = [0, 1],
95: (8)                     v_range: Sequence[float] = [0, 1],
96: (8)                     resolution: Sequence[int] = 32,
97: (8)                     surface_piece_config: dict = {},
98: (8)                     fill_color: ParsableManimColor = BLUE_D,
99: (8)                     fill_opacity: float = 1.0,
100: (8)                    checkerboard_colors: Sequence[ParsableManimColor] | bool = [BLUE_D, BLUE_E],
101: (8)                    stroke_color: ParsableManimColor = LIGHT_GREY,
102: (8)                    stroke_width: float = 0.5,
103: (8)                    should_make_jagged: bool = False,
104: (8)                    pre_function_handle_to_anchor_scale_factor: float = 0.00001,
105: (8)                    **kwargs: Any,
106: (4)                ) -> None:
107: (8)                    self.u_range = u_range
108: (8)                    self.v_range = v_range
109: (8)                    super().__init__(**kwargs)
110: (8)                    self.resolution = resolution
111: (8)                    self.surface_piece_config = surface_piece_config
112: (8)                    self.fill_color: ManimColor = ManimColor(fill_color)
113: (8)                    self.fill_opacity = fill_opacity
114: (8)                    if checkerboard_colors:
115: (12)                       self.checkerboard_colors: list[ManimColor] = [
116: (16)                           ManimColor(x) for x in checkerboard_colors
117: (12)                       ]
118: (8)                    else:
119: (12)                       self.checkerboard_colors = checkerboard_colors
120: (8)                    self.stroke_color: ManimColor = ManimColor(stroke_color)
121: (8)                    self.stroke_width = stroke_width
122: (8)                    self.should_make_jagged = should_make_jagged
123: (8)                    self.pre_function_handle_to_anchor_scale_factor = (
124: (12)                       pre_function_handle_to_anchor_scale_factor
125: (8)                    )
126: (8)                    self._func = func
127: (8)                    self._setup_in_uv_space()
128: (8)                    self.apply_function(lambda p: func(p[0], p[1]))
129: (8)                    if self.should_make_jagged:
130: (12)                       self.make_jagged()
131: (4)                def func(self, u: float, v: float) -> np.ndarray:
132: (8)                    return self._func(u, v)
133: (4)                def _get_u_values_and_v_values(self) -> tuple[np.ndarray, np.ndarray]:
134: (8)                    res = tuplify(self.resolution)
135: (8)                    if len(res) == 1:
136: (12)                       u_res = v_res = res[0]
137: (8)                    else:
138: (12)                       u_res, v_res = res
139: (8)                    u_values = np.linspace(*self.u_range, u_res + 1)
140: (8)                    v_values = np.linspace(*self.v_range, v_res + 1)
141: (8)                    return u_values, v_values
142: (4)                def _setup_in_uv_space(self) -> None:
143: (8)                    u_values, v_values = self._get_u_values_and_v_values()
144: (8)                    faces = VGroup()
145: (8)                    for i in range(len(u_values) - 1):
146: (12)                       for j in range(len(v_values) - 1):
147: (16)                           u1, u2 = u_values[i : i + 2]
148: (16)                           v1, v2 = v_values[j : j + 2]
149: (16)                           face = ThreeDVMobject()
150: (16)                           face.set_points_as_corners(
151: (20)                               [
152: (24)                                   [u1, v1, 0],
153: (24)                                   [u2, v1, 0],
154: (24)                                   [u2, v2, 0],
155: (24)                                   [u1, v2, 0],
156: (24)                                   [u1, v1, 0],
157: (20)                               ],
158: (16)                           )
159: (16)                           faces.add(face)
160: (16)                           face.u_index = i
161: (16)                           face.v_index = j
162: (16)                           face.u1 = u1
163: (16)                           face.u2 = u2
164: (16)                           face.v1 = v1
165: (16)                           face.v2 = v2
166: (8)                    faces.set_fill(color=self.fill_color, opacity=self.fill_opacity)
167: (8)                    faces.set_stroke(
168: (12)                       color=self.stroke_color,
169: (12)                       width=self.stroke_width,
170: (12)                       opacity=self.stroke_opacity,
171: (8)                    )
172: (8)                    self.add(*faces)
173: (8)                    if self.checkerboard_colors:
174: (12)                       self.set_fill_by_checkerboard(*self.checkerboard_colors)
175: (4)                def set_fill_by_checkerboard(
176: (8)                    self, *colors: Iterable[ParsableManimColor], opacity: float | None = None
177: (4)                ) -> Self:
178: (8)                    """Sets the fill_color of each face of :class:`Surface` in
179: (8)                    an alternating pattern.
180: (8)                    Parameters
181: (8)                    ----------
182: (8)                    colors
183: (12)                       List of colors for alternating pattern.
184: (8)                    opacity
185: (12)                       The fill_opacity of :class:`Surface`, from 0 being fully transparent
186: (12)                       to 1 being fully opaque.
187: (8)                    Returns
188: (8)                    -------
189: (8)                    :class:`~.Surface`
190: (12)                       The parametric surface with an alternating pattern.
191: (8)                    """
192: (8)                    n_colors = len(colors)
193: (8)                    for face in self:
194: (12)                       c_index = (face.u_index + face.v_index) % n_colors
195: (12)                       face.set_fill(colors[c_index], opacity=opacity)
196: (8)                    return self
197: (4)                def set_fill_by_value(
198: (8)                    self,
199: (8)                    axes: Mobject,
200: (8)                    colorscale: list[ParsableManimColor] | ParsableManimColor | None = None,
201: (8)                    axis: int = 2,
202: (8)                    **kwargs,
203: (4)                ) -> Self:
204: (8)                    """Sets the color of each mobject of a parametric surface to a color
205: (8)                    relative to its axis-value.
206: (8)                    Parameters
207: (8)                    ----------
208: (8)                    axes
209: (12)                       The axes for the parametric surface, which will be used to map
210: (12)                       axis-values to colors.
211: (8)                    colorscale
212: (12)                       A list of colors, ordered from lower axis-values to higher axis-values.
213: (12)                       If a list of tuples is passed containing colors paired with numbers,
214: (12)                       then those numbers will be used as the pivots.
215: (8)                    axis
216: (12)                       The chosen axis to use for the color mapping. (0 = x, 1 = y, 2 = z)
217: (8)                    Returns
218: (8)                    -------
219: (8)                    :class:`~.Surface`
220: (12)                       The parametric surface with a gradient applied by value. For chaining.
221: (8)                    Examples
222: (8)                    --------
223: (8)                    .. manim:: FillByValueExample
224: (12)                       :save_last_frame:
225: (12)                       class FillByValueExample(ThreeDScene):
226: (16)                           def construct(self):
227: (20)                               resolution_fa = 8
228: (20)                               self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)
229: (20)                               axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))
230: (20)                               def param_surface(u, v):
231: (24)                                   x = u
232: (24)                                   y = v
233: (24)                                   z = np.sin(x) * np.cos(y)
234: (24)                                   return z
235: (20)                               surface_plane = Surface(
236: (24)                                   lambda u, v: axes.c2p(u, v, param_surface(u, v)),
237: (24)                                   resolution=(resolution_fa, resolution_fa),
238: (24)                                   v_range=[0, 5],
239: (24)                                   u_range=[0, 5],
240: (24)                                   )
241: (20)                               surface_plane.set_style(fill_opacity=1)
242: (20)                               surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)
243: (20)                               self.add(axes, surface_plane)
244: (8)                    """
245: (8)                    if "colors" in kwargs and colorscale is None:
246: (12)                       colorscale = kwargs.pop("colors")
247: (12)                       if kwargs:
248: (16)                           raise ValueError(
249: (20)                               "Unsupported keyword argument(s): "
250: (20)                               f"{', '.join(str(key) for key in kwargs)}"
251: (16)                           )
252: (8)                    if colorscale is None:
253: (12)                       logger.warning(
254: (16)                           "The value passed to the colorscale keyword argument was None, "
255: (16)                           "the surface fill color has not been changed"
256: (12)                       )
257: (12)                       return self
258: (8)                    ranges = [axes.x_range, axes.y_range, axes.z_range]
259: (8)                    if type(colorscale[0]) is tuple:
260: (12)                       new_colors, pivots = [
261: (16)                           [i for i, j in colorscale],
262: (16)                           [j for i, j in colorscale],
263: (12)                       ]
264: (8)                    else:
265: (12)                       new_colors = colorscale
266: (12)                       pivot_min = ranges[axis][0]
267: (12)                       pivot_max = ranges[axis][1]
268: (12)                       pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)
269: (12)                       pivots = np.arange(
270: (16)                           start=pivot_min,
271: (16)                           stop=pivot_max + pivot_frequency,
272: (16)                           step=pivot_frequency,
273: (12)                       )
274: (8)                    for mob in self.family_members_with_points():
275: (12)                       axis_value = axes.point_to_coords(mob.get_midpoint())[axis]
276: (12)                       if axis_value <= pivots[0]:
277: (16)                           mob.set_color(new_colors[0])
278: (12)                       elif axis_value >= pivots[-1]:
279: (16)                           mob.set_color(new_colors[-1])
280: (12)                       else:
281: (16)                           for i, pivot in enumerate(pivots):
282: (20)                               if pivot > axis_value:
283: (24)                                   color_index = (axis_value - pivots[i - 1]) / (
284: (28)                                       pivots[i] - pivots[i - 1]
285: (24)                                   )
286: (24)                                   color_index = min(color_index, 1)
287: (24)                                   mob_color = interpolate_color(
288: (28)                                       new_colors[i - 1],
289: (28)                                       new_colors[i],
290: (28)                                       color_index,
291: (24)                                   )
292: (24)                                   if config.renderer == RendererType.OPENGL:
293: (28)                                       mob.set_color(mob_color, recurse=False)
294: (24)                                   elif config.renderer == RendererType.CAIRO:
295: (28)                                       mob.set_color(mob_color, family=False)
296: (24)                                   break
297: (8)                    return self
298: (0)            # Specific shapes
299: (0)            class Sphere(Surface):
300: (4)                """A three-dimensional sphere.
301: (4)                Parameters
302: (4)                ----------
303: (4)                center
304: (8)                    Center of the :class:`Sphere`.
305: (4)                radius
306: (8)                    The radius of the :class:`Sphere`.
307: (4)                resolution
308: (8)                    The number of samples taken of the :class:`Sphere`. A tuple can be used
309: (8)                    to define different resolutions for ``u`` and ``v`` respectively.
310: (4)                u_range
311: (8)                    The range of the ``u`` variable: ``(u_min, u_max)``.
312: (4)                v_range
313: (8)                    The range of the ``v`` variable: ``(v_min, v_max)``.
314: (4)                Examples
315: (4)                --------
316: (4)                .. manim:: ExampleSphere
317: (8)                    :save_last_frame:
318: (8)                    class ExampleSphere(ThreeDScene):
319: (12)                       def construct(self):
320: (16)                           self.set_camera_orientation(phi=PI / 6, theta=PI / 6)
321: (16)                           sphere1 = Sphere(
322: (20)                               center=(3, 0, 0),
323: (20)                               radius=1,
324: (20)                               resolution=(20, 20),
325: (20)                               u_range=[0.001, PI - 0.001],
326: (20)                               v_range=[0, TAU]
327: (16)                           )
328: (16)                           sphere1.set_color(RED)
329: (16)                           self.add(sphere1)
330: (16)                           sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))
331: (16)                           sphere2.set_color(GREEN)
332: (16)                           self.add(sphere2)
333: (16)                           sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))
334: (16)                           sphere3.set_color(BLUE)
335: (16)                           self.add(sphere3)
336: (4)                """
337: (4)                def __init__(
338: (8)                    self,
339: (8)                    center: Point3D = ORIGIN,
340: (8)                    radius: float = 1,
341: (8)                    resolution: Sequence[int] | None = None,
342: (8)                    u_range: Sequence[float] = (0, TAU),
343: (8)                    v_range: Sequence[float] = (0, PI),
344: (8)                    **kwargs,
345: (4)                ) -> None:
346: (8)                    if config.renderer == RendererType.OPENGL:
347: (12)                       res_value = (101, 51)
348: (8)                    elif config.renderer == RendererType.CAIRO:
349: (12)                       res_value = (24, 12)
350: (8)                    else:
351: (12)                       raise Exception("Unknown renderer")
352: (8)                    resolution = resolution if resolution is not None else res_value
353: (8)                    self.radius = radius
354: (8)                    super().__init__(
355: (12)                       self.func,
356: (12)                       resolution=resolution,
357: (12)                       u_range=u_range,
358: (12)                       v_range=v_range,
359: (12)                       **kwargs,
360: (8)                    )
361: (8)                    self.shift(center)
362: (4)                def func(self, u: float, v: float) -> np.ndarray:
363: (8)                    """The z values defining the :class:`Sphere` being plotted.
364: (8)                    Returns
365: (8)                    -------
366: (8)                    :class:`numpy.array`
367: (12)                       The z values defining the :class:`Sphere`.
368: (8)                    """
369: (8)                    return self.radius * np.array(
370: (12)                       [np.cos(u) * np.sin(v), np.sin(u) * np.sin(v), -np.cos(v)],
371: (8)                    )
372: (0)            class Dot3D(Sphere):
373: (4)                """A spherical dot.
374: (4)                Parameters
375: (4)                ----------
376: (4)                point
377: (8)                    The location of the dot.
378: (4)                radius
379: (8)                    The radius of the dot.
380: (4)                color
381: (8)                    The color of the :class:`Dot3D`.
382: (4)                resolution
383: (8)                    The number of samples taken of the :class:`Dot3D`. A tuple can be
384: (8)                    used to define different resolutions for ``u`` and ``v`` respectively.
385: (4)                Examples
386: (4)                --------
387: (4)                .. manim:: Dot3DExample
388: (8)                    :save_last_frame:
389: (8)                    class Dot3DExample(ThreeDScene):
390: (12)                       def construct(self):
391: (16)                           self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)
392: (16)                           axes = ThreeDAxes()
393: (16)                           dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)
394: (16)                           dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)
395: (16)                           dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)
396: (16)                           self.add(axes, dot_1, dot_2,dot_3)
397: (4)                """
398: (4)                def __init__(
399: (8)                    self,
400: (8)                    point: list | np.ndarray = ORIGIN,
401: (8)                    radius: float = DEFAULT_DOT_RADIUS,
402: (8)                    color: ParsableManimColor = WHITE,
403: (8)                    resolution: tuple[int, int] = (8, 8),
404: (8)                    **kwargs,
405: (4)                ) -> None:
406: (8)                    super().__init__(center=point, radius=radius, resolution=resolution, **kwargs)
407: (8)                    self.set_color(color)
408: (0)            class Cube(VGroup):
409: (4)                """A three-dimensional cube.
410: (4)                Parameters
411: (4)                ----------
412: (4)                side_length
413: (8)                    Length of each side of the :class:`Cube`.
414: (4)                fill_opacity
415: (8)                    The opacity of the :class:`Cube`, from 0 being fully transparent to 1 being
416: (8)                    fully opaque. Defaults to 0.75.
417: (4)                fill_color
418: (8)                    The color of the :class:`Cube`.
419: (4)                stroke_width
420: (8)                    The width of the stroke surrounding each face of the :class:`Cube`.
421: (4)                Examples
422: (4)                --------
423: (4)                .. manim:: CubeExample
424: (8)                    :save_last_frame:
425: (8)                    class CubeExample(ThreeDScene):
426: (12)                       def construct(self):
427: (16)                           self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)
428: (16)                           axes = ThreeDAxes()
429: (16)                           cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)
430: (16)                           self.add(cube)
431: (4)                """
432: (4)                def __init__(
433: (8)                    self,
434: (8)                    side_length: float = 2,
435: (8)                    fill_opacity: float = 0.75,
436: (8)                    fill_color: ParsableManimColor = BLUE,
437: (8)                    stroke_width: float = 0,
438: (8)                    **kwargs,
439: (4)                ) -> None:
440: (8)                    self.side_length = side_length
441: (8)                    super().__init__(
442: (12)                       fill_color=fill_color,
443: (12)                       fill_opacity=fill_opacity,
444: (12)                       stroke_width=stroke_width,
445: (12)                       **kwargs,
446: (8)                    )
447: (4)                def generate_points(self) -> None:
448: (8)                    """Creates the sides of the :class:`Cube`."""
449: (8)                    for vect in IN, OUT, LEFT, RIGHT, UP, DOWN:
450: (12)                       face = Square(
451: (16)                           side_length=self.side_length,
452: (16)                           shade_in_3d=True,
453: (12)                       )
454: (12)                       face.flip()
455: (12)                       face.shift(self.side_length * OUT / 2.0)
456: (12)                       face.apply_matrix(z_to_vector(vect))
457: (12)                       self.add(face)
458: (4)                init_points = generate_points
459: (0)            class Prism(Cube):
460: (4)                """A right rectangular prism (or rectangular cuboid).
461: (4)                Defined by the length of each side in ``[x, y, z]`` format.
462: (4)                Parameters
463: (4)                ----------
464: (4)                dimensions
465: (8)                    Dimensions of the :class:`Prism` in ``[x, y, z]`` format.
466: (4)                Examples
467: (4)                --------
468: (4)                .. manim:: ExamplePrism
469: (8)                    :save_last_frame:
470: (8)                    class ExamplePrism(ThreeDScene):
471: (12)                       def construct(self):
472: (16)                           self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)
473: (16)                           prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)
474: (16)                           prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])
475: (16)                           self.add(prismSmall, prismLarge)
476: (4)                """
477: (4)                def __init__(
478: (8)                    self, dimensions: tuple[float, float, float] | np.ndarray = [3, 2, 1], **kwargs
479: (4)                ) -> None:
480: (8)                    self.dimensions = dimensions
481: (8)                    super().__init__(**kwargs)
482: (4)                def generate_points(self) -> None:
483: (8)                    """Creates the sides of the :class:`Prism`."""
484: (8)                    super().generate_points()
485: (8)                    for dim, value in enumerate(self.dimensions):
486: (12)                       self.rescale_to_fit(value, dim, stretch=True)
487: (0)            class Cone(Surface):
488: (4)                """A circular cone.
489: (4)                Can be defined using 2 parameters: its height, and its base radius.
490: (4)                The polar angle, theta, can be calculated using arctan(base_radius /
491: (4)                height) The spherical radius, r, is calculated using the pythagorean
492: (4)                theorem.
493: (4)                Parameters
494: (4)                ----------
495: (4)                base_radius
496: (8)                    The base radius from which the cone tapers.
497: (4)                height
498: (8)                    The height measured from the plane formed by the base_radius to
499: (8)                    the apex of the cone.
500: (4)                direction
501: (8)                    The direction of the apex.
502: (4)                show_base
503: (8)                    Whether to show the base plane or not.
504: (4)                v_range
505: (8)                    The azimuthal angle to start and end at.
506: (4)                u_min
507: (8)                    The radius at the apex.
508: (4)                checkerboard_colors
509: (8)                    Show checkerboard grid texture on the cone.
510: (4)                Examples
511: (4)                --------
512: (4)                .. manim:: ExampleCone
513: (8)                    :save_last_frame:
514: (8)                    class ExampleCone(ThreeDScene):
515: (12)                       def construct(self):
516: (16)                           axes = ThreeDAxes()
517: (16)                           cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)
518: (16)                           self.set_camera_orientation(phi=5*PI/11, theta=PI/9)
519: (16)                           self.add(axes, cone)
520: (4)                """
521: (4)                def __init__(
522: (8)                    self,
523: (8)                    base_radius: float = 1,
524: (8)                    height: float = 1,
525: (8)                    direction: np.ndarray = Z_AXIS,
526: (8)                    show_base: bool = False,
527: (8)                    v_range: Sequence[float] = [0, TAU],
528: (8)                    u_min: float = 0,
529: (8)                    checkerboard_colors: bool = False,
530: (8)                    **kwargs: Any,
531: (4)                ) -> None:
532: (8)                    self.direction = direction
533: (8)                    self.theta = PI - np.arctan(base_radius / height)
534: (8)                    super().__init__(
535: (12)                       self.func,
536: (12)                       v_range=v_range,
537: (12)                       u_range=[u_min, np.sqrt(base_radius**2 + height**2)],
538: (12)                       checkerboard_colors=checkerboard_colors,
539: (12)                       **kwargs,
540: (8)                    )
541: (8)                    # used for rotations
542: (8)                    self._current_theta = 0
543: (8)                    self._current_phi = 0
544: (8)                    if show_base:
545: (12)                       self.base_circle = Circle(
546: (16)                           radius=base_radius,
547: (16)                           color=self.fill_color,
548: (16)                           fill_opacity=self.fill_opacity,
549: (16)                           stroke_width=0,
550: (12)                       )
551: (12)                       self.base_circle.shift(height * IN)
552: (12)                       self.add(self.base_circle)
553: (8)                    self._rotate_to_direction()
554: (4)                def func(self, u: float, v: float) -> np.ndarray:
555: (8)                    """Converts from spherical coordinates to cartesian.
556: (8)                    Parameters
557: (8)                    ----------
558: (8)                    u
559: (12)                       The radius.
560: (8)                    v
561: (12)                       The azimuthal angle.
562: (8)                    Returns
563: (8)                    -------
564: (8)                    :class:`numpy.array`
565: (12)                       Points defining the :class:`Cone`.
566: (8)                    """
567: (8)                    r = u
568: (8)                    phi = v
569: (8)                    return np.array(
570: (12)                       [
571: (16)                           r * np.sin(self.theta) * np.cos(phi),
572: (16)                           r * np.sin(self.theta) * np.sin(phi),
573: (16)                           r * np.cos(self.theta),
574: (12)                       ],
575: (8)                    )
576: (4)                def _rotate_to_direction(self) -> None:
577: (8)                    x, y, z = self.direction
578: (8)                    r = np.sqrt(x**2 + y**2 + z**2)
579: (8)                    if r > 0:
580: (12)                       theta = np.arccos(z / r)
581: (8)                    else:
582: (12)                       theta = 0
583: (8)                    if x == 0:
584: (12)                       if y == 0:  # along the z axis
585: (16)                           phi = 0
586: (12)                       else:
587: (16)                           phi = np.arctan(np.inf)
588: (16)                           if y < 0:
589: (20)                               phi += PI
590: (8)                    else:
591: (12)                       phi = np.arctan(y / x)
592: (8)                    if x < 0:
593: (12)                       phi += PI
594: (8)                    # Undo old rotation (in reverse order)
595: (8)                    self.rotate(-self._current_phi, Z_AXIS, about_point=ORIGIN)
596: (8)                    self.rotate(-self._current_theta, Y_AXIS, about_point=ORIGIN)
597: (8)                    # Do new rotation
598: (8)                    self.rotate(theta, Y_AXIS, about_point=ORIGIN)
599: (8)                    self.rotate(phi, Z_AXIS, about_point=ORIGIN)
600: (8)                    # Store values
601: (8)                    self._current_theta = theta
602: (8)                    self._current_phi = phi
603: (4)                def set_direction(self, direction: np.ndarray) -> None:
604: (8)                    """Changes the direction of the apex of the :class:`Cone`.
605: (8)                    Parameters
606: (8)                    ----------
607: (8)                    direction
608: (12)                       The direction of the apex.
609: (8)                    """
610: (8)                    self.direction = direction
611: (8)                    self._rotate_to_direction()
612: (4)                def get_direction(self) -> np.ndarray:
613: (8)                    """Returns the current direction of the apex of the :class:`Cone`.
614: (8)                    Returns
615: (8)                    -------
616: (8)                    direction : :class:`numpy.array`
617: (12)                       The direction of the apex.
618: (8)                    """
619: (8)                    return self.direction
620: (0)            class Cylinder(Surface):
621: (4)                """A cylinder, defined by its height, radius and direction,
622: (4)                Parameters
623: (4)                ----------
624: (4)                radius
625: (8)                    The radius of the cylinder.
626: (4)                height
627: (8)                    The height of the cylinder.
628: (4)                direction
629: (8)                    The direction of the central axis of the cylinder.
630: (4)                v_range
631: (8)                    The height along the height axis (given by direction) to start and end on.
632: (4)                show_ends
633: (8)                    Whether to show the end caps or not.
634: (4)                resolution
635: (8)                    The number of samples taken of the :class:`Cylinder`. A tuple can be used
636: (8)                    to define different resolutions for ``u`` and ``v`` respectively.
637: (4)                Examples
638: (4)                --------
639: (4)                .. manim:: ExampleCylinder
640: (8)                    :save_last_frame:
641: (8)                    class ExampleCylinder(ThreeDScene):
642: (12)                       def construct(self):
643: (16)                           axes = ThreeDAxes()
644: (16)                           cylinder = Cylinder(radius=2, height=3)
645: (16)                           self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
646: (16)                           self.add(axes, cylinder)
647: (4)                """
648: (4)                def __init__(
649: (8)                    self,
650: (8)                    radius: float = 1,
651: (8)                    height: float = 2,
652: (8)                    direction: np.ndarray = Z_AXIS,
653: (8)                    v_range: Sequence[float] = [0, TAU],
654: (8)                    show_ends: bool = True,
655: (8)                    resolution: Sequence[int] = (24, 24),
656: (8)                    **kwargs,
657: (4)                ) -> None:
658: (8)                    self._height = height
659: (8)                    self.radius = radius
660: (8)                    super().__init__(
661: (12)                       self.func,
662: (12)                       resolution=resolution,
663: (12)                       u_range=[-self._height / 2, self._height / 2],
664: (12)                       v_range=v_range,
665: (12)                       **kwargs,
666: (8)                    )
667: (8)                    if show_ends:
668: (12)                       self.add_bases()
669: (8)                    self._current_phi = 0
670: (8)                    self._current_theta = 0
671: (8)                    self.set_direction(direction)
672: (4)                def func(self, u: float, v: float) -> np.ndarray:
673: (8)                    """Converts from cylindrical coordinates to cartesian.
674: (8)                    Parameters
675: (8)                    ----------
676: (8)                    u
677: (12)                       The height.
678: (8)                    v
679: (12)                       The azimuthal angle.
680: (8)                    Returns
681: (8)                    -------
682: (8)                    :class:`numpy.ndarray`
683: (12)                       Points defining the :class:`Cylinder`.
684: (8)                    """
685: (8)                    height = u
686: (8)                    phi = v
687: (8)                    r = self.radius
688: (8)                    return np.array([r * np.cos(phi), r * np.sin(phi), height])
689: (4)                def add_bases(self) -> None:
690: (8)                    """Adds the end caps of the cylinder."""
691: (8)                    if config.renderer == RendererType.OPENGL:
692: (12)                       color = self.color
693: (12)                       opacity = self.opacity
694: (8)                    elif config.renderer == RendererType.CAIRO:
695: (12)                       color = self.fill_color
696: (12)                       opacity = self.fill_opacity
697: (8)                    self.base_top = Circle(
698: (12)                       radius=self.radius,
699: (12)                       color=color,
700: (12)                       fill_opacity=opacity,
701: (12)                       shade_in_3d=True,
702: (12)                       stroke_width=0,
703: (8)                    )
704: (8)                    self.base_top.shift(self.u_range[1] * IN)
705: (8)                    self.base_bottom = Circle(
706: (12)                       radius=self.radius,
707: (12)                       color=color,
708: (12)                       fill_opacity=opacity,
709: (12)                       shade_in_3d=True,
710: (12)                       stroke_width=0,
711: (8)                    )
712: (8)                    self.base_bottom.shift(self.u_range[0] * IN)
713: (8)                    self.add(self.base_top, self.base_bottom)
714: (4)                def _rotate_to_direction(self) -> None:
715: (8)                    x, y, z = self.direction
716: (8)                    r = np.sqrt(x**2 + y**2 + z**2)
717: (8)                    if r > 0:
718: (12)                       theta = np.arccos(z / r)
719: (8)                    else:
720: (12)                       theta = 0
721: (8)                    if x == 0:
722: (12)                       if y == 0:  # along the z axis
723: (16)                           phi = 0
724: (12)                       else:  # along the x axis
725: (16)                           phi = np.arctan(np.inf)
726: (16)                           if y < 0:
727: (20)                               phi += PI
728: (8)                    else:
729: (12)                       phi = np.arctan(y / x)
730: (8)                    if x < 0:
731: (12)                       phi += PI
732: (8)                    # undo old rotation (in reverse direction)
733: (8)                    self.rotate(-self._current_phi, Z_AXIS, about_point=ORIGIN)
734: (8)                    self.rotate(-self._current_theta, Y_AXIS, about_point=ORIGIN)
735: (8)                    # do new rotation
736: (8)                    self.rotate(theta, Y_AXIS, about_point=ORIGIN)
737: (8)                    self.rotate(phi, Z_AXIS, about_point=ORIGIN)
738: (8)                    # store new values
739: (8)                    self._current_theta = theta
740: (8)                    self._current_phi = phi
741: (4)                def set_direction(self, direction: np.ndarray) -> None:
742: (8)                    """Sets the direction of the central axis of the :class:`Cylinder`.
743: (8)                    Parameters
744: (8)                    ----------
745: (8)                    direction : :class:`numpy.array`
746: (12)                       The direction of the central axis of the :class:`Cylinder`.
747: (8)                    """
748: (8)                    # if get_norm(direction) is get_norm(self.direction):
749: (8)                    #     pass
750: (8)                    self.direction = direction
751: (8)                    self._rotate_to_direction()
752: (4)                def get_direction(self) -> np.ndarray:
753: (8)                    """Returns the direction of the central axis of the :class:`Cylinder`.
754: (8)                    Returns
755: (8)                    -------
756: (8)                    direction : :class:`numpy.array`
757: (12)                       The direction of the central axis of the :class:`Cylinder`.
758: (8)                    """
759: (8)                    return self.direction
760: (0)            class Line3D(Cylinder):
761: (4)                """A cylindrical line, for use in ThreeDScene.
762: (4)                Parameters
763: (4)                ----------
764: (4)                start
765: (8)                    The start point of the line.
766: (4)                end
767: (8)                    The end point of the line.
768: (4)                thickness
769: (8)                    The thickness of the line.
770: (4)                color
771: (8)                    The color of the line.
772: (4)                Examples
773: (4)                --------
774: (4)                .. manim:: ExampleLine3D
775: (8)                    :save_last_frame:
776: (8)                    class ExampleLine3D(ThreeDScene):
777: (12)                       def construct(self):
778: (16)                           axes = ThreeDAxes()
779: (16)                           line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))
780: (16)                           self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
781: (16)                           self.add(axes, line)
782: (4)                """
783: (4)                def __init__(
784: (8)                    self,
785: (8)                    start: np.ndarray = LEFT,
786: (8)                    end: np.ndarray = RIGHT,
787: (8)                    thickness: float = 0.02,
788: (8)                    color: ParsableManimColor | None = None,
789: (8)                    **kwargs,
790: (4)                ):
791: (8)                    self.thickness = thickness
792: (8)                    self.set_start_and_end_attrs(start, end, **kwargs)
793: (8)                    if color is not None:
794: (12)                       self.set_color(color)
795: (4)                def set_start_and_end_attrs(
796: (8)                    self, start: np.ndarray, end: np.ndarray, **kwargs
797: (4)                ) -> None:
798: (8)                    """Sets the start and end points of the line.
799: (8)                    If either ``start`` or ``end`` are :class:`Mobjects <.Mobject>`,
800: (8)                    this gives their centers.
801: (8)                    Parameters
802: (8)                    ----------
803: (8)                    start
804: (12)                       Starting point or :class:`Mobject`.
805: (8)                    end
806: (12)                       Ending point or :class:`Mobject`.
807: (8)                    """
808: (8)                    rough_start = self.pointify(start)
809: (8)                    rough_end = self.pointify(end)
810: (8)                    self.vect = rough_end - rough_start
811: (8)                    self.length = np.linalg.norm(self.vect)
812: (8)                    self.direction = normalize(self.vect)
813: (8)                    # Now that we know the direction between them,
814: (8)                    # we can the appropriate boundary point from
815: (8)                    # start and end, if they're mobjects
816: (8)                    self.start = self.pointify(start, self.direction)
817: (8)                    self.end = self.pointify(end, -self.direction)
818: (8)                    super().__init__(
819: (12)                       height=np.linalg.norm(self.vect),
820: (12)                       radius=self.thickness,
821: (12)                       direction=self.direction,
822: (12)                       **kwargs,
823: (8)                    )
824: (8)                    self.shift((self.start + self.end) / 2)
825: (4)                def pointify(
826: (8)                    self,
827: (8)                    mob_or_point: Mobject | Point3D,
828: (8)                    direction: Vector3D = None,
829: (4)                ) -> np.ndarray:
830: (8)                    """Gets a point representing the center of the :class:`Mobjects <.Mobject>`.
831: (8)                    Parameters
832: (8)                    ----------
833: (8)                    mob_or_point
834: (12)                       :class:`Mobjects <.Mobject>` or point whose center should be returned.
835: (8)                    direction
836: (12)                       If an edge of a :class:`Mobjects <.Mobject>` should be returned, the direction of the edge.
837: (8)                    Returns
838: (8)                    -------
839: (8)                    :class:`numpy.array`
840: (12)                       Center of the :class:`Mobjects <.Mobject>` or point, or edge if direction is given.
841: (8)                    """
842: (8)                    if isinstance(mob_or_point, (Mobject, OpenGLMobject)):
843: (12)                       mob = mob_or_point
844: (12)                       if direction is None:
845: (16)                           return mob.get_center()
846: (12)                       else:
847: (16)                           return mob.get_boundary_point(direction)
848: (8)                    return np.array(mob_or_point)
849: (4)                def get_start(self) -> np.ndarray:
850: (8)                    """Returns the starting point of the :class:`Line3D`.
851: (8)                    Returns
852: (8)                    -------
853: (8)                    start : :class:`numpy.array`
854: (12)                       Starting point of the :class:`Line3D`.
855: (8)                    """
856: (8)                    return self.start
857: (4)                def get_end(self) -> np.ndarray:
858: (8)                    """Returns the ending point of the :class:`Line3D`.
859: (8)                    Returns
860: (8)                    -------
861: (8)                    end : :class:`numpy.array`
862: (12)                       Ending point of the :class:`Line3D`.
863: (8)                    """
864: (8)                    return self.end
865: (4)                @classmethod
866: (4)                def parallel_to(
867: (8)                    cls,
868: (8)                    line: Line3D,
869: (8)                    point: Vector3D = ORIGIN,
870: (8)                    length: float = 5,
871: (8)                    **kwargs,
872: (4)                ) -> Line3D:
873: (8)                    """Returns a line parallel to another line going through
874: (8)                    a given point.
875: (8)                    Parameters
876: (8)                    ----------
877: (8)                    line
878: (12)                       The line to be parallel to.
879: (8)                    point
880: (12)                       The point to pass through.
881: (8)                    length
882: (12)                       Length of the parallel line.
883: (8)                    kwargs
884: (12)                       Additional parameters to be passed to the class.
885: (8)                    Returns
886: (8)                    -------
887: (8)                    :class:`Line3D`
888: (12)                       Line parallel to ``line``.
889: (8)                    Examples
890: (8)                    --------
891: (8)                    .. manim:: ParallelLineExample
892: (12)                       :save_last_frame:
893: (12)                       class ParallelLineExample(ThreeDScene):
894: (16)                           def construct(self):
895: (20)                               self.set_camera_orientation(PI / 3, -PI / 4)
896: (20)                               ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)
897: (20)                               line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)
898: (20)                               line2 = Line3D.parallel_to(line1, color=YELLOW)
899: (20)                               self.add(ax, line1, line2)
900: (8)                    """
901: (8)                    point = np.array(point)
902: (8)                    vect = normalize(line.vect)
903: (8)                    return cls(
904: (12)                       point + vect * length / 2,
905: (12)                       point - vect * length / 2,
906: (12)                       **kwargs,
907: (8)                    )
908: (4)                @classmethod
909: (4)                def perpendicular_to(
910: (8)                    cls,
911: (8)                    line: Line3D,
912: (8)                    point: Vector3D = ORIGIN,
913: (8)                    length: float = 5,
914: (8)                    **kwargs,
915: (4)                ) -> Line3D:
916: (8)                    """Returns a line perpendicular to another line going through
917: (8)                    a given point.
918: (8)                    Parameters
919: (8)                    ----------
920: (8)                    line
921: (12)                       The line to be perpendicular to.
922: (8)                    point
923: (12)                       The point to pass through.
924: (8)                    length
925: (12)                       Length of the perpendicular line.
926: (8)                    kwargs
927: (12)                       Additional parameters to be passed to the class.
928: (8)                    Returns
929: (8)                    -------
930: (8)                    :class:`Line3D`
931: (12)                       Line perpendicular to ``line``.
932: (8)                    Examples
933: (8)                    --------
934: (8)                    .. manim:: PerpLineExample
935: (12)                       :save_last_frame:
936: (12)                       class PerpLineExample(ThreeDScene):
937: (16)                           def construct(self):
938: (20)                               self.set_camera_orientation(PI / 3, -PI / 4)
939: (20)                               ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)
940: (20)                               line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)
941: (20)                               line2 = Line3D.perpendicular_to(line1, color=BLUE)
942: (20)                               self.add(ax, line1, line2)
943: (8)                    """
944: (8)                    point = np.array(point)
945: (8)                    norm = np.cross(line.vect, point - line.start)
946: (8)                    if all(np.linalg.norm(norm) == np.zeros(3)):
947: (12)                       raise ValueError("Could not find the perpendicular.")
948: (8)                    start, end = perpendicular_bisector([line.start, line.end], norm)
949: (8)                    vect = normalize(end - start)
950: (8)                    return cls(
951: (12)                       point + vect * length / 2,
952: (12)                       point - vect * length / 2,
953: (12)                       **kwargs,
954: (8)                    )
955: (0)            class Arrow3D(Line3D):
956: (4)                """An arrow made out of a cylindrical line and a conical tip.
957: (4)                Parameters
958: (4)                ----------
959: (4)                start
960: (8)                    The start position of the arrow.
961: (4)                end
962: (8)                    The end position of the arrow.
963: (4)                thickness
964: (8)                    The thickness of the arrow.
965: (4)                height
966: (8)                    The height of the conical tip.
967: (4)                base_radius
968: (8)                    The base radius of the conical tip.
969: (4)                color
970: (8)                    The color of the arrow.
971: (4)                Examples
972: (4)                --------
973: (4)                .. manim:: ExampleArrow3D
974: (8)                    :save_last_frame:
975: (8)                    class ExampleArrow3D(ThreeDScene):
976: (12)                       def construct(self):
977: (16)                           axes = ThreeDAxes()
978: (16)                           arrow = Arrow3D(
979: (20)                               start=np.array([0, 0, 0]),
980: (20)                               end=np.array([2, 2, 2]),
981: (20)                               resolution=8
982: (16)                           )
983: (16)                           self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
984: (16)                           self.add(axes, arrow)
985: (4)                """
986: (4)                def __init__(
987: (8)                    self,
988: (8)                    start: np.ndarray = LEFT,
989: (8)                    end: np.ndarray = RIGHT,
990: (8)                    thickness: float = 0.02,
991: (8)                    height: float = 0.3,
992: (8)                    base_radius: float = 0.08,
993: (8)                    color: ParsableManimColor = WHITE,
994: (8)                    **kwargs,
995: (4)                ) -> None:
996: (8)                    super().__init__(
997: (12)                       start=start, end=end, thickness=thickness, color=color, **kwargs
998: (8)                    )
999: (8)                    self.length = np.linalg.norm(self.vect)
1000: (8)                   self.set_start_and_end_attrs(
1001: (12)                      self.start,
1002: (12)                      self.end - height * self.direction,
1003: (12)                      **kwargs,
1004: (8)                   )
1005: (8)                   self.cone = Cone(
1006: (12)                      direction=self.direction, base_radius=base_radius, height=height, **kwargs
1007: (8)                   )
1008: (8)                   self.cone.shift(end)
1009: (8)                   self.add(self.cone)
1010: (8)                   self.set_color(color)
1011: (0)           class Torus(Surface):
1012: (4)               """A torus.
1013: (4)               Parameters
1014: (4)               ----------
1015: (4)               major_radius
1016: (8)                   Distance from the center of the tube to the center of the torus.
1017: (4)               minor_radius
1018: (8)                   Radius of the tube.
1019: (4)               u_range
1020: (8)                   The range of the ``u`` variable: ``(u_min, u_max)``.
1021: (4)               v_range
1022: (8)                   The range of the ``v`` variable: ``(v_min, v_max)``.
1023: (4)               resolution
1024: (8)                   The number of samples taken of the :class:`Torus`. A tuple can be
1025: (8)                   used to define different resolutions for ``u`` and ``v`` respectively.
1026: (4)               Examples
1027: (4)               --------
1028: (4)               .. manim :: ExampleTorus
1029: (8)                   :save_last_frame:
1030: (8)                   class ExampleTorus(ThreeDScene):
1031: (12)                      def construct(self):
1032: (16)                          axes = ThreeDAxes()
1033: (16)                          torus = Torus()
1034: (16)                          self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
1035: (16)                          self.add(axes, torus)
1036: (4)               """
1037: (4)               def __init__(
1038: (8)                   self,
1039: (8)                   major_radius: float = 3,
1040: (8)                   minor_radius: float = 1,
1041: (8)                   u_range: Sequence[float] = (0, TAU),
1042: (8)                   v_range: Sequence[float] = (0, TAU),
1043: (8)                   resolution: tuple[int, int] | None = None,
1044: (8)                   **kwargs,
1045: (4)               ) -> None:
1046: (8)                   if config.renderer == RendererType.OPENGL:
1047: (12)                      res_value = (101, 101)
1048: (8)                   elif config.renderer == RendererType.CAIRO:
1049: (12)                      res_value = (24, 24)
1050: (8)                   resolution = resolution if resolution is not None else res_value
1051: (8)                   self.R = major_radius
1052: (8)                   self.r = minor_radius
1053: (8)                   super().__init__(
1054: (12)                      self.func,
1055: (12)                      u_range=u_range,
1056: (12)                      v_range=v_range,
1057: (12)                      resolution=resolution,
1058: (12)                      **kwargs,
1059: (8)                   )
1060: (4)               def func(self, u: float, v: float) -> np.ndarray:
1061: (8)                   """The z values defining the :class:`Torus` being plotted.
1062: (8)                   Returns
1063: (8)                   -------
1064: (8)                   :class:`numpy.ndarray`
1065: (12)                      The z values defining the :class:`Torus`.
1066: (8)                   """
1067: (8)                   P = np.array([np.cos(u), np.sin(u), 0])
1068: (8)                   return (self.R - self.r * np.cos(v)) * P - self.r * np.sin(v) * OUT

----------------------------------------

File 42 - .\types \point_cloud_mobject.py:

1: (0)              """Mobjects representing point clouds."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["PMobject", "Mobject1D", "Mobject2D", "PGroup", "PointCloudDot", "Point"]
4: (0)              import numpy as np
5: (0)              from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
6: (0)              from manim.mobject.opengl.opengl_point_cloud_mobject import OpenGLPMobject
7: (0)              from ...constants import *
8: (0)              from ...mobject.mobject import Mobject
9: (0)              from ...utils.bezier import interpolate
10: (0)             from ...utils.color import (
11: (4)                 BLACK,
12: (4)                 WHITE,
13: (4)                 YELLOW,
14: (4)                 ManimColor,
15: (4)                 color_gradient,
16: (4)                 color_to_rgba,
17: (4)                 rgba_to_color,
18: (0)             )
19: (0)             from ...utils.iterables import stretch_array_to_length
20: (0)             __all__ = ["PMobject", "Mobject1D", "Mobject2D", "PGroup", "PointCloudDot", "Point"]
21: (0)             class PMobject(Mobject, metaclass=ConvertToOpenGL):
22: (4)                 """A disc made of a cloud of Dots
23: (4)                 Examples
24: (4)                 --------
25: (4)                 .. manim:: PMobjectExample
26: (8)                     :save_last_frame:
27: (8)                     class PMobjectExample(Scene):
28: (12)                        def construct(self):
29: (16)                            pG = PGroup()  # This is just a collection of PMobject's
30: (16)                            # As the scale factor increases, the number of points
31: (16)                            # removed increases.
32: (16)                            for sf in range(1, 9 + 1):
33: (20)                                p = PointCloudDot(density=20, radius=1).thin_out(sf)
34: (20)                                # PointCloudDot is a type of PMobject
35: (20)                                # and can therefore be added to a PGroup
36: (20)                                pG.add(p)
37: (16)                            # This organizes all the shapes in a grid.
38: (16)                            pG.arrange_in_grid()
39: (16)                            self.add(pG)
40: (4)                 """
41: (4)                 def __init__(self, stroke_width=DEFAULT_STROKE_WIDTH, **kwargs):
42: (8)                     self.stroke_width = stroke_width
43: (8)                     super().__init__(**kwargs)
44: (4)                 def reset_points(self):
45: (8)                     self.rgbas = np.zeros((0, 4))
46: (8)                     self.points = np.zeros((0, 3))
47: (8)                     return self
48: (4)                 def get_array_attrs(self):
49: (8)                     return super().get_array_attrs() + ["rgbas"]
50: (4)                 def add_points(self, points, rgbas=None, color=None, alpha=1):
51: (8)                     """Add points.
52: (8)                     Points must be a Nx3 numpy array.
53: (8)                     Rgbas must be a Nx4 numpy array if it is not None.
54: (8)                     """
55: (8)                     if not isinstance(points, np.ndarray):
56: (12)                        points = np.array(points)
57: (8)                     num_new_points = len(points)
58: (8)                     self.points = np.append(self.points, points, axis=0)
59: (8)                     if rgbas is None:
60: (12)                        color = ManimColor(color) if color else self.color
61: (12)                        rgbas = np.repeat([color_to_rgba(color, alpha)], num_new_points, axis=0)
62: (8)                     elif len(rgbas) != len(points):
63: (12)                        raise ValueError("points and rgbas must have same length")
64: (8)                     self.rgbas = np.append(self.rgbas, rgbas, axis=0)
65: (8)                     return self
66: (4)                 def set_color(self, color=YELLOW, family=True):
67: (8)                     rgba = color_to_rgba(color)
68: (8)                     mobs = self.family_members_with_points() if family else [self]
69: (8)                     for mob in mobs:
70: (12)                        mob.rgbas[:, :] = rgba
71: (8)                     self.color = color
72: (8)                     return self
73: (4)                 def get_stroke_width(self):
74: (8)                     return self.stroke_width
75: (4)                 def set_stroke_width(self, width, family=True):
76: (8)                     mobs = self.family_members_with_points() if family else [self]
77: (8)                     for mob in mobs:
78: (12)                        mob.stroke_width = width
79: (8)                     return self
80: (4)                 def set_color_by_gradient(self, *colors):
81: (8)                     self.rgbas = np.array(
82: (12)                        list(map(color_to_rgba, color_gradient(*colors, len(self.points)))),
83: (8)                     )
84: (8)                     return self
85: (4)                 def set_colors_by_radial_gradient(
86: (8)                     self,
87: (8)                     center=None,
88: (8)                     radius=1,
89: (8)                     inner_color=WHITE,
90: (8)                     outer_color=BLACK,
91: (4)                 ):
92: (8)                     start_rgba, end_rgba = list(map(color_to_rgba, [inner_color, outer_color]))
93: (8)                     if center is None:
94: (12)                        center = self.get_center()
95: (8)                     for mob in self.family_members_with_points():
96: (12)                        distances = np.abs(self.points - center)
97: (12)                        alphas = np.linalg.norm(distances, axis=1) / radius
98: (12)                        mob.rgbas = np.array(
99: (16)                            np.array(
100: (20)                               [interpolate(start_rgba, end_rgba, alpha) for alpha in alphas],
101: (16)                           ),
102: (12)                       )
103: (8)                    return self
104: (4)                def match_colors(self, mobject):
105: (8)                    Mobject.align_data(self, mobject)
106: (8)                    self.rgbas = np.array(mobject.rgbas)
107: (8)                    return self
108: (4)                def filter_out(self, condition):
109: (8)                    for mob in self.family_members_with_points():
110: (12)                       to_eliminate = ~np.apply_along_axis(condition, 1, mob.points)
111: (12)                       mob.points = mob.points[to_eliminate]
112: (12)                       mob.rgbas = mob.rgbas[to_eliminate]
113: (8)                    return self
114: (4)                def thin_out(self, factor=5):
115: (8)                    """
116: (8)                    Removes all but every nth point for n = factor
117: (8)                    """
118: (8)                    for mob in self.family_members_with_points():
119: (12)                       num_points = self.get_num_points()
120: (12)                       mob.apply_over_attr_arrays(
121: (16)                           lambda arr: arr[np.arange(0, num_points, factor)],
122: (12)                       )
123: (8)                    return self
124: (4)                def sort_points(self, function=lambda p: p[0]):
125: (8)                    """
126: (8)                    Function is any map from R^3 to R
127: (8)                    """
128: (8)                    for mob in self.family_members_with_points():
129: (12)                       indices = np.argsort(np.apply_along_axis(function, 1, mob.points))
130: (12)                       mob.apply_over_attr_arrays(lambda arr: arr[indices])
131: (8)                    return self
132: (4)                def fade_to(self, color, alpha, family=True):
133: (8)                    self.rgbas = interpolate(self.rgbas, color_to_rgba(color), alpha)
134: (8)                    for mob in self.submobjects:
135: (12)                       mob.fade_to(color, alpha, family)
136: (8)                    return self
137: (4)                def get_all_rgbas(self):
138: (8)                    return self.get_merged_array("rgbas")
139: (4)                def ingest_submobjects(self):
140: (8)                    attrs = self.get_array_attrs()
141: (8)                    arrays = list(map(self.get_merged_array, attrs))
142: (8)                    for attr, array in zip(attrs, arrays):
143: (12)                       setattr(self, attr, array)
144: (8)                    self.submobjects = []
145: (8)                    return self
146: (4)                def get_color(self):
147: (8)                    return rgba_to_color(self.rgbas[0, :])
148: (4)                def point_from_proportion(self, alpha):
149: (8)                    index = alpha * (self.get_num_points() - 1)
150: (8)                    return self.points[index]
151: (4)                @staticmethod
152: (4)                def get_mobject_type_class():
153: (8)                    return PMobject
154: (4)                # Alignment
155: (4)                def align_points_with_larger(self, larger_mobject):
156: (8)                    assert isinstance(larger_mobject, PMobject)
157: (8)                    self.apply_over_attr_arrays(
158: (12)                       lambda a: stretch_array_to_length(a, larger_mobject.get_num_points()),
159: (8)                    )
160: (4)                def get_point_mobject(self, center=None):
161: (8)                    if center is None:
162: (12)                       center = self.get_center()
163: (8)                    return Point(center)
164: (4)                def interpolate_color(self, mobject1, mobject2, alpha):
165: (8)                    self.rgbas = interpolate(mobject1.rgbas, mobject2.rgbas, alpha)
166: (8)                    self.set_stroke_width(
167: (12)                       interpolate(
168: (16)                           mobject1.get_stroke_width(),
169: (16)                           mobject2.get_stroke_width(),
170: (16)                           alpha,
171: (12)                       ),
172: (8)                    )
173: (8)                    return self
174: (4)                def pointwise_become_partial(self, mobject, a, b):
175: (8)                    lower_index, upper_index = (int(x * mobject.get_num_points()) for x in (a, b))
176: (8)                    for attr in self.get_array_attrs():
177: (12)                       full_array = getattr(mobject, attr)
178: (12)                       partial_array = full_array[lower_index:upper_index]
179: (12)                       setattr(self, attr, partial_array)
180: (0)            # TODO, Make the two implementations below non-redundant
181: (0)            class Mobject1D(PMobject, metaclass=ConvertToOpenGL):
182: (4)                def __init__(self, density=DEFAULT_POINT_DENSITY_1D, **kwargs):
183: (8)                    self.density = density
184: (8)                    self.epsilon = 1.0 / self.density
185: (8)                    super().__init__(**kwargs)
186: (4)                def add_line(self, start, end, color=None):
187: (8)                    start, end = list(map(np.array, [start, end]))
188: (8)                    length = np.linalg.norm(end - start)
189: (8)                    if length == 0:
190: (12)                       points = [start]
191: (8)                    else:
192: (12)                       epsilon = self.epsilon / length
193: (12)                       points = [interpolate(start, end, t) for t in np.arange(0, 1, epsilon)]
194: (8)                    self.add_points(points, color=color)
195: (0)            class Mobject2D(PMobject, metaclass=ConvertToOpenGL):
196: (4)                def __init__(self, density=DEFAULT_POINT_DENSITY_2D, **kwargs):
197: (8)                    self.density = density
198: (8)                    self.epsilon = 1.0 / self.density
199: (8)                    super().__init__(**kwargs)
200: (0)            class PGroup(PMobject):
201: (4)                """A group for several point mobjects.
202: (4)                Examples
203: (4)                --------
204: (4)                .. manim:: PgroupExample
205: (8)                    :save_last_frame:
206: (8)                    class PgroupExample(Scene):
207: (12)                       def construct(self):
208: (16)                           p1 = PointCloudDot(radius=1, density=20, color=BLUE)
209: (16)                           p1.move_to(4.5 * LEFT)
210: (16)                           p2 = PointCloudDot()
211: (16)                           p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)
212: (16)                           p3.move_to(4.5 * RIGHT)
213: (16)                           pList = PGroup(p1, p2, p3)
214: (16)                           self.add(pList)
215: (4)                """
216: (4)                def __init__(self, *pmobs, **kwargs):
217: (8)                    if not all(isinstance(m, (PMobject, OpenGLPMobject)) for m in pmobs):
218: (12)                       raise ValueError(
219: (16)                           "All submobjects must be of type PMobject or OpenGLPMObject"
220: (16)                           " if using the opengl renderer",
221: (12)                       )
222: (8)                    super().__init__(**kwargs)
223: (8)                    self.add(*pmobs)
224: (4)                def fade_to(self, color, alpha, family=True):
225: (8)                    if family:
226: (12)                       for mob in self.submobjects:
227: (16)                           mob.fade_to(color, alpha, family)
228: (0)            class PointCloudDot(Mobject1D):
229: (4)                """A disc made of a cloud of dots.
230: (4)                Examples
231: (4)                --------
232: (4)                .. manim:: PointCloudDotExample
233: (8)                    :save_last_frame:
234: (8)                    class PointCloudDotExample(Scene):
235: (12)                       def construct(self):
236: (16)                           cloud_1 = PointCloudDot(color=RED)
237: (16)                           cloud_2 = PointCloudDot(stroke_width=4, radius=1)
238: (16)                           cloud_3 = PointCloudDot(density=15)
239: (16)                           group = Group(cloud_1, cloud_2, cloud_3).arrange()
240: (16)                           self.add(group)
241: (4)                .. manim:: PointCloudDotExample2
242: (8)                    class PointCloudDotExample2(Scene):
243: (12)                       def construct(self):
244: (16)                           plane = ComplexPlane()
245: (16)                           cloud = PointCloudDot(color=RED)
246: (16)                           self.add(
247: (20)                               plane, cloud
248: (16)                           )
249: (16)                           self.wait()
250: (16)                           self.play(
251: (20)                               cloud.animate.apply_complex_function(lambda z: np.exp(z))
252: (16)                           )
253: (4)                """
254: (4)                def __init__(
255: (8)                    self,
256: (8)                    center=ORIGIN,
257: (8)                    radius=2.0,
258: (8)                    stroke_width=2,
259: (8)                    density=DEFAULT_POINT_DENSITY_1D,
260: (8)                    color=YELLOW,
261: (8)                    **kwargs,
262: (4)                ):
263: (8)                    self.radius = radius
264: (8)                    self.epsilon = 1.0 / density
265: (8)                    super().__init__(
266: (12)                       stroke_width=stroke_width, density=density, color=color, **kwargs
267: (8)                    )
268: (8)                    self.shift(center)
269: (4)                def init_points(self):
270: (8)                    self.reset_points()
271: (8)                    self.generate_points()
272: (4)                def generate_points(self):
273: (8)                    self.add_points(
274: (12)                       [
275: (16)                           r * (np.cos(theta) * RIGHT + np.sin(theta) * UP)
276: (16)                           for r in np.arange(self.epsilon, self.radius, self.epsilon)
277: (16)                           # Num is equal to int(stop - start)/ (step + 1) reformulated.
278: (16)                           for theta in np.linspace(
279: (20)                               0,
280: (20)                               2 * np.pi,
281: (20)                               num=int(2 * np.pi * (r + self.epsilon) / self.epsilon),
282: (16)                           )
283: (12)                       ],
284: (8)                    )
285: (0)            class Point(PMobject):
286: (4)                """A mobject representing a point.
287: (4)                Examples
288: (4)                --------
289: (4)                .. manim:: ExamplePoint
290: (8)                    :save_last_frame:
291: (8)                    class ExamplePoint(Scene):
292: (12)                       def construct(self):
293: (16)                           colorList = [RED, GREEN, BLUE, YELLOW]
294: (16)                           for i in range(200):
295: (20)                               point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))
296: (20)                               self.add(point)
297: (16)                           for i in range(200):
298: (20)                               point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))
299: (20)                               self.add(point)
300: (16)                           self.add(point)
301: (4)                """
302: (4)                def __init__(self, location=ORIGIN, color=BLACK, **kwargs):
303: (8)                    self.location = location
304: (8)                    super().__init__(color=color, **kwargs)
305: (4)                def init_points(self):
306: (8)                    self.reset_points()
307: (8)                    self.generate_points()
308: (8)                    self.set_points([self.location])
309: (4)                def generate_points(self):
310: (8)                    self.add_points([self.location])

----------------------------------------

File 43 - .\opengl \opengl_image_mobject.py:

1: (0)              from __future__ import annotations
2: (0)              __all__ = [
3: (4)                  "OpenGLImageMobject",
4: (0)              ]
5: (0)              from pathlib import Path
6: (0)              import numpy as np
7: (0)              from PIL import Image
8: (0)              from PIL.Image import Resampling
9: (0)              from manim.mobject.opengl.opengl_surface import OpenGLSurface, OpenGLTexturedSurface
10: (0)             from manim.utils.images import get_full_raster_image_path
11: (0)             __all__ = ["OpenGLImageMobject"]
12: (0)             class OpenGLImageMobject(OpenGLTexturedSurface):
13: (4)                 def __init__(
14: (8)                     self,
15: (8)                     filename_or_array: str | Path | np.ndarray,
16: (8)                     width: float = None,
17: (8)                     height: float = None,
18: (8)                     image_mode: str = "RGBA",
19: (8)                     resampling_algorithm: int = Resampling.BICUBIC,
20: (8)                     opacity: float = 1,
21: (8)                     gloss: float = 0,
22: (8)                     shadow: float = 0,
23: (8)                     **kwargs,
24: (4)                 ):
25: (8)                     self.image = filename_or_array
26: (8)                     self.resampling_algorithm = resampling_algorithm
27: (8)                     if isinstance(filename_or_array, np.ndarray):
28: (12)                        self.size = self.image.shape[1::-1]
29: (8)                     elif isinstance(filename_or_array, (str, Path)):
30: (12)                        path = get_full_raster_image_path(filename_or_array)
31: (12)                        self.size = Image.open(path).size
32: (8)                     if width is None and height is None:
33: (12)                        width = 4 * self.size[0] / self.size[1]
34: (12)                        height = 4
35: (8)                     if height is None:
36: (12)                        height = width * self.size[1] / self.size[0]
37: (8)                     if width is None:
38: (12)                        width = height * self.size[0] / self.size[1]
39: (8)                     surface = OpenGLSurface(
40: (12)                        lambda u, v: np.array([u, v, 0]),
41: (12)                        [-width / 2, width / 2],
42: (12)                        [-height / 2, height / 2],
43: (12)                        opacity=opacity,
44: (12)                        gloss=gloss,
45: (12)                        shadow=shadow,
46: (8)                     )
47: (8)                     super().__init__(
48: (12)                        surface,
49: (12)                        self.image,
50: (12)                        image_mode=image_mode,
51: (12)                        opacity=opacity,
52: (12)                        gloss=gloss,
53: (12)                        shadow=shadow,
54: (12)                        **kwargs,
55: (8)                     )
56: (4)                 def get_image_from_file(
57: (8)                     self,
58: (8)                     image_file: str | Path | np.ndarray,
59: (8)                     image_mode: str,
60: (4)                 ):
61: (8)                     if isinstance(image_file, (str, Path)):
62: (12)                        return super().get_image_from_file(image_file, image_mode)
63: (8)                     else:
64: (12)                        return (
65: (16)                            Image.fromarray(image_file.astype("uint8"))
66: (16)                            .convert(image_mode)
67: (16)                            .resize(
68: (20)                                np.array(image_file.shape[:2])
69: (20)                                * 200,  # assumption of 200 ppmu (pixels per manim unit) would suffice
70: (20)                                resample=self.resampling_algorithm,
71: (16)                            )
72: (12)                        )

----------------------------------------

File 44 - .\opengl \opengl_three_dimensions.py:

1: (0)              from __future__ import annotations
2: (0)              import numpy as np
3: (0)              from manim.mobject.opengl.opengl_surface import OpenGLSurface
4: (0)              from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVGroup, OpenGLVMobject
5: (0)              __all__ = ["OpenGLSurfaceMesh"]
6: (0)              class OpenGLSurfaceMesh(OpenGLVGroup):
7: (4)                  def __init__(
8: (8)                      self,
9: (8)                      uv_surface,
10: (8)                     resolution=None,
11: (8)                     stroke_width=1,
12: (8)                     normal_nudge=1e-2,
13: (8)                     depth_test=True,
14: (8)                     flat_stroke=False,
15: (8)                     **kwargs,
16: (4)                 ):
17: (8)                     if not isinstance(uv_surface, OpenGLSurface):
18: (12)                        raise Exception("uv_surface must be of type OpenGLSurface")
19: (8)                     self.uv_surface = uv_surface
20: (8)                     self.resolution = resolution if resolution is not None else (21, 21)
21: (8)                     self.normal_nudge = normal_nudge
22: (8)                     super().__init__(
23: (12)                        stroke_width=stroke_width,
24: (12)                        depth_test=depth_test,
25: (12)                        flat_stroke=flat_stroke,
26: (12)                        **kwargs,
27: (8)                     )
28: (4)                 def init_points(self):
29: (8)                     uv_surface = self.uv_surface
30: (8)                     full_nu, full_nv = uv_surface.resolution
31: (8)                     part_nu, part_nv = self.resolution
32: (8)                     u_indices = np.linspace(0, full_nu, part_nu).astype(int)
33: (8)                     v_indices = np.linspace(0, full_nv, part_nv).astype(int)
34: (8)                     points, du_points, dv_points = uv_surface.get_surface_points_and_nudged_points()
35: (8)                     normals = uv_surface.get_unit_normals()
36: (8)                     nudged_points = points + self.normal_nudge * normals
37: (8)                     for ui in u_indices:
38: (12)                        path = OpenGLVMobject()
39: (12)                        full_ui = full_nv * ui
40: (12)                        path.set_points_smoothly(nudged_points[full_ui : full_ui + full_nv])
41: (12)                        self.add(path)
42: (8)                     for vi in v_indices:
43: (12)                        path = OpenGLVMobject()
44: (12)                        path.set_points_smoothly(nudged_points[vi::full_nv])
45: (12)                        self.add(path)

----------------------------------------

File 45 - .\opengl \opengl_vectorized_mobject.py:

1: (0)              from __future__ import annotations
2: (0)              import itertools as it
3: (0)              import operator as op
4: (0)              from functools import reduce, wraps
5: (0)              from typing import Callable, Iterable, Sequence
6: (0)              import moderngl
7: (0)              import numpy as np
8: (0)              from manim import config
9: (0)              from manim.constants import *
10: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLMobject, OpenGLPoint
11: (0)             from manim.renderer.shader_wrapper import ShaderWrapper
12: (0)             from manim.utils.bezier import (
13: (4)                 bezier,
14: (4)                 get_quadratic_approximation_of_cubic,
15: (4)                 get_smooth_cubic_bezier_handle_points,
16: (4)                 integer_interpolate,
17: (4)                 interpolate,
18: (4)                 partial_quadratic_bezier_points,
19: (4)                 proportions_along_bezier_curve_for_point,
20: (4)                 quadratic_bezier_remap,
21: (0)             )
22: (0)             from manim.utils.color import BLACK, WHITE, ManimColor, ParsableManimColor
23: (0)             from manim.utils.config_ops import _Data
24: (0)             from manim.utils.iterables import listify, make_even, resize_with_interpolation
25: (0)             from manim.utils.space_ops import (
26: (4)                 angle_between_vectors,
27: (4)                 cross2d,
28: (4)                 earclip_triangulation,
29: (4)                 get_unit_normal,
30: (4)                 shoelace_direction,
31: (4)                 z_to_vector,
32: (0)             )
33: (0)             __all__ = [
34: (4)                 "triggers_refreshed_triangulation",
35: (4)                 "OpenGLVMobject",
36: (4)                 "OpenGLVGroup",
37: (4)                 "OpenGLVectorizedPoint",
38: (4)                 "OpenGLCurvesAsSubmobjects",
39: (4)                 "OpenGLDashedVMobject",
40: (0)             ]
41: (0)             def triggers_refreshed_triangulation(func):
42: (4)                 @wraps(func)
43: (4)                 def wrapper(self, *args, **kwargs):
44: (8)                     old_points = np.empty((0, 3))
45: (8)                     for mob in self.family_members_with_points():
46: (12)                        old_points = np.concatenate((old_points, mob.points), axis=0)
47: (8)                     func(self, *args, **kwargs)
48: (8)                     new_points = np.empty((0, 3))
49: (8)                     for mob in self.family_members_with_points():
50: (12)                        new_points = np.concatenate((new_points, mob.points), axis=0)
51: (8)                     if not np.array_equal(new_points, old_points):
52: (12)                        self.refresh_triangulation()
53: (12)                        self.refresh_unit_normal()
54: (8)                     return self
55: (4)                 return wrapper
56: (0)             class OpenGLVMobject(OpenGLMobject):
57: (4)                 """A vectorized mobject."""
58: (4)                 fill_dtype = [
59: (8)                     ("point", np.float32, (3,)),
60: (8)                     ("unit_normal", np.float32, (3,)),
61: (8)                     ("color", np.float32, (4,)),
62: (8)                     ("vert_index", np.float32, (1,)),
63: (4)                 ]
64: (4)                 stroke_dtype = [
65: (8)                     ("point", np.float32, (3,)),
66: (8)                     ("prev_point", np.float32, (3,)),
67: (8)                     ("next_point", np.float32, (3,)),
68: (8)                     ("unit_normal", np.float32, (3,)),
69: (8)                     ("stroke_width", np.float32, (1,)),
70: (8)                     ("color", np.float32, (4,)),
71: (4)                 ]
72: (4)                 stroke_shader_folder = "quadratic_bezier_stroke"
73: (4)                 fill_shader_folder = "quadratic_bezier_fill"
74: (4)                 fill_rgba = _Data()
75: (4)                 stroke_rgba = _Data()
76: (4)                 stroke_width = _Data()
77: (4)                 unit_normal = _Data()
78: (4)                 def __init__(
79: (8)                     self,
80: (8)                     fill_color: ParsableManimColor | None = None,
81: (8)                     fill_opacity: float = 0.0,
82: (8)                     stroke_color: ParsableManimColor | None = None,
83: (8)                     stroke_opacity: float = 1.0,
84: (8)                     stroke_width: float = DEFAULT_STROKE_WIDTH,
85: (8)                     draw_stroke_behind_fill: bool = False,
86: (8)                     # Indicates that it will not be displayed, but
87: (8)                     # that it should count in parent mobject's path
88: (8)                     pre_function_handle_to_anchor_scale_factor: float = 0.01,
89: (8)                     make_smooth_after_applying_functions: float = False,
90: (8)                     background_image_file: str | None = None,
91: (8)                     # This is within a pixel
92: (8)                     # TODO, do we care about accounting for
93: (8)                     # varying zoom levels?
94: (8)                     tolerance_for_point_equality: float = 1e-8,
95: (8)                     n_points_per_curve: int = 3,
96: (8)                     long_lines: bool = False,
97: (8)                     should_subdivide_sharp_curves: bool = False,
98: (8)                     should_remove_null_curves: bool = False,
99: (8)                     # Could also be "bevel", "miter", "round"
100: (8)                    joint_type: LineJointType | None = None,
101: (8)                    flat_stroke: bool = True,
102: (8)                    render_primitive=moderngl.TRIANGLES,
103: (8)                    triangulation_locked: bool = False,
104: (8)                    **kwargs,
105: (4)                ):
106: (8)                    self.data = {}
107: (8)                    self.fill_opacity = fill_opacity
108: (8)                    self.stroke_opacity = stroke_opacity
109: (8)                    self.stroke_width = stroke_width
110: (8)                    self.draw_stroke_behind_fill = draw_stroke_behind_fill
111: (8)                    # Indicates that it will not be displayed, but
112: (8)                    # that it should count in parent mobject's path
113: (8)                    self.pre_function_handle_to_anchor_scale_factor = (
114: (12)                       pre_function_handle_to_anchor_scale_factor
115: (8)                    )
116: (8)                    self.make_smooth_after_applying_functions = make_smooth_after_applying_functions
117: (8)                    self.background_image_file = background_image_file
118: (8)                    # This is within a pixel
119: (8)                    # TODO, do we care about accounting for
120: (8)                    # varying zoom levels?
121: (8)                    self.tolerance_for_point_equality = tolerance_for_point_equality
122: (8)                    self.n_points_per_curve = n_points_per_curve
123: (8)                    self.long_lines = long_lines
124: (8)                    self.should_subdivide_sharp_curves = should_subdivide_sharp_curves
125: (8)                    self.should_remove_null_curves = should_remove_null_curves
126: (8)                    if joint_type is None:
127: (12)                       joint_type = LineJointType.AUTO
128: (8)                    self.joint_type = joint_type
129: (8)                    self.flat_stroke = flat_stroke
130: (8)                    self.render_primitive = render_primitive
131: (8)                    self.triangulation_locked = triangulation_locked
132: (8)                    self.needs_new_triangulation = True
133: (8)                    self.triangulation = np.zeros(0, dtype="i4")
134: (8)                    self.orientation = 1
135: (8)                    self.fill_data = None
136: (8)                    self.stroke_data = None
137: (8)                    self.fill_shader_wrapper = None
138: (8)                    self.stroke_shader_wrapper = None
139: (8)                    self.init_shader_data()
140: (8)                    super().__init__(**kwargs)
141: (8)                    self.refresh_unit_normal()
142: (8)                    if fill_color is not None:
143: (12)                       self.fill_color = ManimColor.parse(fill_color)
144: (8)                    if stroke_color is not None:
145: (12)                       self.stroke_color = ManimColor.parse(stroke_color)
146: (4)                def get_group_class(self):
147: (8)                    return OpenGLVGroup
148: (4)                @staticmethod
149: (4)                def get_mobject_type_class():
150: (8)                    return OpenGLVMobject
151: (4)                def init_data(self):
152: (8)                    super().init_data()
153: (8)                    self.data.pop("rgbas")
154: (8)                    self.fill_rgba = np.zeros((1, 4))
155: (8)                    self.stroke_rgba = np.zeros((1, 4))
156: (8)                    self.unit_normal = np.zeros((1, 3))
157: (8)                    # stroke_width belongs to self.data, but is defined through init_colors+set_stroke
158: (4)                # Colors
159: (4)                def init_colors(self):
160: (8)                    self.set_fill(
161: (12)                       color=self.fill_color or self.color,
162: (12)                       opacity=self.fill_opacity,
163: (8)                    )
164: (8)                    self.set_stroke(
165: (12)                       color=self.stroke_color or self.color,
166: (12)                       width=self.stroke_width,
167: (12)                       opacity=self.stroke_opacity,
168: (12)                       background=self.draw_stroke_behind_fill,
169: (8)                    )
170: (8)                    self.set_gloss(self.gloss)
171: (8)                    self.set_flat_stroke(self.flat_stroke)
172: (8)                    return self
173: (4)                def set_fill(
174: (8)                    self,
175: (8)                    color: ParsableManimColor | None = None,
176: (8)                    opacity: float | None = None,
177: (8)                    recurse: bool = True,
178: (4)                ) -> OpenGLVMobject:
179: (8)                    """Set the fill color and fill opacity of a :class:`OpenGLVMobject`.
180: (8)                    Parameters
181: (8)                    ----------
182: (8)                    color
183: (12)                       Fill color of the :class:`OpenGLVMobject`.
184: (8)                    opacity
185: (12)                       Fill opacity of the :class:`OpenGLVMobject`.
186: (8)                    recurse
187: (12)                       If ``True``, the fill color of all submobjects is also set.
188: (8)                    Returns
189: (8)                    -------
190: (8)                    OpenGLVMobject
191: (12)                       self. For chaining purposes.
192: (8)                    Examples
193: (8)                    --------
194: (8)                    .. manim:: SetFill
195: (12)                       :save_last_frame:
196: (12)                       class SetFill(Scene):
197: (16)                           def construct(self):
198: (20)                               square = Square().scale(2).set_fill(WHITE,1)
199: (20)                               circle1 = Circle().set_fill(GREEN,0.8)
200: (20)                               circle2 = Circle().set_fill(YELLOW) # No fill_opacity
201: (20)                               circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)
202: (20)                               group = Group(circle1,circle2,circle3).arrange()
203: (20)                               self.add(square)
204: (20)                               self.add(group)
205: (8)                    See Also
206: (8)                    --------
207: (8)                    :meth:`~.OpenGLVMobject.set_style`
208: (8)                    """
209: (8)                    if opacity is not None:
210: (12)                       self.fill_opacity = opacity
211: (8)                    if recurse:
212: (12)                       for submobject in self.submobjects:
213: (16)                           submobject.set_fill(color, opacity, recurse)
214: (8)                    self.set_rgba_array(color, opacity, "fill_rgba", recurse)
215: (8)                    return self
216: (4)                def set_stroke(
217: (8)                    self,
218: (8)                    color=None,
219: (8)                    width=None,
220: (8)                    opacity=None,
221: (8)                    background=None,
222: (8)                    recurse=True,
223: (4)                ):
224: (8)                    if opacity is not None:
225: (12)                       self.stroke_opacity = opacity
226: (8)                    if recurse:
227: (12)                       for submobject in self.submobjects:
228: (16)                           submobject.set_stroke(
229: (20)                               color=color,
230: (20)                               width=width,
231: (20)                               opacity=opacity,
232: (20)                               background=background,
233: (20)                               recurse=recurse,
234: (16)                           )
235: (8)                    self.set_rgba_array(color, opacity, "stroke_rgba", recurse)
236: (8)                    if width is not None:
237: (12)                       for mob in self.get_family(recurse):
238: (16)                           mob.stroke_width = np.array([[width] for width in listify(width)])
239: (8)                    if background is not None:
240: (12)                       for mob in self.get_family(recurse):
241: (16)                           mob.draw_stroke_behind_fill = background
242: (8)                    return self
243: (4)                def set_style(
244: (8)                    self,
245: (8)                    fill_color=None,
246: (8)                    fill_opacity=None,
247: (8)                    fill_rgba=None,
248: (8)                    stroke_color=None,
249: (8)                    stroke_opacity=None,
250: (8)                    stroke_rgba=None,
251: (8)                    stroke_width=None,
252: (8)                    gloss=None,
253: (8)                    shadow=None,
254: (8)                    recurse=True,
255: (4)                ):
256: (8)                    if fill_rgba is not None:
257: (12)                       self.fill_rgba = resize_with_interpolation(fill_rgba, len(fill_rgba))
258: (8)                    else:
259: (12)                       self.set_fill(color=fill_color, opacity=fill_opacity, recurse=recurse)
260: (8)                    if stroke_rgba is not None:
261: (12)                       self.stroke_rgba = resize_with_interpolation(stroke_rgba, len(fill_rgba))
262: (12)                       self.set_stroke(width=stroke_width)
263: (8)                    else:
264: (12)                       self.set_stroke(
265: (16)                           color=stroke_color,
266: (16)                           width=stroke_width,
267: (16)                           opacity=stroke_opacity,
268: (16)                           recurse=recurse,
269: (12)                       )
270: (8)                    if gloss is not None:
271: (12)                       self.set_gloss(gloss, recurse=recurse)
272: (8)                    if shadow is not None:
273: (12)                       self.set_shadow(shadow, recurse=recurse)
274: (8)                    return self
275: (4)                def get_style(self):
276: (8)                    return {
277: (12)                       "fill_rgba": self.fill_rgba,
278: (12)                       "stroke_rgba": self.stroke_rgba,
279: (12)                       "stroke_width": self.stroke_width,
280: (12)                       "gloss": self.gloss,
281: (12)                       "shadow": self.shadow,
282: (8)                    }
283: (4)                def match_style(self, vmobject, recurse=True):
284: (8)                    vmobject_style = vmobject.get_style()
285: (8)                    if config.renderer == RendererType.OPENGL:
286: (12)                       vmobject_style["stroke_width"] = vmobject_style["stroke_width"][0][0]
287: (8)                    self.set_style(**vmobject_style, recurse=False)
288: (8)                    if recurse:
289: (12)                       # Does its best to match up submobject lists, and
290: (12)                       # match styles accordingly
291: (12)                       submobs1, submobs2 = self.submobjects, vmobject.submobjects
292: (12)                       if len(submobs1) == 0:
293: (16)                           return self
294: (12)                       elif len(submobs2) == 0:
295: (16)                           submobs2 = [vmobject]
296: (12)                       for sm1, sm2 in zip(*make_even(submobs1, submobs2)):
297: (16)                           sm1.match_style(sm2)
298: (8)                    return self
299: (4)                def set_color(self, color, opacity=None, recurse=True):
300: (8)                    if opacity is not None:
301: (12)                       self.opacity = opacity
302: (8)                    self.set_fill(color, opacity=opacity, recurse=recurse)
303: (8)                    self.set_stroke(color, opacity=opacity, recurse=recurse)
304: (8)                    return self
305: (4)                def set_opacity(self, opacity, recurse=True):
306: (8)                    self.set_fill(opacity=opacity, recurse=recurse)
307: (8)                    self.set_stroke(opacity=opacity, recurse=recurse)
308: (8)                    return self
309: (4)                def fade(self, darkness=0.5, recurse=True):
310: (8)                    factor = 1.0 - darkness
311: (8)                    self.set_fill(
312: (12)                       opacity=factor * self.get_fill_opacity(),
313: (12)                       recurse=False,
314: (8)                    )
315: (8)                    self.set_stroke(
316: (12)                       opacity=factor * self.get_stroke_opacity(),
317: (12)                       recurse=False,
318: (8)                    )
319: (8)                    super().fade(darkness, recurse)
320: (8)                    return self
321: (4)                # Todo im not quite sure why we are doing this
322: (4)                def get_fill_colors(self):
323: (8)                    return [ManimColor.from_rgb(rgba[:3]) for rgba in self.fill_rgba]
324: (4)                def get_fill_opacities(self):
325: (8)                    return self.fill_rgba[:, 3]
326: (4)                def get_stroke_colors(self):
327: (8)                    return [ManimColor.from_rgb(rgba[:3]) for rgba in self.stroke_rgba]
328: (4)                def get_stroke_opacities(self):
329: (8)                    return self.stroke_rgba[:, 3]
330: (4)                def get_stroke_widths(self):
331: (8)                    return self.stroke_width
332: (4)                # TODO, it's weird for these to return the first of various lists
333: (4)                # rather than the full information
334: (4)                def get_fill_color(self):
335: (8)                    """
336: (8)                    If there are multiple colors (for gradient)
337: (8)                    this returns the first one
338: (8)                    """
339: (8)                    return self.get_fill_colors()[0]
340: (4)                def get_fill_opacity(self):
341: (8)                    """
342: (8)                    If there are multiple opacities, this returns the
343: (8)                    first
344: (8)                    """
345: (8)                    return self.get_fill_opacities()[0]
346: (4)                def get_stroke_color(self):
347: (8)                    return self.get_stroke_colors()[0]
348: (4)                def get_stroke_width(self):
349: (8)                    return self.get_stroke_widths()[0]
350: (4)                def get_stroke_opacity(self):
351: (8)                    return self.get_stroke_opacities()[0]
352: (4)                def get_color(self):
353: (8)                    if self.has_stroke():
354: (12)                       return self.get_stroke_color()
355: (8)                    return self.get_fill_color()
356: (4)                def get_colors(self):
357: (8)                    if self.has_stroke():
358: (12)                       return self.get_stroke_colors()
359: (8)                    return self.get_fill_colors()
360: (4)                stroke_color = property(get_stroke_color, set_stroke)
361: (4)                color = property(get_color, set_color)
362: (4)                fill_color = property(get_fill_color, set_fill)
363: (4)                def has_stroke(self):
364: (8)                    stroke_widths = self.get_stroke_widths()
365: (8)                    stroke_opacities = self.get_stroke_opacities()
366: (8)                    return (
367: (12)                       stroke_widths is not None
368: (12)                       and stroke_opacities is not None
369: (12)                       and any(stroke_widths)
370: (12)                       and any(stroke_opacities)
371: (8)                    )
372: (4)                def has_fill(self):
373: (8)                    fill_opacities = self.get_fill_opacities()
374: (8)                    return fill_opacities is not None and any(fill_opacities)
375: (4)                def get_opacity(self):
376: (8)                    if self.has_fill():
377: (12)                       return self.get_fill_opacity()
378: (8)                    return self.get_stroke_opacity()
379: (4)                def set_flat_stroke(self, flat_stroke=True, recurse=True):
380: (8)                    for mob in self.get_family(recurse):
381: (12)                       mob.flat_stroke = flat_stroke
382: (8)                    return self
383: (4)                def get_flat_stroke(self):
384: (8)                    return self.flat_stroke
385: (4)                # Points
386: (4)                def set_anchors_and_handles(self, anchors1, handles, anchors2):
387: (8)                    assert len(anchors1) == len(handles) == len(anchors2)
388: (8)                    nppc = self.n_points_per_curve
389: (8)                    new_points = np.zeros((nppc * len(anchors1), self.dim))
390: (8)                    arrays = [anchors1, handles, anchors2]
391: (8)                    for index, array in enumerate(arrays):
392: (12)                       new_points[index::nppc] = array
393: (8)                    self.set_points(new_points)
394: (8)                    return self
395: (4)                def start_new_path(self, point):
396: (8)                    assert self.get_num_points() % self.n_points_per_curve == 0
397: (8)                    self.append_points([point])
398: (8)                    return self
399: (4)                def add_cubic_bezier_curve(self, anchor1, handle1, handle2, anchor2):
400: (8)                    new_points = get_quadratic_approximation_of_cubic(
401: (12)                       anchor1,
402: (12)                       handle1,
403: (12)                       handle2,
404: (12)                       anchor2,
405: (8)                    )
406: (8)                    self.append_points(new_points)
407: (4)                def add_cubic_bezier_curve_to(self, handle1, handle2, anchor):
408: (8)                    """
409: (8)                    Add cubic bezier curve to the path.
410: (8)                    """
411: (8)                    self.throw_error_if_no_points()
412: (8)                    quadratic_approx = get_quadratic_approximation_of_cubic(
413: (12)                       self.get_last_point(),
414: (12)                       handle1,
415: (12)                       handle2,
416: (12)                       anchor,
417: (8)                    )
418: (8)                    if self.has_new_path_started():
419: (12)                       self.append_points(quadratic_approx[1:])
420: (8)                    else:
421: (12)                       self.append_points(quadratic_approx)
422: (4)                def add_quadratic_bezier_curve_to(self, handle, anchor):
423: (8)                    self.throw_error_if_no_points()
424: (8)                    if self.has_new_path_started():
425: (12)                       self.append_points([handle, anchor])
426: (8)                    else:
427: (12)                       self.append_points([self.get_last_point(), handle, anchor])
428: (4)                def add_line_to(self, point: Sequence[float]) -> OpenGLVMobject:
429: (8)                    """Add a straight line from the last point of OpenGLVMobject to the given point.
430: (8)                    Parameters
431: (8)                    ----------
432: (8)                    point
433: (12)                       end of the straight line.
434: (8)                    """
435: (8)                    end = self.points[-1]
436: (8)                    alphas = np.linspace(0, 1, self.n_points_per_curve)
437: (8)                    if self.long_lines:
438: (12)                       halfway = interpolate(end, point, 0.5)
439: (12)                       points = [interpolate(end, halfway, a) for a in alphas] + [
440: (16)                           interpolate(halfway, point, a) for a in alphas
441: (12)                       ]
442: (8)                    else:
443: (12)                       points = [interpolate(end, point, a) for a in alphas]
444: (8)                    if self.has_new_path_started():
445: (12)                       points = points[1:]
446: (8)                    self.append_points(points)
447: (8)                    return self
448: (4)                def add_smooth_curve_to(self, point):
449: (8)                    if self.has_new_path_started():
450: (12)                       self.add_line_to(point)
451: (8)                    else:
452: (12)                       self.throw_error_if_no_points()
453: (12)                       new_handle = self.get_reflection_of_last_handle()
454: (12)                       self.add_quadratic_bezier_curve_to(new_handle, point)
455: (8)                    return self
456: (4)                def add_smooth_cubic_curve_to(self, handle, point):
457: (8)                    self.throw_error_if_no_points()
458: (8)                    new_handle = self.get_reflection_of_last_handle()
459: (8)                    self.add_cubic_bezier_curve_to(new_handle, handle, point)
460: (4)                def has_new_path_started(self):
461: (8)                    return self.get_num_points() % self.n_points_per_curve == 1
462: (4)                def get_last_point(self):
463: (8)                    return self.points[-1]
464: (4)                def get_reflection_of_last_handle(self):
465: (8)                    points = self.points
466: (8)                    return 2 * points[-1] - points[-2]
467: (4)                def close_path(self):
468: (8)                    if not self.is_closed():
469: (12)                       self.add_line_to(self.get_subpaths()[-1][0])
470: (4)                def is_closed(self):
471: (8)                    return self.consider_points_equals(self.points[0], self.points[-1])
472: (4)                def subdivide_sharp_curves(self, angle_threshold=30 * DEGREES, recurse=True):
473: (8)                    vmobs = [vm for vm in self.get_family(recurse) if vm.has_points()]
474: (8)                    for vmob in vmobs:
475: (12)                       new_points = []
476: (12)                       for tup in vmob.get_bezier_tuples():
477: (16)                           angle = angle_between_vectors(tup[1] - tup[0], tup[2] - tup[1])
478: (16)                           if angle > angle_threshold:
479: (20)                               n = int(np.ceil(angle / angle_threshold))
480: (20)                               alphas = np.linspace(0, 1, n + 1)
481: (20)                               new_points.extend(
482: (24)                                   [
483: (28)                                       partial_quadratic_bezier_points(tup, a1, a2)
484: (28)                                       for a1, a2 in zip(alphas, alphas[1:])
485: (24)                                   ],
486: (20)                               )
487: (16)                           else:
488: (20)                               new_points.append(tup)
489: (12)                       vmob.set_points(np.vstack(new_points))
490: (8)                    return self
491: (4)                def add_points_as_corners(self, points):
492: (8)                    for point in points:
493: (12)                       self.add_line_to(point)
494: (8)                    return points
495: (4)                def set_points_as_corners(self, points: Iterable[float]) -> OpenGLVMobject:
496: (8)                    """Given an array of points, set them as corner of the vmobject.
497: (8)                    To achieve that, this algorithm sets handles aligned with the anchors such that the resultant bezier curve will be the segment
498: (8)                    between the two anchors.
499: (8)                    Parameters
500: (8)                    ----------
501: (8)                    points
502: (12)                       Array of points that will be set as corners.
503: (8)                    Returns
504: (8)                    -------
505: (8)                    OpenGLVMobject
506: (12)                       self. For chaining purposes.
507: (8)                    """
508: (8)                    nppc = self.n_points_per_curve
509: (8)                    points = np.array(points)
510: (8)                    self.set_anchors_and_handles(
511: (12)                       *(interpolate(points[:-1], points[1:], a) for a in np.linspace(0, 1, nppc))
512: (8)                    )
513: (8)                    return self
514: (4)                def set_points_smoothly(self, points, true_smooth=False):
515: (8)                    self.set_points_as_corners(points)
516: (8)                    self.make_smooth()
517: (8)                    return self
518: (4)                def change_anchor_mode(self, mode):
519: (8)                    """Changes the anchor mode of the bezier curves. This will modify the handles.
520: (8)                    There can be only three modes, "jagged", "approx_smooth"  and "true_smooth".
521: (8)                    Returns
522: (8)                    -------
523: (8)                    OpenGLVMobject
524: (12)                       For chaining purposes.
525: (8)                    """
526: (8)                    assert mode in ("jagged", "approx_smooth", "true_smooth")
527: (8)                    nppc = self.n_points_per_curve
528: (8)                    for submob in self.family_members_with_points():
529: (12)                       subpaths = submob.get_subpaths()
530: (12)                       submob.clear_points()
531: (12)                       for subpath in subpaths:
532: (16)                           anchors = np.vstack([subpath[::nppc], subpath[-1:]])
533: (16)                           new_subpath = np.array(subpath)
534: (16)                           if mode == "approx_smooth":
535: (20)                               # TODO: get_smooth_quadratic_bezier_handle_points is not defined
536: (20)                               new_subpath[1::nppc] = get_smooth_quadratic_bezier_handle_points(
537: (24)                                   anchors,
538: (20)                               )
539: (16)                           elif mode == "true_smooth":
540: (20)                               h1, h2 = get_smooth_cubic_bezier_handle_points(anchors)
541: (20)                               new_subpath = get_quadratic_approximation_of_cubic(
542: (24)                                   anchors[:-1],
543: (24)                                   h1,
544: (24)                                   h2,
545: (24)                                   anchors[1:],
546: (20)                               )
547: (16)                           elif mode == "jagged":
548: (20)                               new_subpath[1::nppc] = 0.5 * (anchors[:-1] + anchors[1:])
549: (16)                           submob.append_points(new_subpath)
550: (12)                       submob.refresh_triangulation()
551: (8)                    return self
552: (4)                def make_smooth(self):
553: (8)                    """
554: (8)                    This will double the number of points in the mobject,
555: (8)                    so should not be called repeatedly.  It also means
556: (8)                    transforming between states before and after calling
557: (8)                    this might have strange artifacts
558: (8)                    """
559: (8)                    self.change_anchor_mode("true_smooth")
560: (8)                    return self
561: (4)                def make_approximately_smooth(self):
562: (8)                    """
563: (8)                    Unlike make_smooth, this will not change the number of
564: (8)                    points, but it also does not result in a perfectly smooth
565: (8)                    curve.  It's most useful when the points have been
566: (8)                    sampled at a not-too-low rate from a continuous function,
567: (8)                    as in the case of ParametricCurve
568: (8)                    """
569: (8)                    self.change_anchor_mode("approx_smooth")
570: (8)                    return self
571: (4)                def make_jagged(self):
572: (8)                    self.change_anchor_mode("jagged")
573: (8)                    return self
574: (4)                def add_subpath(self, points):
575: (8)                    assert len(points) % self.n_points_per_curve == 0
576: (8)                    self.append_points(points)
577: (8)                    return self
578: (4)                def append_vectorized_mobject(self, vectorized_mobject):
579: (8)                    new_points = list(vectorized_mobject.points)
580: (8)                    if self.has_new_path_started():
581: (12)                       # Remove last point, which is starting
582: (12)                       # a new path
583: (12)                       self.resize_data(len(self.points - 1))
584: (8)                    self.append_points(new_points)
585: (8)                    return self
586: (4)                #
587: (4)                def consider_points_equals(self, p0, p1):
588: (8)                    return np.linalg.norm(p1 - p0) < self.tolerance_for_point_equality
589: (4)                # Information about the curve
590: (4)                def force_direction(self, target_direction: str):
591: (8)                    """Makes sure that points are either directed clockwise or
592: (8)                    counterclockwise.
593: (8)                    Parameters
594: (8)                    ----------
595: (8)                    target_direction
596: (12)                       Either ``"CW"`` or ``"CCW"``.
597: (8)                    """
598: (8)                    if target_direction not in ("CW", "CCW"):
599: (12)                       raise ValueError('Invalid input for force_direction. Use "CW" or "CCW"')
600: (8)                    if self.get_direction() != target_direction:
601: (12)                       self.reverse_points()
602: (8)                    return self
603: (4)                def reverse_direction(self):
604: (8)                    """Reverts the point direction by inverting the point order.
605: (8)                    Returns
606: (8)                    -------
607: (8)                    :class:`OpenGLVMobject`
608: (12)                       Returns self.
609: (8)                    Examples
610: (8)                    --------
611: (8)                    .. manim:: ChangeOfDirection
612: (12)                       class ChangeOfDirection(Scene):
613: (16)                           def construct(self):
614: (20)                               ccw = RegularPolygon(5)
615: (20)                               ccw.shift(LEFT)
616: (20)                               cw = RegularPolygon(5)
617: (20)                               cw.shift(RIGHT).reverse_direction()
618: (20)                               self.play(Create(ccw), Create(cw),
619: (20)                               run_time=4)
620: (8)                    """
621: (8)                    self.set_points(self.points[::-1])
622: (8)                    return self
623: (4)                def get_bezier_tuples_from_points(self, points):
624: (8)                    nppc = self.n_points_per_curve
625: (8)                    remainder = len(points) % nppc
626: (8)                    points = points[: len(points) - remainder]
627: (8)                    return points.reshape((-1, nppc, 3))
628: (4)                def get_bezier_tuples(self):
629: (8)                    return self.get_bezier_tuples_from_points(self.points)
630: (4)                def get_subpaths_from_points(self, points):
631: (8)                    nppc = self.n_points_per_curve
632: (8)                    diffs = points[nppc - 1 : -1 : nppc] - points[nppc::nppc]
633: (8)                    splits = (diffs * diffs).sum(1) > self.tolerance_for_point_equality
634: (8)                    split_indices = np.arange(nppc, len(points), nppc, dtype=int)[splits]
635: (8)                    # split_indices = filter(
636: (8)                    #     lambda n: not self.consider_points_equals(points[n - 1], points[n]),
637: (8)                    #     range(nppc, len(points), nppc)
638: (8)                    # )
639: (8)                    split_indices = [0, *split_indices, len(points)]
640: (8)                    return [
641: (12)                       points[i1:i2]
642: (12)                       for i1, i2 in zip(split_indices, split_indices[1:])
643: (12)                       if (i2 - i1) >= nppc
644: (8)                    ]
645: (4)                def get_subpaths(self):
646: (8)                    """Returns subpaths formed by the curves of the OpenGLVMobject.
647: (8)                    Subpaths are ranges of curves with each pair of consecutive
648: (8)                    curves having their end/start points coincident.
649: (8)                    Returns
650: (8)                    -------
651: (8)                    Tuple
652: (12)                       subpaths.
653: (8)                    """
654: (8)                    return self.get_subpaths_from_points(self.points)
655: (4)                def get_nth_curve_points(self, n: int) -> np.ndarray:
656: (8)                    """Returns the points defining the nth curve of the vmobject.
657: (8)                    Parameters
658: (8)                    ----------
659: (8)                    n
660: (12)                       index of the desired bezier curve.
661: (8)                    Returns
662: (8)                    -------
663: (8)                    np.ndarray
664: (12)                       points defininf the nth bezier curve (anchors, handles)
665: (8)                    """
666: (8)                    assert n < self.get_num_curves()
667: (8)                    nppc = self.n_points_per_curve
668: (8)                    return self.points[nppc * n : nppc * (n + 1)]
669: (4)                def get_nth_curve_function(self, n: int) -> Callable[[float], np.ndarray]:
670: (8)                    """Returns the expression of the nth curve.
671: (8)                    Parameters
672: (8)                    ----------
673: (8)                    n
674: (12)                       index of the desired curve.
675: (8)                    Returns
676: (8)                    -------
677: (8)                    typing.Callable[float]
678: (12)                       expression of the nth bezier curve.
679: (8)                    """
680: (8)                    return bezier(self.get_nth_curve_points(n))
681: (4)                def get_nth_curve_function_with_length(
682: (8)                    self,
683: (8)                    n: int,
684: (8)                    sample_points: int | None = None,
685: (4)                ) -> tuple[Callable[[float], np.ndarray], float]:
686: (8)                    """Returns the expression of the nth curve along with its (approximate) length.
687: (8)                    Parameters
688: (8)                    ----------
689: (8)                    n
690: (12)                       The index of the desired curve.
691: (8)                    sample_points
692: (12)                       The number of points to sample to find the length.
693: (8)                    Returns
694: (8)                    -------
695: (8)                    curve : Callable[[float], np.ndarray]
696: (12)                       The function for the nth curve.
697: (8)                    length : :class:`float`
698: (12)                       The length of the nth curve.
699: (8)                    """
700: (8)                    if sample_points is None:
701: (12)                       sample_points = 10
702: (8)                    curve = self.get_nth_curve_function(n)
703: (8)                    norms = self.get_nth_curve_length_pieces(n, sample_points)
704: (8)                    length = np.sum(norms)
705: (8)                    return curve, length
706: (4)                def get_num_curves(self) -> int:
707: (8)                    """Returns the number of curves of the vmobject.
708: (8)                    Returns
709: (8)                    -------
710: (8)                    int
711: (12)                       number of curves. of the vmobject.
712: (8)                    """
713: (8)                    return self.get_num_points() // self.n_points_per_curve
714: (4)                def get_nth_curve_length(
715: (8)                    self,
716: (8)                    n: int,
717: (8)                    sample_points: int | None = None,
718: (4)                ) -> float:
719: (8)                    """Returns the (approximate) length of the nth curve.
720: (8)                    Parameters
721: (8)                    ----------
722: (8)                    n
723: (12)                       The index of the desired curve.
724: (8)                    sample_points
725: (12)                       The number of points to sample to find the length.
726: (8)                    Returns
727: (8)                    -------
728: (8)                    length : :class:`float`
729: (12)                       The length of the nth curve.
730: (8)                    """
731: (8)                    _, length = self.get_nth_curve_function_with_length(n, sample_points)
732: (8)                    return length
733: (4)                def get_curve_functions(
734: (8)                    self,
735: (4)                ) -> Iterable[Callable[[float], np.ndarray]]:
736: (8)                    """Gets the functions for the curves of the mobject.
737: (8)                    Returns
738: (8)                    -------
739: (8)                    Iterable[Callable[[float], np.ndarray]]
740: (12)                       The functions for the curves.
741: (8)                    """
742: (8)                    num_curves = self.get_num_curves()
743: (8)                    for n in range(num_curves):
744: (12)                       yield self.get_nth_curve_function(n)
745: (4)                def get_nth_curve_length_pieces(
746: (8)                    self,
747: (8)                    n: int,
748: (8)                    sample_points: int | None = None,
749: (4)                ) -> np.ndarray:
750: (8)                    """Returns the array of short line lengths used for length approximation.
751: (8)                    Parameters
752: (8)                    ----------
753: (8)                    n
754: (12)                       The index of the desired curve.
755: (8)                    sample_points
756: (12)                       The number of points to sample to find the length.
757: (8)                    Returns
758: (8)                    -------
759: (8)                    np.ndarray
760: (12)                       The short length-pieces of the nth curve.
761: (8)                    """
762: (8)                    if sample_points is None:
763: (12)                       sample_points = 10
764: (8)                    curve = self.get_nth_curve_function(n)
765: (8)                    points = np.array([curve(a) for a in np.linspace(0, 1, sample_points)])
766: (8)                    diffs = points[1:] - points[:-1]
767: (8)                    norms = np.apply_along_axis(np.linalg.norm, 1, diffs)
768: (8)                    return norms
769: (4)                def get_curve_functions_with_lengths(
770: (8)                    self, **kwargs
771: (4)                ) -> Iterable[tuple[Callable[[float], np.ndarray], float]]:
772: (8)                    """Gets the functions and lengths of the curves for the mobject.
773: (8)                    Parameters
774: (8)                    ----------
775: (8)                    **kwargs
776: (12)                       The keyword arguments passed to :meth:`get_nth_curve_function_with_length`
777: (8)                    Returns
778: (8)                    -------
779: (8)                    Iterable[Tuple[Callable[[float], np.ndarray], float]]
780: (12)                       The functions and lengths of the curves.
781: (8)                    """
782: (8)                    num_curves = self.get_num_curves()
783: (8)                    for n in range(num_curves):
784: (12)                       yield self.get_nth_curve_function_with_length(n, **kwargs)
785: (4)                def point_from_proportion(self, alpha: float) -> np.ndarray:
786: (8)                    """Gets the point at a proportion along the path of the :class:`OpenGLVMobject`.
787: (8)                    Parameters
788: (8)                    ----------
789: (8)                    alpha
790: (12)                       The proportion along the the path of the :class:`OpenGLVMobject`.
791: (8)                    Returns
792: (8)                    -------
793: (8)                    :class:`numpy.ndarray`
794: (12)                       The point on the :class:`OpenGLVMobject`.
795: (8)                    Raises
796: (8)                    ------
797: (8)                    :exc:`ValueError`
798: (12)                       If ``alpha`` is not between 0 and 1.
799: (8)                    :exc:`Exception`
800: (12)                       If the :class:`OpenGLVMobject` has no points.
801: (8)                    """
802: (8)                    if alpha < 0 or alpha > 1:
803: (12)                       raise ValueError(f"Alpha {alpha} not between 0 and 1.")
804: (8)                    self.throw_error_if_no_points()
805: (8)                    if alpha == 1:
806: (12)                       return self.points[-1]
807: (8)                    curves_and_lengths = tuple(self.get_curve_functions_with_lengths())
808: (8)                    target_length = alpha * np.sum(
809: (12)                       np.fromiter((length for _, length in curves_and_lengths), dtype=np.float64)
810: (8)                    )
811: (8)                    current_length = 0
812: (8)                    for curve, length in curves_and_lengths:
813: (12)                       if current_length + length >= target_length:
814: (16)                           if length != 0:
815: (20)                               residue = (target_length - current_length) / length
816: (16)                           else:
817: (20)                               residue = 0
818: (16)                           return curve(residue)
819: (12)                       current_length += length
820: (4)                def proportion_from_point(
821: (8)                    self,
822: (8)                    point: Iterable[float | int],
823: (4)                ) -> float:
824: (8)                    """Returns the proportion along the path of the :class:`OpenGLVMobject`
825: (8)                    a particular given point is at.
826: (8)                    Parameters
827: (8)                    ----------
828: (8)                    point
829: (12)                       The Cartesian coordinates of the point which may or may not lie on the :class:`OpenGLVMobject`
830: (8)                    Returns
831: (8)                    -------
832: (8)                    float
833: (12)                       The proportion along the path of the :class:`OpenGLVMobject`.
834: (8)                    Raises
835: (8)                    ------
836: (8)                    :exc:`ValueError`
837: (12)                       If ``point`` does not lie on the curve.
838: (8)                    :exc:`Exception`
839: (12)                       If the :class:`OpenGLVMobject` has no points.
840: (8)                    """
841: (8)                    self.throw_error_if_no_points()
842: (8)                    # Iterate over each bezier curve that the ``VMobject`` is composed of, checking
843: (8)                    # if the point lies on that curve. If it does not lie on that curve, add
844: (8)                    # the whole length of the curve to ``target_length`` and move onto the next
845: (8)                    # curve. If the point does lie on the curve, add how far along the curve
846: (8)                    # the point is to ``target_length``.
847: (8)                    # Then, divide ``target_length`` by the total arc length of the shape to get
848: (8)                    # the proportion along the ``VMobject`` the point is at.
849: (8)                    num_curves = self.get_num_curves()
850: (8)                    total_length = self.get_arc_length()
851: (8)                    target_length = 0
852: (8)                    for n in range(num_curves):
853: (12)                       control_points = self.get_nth_curve_points(n)
854: (12)                       length = self.get_nth_curve_length(n)
855: (12)                       proportions_along_bezier = proportions_along_bezier_curve_for_point(
856: (16)                           point,
857: (16)                           control_points,
858: (12)                       )
859: (12)                       if len(proportions_along_bezier) > 0:
860: (16)                           proportion_along_nth_curve = max(proportions_along_bezier)
861: (16)                           target_length += length * proportion_along_nth_curve
862: (16)                           break
863: (12)                       target_length += length
864: (8)                    else:
865: (12)                       raise ValueError(f"Point {point} does not lie on this curve.")
866: (8)                    alpha = target_length / total_length
867: (8)                    return alpha
868: (4)                def get_anchors_and_handles(self) -> Iterable[np.ndarray]:
869: (8)                    """
870: (8)                    Returns anchors1, handles, anchors2,
871: (8)                    where (anchors1[i], handles[i], anchors2[i])
872: (8)                    will be three points defining a quadratic bezier curve
873: (8)                    for any i in range(0, len(anchors1))
874: (8)                    """
875: (8)                    nppc = self.n_points_per_curve
876: (8)                    points = self.points
877: (8)                    return [points[i::nppc] for i in range(nppc)]
878: (4)                def get_start_anchors(self) -> np.ndarray:
879: (8)                    """Returns the start anchors of the bezier curves.
880: (8)                    Returns
881: (8)                    -------
882: (8)                    np.ndarray
883: (12)                       Starting anchors
884: (8)                    """
885: (8)                    return self.points[0 :: self.n_points_per_curve]
886: (4)                def get_end_anchors(self) -> np.ndarray:
887: (8)                    """Return the starting anchors of the bezier curves.
888: (8)                    Returns
889: (8)                    -------
890: (8)                    np.ndarray
891: (12)                       Starting anchors
892: (8)                    """
893: (8)                    nppc = self.n_points_per_curve
894: (8)                    return self.points[nppc - 1 :: nppc]
895: (4)                def get_anchors(self) -> Iterable[np.ndarray]:
896: (8)                    """Returns the anchors of the curves forming the OpenGLVMobject.
897: (8)                    Returns
898: (8)                    -------
899: (8)                    Iterable[np.ndarray]
900: (12)                       The anchors.
901: (8)                    """
902: (8)                    points = self.points
903: (8)                    if len(points) == 1:
904: (12)                       return points
905: (8)                    s = self.get_start_anchors()
906: (8)                    e = self.get_end_anchors()
907: (8)                    return list(it.chain.from_iterable(zip(s, e)))
908: (4)                def get_points_without_null_curves(self, atol=1e-9):
909: (8)                    nppc = self.n_points_per_curve
910: (8)                    points = self.points
911: (8)                    distinct_curves = reduce(
912: (12)                       op.or_,
913: (12)                       [
914: (16)                           (abs(points[i::nppc] - points[0::nppc]) > atol).any(1)
915: (16)                           for i in range(1, nppc)
916: (12)                       ],
917: (8)                    )
918: (8)                    return points[distinct_curves.repeat(nppc)]
919: (4)                def get_arc_length(self, sample_points_per_curve: int | None = None) -> float:
920: (8)                    """Return the approximated length of the whole curve.
921: (8)                    Parameters
922: (8)                    ----------
923: (8)                    sample_points_per_curve
924: (12)                       Number of sample points per curve used to approximate the length. More points result in a better approximation.
925: (8)                    Returns
926: (8)                    -------
927: (8)                    float
928: (12)                       The length of the :class:`OpenGLVMobject`.
929: (8)                    """
930: (8)                    return np.sum(
931: (12)                       length
932: (12)                       for _, length in self.get_curve_functions_with_lengths(
933: (16)                           sample_points=sample_points_per_curve,
934: (12)                       )
935: (8)                    )
936: (4)                def get_area_vector(self):
937: (8)                    # Returns a vector whose length is the area bound by
938: (8)                    # the polygon formed by the anchor points, pointing
939: (8)                    # in a direction perpendicular to the polygon according
940: (8)                    # to the right hand rule.
941: (8)                    if not self.has_points():
942: (12)                       return np.zeros(3)
943: (8)                    nppc = self.n_points_per_curve
944: (8)                    points = self.points
945: (8)                    p0 = points[0::nppc]
946: (8)                    p1 = points[nppc - 1 :: nppc]
947: (8)                    # Each term goes through all edges [(x1, y1, z1), (x2, y2, z2)]
948: (8)                    return 0.5 * np.array(
949: (12)                       [
950: (16)                           sum(
951: (20)                               (p0[:, 1] + p1[:, 1]) * (p1[:, 2] - p0[:, 2]),
952: (16)                           ),  # Add up (y1 + y2)*(z2 - z1)
953: (16)                           sum(
954: (20)                               (p0[:, 2] + p1[:, 2]) * (p1[:, 0] - p0[:, 0]),
955: (16)                           ),  # Add up (z1 + z2)*(x2 - x1)
956: (16)                           sum(
957: (20)                               (p0[:, 0] + p1[:, 0]) * (p1[:, 1] - p0[:, 1]),
958: (16)                           ),  # Add up (x1 + x2)*(y2 - y1)
959: (12)                       ],
960: (8)                    )
961: (4)                def get_direction(self):
962: (8)                    """Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.
963: (8)                    The direction of points determines in which direction the
964: (8)                    object is drawn, clockwise or counterclockwise.
965: (8)                    Examples
966: (8)                    --------
967: (8)                    The default direction of a :class:`~.Circle` is counterclockwise::
968: (12)                       >>> from manim import Circle
969: (12)                       >>> Circle().get_direction()
970: (12)                       'CCW'
971: (8)                    Returns
972: (8)                    -------
973: (8)                    :class:`str`
974: (12)                       Either ``"CW"`` or ``"CCW"``.
975: (8)                    """
976: (8)                    return shoelace_direction(self.get_start_anchors())
977: (4)                def get_unit_normal(self, recompute=False):
978: (8)                    if not recompute:
979: (12)                       return self.unit_normal[0]
980: (8)                    if len(self.points) < 3:
981: (12)                       return OUT
982: (8)                    area_vect = self.get_area_vector()
983: (8)                    area = np.linalg.norm(area_vect)
984: (8)                    if area > 0:
985: (12)                       return area_vect / area
986: (8)                    else:
987: (12)                       points = self.points
988: (12)                       return get_unit_normal(
989: (16)                           points[1] - points[0],
990: (16)                           points[2] - points[1],
991: (12)                       )
992: (4)                def refresh_unit_normal(self):
993: (8)                    for mob in self.get_family():
994: (12)                       mob.unit_normal[:] = mob.get_unit_normal(recompute=True)
995: (8)                    return self
996: (4)                # Alignment
997: (4)                def align_points(self, vmobject):
998: (8)                    # TODO: This shortcut can be a bit over eager. What if they have the same length, but different subpath lengths?
999: (8)                    if self.get_num_points() == len(vmobject.points):
1000: (12)                      return
1001: (8)                   for mob in self, vmobject:
1002: (12)                      # If there are no points, add one to
1003: (12)                      # where the "center" is
1004: (12)                      if not mob.has_points():
1005: (16)                          mob.start_new_path(mob.get_center())
1006: (12)                      # If there's only one point, turn it into
1007: (12)                      # a null curve
1008: (12)                      if mob.has_new_path_started():
1009: (16)                          mob.add_line_to(mob.points[0])
1010: (8)                   # Figure out what the subpaths are, and align
1011: (8)                   subpaths1 = self.get_subpaths()
1012: (8)                   subpaths2 = vmobject.get_subpaths()
1013: (8)                   n_subpaths = max(len(subpaths1), len(subpaths2))
1014: (8)                   # Start building new ones
1015: (8)                   new_subpaths1 = []
1016: (8)                   new_subpaths2 = []
1017: (8)                   nppc = self.n_points_per_curve
1018: (8)                   def get_nth_subpath(path_list, n):
1019: (12)                      if n >= len(path_list):
1020: (16)                          # Create a null path at the very end
1021: (16)                          return [path_list[-1][-1]] * nppc
1022: (12)                      path = path_list[n]
1023: (12)                      # Check for useless points at the end of the path and remove them
1024: (12)                      # https://github.com/ManimCommunity/manim/issues/1959
1025: (12)                      while len(path) > nppc:
1026: (16)                          # If the last nppc points are all equal to the preceding point
1027: (16)                          if self.consider_points_equals(path[-nppc:], path[-nppc - 1]):
1028: (20)                              path = path[:-nppc]
1029: (16)                          else:
1030: (20)                              break
1031: (12)                      return path
1032: (8)                   for n in range(n_subpaths):
1033: (12)                      sp1 = get_nth_subpath(subpaths1, n)
1034: (12)                      sp2 = get_nth_subpath(subpaths2, n)
1035: (12)                      diff1 = max(0, (len(sp2) - len(sp1)) // nppc)
1036: (12)                      diff2 = max(0, (len(sp1) - len(sp2)) // nppc)
1037: (12)                      sp1 = self.insert_n_curves_to_point_list(diff1, sp1)
1038: (12)                      sp2 = self.insert_n_curves_to_point_list(diff2, sp2)
1039: (12)                      new_subpaths1.append(sp1)
1040: (12)                      new_subpaths2.append(sp2)
1041: (8)                   self.set_points(np.vstack(new_subpaths1))
1042: (8)                   vmobject.set_points(np.vstack(new_subpaths2))
1043: (8)                   return self
1044: (4)               def insert_n_curves(self, n: int, recurse=True) -> OpenGLVMobject:
1045: (8)                   """Inserts n curves to the bezier curves of the vmobject.
1046: (8)                   Parameters
1047: (8)                   ----------
1048: (8)                   n
1049: (12)                      Number of curves to insert.
1050: (8)                   Returns
1051: (8)                   -------
1052: (8)                   OpenGLVMobject
1053: (12)                      for chaining.
1054: (8)                   """
1055: (8)                   for mob in self.get_family(recurse):
1056: (12)                      if mob.get_num_curves() > 0:
1057: (16)                          new_points = mob.insert_n_curves_to_point_list(n, mob.points)
1058: (16)                          # TODO, this should happen in insert_n_curves_to_point_list
1059: (16)                          if mob.has_new_path_started():
1060: (20)                              new_points = np.vstack([new_points, mob.get_last_point()])
1061: (16)                          mob.set_points(new_points)
1062: (8)                   return self
1063: (4)               def insert_n_curves_to_point_list(self, n: int, points: np.ndarray) -> np.ndarray:
1064: (8)                   """Given an array of k points defining a bezier curves
1065: (9)                    (anchors and handles), returns points defining exactly
1066: (8)                   k + n bezier curves.
1067: (8)                   Parameters
1068: (8)                   ----------
1069: (8)                   n
1070: (12)                      Number of desired curves.
1071: (8)                   points
1072: (12)                      Starting points.
1073: (8)                   Returns
1074: (8)                   -------
1075: (8)                   np.ndarray
1076: (12)                      Points generated.
1077: (8)                   """
1078: (8)                   nppc = self.n_points_per_curve
1079: (8)                   if len(points) == 1:
1080: (12)                      return np.repeat(points, nppc * n, 0)
1081: (8)                   bezier_groups = self.get_bezier_tuples_from_points(points)
1082: (8)                   norms = np.array([np.linalg.norm(bg[nppc - 1] - bg[0]) for bg in bezier_groups])
1083: (8)                   total_norm = sum(norms)
1084: (8)                   # Calculate insertions per curve (ipc)
1085: (8)                   if total_norm < 1e-6:
1086: (12)                      ipc = [n] + [0] * (len(bezier_groups) - 1)
1087: (8)                   else:
1088: (12)                      ipc = np.round(n * norms / sum(norms)).astype(int)
1089: (8)                   diff = n - sum(ipc)
1090: (8)                   for _ in range(diff):
1091: (12)                      ipc[np.argmin(ipc)] += 1
1092: (8)                   for _ in range(-diff):
1093: (12)                      ipc[np.argmax(ipc)] -= 1
1094: (8)                   new_length = sum(x + 1 for x in ipc)
1095: (8)                   new_points = np.empty((new_length, nppc, 3))
1096: (8)                   i = 0
1097: (8)                   for group, n_inserts in zip(bezier_groups, ipc):
1098: (12)                      # What was once a single quadratic curve defined
1099: (12)                      # by "group" will now be broken into n_inserts + 1
1100: (12)                      # smaller quadratic curves
1101: (12)                      alphas = np.linspace(0, 1, n_inserts + 2)
1102: (12)                      for a1, a2 in zip(alphas, alphas[1:]):
1103: (16)                          new_points[i] = partial_quadratic_bezier_points(group, a1, a2)
1104: (16)                          i = i + 1
1105: (8)                   return np.vstack(new_points)
1106: (4)               def interpolate(self, mobject1, mobject2, alpha, *args, **kwargs):
1107: (8)                   super().interpolate(mobject1, mobject2, alpha, *args, **kwargs)
1108: (8)                   if config["use_projection_fill_shaders"]:
1109: (12)                      self.refresh_triangulation()
1110: (8)                   else:
1111: (12)                      if self.has_fill():
1112: (16)                          tri1 = mobject1.get_triangulation()
1113: (16)                          tri2 = mobject2.get_triangulation()
1114: (16)                          if len(tri1) != len(tri2) or not np.all(tri1 == tri2):
1115: (20)                              self.refresh_triangulation()
1116: (8)                   return self
1117: (4)               def pointwise_become_partial(
1118: (8)                   self, vmobject: OpenGLVMobject, a: float, b: float, remap: bool = True
1119: (4)               ) -> OpenGLVMobject:
1120: (8)                   """Given two bounds a and b, transforms the points of the self vmobject into the points of the vmobject
1121: (8)                   passed as parameter with respect to the bounds. Points here stand for control points of the bezier curves (anchors and handles)
1122: (8)                   Parameters
1123: (8)                   ----------
1124: (8)                   vmobject
1125: (12)                      The vmobject that will serve as a model.
1126: (8)                   a
1127: (12)                      upper-bound.
1128: (8)                   b
1129: (12)                      lower-bound
1130: (8)                   remap
1131: (12)                      if the point amount should be kept the same (True)
1132: (12)                      This option should be manually set to False if keeping the number of points is not needed
1133: (8)                   """
1134: (8)                   assert isinstance(vmobject, OpenGLVMobject)
1135: (8)                   # Partial curve includes three portions:
1136: (8)                   # - A middle section, which matches the curve exactly
1137: (8)                   # - A start, which is some ending portion of an inner cubic
1138: (8)                   # - An end, which is the starting portion of a later inner cubic
1139: (8)                   if a <= 0 and b >= 1:
1140: (12)                      self.set_points(vmobject.points)
1141: (12)                      return self
1142: (8)                   bezier_triplets = vmobject.get_bezier_tuples()
1143: (8)                   num_quadratics = len(bezier_triplets)
1144: (8)                   # The following two lines will compute which bezier curves of the given mobject need to be processed.
1145: (8)                   # The residue basically indicates the proportion of the selected Bèzier curve.
1146: (8)                   # Ex: if lower_index is 3, and lower_residue is 0.4, then the algorithm will append to the points 0.4 of the third bezier curve
1147: (8)                   lower_index, lower_residue = integer_interpolate(0, num_quadratics, a)
1148: (8)                   upper_index, upper_residue = integer_interpolate(0, num_quadratics, b)
1149: (8)                   self.clear_points()
1150: (8)                   if num_quadratics == 0:
1151: (12)                      return self
1152: (8)                   if lower_index == upper_index:
1153: (12)                      self.append_points(
1154: (16)                          partial_quadratic_bezier_points(
1155: (20)                              bezier_triplets[lower_index],
1156: (20)                              lower_residue,
1157: (20)                              upper_residue,
1158: (16)                          ),
1159: (12)                      )
1160: (8)                   else:
1161: (12)                      self.append_points(
1162: (16)                          partial_quadratic_bezier_points(
1163: (20)                              bezier_triplets[lower_index], lower_residue, 1
1164: (16)                          ),
1165: (12)                      )
1166: (12)                      inner_points = bezier_triplets[lower_index + 1 : upper_index]
1167: (12)                      if len(inner_points) > 0:
1168: (16)                          if remap:
1169: (20)                              new_triplets = quadratic_bezier_remap(
1170: (24)                                  inner_points, num_quadratics - 2
1171: (20)                              )
1172: (16)                          else:
1173: (20)                              new_triplets = bezier_triplets
1174: (16)                          self.append_points(np.asarray(new_triplets).reshape(-1, 3))
1175: (12)                      self.append_points(
1176: (16)                          partial_quadratic_bezier_points(
1177: (20)                              bezier_triplets[upper_index], 0, upper_residue
1178: (16)                          ),
1179: (12)                      )
1180: (8)                   return self
1181: (4)               def get_subcurve(self, a: float, b: float) -> OpenGLVMobject:
1182: (8)                   """Returns the subcurve of the OpenGLVMobject between the interval [a, b].
1183: (8)                   The curve is a OpenGLVMobject itself.
1184: (8)                   Parameters
1185: (8)                   ----------
1186: (8)                   a
1187: (12)                      The lower bound.
1188: (8)                   b
1189: (12)                      The upper bound.
1190: (8)                   Returns
1191: (8)                   -------
1192: (8)                   OpenGLVMobject
1193: (12)                      The subcurve between of [a, b]
1194: (8)                   """
1195: (8)                   vmob = self.copy()
1196: (8)                   vmob.pointwise_become_partial(self, a, b)
1197: (8)                   return vmob
1198: (4)               # Related to triangulation
1199: (4)               def refresh_triangulation(self):
1200: (8)                   for mob in self.get_family():
1201: (12)                      mob.needs_new_triangulation = True
1202: (8)                   return self
1203: (4)               def get_triangulation(self, normal_vector=None):
1204: (8)                   # Figure out how to triangulate the interior to know
1205: (8)                   # how to send the points as to the vertex shader.
1206: (8)                   # First triangles come directly from the points
1207: (8)                   if normal_vector is None:
1208: (12)                      normal_vector = self.get_unit_normal()
1209: (8)                   if not self.needs_new_triangulation:
1210: (12)                      return self.triangulation
1211: (8)                   points = self.points
1212: (8)                   if len(points) <= 1:
1213: (12)                      self.triangulation = np.zeros(0, dtype="i4")
1214: (12)                      self.needs_new_triangulation = False
1215: (12)                      return self.triangulation
1216: (8)                   if not np.isclose(normal_vector, OUT).all():
1217: (12)                      # Rotate points such that unit normal vector is OUT
1218: (12)                      points = np.dot(points, z_to_vector(normal_vector))
1219: (8)                   indices = np.arange(len(points), dtype=int)
1220: (8)                   b0s = points[0::3]
1221: (8)                   b1s = points[1::3]
1222: (8)                   b2s = points[2::3]
1223: (8)                   v01s = b1s - b0s
1224: (8)                   v12s = b2s - b1s
1225: (8)                   crosses = cross2d(v01s, v12s)
1226: (8)                   convexities = np.sign(crosses)
1227: (8)                   atol = self.tolerance_for_point_equality
1228: (8)                   end_of_loop = np.zeros(len(b0s), dtype=bool)
1229: (8)                   end_of_loop[:-1] = (np.abs(b2s[:-1] - b0s[1:]) > atol).any(1)
1230: (8)                   end_of_loop[-1] = True
1231: (8)                   concave_parts = convexities < 0
1232: (8)                   # These are the vertices to which we'll apply a polygon triangulation
1233: (8)                   inner_vert_indices = np.hstack(
1234: (12)                      [
1235: (16)                          indices[0::3],
1236: (16)                          indices[1::3][concave_parts],
1237: (16)                          indices[2::3][end_of_loop],
1238: (12)                      ],
1239: (8)                   )
1240: (8)                   inner_vert_indices.sort()
1241: (8)                   rings = np.arange(1, len(inner_vert_indices) + 1)[inner_vert_indices % 3 == 2]
1242: (8)                   # Triangulate
1243: (8)                   inner_verts = points[inner_vert_indices]
1244: (8)                   inner_tri_indices = inner_vert_indices[
1245: (12)                      earclip_triangulation(inner_verts, rings)
1246: (8)                   ]
1247: (8)                   tri_indices = np.hstack([indices, inner_tri_indices])
1248: (8)                   self.triangulation = tri_indices
1249: (8)                   self.needs_new_triangulation = False
1250: (8)                   return tri_indices
1251: (4)               @triggers_refreshed_triangulation
1252: (4)               def set_points(self, points):
1253: (8)                   super().set_points(points)
1254: (8)                   return self
1255: (4)               @triggers_refreshed_triangulation
1256: (4)               def set_data(self, data):
1257: (8)                   super().set_data(data)
1258: (8)                   return self
1259: (4)               # TODO, how to be smart about tangents here?
1260: (4)               @triggers_refreshed_triangulation
1261: (4)               def apply_function(self, function, make_smooth=False, **kwargs):
1262: (8)                   super().apply_function(function, **kwargs)
1263: (8)                   if self.make_smooth_after_applying_functions or make_smooth:
1264: (12)                      self.make_approximately_smooth()
1265: (8)                   return self
1266: (4)               @triggers_refreshed_triangulation
1267: (4)               def apply_points_function(self, *args, **kwargs):
1268: (8)                   super().apply_points_function(*args, **kwargs)
1269: (8)                   return self
1270: (4)               @triggers_refreshed_triangulation
1271: (4)               def flip(self, *args, **kwargs):
1272: (8)                   super().flip(*args, **kwargs)
1273: (8)                   return self
1274: (4)               # For shaders
1275: (4)               def init_shader_data(self):
1276: (8)                   self.fill_data = np.zeros(0, dtype=self.fill_dtype)
1277: (8)                   self.stroke_data = np.zeros(0, dtype=self.stroke_dtype)
1278: (8)                   self.fill_shader_wrapper = ShaderWrapper(
1279: (12)                      vert_data=self.fill_data,
1280: (12)                      vert_indices=np.zeros(0, dtype="i4"),
1281: (12)                      shader_folder=self.fill_shader_folder,
1282: (12)                      render_primitive=self.render_primitive,
1283: (8)                   )
1284: (8)                   self.stroke_shader_wrapper = ShaderWrapper(
1285: (12)                      vert_data=self.stroke_data,
1286: (12)                      shader_folder=self.stroke_shader_folder,
1287: (12)                      render_primitive=self.render_primitive,
1288: (8)                   )
1289: (4)               def refresh_shader_wrapper_id(self):
1290: (8)                   for wrapper in [self.fill_shader_wrapper, self.stroke_shader_wrapper]:
1291: (12)                      wrapper.refresh_id()
1292: (8)                   return self
1293: (4)               def get_fill_shader_wrapper(self):
1294: (8)                   self.update_fill_shader_wrapper()
1295: (8)                   return self.fill_shader_wrapper
1296: (4)               def update_fill_shader_wrapper(self):
1297: (8)                   self.fill_shader_wrapper.vert_data = self.get_fill_shader_data()
1298: (8)                   self.fill_shader_wrapper.vert_indices = self.get_triangulation()
1299: (8)                   self.fill_shader_wrapper.uniforms = self.get_fill_uniforms()
1300: (8)                   self.fill_shader_wrapper.depth_test = self.depth_test
1301: (4)               def get_stroke_shader_wrapper(self):
1302: (8)                   self.update_stroke_shader_wrapper()
1303: (8)                   return self.stroke_shader_wrapper
1304: (4)               def update_stroke_shader_wrapper(self):
1305: (8)                   self.stroke_shader_wrapper.vert_data = self.get_stroke_shader_data()
1306: (8)                   self.stroke_shader_wrapper.uniforms = self.get_stroke_uniforms()
1307: (8)                   self.stroke_shader_wrapper.depth_test = self.depth_test
1308: (4)               def get_shader_wrapper_list(self):
1309: (8)                   # Build up data lists
1310: (8)                   fill_shader_wrappers = []
1311: (8)                   stroke_shader_wrappers = []
1312: (8)                   back_stroke_shader_wrappers = []
1313: (8)                   for submob in self.family_members_with_points():
1314: (12)                      if submob.has_fill() and not config["use_projection_fill_shaders"]:
1315: (16)                          fill_shader_wrappers.append(submob.get_fill_shader_wrapper())
1316: (12)                      if submob.has_stroke() and not config["use_projection_stroke_shaders"]:
1317: (16)                          ssw = submob.get_stroke_shader_wrapper()
1318: (16)                          if submob.draw_stroke_behind_fill:
1319: (20)                              back_stroke_shader_wrappers.append(ssw)
1320: (16)                          else:
1321: (20)                              stroke_shader_wrappers.append(ssw)
1322: (8)                   # Combine data lists
1323: (8)                   wrapper_lists = [
1324: (12)                      back_stroke_shader_wrappers,
1325: (12)                      fill_shader_wrappers,
1326: (12)                      stroke_shader_wrappers,
1327: (8)                   ]
1328: (8)                   result = []
1329: (8)                   for wlist in wrapper_lists:
1330: (12)                      if wlist:
1331: (16)                          wrapper = wlist[0]
1332: (16)                          wrapper.combine_with(*wlist[1:])
1333: (16)                          result.append(wrapper)
1334: (8)                   return result
1335: (4)               def get_stroke_uniforms(self):
1336: (8)                   result = dict(super().get_shader_uniforms())
1337: (8)                   result["joint_type"] = self.joint_type.value
1338: (8)                   result["flat_stroke"] = float(self.flat_stroke)
1339: (8)                   return result
1340: (4)               def get_fill_uniforms(self):
1341: (8)                   return {
1342: (12)                      "is_fixed_in_frame": float(self.is_fixed_in_frame),
1343: (12)                      "is_fixed_orientation": float(self.is_fixed_orientation),
1344: (12)                      "fixed_orientation_center": self.fixed_orientation_center,
1345: (12)                      "gloss": self.gloss,
1346: (12)                      "shadow": self.shadow,
1347: (8)                   }
1348: (4)               def get_stroke_shader_data(self):
1349: (8)                   points = self.points
1350: (8)                   if len(self.stroke_data) != len(points):
1351: (12)                      self.stroke_data = np.zeros(len(points), dtype=OpenGLVMobject.stroke_dtype)
1352: (8)                   if "points" not in self.locked_data_keys:
1353: (12)                      nppc = self.n_points_per_curve
1354: (12)                      self.stroke_data["point"] = points
1355: (12)                      self.stroke_data["prev_point"][:nppc] = points[-nppc:]
1356: (12)                      self.stroke_data["prev_point"][nppc:] = points[:-nppc]
1357: (12)                      self.stroke_data["next_point"][:-nppc] = points[nppc:]
1358: (12)                      self.stroke_data["next_point"][-nppc:] = points[:nppc]
1359: (8)                   self.read_data_to_shader(self.stroke_data, "color", "stroke_rgba")
1360: (8)                   self.read_data_to_shader(self.stroke_data, "stroke_width", "stroke_width")
1361: (8)                   self.read_data_to_shader(self.stroke_data, "unit_normal", "unit_normal")
1362: (8)                   return self.stroke_data
1363: (4)               def get_fill_shader_data(self):
1364: (8)                   points = self.points
1365: (8)                   if len(self.fill_data) != len(points):
1366: (12)                      self.fill_data = np.zeros(len(points), dtype=OpenGLVMobject.fill_dtype)
1367: (12)                      self.fill_data["vert_index"][:, 0] = range(len(points))
1368: (8)                   self.read_data_to_shader(self.fill_data, "point", "points")
1369: (8)                   self.read_data_to_shader(self.fill_data, "color", "fill_rgba")
1370: (8)                   self.read_data_to_shader(self.fill_data, "unit_normal", "unit_normal")
1371: (8)                   return self.fill_data
1372: (4)               def refresh_shader_data(self):
1373: (8)                   self.get_fill_shader_data()
1374: (8)                   self.get_stroke_shader_data()
1375: (4)               def get_fill_shader_vert_indices(self):
1376: (8)                   return self.get_triangulation()
1377: (0)           class OpenGLVGroup(OpenGLVMobject):
1378: (4)               """A group of vectorized mobjects.
1379: (4)               This can be used to group multiple :class:`~.OpenGLVMobject` instances together
1380: (4)               in order to scale, move, ... them together.
1381: (4)               Examples
1382: (4)               --------
1383: (4)               To add :class:`~.OpenGLVMobject`s to a :class:`~.OpenGLVGroup`, you can either use the
1384: (4)               :meth:`~.OpenGLVGroup.add` method, or use the `+` and `+=` operators. Similarly, you
1385: (4)               can subtract elements of a OpenGLVGroup via :meth:`~.OpenGLVGroup.remove` method, or
1386: (4)               `-` and `-=` operators:
1387: (4)               .. doctest::
1388: (8)                   >>> from manim import config
1389: (8)                   >>> original_renderer = config.renderer
1390: (8)                   >>> config.renderer = "opengl"
1391: (8)                   >>> from manim import Triangle, Square
1392: (8)                   >>> from manim.opengl import OpenGLVGroup
1393: (8)                   >>> config.renderer
1394: (8)                   <RendererType.OPENGL: 'opengl'>
1395: (8)                   >>> vg = OpenGLVGroup()
1396: (8)                   >>> triangle, square = Triangle(), Square()
1397: (8)                   >>> vg.add(triangle)
1398: (8)                   OpenGLVGroup(Triangle)
1399: (8)                   >>> vg + square  # a new OpenGLVGroup is constructed
1400: (8)                   OpenGLVGroup(Triangle, Square)
1401: (8)                   >>> vg  # not modified
1402: (8)                   OpenGLVGroup(Triangle)
1403: (8)                   >>> vg += square  # modifies vg
1404: (8)                   >>> vg
1405: (8)                   OpenGLVGroup(Triangle, Square)
1406: (8)                   >>> vg.remove(triangle)
1407: (8)                   OpenGLVGroup(Square)
1408: (8)                   >>> vg - square  # a new OpenGLVGroup is constructed
1409: (8)                   OpenGLVGroup()
1410: (8)                   >>> vg  # not modified
1411: (8)                   OpenGLVGroup(Square)
1412: (8)                   >>> vg -= square  # modifies vg
1413: (8)                   >>> vg
1414: (8)                   OpenGLVGroup()
1415: (8)                   >>> config.renderer = original_renderer
1416: (4)               .. manim:: ArcShapeIris
1417: (8)                   :save_last_frame:
1418: (8)                   class ArcShapeIris(Scene):
1419: (12)                      def construct(self):
1420: (16)                          colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]
1421: (16)                          radius = [1 + rad * 0.1 for rad in range(len(colors))]
1422: (16)                          circles_group = OpenGLVGroup()
1423: (16)                          # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]
1424: (16)                          circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)
1425: (36)                                              for rad, col in zip(radius, colors)])
1426: (16)                          self.add(circles_group)
1427: (4)               """
1428: (4)               def __init__(self, *vmobjects, **kwargs):
1429: (8)                   if not all(isinstance(m, OpenGLVMobject) for m in vmobjects):
1430: (12)                      raise Exception("All submobjects must be of type OpenGLVMobject")
1431: (8)                   super().__init__(**kwargs)
1432: (8)                   self.add(*vmobjects)
1433: (4)               def __repr__(self):
1434: (8)                   return (
1435: (12)                      self.__class__.__name__
1436: (12)                      + "("
1437: (12)                      + ", ".join(str(mob) for mob in self.submobjects)
1438: (12)                      + ")"
1439: (8)                   )
1440: (4)               def __str__(self):
1441: (8)                   return (
1442: (12)                      f"{self.__class__.__name__} of {len(self.submobjects)} "
1443: (12)                      f"submobject{'s' if len(self.submobjects) > 0 else ''}"
1444: (8)                   )
1445: (4)               def add(self, *vmobjects: OpenGLVMobject):
1446: (8)                   """Checks if all passed elements are an instance of OpenGLVMobject and then add them to submobjects
1447: (8)                   Parameters
1448: (8)                   ----------
1449: (8)                   vmobjects
1450: (12)                      List of OpenGLVMobject to add
1451: (8)                   Returns
1452: (8)                   -------
1453: (8)                   :class:`OpenGLVGroup`
1454: (8)                   Raises
1455: (8)                   ------
1456: (8)                   TypeError
1457: (12)                      If one element of the list is not an instance of OpenGLVMobject
1458: (8)                   Examples
1459: (8)                   --------
1460: (8)                   .. manim:: AddToOpenGLVGroup
1461: (12)                      class AddToOpenGLVGroup(Scene):
1462: (16)                          def construct(self):
1463: (20)                              circle_red = Circle(color=RED)
1464: (20)                              circle_green = Circle(color=GREEN)
1465: (20)                              circle_blue = Circle(color=BLUE)
1466: (20)                              circle_red.shift(LEFT)
1467: (20)                              circle_blue.shift(RIGHT)
1468: (20)                              gr = OpenGLVGroup(circle_red, circle_green)
1469: (20)                              gr2 = OpenGLVGroup(circle_blue) # Constructor uses add directly
1470: (20)                              self.add(gr,gr2)
1471: (20)                              self.wait()
1472: (20)                              gr += gr2 # Add group to another
1473: (20)                              self.play(
1474: (24)                                  gr.animate.shift(DOWN),
1475: (20)                              )
1476: (20)                              gr -= gr2 # Remove group
1477: (20)                              self.play( # Animate groups separately
1478: (24)                                  gr.animate.shift(LEFT),
1479: (24)                                  gr2.animate.shift(UP),
1480: (20)                              )
1481: (20)                              self.play( #Animate groups without modification
1482: (24)                                  (gr+gr2).animate.shift(RIGHT)
1483: (20)                              )
1484: (20)                              self.play( # Animate group without component
1485: (24)                                  (gr-circle_red).animate.shift(RIGHT)
1486: (20)                              )
1487: (8)                   """
1488: (8)                   if not all(isinstance(m, OpenGLVMobject) for m in vmobjects):
1489: (12)                      raise TypeError("All submobjects must be of type OpenGLVMobject")
1490: (8)                   return super().add(*vmobjects)
1491: (4)               def __add__(self, vmobject):
1492: (8)                   return OpenGLVGroup(*self.submobjects, vmobject)
1493: (4)               def __iadd__(self, vmobject):
1494: (8)                   return self.add(vmobject)
1495: (4)               def __sub__(self, vmobject):
1496: (8)                   copy = OpenGLVGroup(*self.submobjects)
1497: (8)                   copy.remove(vmobject)
1498: (8)                   return copy
1499: (4)               def __isub__(self, vmobject):
1500: (8)                   return self.remove(vmobject)
1501: (4)               def __setitem__(self, key: int, value: OpenGLVMobject | Sequence[OpenGLVMobject]):
1502: (8)                   """Override the [] operator for item assignment.
1503: (8)                   Parameters
1504: (8)                   ----------
1505: (8)                   key
1506: (12)                      The index of the submobject to be assigned
1507: (8)                   value
1508: (12)                      The vmobject value to assign to the key
1509: (8)                   Returns
1510: (8)                   -------
1511: (8)                   None
1512: (8)                   Tests
1513: (8)                   -----
1514: (8)                   .. doctest::
1515: (12)                      >>> from manim import config
1516: (12)                      >>> original_renderer = config.renderer
1517: (12)                      >>> config.renderer = "opengl"
1518: (12)                      >>> vgroup = OpenGLVGroup(OpenGLVMobject())
1519: (12)                      >>> new_obj = OpenGLVMobject()
1520: (12)                      >>> vgroup[0] = new_obj
1521: (12)                      >>> config.renderer = original_renderer
1522: (8)                   """
1523: (8)                   if not all(isinstance(m, OpenGLVMobject) for m in value):
1524: (12)                      raise TypeError("All submobjects must be of type OpenGLVMobject")
1525: (8)                   self.submobjects[key] = value
1526: (0)           class OpenGLVectorizedPoint(OpenGLPoint, OpenGLVMobject):
1527: (4)               def __init__(
1528: (8)                   self,
1529: (8)                   location=ORIGIN,
1530: (8)                   color=BLACK,
1531: (8)                   fill_opacity=0,
1532: (8)                   stroke_width=0,
1533: (8)                   artificial_width=0.01,
1534: (8)                   artificial_height=0.01,
1535: (8)                   **kwargs,
1536: (4)               ):
1537: (8)                   self.artificial_width = artificial_width
1538: (8)                   self.artificial_height = artificial_height
1539: (8)                   super().__init__(
1540: (12)                      color=color, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs
1541: (8)                   )
1542: (8)                   self.set_points(np.array([location]))
1543: (0)           class OpenGLCurvesAsSubmobjects(OpenGLVGroup):
1544: (4)               """Convert a curve's elements to submobjects.
1545: (4)               Examples
1546: (4)               --------
1547: (4)               .. manim:: LineGradientExample
1548: (8)                   :save_last_frame:
1549: (8)                   class LineGradientExample(Scene):
1550: (12)                      def construct(self):
1551: (16)                          curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)
1552: (16)                          new_curve = CurvesAsSubmobjects(curve)
1553: (16)                          new_curve.set_color_by_gradient(BLUE, RED)
1554: (16)                          self.add(new_curve.shift(UP), curve)
1555: (4)               """
1556: (4)               def __init__(self, vmobject, **kwargs):
1557: (8)                   super().__init__(**kwargs)
1558: (8)                   for tup in vmobject.get_bezier_tuples():
1559: (12)                      part = OpenGLVMobject()
1560: (12)                      part.set_points(tup)
1561: (12)                      part.match_style(vmobject)
1562: (12)                      self.add(part)
1563: (0)           class OpenGLDashedVMobject(OpenGLVMobject):
1564: (4)               """A :class:`OpenGLVMobject` composed of dashes instead of lines.
1565: (4)               Examples
1566: (4)               --------
1567: (4)               .. manim:: DashedVMobjectExample
1568: (8)                   :save_last_frame:
1569: (8)                   class DashedVMobjectExample(Scene):
1570: (12)                      def construct(self):
1571: (16)                          r = 0.5
1572: (16)                          top_row = OpenGLVGroup()  # Increasing num_dashes
1573: (16)                          for dashes in range(2, 12):
1574: (20)                              circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)
1575: (20)                              top_row.add(circ)
1576: (16)                          middle_row = OpenGLVGroup()  # Increasing dashed_ratio
1577: (16)                          for ratio in np.arange(1 / 11, 1, 1 / 11):
1578: (20)                              circ = DashedVMobject(
1579: (24)                                  Circle(radius=r, color=WHITE), dashed_ratio=ratio
1580: (20)                              )
1581: (20)                              middle_row.add(circ)
1582: (16)                          sq = DashedVMobject(Square(1.5, color=RED))
1583: (16)                          penta = DashedVMobject(RegularPolygon(5, color=BLUE))
1584: (16)                          bottom_row = OpenGLVGroup(sq, penta)
1585: (16)                          top_row.arrange(buff=0.4)
1586: (16)                          middle_row.arrange()
1587: (16)                          bottom_row.arrange(buff=1)
1588: (16)                          everything = OpenGLVGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)
1589: (16)                          self.add(everything)
1590: (4)               """
1591: (4)               def __init__(
1592: (8)                   self,
1593: (8)                   vmobject: OpenGLVMobject,
1594: (8)                   num_dashes: int = 15,
1595: (8)                   dashed_ratio: float = 0.5,
1596: (8)                   color: ParsableManimColor = WHITE,
1597: (8)                   **kwargs,
1598: (4)               ):
1599: (8)                   self.dashed_ratio = dashed_ratio
1600: (8)                   self.num_dashes = num_dashes
1601: (8)                   super().__init__(color=color, **kwargs)
1602: (8)                   r = self.dashed_ratio
1603: (8)                   n = self.num_dashes
1604: (8)                   if num_dashes > 0:
1605: (12)                      # Assuming total length is 1
1606: (12)                      dash_len = r / n
1607: (12)                      if vmobject.is_closed():
1608: (16)                          void_len = (1 - r) / n
1609: (12)                      else:
1610: (16)                          void_len = (1 - r) / (n - 1)
1611: (12)                      self.add(
1612: (16)                          *(
1613: (20)                              vmobject.get_subcurve(
1614: (24)                                  i * (dash_len + void_len),
1615: (24)                                  i * (dash_len + void_len) + dash_len,
1616: (20)                              )
1617: (20)                              for i in range(n)
1618: (16)                          )
1619: (12)                      )
1620: (8)                   # Family is already taken care of by get_subcurve
1621: (8)                   # implementation
1622: (8)                   self.match_style(vmobject, recurse=False)

----------------------------------------

File 46 - .\opengl \opengl_point_cloud_mobject.py:

1: (0)              from __future__ import annotations
2: (0)              __all__ = ["OpenGLPMobject", "OpenGLPGroup", "OpenGLPMPoint"]
3: (0)              import moderngl
4: (0)              import numpy as np
5: (0)              from manim.constants import *
6: (0)              from manim.mobject.opengl.opengl_mobject import OpenGLMobject
7: (0)              from manim.utils.bezier import interpolate
8: (0)              from manim.utils.color import BLACK, WHITE, YELLOW, color_gradient, color_to_rgba
9: (0)              from manim.utils.config_ops import _Uniforms
10: (0)             from manim.utils.iterables import resize_with_interpolation
11: (0)             __all__ = ["OpenGLPMobject", "OpenGLPGroup", "OpenGLPMPoint"]
12: (0)             class OpenGLPMobject(OpenGLMobject):
13: (4)                 shader_folder = "true_dot"
14: (4)                 # Scale for consistency with cairo units
15: (4)                 OPENGL_POINT_RADIUS_SCALE_FACTOR = 0.01
16: (4)                 shader_dtype = [
17: (8)                     ("point", np.float32, (3,)),
18: (8)                     ("color", np.float32, (4,)),
19: (4)                 ]
20: (4)                 point_radius = _Uniforms()
21: (4)                 def __init__(
22: (8)                     self, stroke_width=2.0, color=YELLOW, render_primitive=moderngl.POINTS, **kwargs
23: (4)                 ):
24: (8)                     self.stroke_width = stroke_width
25: (8)                     super().__init__(color=color, render_primitive=render_primitive, **kwargs)
26: (8)                     self.point_radius = (
27: (12)                        self.stroke_width * OpenGLPMobject.OPENGL_POINT_RADIUS_SCALE_FACTOR
28: (8)                     )
29: (4)                 def reset_points(self):
30: (8)                     self.rgbas = np.zeros((1, 4))
31: (8)                     self.points = np.zeros((0, 3))
32: (8)                     return self
33: (4)                 def get_array_attrs(self):
34: (8)                     return ["points", "rgbas"]
35: (4)                 def add_points(self, points, rgbas=None, color=None, opacity=None):
36: (8)                     """Add points.
37: (8)                     Points must be a Nx3 numpy array.
38: (8)                     Rgbas must be a Nx4 numpy array if it is not None.
39: (8)                     """
40: (8)                     if rgbas is None and color is None:
41: (12)                        color = YELLOW
42: (8)                     self.append_points(points)
43: (8)                     # rgbas array will have been resized with points
44: (8)                     if color is not None:
45: (12)                        if opacity is None:
46: (16)                            opacity = self.rgbas[-1, 3]
47: (12)                        new_rgbas = np.repeat([color_to_rgba(color, opacity)], len(points), axis=0)
48: (8)                     elif rgbas is not None:
49: (12)                        new_rgbas = rgbas
50: (8)                     elif len(rgbas) != len(points):
51: (12)                        raise ValueError("points and rgbas must have same length")
52: (8)                     self.rgbas = np.append(self.rgbas, new_rgbas, axis=0)
53: (8)                     return self
54: (4)                 def thin_out(self, factor=5):
55: (8)                     """
56: (8)                     Removes all but every nth point for n = factor
57: (8)                     """
58: (8)                     for mob in self.family_members_with_points():
59: (12)                        num_points = mob.get_num_points()
60: (12)                        def thin_func():
61: (16)                            return np.arange(0, num_points, factor)
62: (12)                        if len(mob.points) == len(mob.rgbas):
63: (16)                            mob.set_rgba_array_direct(mob.rgbas[thin_func()])
64: (12)                        mob.set_points(mob.points[thin_func()])
65: (8)                     return self
66: (4)                 def set_color_by_gradient(self, *colors):
67: (8)                     self.rgbas = np.array(
68: (12)                        list(map(color_to_rgba, color_gradient(*colors, self.get_num_points()))),
69: (8)                     )
70: (8)                     return self
71: (4)                 def set_colors_by_radial_gradient(
72: (8)                     self,
73: (8)                     center=None,
74: (8)                     radius=1,
75: (8)                     inner_color=WHITE,
76: (8)                     outer_color=BLACK,
77: (4)                 ):
78: (8)                     start_rgba, end_rgba = list(map(color_to_rgba, [inner_color, outer_color]))
79: (8)                     if center is None:
80: (12)                        center = self.get_center()
81: (8)                     for mob in self.family_members_with_points():
82: (12)                        distances = np.abs(self.points - center)
83: (12)                        alphas = np.linalg.norm(distances, axis=1) / radius
84: (12)                        mob.rgbas = np.array(
85: (16)                            np.array(
86: (20)                                [interpolate(start_rgba, end_rgba, alpha) for alpha in alphas],
87: (16)                            ),
88: (12)                        )
89: (8)                     return self
90: (4)                 def match_colors(self, pmobject):
91: (8)                     self.rgbas[:] = resize_with_interpolation(pmobject.rgbas, self.get_num_points())
92: (8)                     return self
93: (4)                 def fade_to(self, color, alpha, family=True):
94: (8)                     rgbas = interpolate(self.rgbas, color_to_rgba(color), alpha)
95: (8)                     for mob in self.submobjects:
96: (12)                        mob.fade_to(color, alpha, family)
97: (8)                     self.set_rgba_array_direct(rgbas)
98: (8)                     return self
99: (4)                 def filter_out(self, condition):
100: (8)                    for mob in self.family_members_with_points():
101: (12)                       to_keep = ~np.apply_along_axis(condition, 1, mob.points)
102: (12)                       for key in mob.data:
103: (16)                           mob.data[key] = mob.data[key][to_keep]
104: (8)                    return self
105: (4)                def sort_points(self, function=lambda p: p[0]):
106: (8)                    """
107: (8)                    function is any map from R^3 to R
108: (8)                    """
109: (8)                    for mob in self.family_members_with_points():
110: (12)                       indices = np.argsort(np.apply_along_axis(function, 1, mob.points))
111: (12)                       for key in mob.data:
112: (16)                           mob.data[key] = mob.data[key][indices]
113: (8)                    return self
114: (4)                def ingest_submobjects(self):
115: (8)                    for key in self.data:
116: (12)                       self.data[key] = np.vstack([sm.data[key] for sm in self.get_family()])
117: (8)                    return self
118: (4)                def point_from_proportion(self, alpha):
119: (8)                    index = alpha * (self.get_num_points() - 1)
120: (8)                    return self.points[int(index)]
121: (4)                def pointwise_become_partial(self, pmobject, a, b):
122: (8)                    lower_index = int(a * pmobject.get_num_points())
123: (8)                    upper_index = int(b * pmobject.get_num_points())
124: (8)                    for key in self.data:
125: (12)                       self.data[key] = pmobject.data[key][lower_index:upper_index]
126: (8)                    return self
127: (4)                def get_shader_data(self):
128: (8)                    shader_data = np.zeros(len(self.points), dtype=self.shader_dtype)
129: (8)                    self.read_data_to_shader(shader_data, "point", "points")
130: (8)                    self.read_data_to_shader(shader_data, "color", "rgbas")
131: (8)                    return shader_data
132: (4)                @staticmethod
133: (4)                def get_mobject_type_class():
134: (8)                    return OpenGLPMobject
135: (0)            class OpenGLPGroup(OpenGLPMobject):
136: (4)                def __init__(self, *pmobs, **kwargs):
137: (8)                    if not all(isinstance(m, OpenGLPMobject) for m in pmobs):
138: (12)                       raise Exception("All submobjects must be of type OpenglPMObject")
139: (8)                    super().__init__(**kwargs)
140: (8)                    self.add(*pmobs)
141: (4)                def fade_to(self, color, alpha, family=True):
142: (8)                    if family:
143: (12)                       for mob in self.submobjects:
144: (16)                           mob.fade_to(color, alpha, family)
145: (0)            class OpenGLPMPoint(OpenGLPMobject):
146: (4)                def __init__(self, location=ORIGIN, stroke_width=4.0, **kwargs):
147: (8)                    self.location = location
148: (8)                    super().__init__(stroke_width=stroke_width, **kwargs)
149: (4)                def init_points(self):
150: (8)                    self.points = np.array([self.location], dtype=np.float32)

----------------------------------------

File 47 - .\types \vectorized_mobject.py:

1: (0)              """Mobjects that use vector graphics."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "VMobject",
5: (4)                  "VGroup",
6: (4)                  "VDict",
7: (4)                  "VectorizedPoint",
8: (4)                  "CurvesAsSubmobjects",
9: (4)                  "DashedVMobject",
10: (0)             ]
11: (0)             import itertools as it
12: (0)             import sys
13: (0)             from typing import (
14: (4)                 TYPE_CHECKING,
15: (4)                 Callable,
16: (4)                 Generator,
17: (4)                 Hashable,
18: (4)                 Iterable,
19: (4)                 Literal,
20: (4)                 Mapping,
21: (4)                 Sequence,
22: (0)             )
23: (0)             import numpy as np
24: (0)             from PIL.Image import Image
25: (0)             from manim import config
26: (0)             from manim.constants import *
27: (0)             from manim.mobject.mobject import Mobject
28: (0)             from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
29: (0)             from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject
30: (0)             from manim.mobject.three_d.three_d_utils import (
31: (4)                 get_3d_vmob_gradient_start_and_end_points,
32: (0)             )
33: (0)             from manim.utils.bezier import (
34: (4)                 bezier,
35: (4)                 get_smooth_handle_points,
36: (4)                 integer_interpolate,
37: (4)                 interpolate,
38: (4)                 partial_bezier_points,
39: (4)                 proportions_along_bezier_curve_for_point,
40: (0)             )
41: (0)             from manim.utils.color import BLACK, WHITE, ManimColor, ParsableManimColor
42: (0)             from manim.utils.iterables import (
43: (4)                 make_even,
44: (4)                 resize_array,
45: (4)                 stretch_array_to_length,
46: (4)                 tuplify,
47: (0)             )
48: (0)             from manim.utils.space_ops import rotate_vector, shoelace_direction
49: (0)             if TYPE_CHECKING:
50: (4)                 import numpy.typing as npt
51: (4)                 from typing_extensions import Self
52: (4)                 from manim.typing import (
53: (8)                     BezierPoints,
54: (8)                     CubicBezierPoints,
55: (8)                     ManimFloat,
56: (8)                     MappingFunction,
57: (8)                     Point2D,
58: (8)                     Point3D,
59: (8)                     Point3D_Array,
60: (8)                     QuadraticBezierPoints,
61: (8)                     RGBA_Array_Float,
62: (8)                     Vector3D,
63: (8)                     Zeros,
64: (4)                 )
65: (0)             # TODO
66: (0)             # - Change cubic curve groups to have 4 points instead of 3
67: (0)             # - Change sub_path idea accordingly
68: (0)             # - No more mark_paths_closed, instead have the camera test
69: (0)             #   if last point in close to first point
70: (0)             # - Think about length of self.points.  Always 0 or 1 mod 4?
71: (0)             #   That's kind of weird.
72: (0)             __all__ = [
73: (4)                 "VMobject",
74: (4)                 "VGroup",
75: (4)                 "VDict",
76: (4)                 "VectorizedPoint",
77: (4)                 "CurvesAsSubmobjects",
78: (4)                 "VectorizedPoint",
79: (4)                 "DashedVMobject",
80: (0)             ]
81: (0)             class VMobject(Mobject):
82: (4)                 """A vectorized mobject.
83: (4)                 Parameters
84: (4)                 ----------
85: (4)                 background_stroke_color
86: (8)                     The purpose of background stroke is to have something
87: (8)                     that won't overlap fill, e.g.  For text against some
88: (8)                     textured background.
89: (4)                 sheen_factor
90: (8)                     When a color c is set, there will be a second color
91: (8)                     computed based on interpolating c to WHITE by with
92: (8)                     sheen_factor, and the display will gradient to this
93: (8)                     secondary color in the direction of sheen_direction.
94: (4)                 close_new_points
95: (8)                     Indicates that it will not be displayed, but
96: (8)                     that it should count in parent mobject's path
97: (4)                 tolerance_for_point_equality
98: (8)                     This is within a pixel
99: (4)                 joint_type
100: (8)                    The line joint type used to connect the curve segments
101: (8)                    of this vectorized mobject. See :class:`.LineJointType`
102: (8)                    for options.
103: (4)                """
104: (4)                sheen_factor = 0.0
105: (4)                def __init__(
106: (8)                    self,
107: (8)                    fill_color: ParsableManimColor | None = None,
108: (8)                    fill_opacity: float = 0.0,
109: (8)                    stroke_color: ParsableManimColor | None = None,
110: (8)                    stroke_opacity: float = 1.0,
111: (8)                    stroke_width: float = DEFAULT_STROKE_WIDTH,
112: (8)                    background_stroke_color: ParsableManimColor | None = BLACK,
113: (8)                    background_stroke_opacity: float = 1.0,
114: (8)                    background_stroke_width: float = 0,
115: (8)                    sheen_factor: float = 0.0,
116: (8)                    joint_type: LineJointType | None = None,
117: (8)                    sheen_direction: Vector3D = UL,
118: (8)                    close_new_points: bool = False,
119: (8)                    pre_function_handle_to_anchor_scale_factor: float = 0.01,
120: (8)                    make_smooth_after_applying_functions: bool = False,
121: (8)                    background_image: Image | str | None = None,
122: (8)                    shade_in_3d: bool = False,
123: (8)                    # TODO, do we care about accounting for varying zoom levels?
124: (8)                    tolerance_for_point_equality: float = 1e-6,
125: (8)                    n_points_per_cubic_curve: int = 4,
126: (8)                    cap_style: CapStyleType = CapStyleType.AUTO,
127: (8)                    **kwargs,
128: (4)                ):
129: (8)                    self.fill_opacity = fill_opacity
130: (8)                    self.stroke_opacity = stroke_opacity
131: (8)                    self.stroke_width = stroke_width
132: (8)                    if background_stroke_color is not None:
133: (12)                       self.background_stroke_color: ManimColor = ManimColor(
134: (16)                           background_stroke_color
135: (12)                       )
136: (8)                    self.background_stroke_opacity: float = background_stroke_opacity
137: (8)                    self.background_stroke_width: float = background_stroke_width
138: (8)                    self.sheen_factor: float = sheen_factor
139: (8)                    self.joint_type: LineJointType = (
140: (12)                       LineJointType.AUTO if joint_type is None else joint_type
141: (8)                    )
142: (8)                    self.sheen_direction: Vector3D = sheen_direction
143: (8)                    self.close_new_points: bool = close_new_points
144: (8)                    self.pre_function_handle_to_anchor_scale_factor: float = (
145: (12)                       pre_function_handle_to_anchor_scale_factor
146: (8)                    )
147: (8)                    self.make_smooth_after_applying_functions: bool = (
148: (12)                       make_smooth_after_applying_functions
149: (8)                    )
150: (8)                    self.background_image: Image | str | None = background_image
151: (8)                    self.shade_in_3d: bool = shade_in_3d
152: (8)                    self.tolerance_for_point_equality: float = tolerance_for_point_equality
153: (8)                    self.n_points_per_cubic_curve: int = n_points_per_cubic_curve
154: (8)                    self.cap_style: CapStyleType = cap_style
155: (8)                    super().__init__(**kwargs)
156: (8)                    self.submobjects: list[VMobject]
157: (8)                    # TODO: Find where color overwrites are happening and remove the color doubling
158: (8)                    # if "color" in kwargs:
159: (8)                    #     fill_color = kwargs["color"]
160: (8)                    #     stroke_color = kwargs["color"]
161: (8)                    if fill_color is not None:
162: (12)                       self.fill_color = ManimColor.parse(fill_color)
163: (8)                    if stroke_color is not None:
164: (12)                       self.stroke_color = ManimColor.parse(stroke_color)
165: (4)                # OpenGL compatibility
166: (4)                @property
167: (4)                def n_points_per_curve(self) -> int:
168: (8)                    return self.n_points_per_cubic_curve
169: (4)                def get_group_class(self) -> type[VGroup]:
170: (8)                    return VGroup
171: (4)                @staticmethod
172: (4)                def get_mobject_type_class() -> type[VMobject]:
173: (8)                    return VMobject
174: (4)                # Colors
175: (4)                def init_colors(self, propagate_colors: bool = True) -> Self:
176: (8)                    self.set_fill(
177: (12)                       color=self.fill_color,
178: (12)                       opacity=self.fill_opacity,
179: (12)                       family=propagate_colors,
180: (8)                    )
181: (8)                    self.set_stroke(
182: (12)                       color=self.stroke_color,
183: (12)                       width=self.stroke_width,
184: (12)                       opacity=self.stroke_opacity,
185: (12)                       family=propagate_colors,
186: (8)                    )
187: (8)                    self.set_background_stroke(
188: (12)                       color=self.background_stroke_color,
189: (12)                       width=self.background_stroke_width,
190: (12)                       opacity=self.background_stroke_opacity,
191: (12)                       family=propagate_colors,
192: (8)                    )
193: (8)                    self.set_sheen(
194: (12)                       factor=self.sheen_factor,
195: (12)                       direction=self.sheen_direction,
196: (12)                       family=propagate_colors,
197: (8)                    )
198: (8)                    if not propagate_colors:
199: (12)                       for submobject in self.submobjects:
200: (16)                           submobject.init_colors(propagate_colors=False)
201: (8)                    return self
202: (4)                def generate_rgbas_array(
203: (8)                    self, color: ManimColor | list[ManimColor], opacity: float | Iterable[float]
204: (4)                ) -> RGBA_Array_Float:
205: (8)                    """
206: (8)                    First arg can be either a color, or a tuple/list of colors.
207: (8)                    Likewise, opacity can either be a float, or a tuple of floats.
208: (8)                    If self.sheen_factor is not zero, and only
209: (8)                    one color was passed in, a second slightly light color
210: (8)                    will automatically be added for the gradient
211: (8)                    """
212: (8)                    colors: list[ManimColor] = [
213: (12)                       ManimColor(c) if (c is not None) else BLACK for c in tuplify(color)
214: (8)                    ]
215: (8)                    opacities: list[float] = [
216: (12)                       o if (o is not None) else 0.0 for o in tuplify(opacity)
217: (8)                    ]
218: (8)                    rgbas: npt.NDArray[RGBA_Array_Float] = np.array(
219: (12)                       [c.to_rgba_with_alpha(o) for c, o in zip(*make_even(colors, opacities))],
220: (8)                    )
221: (8)                    sheen_factor = self.get_sheen_factor()
222: (8)                    if sheen_factor != 0 and len(rgbas) == 1:
223: (12)                       light_rgbas = np.array(rgbas)
224: (12)                       light_rgbas[:, :3] += sheen_factor
225: (12)                       np.clip(light_rgbas, 0, 1, out=light_rgbas)
226: (12)                       rgbas = np.append(rgbas, light_rgbas, axis=0)
227: (8)                    return rgbas
228: (4)                def update_rgbas_array(
229: (8)                    self,
230: (8)                    array_name: str,
231: (8)                    color: ManimColor | None = None,
232: (8)                    opacity: float | None = None,
233: (4)                ) -> Self:
234: (8)                    rgbas = self.generate_rgbas_array(color, opacity)
235: (8)                    if not hasattr(self, array_name):
236: (12)                       setattr(self, array_name, rgbas)
237: (12)                       return self
238: (8)                    # Match up current rgbas array with the newly calculated
239: (8)                    # one. 99% of the time they'll be the same.
240: (8)                    curr_rgbas = getattr(self, array_name)
241: (8)                    if len(curr_rgbas) < len(rgbas):
242: (12)                       curr_rgbas = stretch_array_to_length(curr_rgbas, len(rgbas))
243: (12)                       setattr(self, array_name, curr_rgbas)
244: (8)                    elif len(rgbas) < len(curr_rgbas):
245: (12)                       rgbas = stretch_array_to_length(rgbas, len(curr_rgbas))
246: (8)                    # Only update rgb if color was not None, and only
247: (8)                    # update alpha channel if opacity was passed in
248: (8)                    if color is not None:
249: (12)                       curr_rgbas[:, :3] = rgbas[:, :3]
250: (8)                    if opacity is not None:
251: (12)                       curr_rgbas[:, 3] = rgbas[:, 3]
252: (8)                    return self
253: (4)                def set_fill(
254: (8)                    self,
255: (8)                    color: ParsableManimColor | None = None,
256: (8)                    opacity: float | None = None,
257: (8)                    family: bool = True,
258: (4)                ) -> Self:
259: (8)                    """Set the fill color and fill opacity of a :class:`VMobject`.
260: (8)                    Parameters
261: (8)                    ----------
262: (8)                    color
263: (12)                       Fill color of the :class:`VMobject`.
264: (8)                    opacity
265: (12)                       Fill opacity of the :class:`VMobject`.
266: (8)                    family
267: (12)                       If ``True``, the fill color of all submobjects is also set.
268: (8)                    Returns
269: (8)                    -------
270: (8)                    :class:`VMobject`
271: (12)                       ``self``
272: (8)                    Examples
273: (8)                    --------
274: (8)                    .. manim:: SetFill
275: (12)                       :save_last_frame:
276: (12)                       class SetFill(Scene):
277: (16)                           def construct(self):
278: (20)                               square = Square().scale(2).set_fill(WHITE,1)
279: (20)                               circle1 = Circle().set_fill(GREEN,0.8)
280: (20)                               circle2 = Circle().set_fill(YELLOW) # No fill_opacity
281: (20)                               circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)
282: (20)                               group = Group(circle1,circle2,circle3).arrange()
283: (20)                               self.add(square)
284: (20)                               self.add(group)
285: (8)                    See Also
286: (8)                    --------
287: (8)                    :meth:`~.VMobject.set_style`
288: (8)                    """
289: (8)                    if family:
290: (12)                       for submobject in self.submobjects:
291: (16)                           submobject.set_fill(color, opacity, family)
292: (8)                    self.update_rgbas_array("fill_rgbas", color, opacity)
293: (8)                    self.fill_rgbas: RGBA_Array_Float
294: (8)                    if opacity is not None:
295: (12)                       self.fill_opacity = opacity
296: (8)                    return self
297: (4)                def set_stroke(
298: (8)                    self,
299: (8)                    color: ParsableManimColor = None,
300: (8)                    width: float | None = None,
301: (8)                    opacity: float | None = None,
302: (8)                    background=False,
303: (8)                    family: bool = True,
304: (4)                ) -> Self:
305: (8)                    if family:
306: (12)                       for submobject in self.submobjects:
307: (16)                           submobject.set_stroke(color, width, opacity, background, family)
308: (8)                    if background:
309: (12)                       array_name = "background_stroke_rgbas"
310: (12)                       width_name = "background_stroke_width"
311: (12)                       opacity_name = "background_stroke_opacity"
312: (8)                    else:
313: (12)                       array_name = "stroke_rgbas"
314: (12)                       width_name = "stroke_width"
315: (12)                       opacity_name = "stroke_opacity"
316: (8)                    self.update_rgbas_array(array_name, color, opacity)
317: (8)                    if width is not None:
318: (12)                       setattr(self, width_name, width)
319: (8)                    if opacity is not None:
320: (12)                       setattr(self, opacity_name, opacity)
321: (8)                    if color is not None and background:
322: (12)                       if isinstance(color, (list, tuple)):
323: (16)                           self.background_stroke_color = ManimColor.parse(color)
324: (12)                       else:
325: (16)                           self.background_stroke_color = ManimColor(color)
326: (8)                    return self
327: (4)                def set_cap_style(self, cap_style: CapStyleType) -> Self:
328: (8)                    """
329: (8)                    Sets the cap style of the :class:`VMobject`.
330: (8)                    Parameters
331: (8)                    ----------
332: (8)                    cap_style
333: (12)                       The cap style to be set. See :class:`.CapStyleType` for options.
334: (8)                    Returns
335: (8)                    -------
336: (8)                    :class:`VMobject`
337: (12)                       ``self``
338: (8)                    Examples
339: (8)                    --------
340: (8)                    .. manim:: CapStyleExample
341: (12)                       :save_last_frame:
342: (12)                       class CapStyleExample(Scene):
343: (16)                           def construct(self):
344: (20)                               line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)
345: (20)                               line.set_cap_style(CapStyleType.ROUND)
346: (20)                               self.add(line)
347: (8)                    """
348: (8)                    self.cap_style = cap_style
349: (8)                    return self
350: (4)                def set_background_stroke(self, **kwargs) -> Self:
351: (8)                    kwargs["background"] = True
352: (8)                    self.set_stroke(**kwargs)
353: (8)                    return self
354: (4)                def set_style(
355: (8)                    self,
356: (8)                    fill_color: ParsableManimColor | None = None,
357: (8)                    fill_opacity: float | None = None,
358: (8)                    stroke_color: ParsableManimColor | None = None,
359: (8)                    stroke_width: float | None = None,
360: (8)                    stroke_opacity: float | None = None,
361: (8)                    background_stroke_color: ParsableManimColor | None = None,
362: (8)                    background_stroke_width: float | None = None,
363: (8)                    background_stroke_opacity: float | None = None,
364: (8)                    sheen_factor: float | None = None,
365: (8)                    sheen_direction: Vector3D | None = None,
366: (8)                    background_image: Image | str | None = None,
367: (8)                    family: bool = True,
368: (4)                ) -> Self:
369: (8)                    self.set_fill(color=fill_color, opacity=fill_opacity, family=family)
370: (8)                    self.set_stroke(
371: (12)                       color=stroke_color,
372: (12)                       width=stroke_width,
373: (12)                       opacity=stroke_opacity,
374: (12)                       family=family,
375: (8)                    )
376: (8)                    self.set_background_stroke(
377: (12)                       color=background_stroke_color,
378: (12)                       width=background_stroke_width,
379: (12)                       opacity=background_stroke_opacity,
380: (12)                       family=family,
381: (8)                    )
382: (8)                    if sheen_factor:
383: (12)                       self.set_sheen(
384: (16)                           factor=sheen_factor,
385: (16)                           direction=sheen_direction,
386: (16)                           family=family,
387: (12)                       )
388: (8)                    if background_image:
389: (12)                       self.color_using_background_image(background_image)
390: (8)                    return self
391: (4)                def get_style(self, simple: bool = False) -> dict:
392: (8)                    ret = {
393: (12)                       "stroke_opacity": self.get_stroke_opacity(),
394: (12)                       "stroke_width": self.get_stroke_width(),
395: (8)                    }
396: (8)                    # TODO: FIX COLORS HERE
397: (8)                    if simple:
398: (12)                       ret["fill_color"] = self.get_fill_color()
399: (12)                       ret["fill_opacity"] = self.get_fill_opacity()
400: (12)                       ret["stroke_color"] = self.get_stroke_color()
401: (8)                    else:
402: (12)                       ret["fill_color"] = self.get_fill_colors()
403: (12)                       ret["fill_opacity"] = self.get_fill_opacities()
404: (12)                       ret["stroke_color"] = self.get_stroke_colors()
405: (12)                       ret["background_stroke_color"] = self.get_stroke_colors(background=True)
406: (12)                       ret["background_stroke_width"] = self.get_stroke_width(background=True)
407: (12)                       ret["background_stroke_opacity"] = self.get_stroke_opacity(background=True)
408: (12)                       ret["sheen_factor"] = self.get_sheen_factor()
409: (12)                       ret["sheen_direction"] = self.get_sheen_direction()
410: (12)                       ret["background_image"] = self.get_background_image()
411: (8)                    return ret
412: (4)                def match_style(self, vmobject: VMobject, family: bool = True) -> Self:
413: (8)                    self.set_style(**vmobject.get_style(), family=False)
414: (8)                    if family:
415: (12)                       # Does its best to match up submobject lists, and
416: (12)                       # match styles accordingly
417: (12)                       submobs1, submobs2 = self.submobjects, vmobject.submobjects
418: (12)                       if len(submobs1) == 0:
419: (16)                           return self
420: (12)                       elif len(submobs2) == 0:
421: (16)                           submobs2 = [vmobject]
422: (12)                       for sm1, sm2 in zip(*make_even(submobs1, submobs2)):
423: (16)                           sm1.match_style(sm2)
424: (8)                    return self
425: (4)                def set_color(self, color: ParsableManimColor, family: bool = True) -> Self:
426: (8)                    self.set_fill(color, family=family)
427: (8)                    self.set_stroke(color, family=family)
428: (8)                    return self
429: (4)                def set_opacity(self, opacity: float, family: bool = True) -> Self:
430: (8)                    self.set_fill(opacity=opacity, family=family)
431: (8)                    self.set_stroke(opacity=opacity, family=family)
432: (8)                    self.set_stroke(opacity=opacity, family=family, background=True)
433: (8)                    return self
434: (4)                def fade(self, darkness: float = 0.5, family: bool = True) -> Self:
435: (8)                    factor = 1.0 - darkness
436: (8)                    self.set_fill(opacity=factor * self.get_fill_opacity(), family=False)
437: (8)                    self.set_stroke(opacity=factor * self.get_stroke_opacity(), family=False)
438: (8)                    self.set_background_stroke(
439: (12)                       opacity=factor * self.get_stroke_opacity(background=True),
440: (12)                       family=False,
441: (8)                    )
442: (8)                    super().fade(darkness, family)
443: (8)                    return self
444: (4)                def get_fill_rgbas(self) -> RGBA_Array_Float | Zeros:
445: (8)                    try:
446: (12)                       return self.fill_rgbas
447: (8)                    except AttributeError:
448: (12)                       return np.zeros((1, 4))
449: (4)                def get_fill_color(self) -> ManimColor:
450: (8)                    """
451: (8)                    If there are multiple colors (for gradient)
452: (8)                    this returns the first one
453: (8)                    """
454: (8)                    return self.get_fill_colors()[0]
455: (4)                fill_color = property(get_fill_color, set_fill)
456: (4)                def get_fill_opacity(self) -> ManimFloat:
457: (8)                    """
458: (8)                    If there are multiple opacities, this returns the
459: (8)                    first
460: (8)                    """
461: (8)                    return self.get_fill_opacities()[0]
462: (4)                # TODO: Does this just do a copy?
463: (4)                # TODO: I have the feeling that this function should not return None, does that have any usage ?
464: (4)                def get_fill_colors(self) -> list[ManimColor | None]:
465: (8)                    return [
466: (12)                       ManimColor(rgba[:3]) if rgba.any() else None
467: (12)                       for rgba in self.get_fill_rgbas()
468: (8)                    ]
469: (4)                def get_fill_opacities(self) -> npt.NDArray[ManimFloat]:
470: (8)                    return self.get_fill_rgbas()[:, 3]
471: (4)                def get_stroke_rgbas(self, background: bool = False) -> RGBA_Array_float | Zeros:
472: (8)                    try:
473: (12)                       if background:
474: (16)                           self.background_stroke_rgbas: RGBA_Array_Float
475: (16)                           rgbas = self.background_stroke_rgbas
476: (12)                       else:
477: (16)                           self.stroke_rgbas: RGBA_Array_Float
478: (16)                           rgbas = self.stroke_rgbas
479: (12)                       return rgbas
480: (8)                    except AttributeError:
481: (12)                       return np.zeros((1, 4))
482: (4)                def get_stroke_color(self, background: bool = False) -> ManimColor | None:
483: (8)                    return self.get_stroke_colors(background)[0]
484: (4)                stroke_color = property(get_stroke_color, set_stroke)
485: (4)                def get_stroke_width(self, background: bool = False) -> float:
486: (8)                    if background:
487: (12)                       self.background_stroke_width: float
488: (12)                       width = self.background_stroke_width
489: (8)                    else:
490: (12)                       width = self.stroke_width
491: (12)                       if isinstance(width, str):
492: (16)                           width = int(width)
493: (8)                    return max(0.0, width)
494: (4)                def get_stroke_opacity(self, background: bool = False) -> ManimFloat:
495: (8)                    return self.get_stroke_opacities(background)[0]
496: (4)                def get_stroke_colors(self, background: bool = False) -> list[ManimColor | None]:
497: (8)                    return [
498: (12)                       ManimColor(rgba[:3]) if rgba.any() else None
499: (12)                       for rgba in self.get_stroke_rgbas(background)
500: (8)                    ]
501: (4)                def get_stroke_opacities(self, background: bool = False) -> npt.NDArray[ManimFloat]:
502: (8)                    return self.get_stroke_rgbas(background)[:, 3]
503: (4)                def get_color(self) -> ManimColor:
504: (8)                    if np.all(self.get_fill_opacities() == 0):
505: (12)                       return self.get_stroke_color()
506: (8)                    return self.get_fill_color()
507: (4)                color = property(get_color, set_color)
508: (4)                def set_sheen_direction(self, direction: Vector3D, family: bool = True) -> Self:
509: (8)                    """Sets the direction of the applied sheen.
510: (8)                    Parameters
511: (8)                    ----------
512: (8)                    direction
513: (12)                       Direction from where the gradient is applied.
514: (8)                    Examples
515: (8)                    --------
516: (8)                    Normal usage::
517: (12)                       Circle().set_sheen_direction(UP)
518: (8)                    See Also
519: (8)                    --------
520: (8)                    :meth:`~.VMobject.set_sheen`
521: (8)                    :meth:`~.VMobject.rotate_sheen_direction`
522: (8)                    """
523: (8)                    direction = np.array(direction)
524: (8)                    if family:
525: (12)                       for submob in self.get_family():
526: (16)                           submob.sheen_direction = direction
527: (8)                    else:
528: (12)                       self.sheen_direction: Vector3D = direction
529: (8)                    return self
530: (4)                def rotate_sheen_direction(
531: (8)                    self, angle: float, axis: Vector3D = OUT, family: bool = True
532: (4)                ) -> Self:
533: (8)                    """Rotates the direction of the applied sheen.
534: (8)                    Parameters
535: (8)                    ----------
536: (8)                    angle
537: (12)                       Angle by which the direction of sheen is rotated.
538: (8)                    axis
539: (12)                       Axis of rotation.
540: (8)                    Examples
541: (8)                    --------
542: (8)                    Normal usage::
543: (12)                       Circle().set_sheen_direction(UP).rotate_sheen_direction(PI)
544: (8)                    See Also
545: (8)                    --------
546: (8)                    :meth:`~.VMobject.set_sheen_direction`
547: (8)                    """
548: (8)                    if family:
549: (12)                       for submob in self.get_family():
550: (16)                           submob.sheen_direction = rotate_vector(
551: (20)                               submob.sheen_direction,
552: (20)                               angle,
553: (20)                               axis,
554: (16)                           )
555: (8)                    else:
556: (12)                       self.sheen_direction = rotate_vector(self.sheen_direction, angle, axis)
557: (8)                    return self
558: (4)                def set_sheen(
559: (8)                    self, factor: float, direction: Vector3D | None = None, family: bool = True
560: (4)                ) -> Self:
561: (8)                    """Applies a color gradient from a direction.
562: (8)                    Parameters
563: (8)                    ----------
564: (8)                    factor
565: (12)                       The extent of lustre/gradient to apply. If negative, the gradient
566: (12)                       starts from black, if positive the gradient starts from white and
567: (12)                       changes to the current color.
568: (8)                    direction
569: (12)                       Direction from where the gradient is applied.
570: (8)                    Examples
571: (8)                    --------
572: (8)                    .. manim:: SetSheen
573: (12)                       :save_last_frame:
574: (12)                       class SetSheen(Scene):
575: (16)                           def construct(self):
576: (20)                               circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)
577: (20)                               self.add(circle)
578: (8)                    """
579: (8)                    if family:
580: (12)                       for submob in self.submobjects:
581: (16)                           submob.set_sheen(factor, direction, family)
582: (8)                    self.sheen_factor: float = factor
583: (8)                    if direction is not None:
584: (12)                       # family set to false because recursion will
585: (12)                       # already be handled above
586: (12)                       self.set_sheen_direction(direction, family=False)
587: (8)                    # Reset color to put sheen_factor into effect
588: (8)                    if factor != 0:
589: (12)                       self.set_stroke(self.get_stroke_color(), family=family)
590: (12)                       self.set_fill(self.get_fill_color(), family=family)
591: (8)                    return self
592: (4)                def get_sheen_direction(self) -> Vector3D:
593: (8)                    return np.array(self.sheen_direction)
594: (4)                def get_sheen_factor(self) -> float:
595: (8)                    return self.sheen_factor
596: (4)                def get_gradient_start_and_end_points(self) -> tuple[Point3D, Point3D]:
597: (8)                    if self.shade_in_3d:
598: (12)                       return get_3d_vmob_gradient_start_and_end_points(self)
599: (8)                    else:
600: (12)                       direction = self.get_sheen_direction()
601: (12)                       c = self.get_center()
602: (12)                       bases = np.array(
603: (16)                           [self.get_edge_center(vect) - c for vect in [RIGHT, UP, OUT]],
604: (12)                       ).transpose()
605: (12)                       offset = np.dot(bases, direction)
606: (12)                       return (c - offset, c + offset)
607: (4)                def color_using_background_image(self, background_image: Image | str) -> Self:
608: (8)                    self.background_image: Image | str = background_image
609: (8)                    self.set_color(WHITE)
610: (8)                    for submob in self.submobjects:
611: (12)                       submob.color_using_background_image(background_image)
612: (8)                    return self
613: (4)                def get_background_image(self) -> Image | str:
614: (8)                    return self.background_image
615: (4)                def match_background_image(self, vmobject: VMobject) -> Self:
616: (8)                    self.color_using_background_image(vmobject.get_background_image())
617: (8)                    return self
618: (4)                def set_shade_in_3d(
619: (8)                    self, value: bool = True, z_index_as_group: bool = False
620: (4)                ) -> Self:
621: (8)                    for submob in self.get_family():
622: (12)                       submob.shade_in_3d = value
623: (12)                       if z_index_as_group:
624: (16)                           submob.z_index_group = self
625: (8)                    return self
626: (4)                def set_points(self, points: Point3D_Array) -> Self:
627: (8)                    self.points: Point3D_Array = np.array(points)
628: (8)                    return self
629: (4)                def resize_points(
630: (8)                    self,
631: (8)                    new_length: int,
632: (8)                    resize_func: Callable[[Point3D, int], Point3D] = resize_array,
633: (4)                ) -> Self:
634: (8)                    """Resize the array of anchor points and handles to have
635: (8)                    the specified size.
636: (8)                    Parameters
637: (8)                    ----------
638: (8)                    new_length
639: (12)                       The new (total) number of points.
640: (8)                    resize_func
641: (12)                       A function mapping a Numpy array (the points) and an integer
642: (12)                       (the target size) to a Numpy array. The default implementation
643: (12)                       is based on Numpy's ``resize`` function.
644: (8)                    """
645: (8)                    if new_length != len(self.points):
646: (12)                       self.points = resize_func(self.points, new_length)
647: (8)                    return self
648: (4)                def set_anchors_and_handles(
649: (8)                    self,
650: (8)                    anchors1: CubicBezierPoints,
651: (8)                    handles1: CubicBezierPoints,
652: (8)                    handles2: CubicBezierPoints,
653: (8)                    anchors2: CubicBezierPoints,
654: (4)                ) -> Self:
655: (8)                    """Given two sets of anchors and handles, process them to set them as anchors
656: (8)                    and handles of the VMobject.
657: (8)                    anchors1[i], handles1[i], handles2[i] and anchors2[i] define the i-th bezier
658: (8)                    curve of the vmobject. There are four hardcoded parameters and this is a
659: (8)                    problem as it makes the number of points per cubic curve unchangeable from 4
660: (8)                    (two anchors and two handles).
661: (8)                    Returns
662: (8)                    -------
663: (8)                    :class:`VMobject`
664: (12)                       ``self``
665: (8)                    """
666: (8)                    assert len(anchors1) == len(handles1) == len(handles2) == len(anchors2)
667: (8)                    nppcc = self.n_points_per_cubic_curve  # 4
668: (8)                    total_len = nppcc * len(anchors1)
669: (8)                    self.points = np.zeros((total_len, self.dim))
670: (8)                    # the following will, from the four sets, dispatch them in points such that
671: (8)                    # self.points = [
672: (8)                    #     anchors1[0], handles1[0], handles2[0], anchors1[0], anchors1[1],
673: (8)                    #     handles1[1], ...
674: (8)                    # ]
675: (8)                    arrays = [anchors1, handles1, handles2, anchors2]
676: (8)                    for index, array in enumerate(arrays):
677: (12)                       self.points[index::nppcc] = array
678: (8)                    return self
679: (4)                def clear_points(self) -> None:
680: (8)                    self.points = np.zeros((0, self.dim))
681: (4)                def append_points(self, new_points: Point3D_Array) -> Self:
682: (8)                    # TODO, check that number new points is a multiple of 4?
683: (8)                    # or else that if len(self.points) % 4 == 1, then
684: (8)                    # len(new_points) % 4 == 3?
685: (8)                    self.points = np.append(self.points, new_points, axis=0)
686: (8)                    return self
687: (4)                def start_new_path(self, point: Point3D) -> Self:
688: (8)                    if len(self.points) % 4 != 0:
689: (12)                       # close the open path by appending the last
690: (12)                       # start anchor sufficiently often
691: (12)                       last_anchor = self.get_start_anchors()[-1]
692: (12)                       for _ in range(4 - (len(self.points) % 4)):
693: (16)                           self.append_points([last_anchor])
694: (8)                    self.append_points([point])
695: (8)                    return self
696: (4)                def add_cubic_bezier_curve(
697: (8)                    self,
698: (8)                    anchor1: CubicBezierPoints,
699: (8)                    handle1: CubicBezierPoints,
700: (8)                    handle2: CubicBezierPoints,
701: (8)                    anchor2: CubicBezierPoints,
702: (4)                ) -> None:
703: (8)                    # TODO, check the len(self.points) % 4 == 0?
704: (8)                    self.append_points([anchor1, handle1, handle2, anchor2])
705: (4)                # what type is curves?
706: (4)                def add_cubic_bezier_curves(self, curves) -> None:
707: (8)                    self.append_points(curves.flatten())
708: (4)                def add_cubic_bezier_curve_to(
709: (8)                    self,
710: (8)                    handle1: CubicBezierPoints,
711: (8)                    handle2: CubicBezierPoints,
712: (8)                    anchor: CubicBezierPoints,
713: (4)                ) -> Self:
714: (8)                    """Add cubic bezier curve to the path.
715: (8)                    NOTE : the first anchor is not a parameter as by default the end of the last sub-path!
716: (8)                    Parameters
717: (8)                    ----------
718: (8)                    handle1
719: (12)                       first handle
720: (8)                    handle2
721: (12)                       second handle
722: (8)                    anchor
723: (12)                       anchor
724: (8)                    Returns
725: (8)                    -------
726: (8)                    :class:`VMobject`
727: (12)                       ``self``
728: (8)                    """
729: (8)                    self.throw_error_if_no_points()
730: (8)                    new_points = [handle1, handle2, anchor]
731: (8)                    if self.has_new_path_started():
732: (12)                       self.append_points(new_points)
733: (8)                    else:
734: (12)                       self.append_points([self.get_last_point()] + new_points)
735: (8)                    return self
736: (4)                def add_quadratic_bezier_curve_to(
737: (8)                    self,
738: (8)                    handle: QuadraticBezierPoints,
739: (8)                    anchor: QuadraticBezierPoints,
740: (4)                ) -> Self:
741: (8)                    """Add Quadratic bezier curve to the path.
742: (8)                    Returns
743: (8)                    -------
744: (8)                    :class:`VMobject`
745: (12)                       ``self``
746: (8)                    """
747: (8)                    # How does one approximate a quadratic with a cubic?
748: (8)                    # refer to the Wikipedia page on Bezier curves
749: (8)                    # https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Degree_elevation, accessed Jan 20, 2021
750: (8)                    # 1. Copy the end points, and then
751: (8)                    # 2. Place the 2 middle control points 2/3 along the line segments
752: (8)                    # from the end points to the quadratic curve's middle control point.
753: (8)                    # I think that's beautiful.
754: (8)                    self.add_cubic_bezier_curve_to(
755: (12)                       2 / 3 * handle + 1 / 3 * self.get_last_point(),
756: (12)                       2 / 3 * handle + 1 / 3 * anchor,
757: (12)                       anchor,
758: (8)                    )
759: (8)                    return self
760: (4)                def add_line_to(self, point: Point3D) -> Self:
761: (8)                    """Add a straight line from the last point of VMobject to the given point.
762: (8)                    Parameters
763: (8)                    ----------
764: (8)                    point
765: (12)                       end of the straight line.
766: (8)                    Returns
767: (8)                    -------
768: (8)                    :class:`VMobject`
769: (12)                       ``self``
770: (8)                    """
771: (8)                    nppcc = self.n_points_per_cubic_curve
772: (8)                    self.add_cubic_bezier_curve_to(
773: (12)                       *(
774: (16)                           interpolate(self.get_last_point(), point, a)
775: (16)                           for a in np.linspace(0, 1, nppcc)[1:]
776: (12)                       )
777: (8)                    )
778: (8)                    return self
779: (4)                def add_smooth_curve_to(self, *points: Point3D) -> Self:
780: (8)                    """Creates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted
781: (8)                    as a handle, the second as an anchor.
782: (8)                    Parameters
783: (8)                    ----------
784: (8)                    points
785: (12)                       Points (anchor and handle, or just anchor) to add a smooth curve from
786: (8)                    Returns
787: (8)                    -------
788: (8)                    :class:`VMobject`
789: (12)                       ``self``
790: (8)                    Raises
791: (8)                    ------
792: (8)                    ValueError
793: (12)                       If 0 or more than 2 points are given.
794: (8)                    """
795: (8)                    # TODO remove the value error and just add two parameters with one optional
796: (8)                    if len(points) == 1:
797: (12)                       handle2 = None
798: (12)                       new_anchor = points[0]
799: (8)                    elif len(points) == 2:
800: (12)                       handle2, new_anchor = points
801: (8)                    else:
802: (12)                       name = sys._getframe(0).f_code.co_name
803: (12)                       raise ValueError(f"Only call {name} with 1 or 2 points")
804: (8)                    if self.has_new_path_started():
805: (12)                       self.add_line_to(new_anchor)
806: (8)                    else:
807: (12)                       self.throw_error_if_no_points()
808: (12)                       last_h2, last_a2 = self.points[-2:]
809: (12)                       last_tangent = last_a2 - last_h2
810: (12)                       handle1 = last_a2 + last_tangent
811: (12)                       if handle2 is None:
812: (16)                           to_anchor_vect = new_anchor - last_a2
813: (16)                           new_tangent = rotate_vector(last_tangent, PI, axis=to_anchor_vect)
814: (16)                           handle2 = new_anchor - new_tangent
815: (12)                       self.append_points([last_a2, handle1, handle2, new_anchor])
816: (8)                    return self
817: (4)                def has_new_path_started(self) -> bool:
818: (8)                    nppcc = self.n_points_per_cubic_curve  # 4
819: (8)                    # A new path starting is defined by a control point which is not part of a bezier subcurve.
820: (8)                    return len(self.points) % nppcc == 1
821: (4)                def get_last_point(self) -> Point3D:
822: (8)                    return self.points[-1]
823: (4)                def is_closed(self) -> bool:
824: (8)                    # TODO use consider_points_equals_2d ?
825: (8)                    return self.consider_points_equals(self.points[0], self.points[-1])
826: (4)                def close_path(self) -> None:
827: (8)                    if not self.is_closed():
828: (12)                       self.add_line_to(self.get_subpaths()[-1][0])
829: (4)                def add_points_as_corners(self, points: Iterable[Point3D]) -> Iterable[Point3D]:
830: (8)                    for point in points:
831: (12)                       self.add_line_to(point)
832: (8)                    return points
833: (4)                def set_points_as_corners(self, points: Point3D_Array) -> Self:
834: (8)                    """Given an array of points, set them as corner of the vmobject.
835: (8)                    To achieve that, this algorithm sets handles aligned with the anchors such that the resultant bezier curve will be the segment
836: (8)                    between the two anchors.
837: (8)                    Parameters
838: (8)                    ----------
839: (8)                    points
840: (12)                       Array of points that will be set as corners.
841: (8)                    Returns
842: (8)                    -------
843: (8)                    :class:`VMobject`
844: (12)                       ``self``
845: (8)                    Examples
846: (8)                    --------
847: (8)                    .. manim:: PointsAsCornersExample
848: (12)                       :save_last_frame:
849: (12)                       class PointsAsCornersExample(Scene):
850: (16)                           def construct(self):
851: (20)                               corners = (
852: (24)                                   # create square
853: (24)                                   UR, UL,
854: (24)                                   DL, DR,
855: (24)                                   UR,
856: (24)                                   # create crosses
857: (24)                                   DL, UL,
858: (24)                                   DR
859: (20)                               )
860: (20)                               vmob = VMobject(stroke_color=RED)
861: (20)                               vmob.set_points_as_corners(corners).scale(2)
862: (20)                               self.add(vmob)
863: (8)                    """
864: (8)                    nppcc = self.n_points_per_cubic_curve
865: (8)                    points = np.array(points)
866: (8)                    # This will set the handles aligned with the anchors.
867: (8)                    # Id est, a bezier curve will be the segment from the two anchors such that the handles belongs to this segment.
868: (8)                    self.set_anchors_and_handles(
869: (12)                       *(interpolate(points[:-1], points[1:], a) for a in np.linspace(0, 1, nppcc))
870: (8)                    )
871: (8)                    return self
872: (4)                def set_points_smoothly(self, points: Point3D_Array) -> Self:
873: (8)                    self.set_points_as_corners(points)
874: (8)                    self.make_smooth()
875: (8)                    return self
876: (4)                def change_anchor_mode(self, mode: Literal["jagged", "smooth"]) -> Self:
877: (8)                    """Changes the anchor mode of the bezier curves. This will modify the handles.
878: (8)                    There can be only two modes, "jagged", and "smooth".
879: (8)                    Returns
880: (8)                    -------
881: (8)                    :class:`VMobject`
882: (12)                       ``self``
883: (8)                    """
884: (8)                    assert mode in ["jagged", "smooth"], 'mode must be either "jagged" or "smooth"'
885: (8)                    nppcc = self.n_points_per_cubic_curve
886: (8)                    for submob in self.family_members_with_points():
887: (12)                       subpaths = submob.get_subpaths()
888: (12)                       submob.clear_points()
889: (12)                       # A subpath can be composed of several bezier curves.
890: (12)                       for subpath in subpaths:
891: (16)                           # This will retrieve the anchors of the subpath, by selecting every n element in the array subpath
892: (16)                           # The append is needed as the last element is not reached when slicing with numpy.
893: (16)                           anchors = np.append(subpath[::nppcc], subpath[-1:], 0)
894: (16)                           if mode == "smooth":
895: (20)                               h1, h2 = get_smooth_handle_points(anchors)
896: (16)                           else:  # mode == "jagged"
897: (20)                               # The following will make the handles aligned with the anchors, thus making the bezier curve a segment
898: (20)                               a1 = anchors[:-1]
899: (20)                               a2 = anchors[1:]
900: (20)                               h1 = interpolate(a1, a2, 1.0 / 3)
901: (20)                               h2 = interpolate(a1, a2, 2.0 / 3)
902: (16)                           new_subpath = np.array(subpath)
903: (16)                           new_subpath[1::nppcc] = h1
904: (16)                           new_subpath[2::nppcc] = h2
905: (16)                           submob.append_points(new_subpath)
906: (8)                    return self
907: (4)                def make_smooth(self) -> Self:
908: (8)                    return self.change_anchor_mode("smooth")
909: (4)                def make_jagged(self) -> Self:
910: (8)                    return self.change_anchor_mode("jagged")
911: (4)                def add_subpath(self, points: Point3D_Array) -> Self:
912: (8)                    assert len(points) % 4 == 0
913: (8)                    self.points: Point3D_Array = np.append(self.points, points, axis=0)
914: (8)                    return self
915: (4)                def append_vectorized_mobject(self, vectorized_mobject: VMobject) -> None:
916: (8)                    new_points = list(vectorized_mobject.points)
917: (8)                    if self.has_new_path_started():
918: (12)                       # Remove last point, which is starting
919: (12)                       # a new path
920: (12)                       self.points = self.points[:-1]
921: (8)                    self.append_points(new_points)
922: (4)                def apply_function(self, function: MappingFunction) -> Self:
923: (8)                    factor = self.pre_function_handle_to_anchor_scale_factor
924: (8)                    self.scale_handle_to_anchor_distances(factor)
925: (8)                    super().apply_function(function)
926: (8)                    self.scale_handle_to_anchor_distances(1.0 / factor)
927: (8)                    if self.make_smooth_after_applying_functions:
928: (12)                       self.make_smooth()
929: (8)                    return self
930: (4)                def rotate(
931: (8)                    self,
932: (8)                    angle: float,
933: (8)                    axis: Vector3D = OUT,
934: (8)                    about_point: Point3D | None = None,
935: (8)                    **kwargs,
936: (4)                ) -> Self:
937: (8)                    self.rotate_sheen_direction(angle, axis)
938: (8)                    super().rotate(angle, axis, about_point, **kwargs)
939: (8)                    return self
940: (4)                def scale_handle_to_anchor_distances(self, factor: float) -> Self:
941: (8)                    """If the distance between a given handle point H and its associated
942: (8)                    anchor point A is d, then it changes H to be a distances factor*d
943: (8)                    away from A, but so that the line from A to H doesn't change.
944: (8)                    This is mostly useful in the context of applying a (differentiable)
945: (8)                    function, to preserve tangency properties.  One would pull all the
946: (8)                    handles closer to their anchors, apply the function then push them out
947: (8)                    again.
948: (8)                    Parameters
949: (8)                    ----------
950: (8)                    factor
951: (12)                       The factor used for scaling.
952: (8)                    Returns
953: (8)                    -------
954: (8)                    :class:`VMobject`
955: (12)                       ``self``
956: (8)                    """
957: (8)                    for submob in self.family_members_with_points():
958: (12)                       if len(submob.points) < self.n_points_per_cubic_curve:
959: (16)                           # The case that a bezier quad is not complete (there is no bezier curve as there is not enough control points.)
960: (16)                           continue
961: (12)                       a1, h1, h2, a2 = submob.get_anchors_and_handles()
962: (12)                       a1_to_h1 = h1 - a1
963: (12)                       a2_to_h2 = h2 - a2
964: (12)                       new_h1 = a1 + factor * a1_to_h1
965: (12)                       new_h2 = a2 + factor * a2_to_h2
966: (12)                       submob.set_anchors_and_handles(a1, new_h1, new_h2, a2)
967: (8)                    return self
968: (4)                #
969: (4)                def consider_points_equals(self, p0: Point3D, p1: Point3D) -> bool:
970: (8)                    return np.allclose(p0, p1, atol=self.tolerance_for_point_equality)
971: (4)                def consider_points_equals_2d(self, p0: Point2D, p1: Point2D) -> bool:
972: (8)                    """Determine if two points are close enough to be considered equal.
973: (8)                    This uses the algorithm from np.isclose(), but expanded here for the
974: (8)                    2D point case. NumPy is overkill for such a small question.
975: (8)                    Parameters
976: (8)                    ----------
977: (8)                    p0
978: (12)                       first point
979: (8)                    p1
980: (12)                       second point
981: (8)                    Returns
982: (8)                    -------
983: (8)                    bool
984: (12)                       whether two points considered close.
985: (8)                    """
986: (8)                    rtol = 1.0e-5  # default from np.isclose()
987: (8)                    atol = self.tolerance_for_point_equality
988: (8)                    if abs(p0[0] - p1[0]) > atol + rtol * abs(p1[0]):
989: (12)                       return False
990: (8)                    if abs(p0[1] - p1[1]) > atol + rtol * abs(p1[1]):
991: (12)                       return False
992: (8)                    return True
993: (4)                # Information about line
994: (4)                def get_cubic_bezier_tuples_from_points(
995: (8)                    self, points: Point3D_Array
996: (4)                ) -> npt.NDArray[Point3D_Array]:
997: (8)                    return np.array(self.gen_cubic_bezier_tuples_from_points(points))
998: (4)                def gen_cubic_bezier_tuples_from_points(
999: (8)                    self, points: Point3D_Array
1000: (4)               ) -> tuple[Point3D_Array]:
1001: (8)                   """Returns the bezier tuples from an array of points.
1002: (8)                   self.points is a list of the anchors and handles of the bezier curves of the mobject (ie [anchor1, handle1, handle2, anchor2, anchor3 ..])
1003: (8)                   This algorithm basically retrieve them by taking an element every n, where n is the number of control points
1004: (8)                   of the bezier curve.
1005: (8)                   Parameters
1006: (8)                   ----------
1007: (8)                   points
1008: (12)                      Points from which control points will be extracted.
1009: (8)                   Returns
1010: (8)                   -------
1011: (8)                   tuple
1012: (12)                      Bezier control points.
1013: (8)                   """
1014: (8)                   nppcc = self.n_points_per_cubic_curve
1015: (8)                   remainder = len(points) % nppcc
1016: (8)                   points = points[: len(points) - remainder]
1017: (8)                   # Basically take every nppcc element.
1018: (8)                   return tuple(points[i : i + nppcc] for i in range(0, len(points), nppcc))
1019: (4)               def get_cubic_bezier_tuples(self) -> npt.NDArray[Point3D_Array]:
1020: (8)                   return self.get_cubic_bezier_tuples_from_points(self.points)
1021: (4)               def _gen_subpaths_from_points(
1022: (8)                   self,
1023: (8)                   points: Point3D_Array,
1024: (8)                   filter_func: Callable[[int], bool],
1025: (4)               ) -> Generator[Point3D_Array]:
1026: (8)                   """Given an array of points defining the bezier curves of the vmobject, return subpaths formed by these points.
1027: (8)                   Here, Two bezier curves form a path if at least two of their anchors are evaluated True by the relation defined by filter_func.
1028: (8)                   The algorithm every bezier tuple (anchors and handles) in ``self.points`` (by regrouping each n elements, where
1029: (8)                   n is the number of points per cubic curve)), and evaluate the relation between two anchors with filter_func.
1030: (8)                   NOTE : The filter_func takes an int n as parameter, and will evaluate the relation between points[n] and points[n - 1]. This should probably be changed so
1031: (8)                   the function takes two points as parameters.
1032: (8)                   Parameters
1033: (8)                   ----------
1034: (8)                   points
1035: (12)                      points defining the bezier curve.
1036: (8)                   filter_func
1037: (12)                      Filter-func defining the relation.
1038: (8)                   Returns
1039: (8)                   -------
1040: (8)                   Generator[Point3D_Array]
1041: (12)                      subpaths formed by the points.
1042: (8)                   """
1043: (8)                   nppcc = self.n_points_per_cubic_curve
1044: (8)                   filtered = filter(filter_func, range(nppcc, len(points), nppcc))
1045: (8)                   split_indices = [0] + list(filtered) + [len(points)]
1046: (8)                   return (
1047: (12)                      points[i1:i2]
1048: (12)                      for i1, i2 in zip(split_indices, split_indices[1:])
1049: (12)                      if (i2 - i1) >= nppcc
1050: (8)                   )
1051: (4)               def get_subpaths_from_points(self, points: Point3D_Array) -> list[Point3D_Array]:
1052: (8)                   return list(
1053: (12)                      self._gen_subpaths_from_points(
1054: (16)                          points,
1055: (16)                          lambda n: not self.consider_points_equals(points[n - 1], points[n]),
1056: (12)                      ),
1057: (8)                   )
1058: (4)               def gen_subpaths_from_points_2d(
1059: (8)                   self, points: Point3D_Array
1060: (4)               ) -> Generator[Point3D_Array]:
1061: (8)                   return self._gen_subpaths_from_points(
1062: (12)                      points,
1063: (12)                      lambda n: not self.consider_points_equals_2d(points[n - 1], points[n]),
1064: (8)                   )
1065: (4)               def get_subpaths(self) -> list[Point3D_Array]:
1066: (8)                   """Returns subpaths formed by the curves of the VMobject.
1067: (8)                   Subpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.
1068: (8)                   Returns
1069: (8)                   -------
1070: (8)                   list[Point3D_Array]
1071: (12)                      subpaths.
1072: (8)                   """
1073: (8)                   return self.get_subpaths_from_points(self.points)
1074: (4)               def get_nth_curve_points(self, n: int) -> Point3D_Array:
1075: (8)                   """Returns the points defining the nth curve of the vmobject.
1076: (8)                   Parameters
1077: (8)                   ----------
1078: (8)                   n
1079: (12)                      index of the desired bezier curve.
1080: (8)                   Returns
1081: (8)                   -------
1082: (8)                   Point3D_Array
1083: (12)                      points defining the nth bezier curve (anchors, handles)
1084: (8)                   """
1085: (8)                   assert n < self.get_num_curves()
1086: (8)                   nppcc = self.n_points_per_cubic_curve
1087: (8)                   return self.points[nppcc * n : nppcc * (n + 1)]
1088: (4)               def get_nth_curve_function(self, n: int) -> Callable[[float], Point3D]:
1089: (8)                   """Returns the expression of the nth curve.
1090: (8)                   Parameters
1091: (8)                   ----------
1092: (8)                   n
1093: (12)                      index of the desired curve.
1094: (8)                   Returns
1095: (8)                   -------
1096: (8)                   Callable[float, Point3D]
1097: (12)                      expression of the nth bezier curve.
1098: (8)                   """
1099: (8)                   return bezier(self.get_nth_curve_points(n))
1100: (4)               def get_nth_curve_length_pieces(
1101: (8)                   self,
1102: (8)                   n: int,
1103: (8)                   sample_points: int | None = None,
1104: (4)               ) -> npt.NDArray[ManimFloat]:
1105: (8)                   """Returns the array of short line lengths used for length approximation.
1106: (8)                   Parameters
1107: (8)                   ----------
1108: (8)                   n
1109: (12)                      The index of the desired curve.
1110: (8)                   sample_points
1111: (12)                      The number of points to sample to find the length.
1112: (8)                   Returns
1113: (8)                   -------
1114: (12)                      The short length-pieces of the nth curve.
1115: (8)                   """
1116: (8)                   if sample_points is None:
1117: (12)                      sample_points = 10
1118: (8)                   curve = self.get_nth_curve_function(n)
1119: (8)                   points = np.array([curve(a) for a in np.linspace(0, 1, sample_points)])
1120: (8)                   diffs = points[1:] - points[:-1]
1121: (8)                   norms = np.linalg.norm(diffs, axis=1)
1122: (8)                   return norms
1123: (4)               def get_nth_curve_length(
1124: (8)                   self,
1125: (8)                   n: int,
1126: (8)                   sample_points: int | None = None,
1127: (4)               ) -> float:
1128: (8)                   """Returns the (approximate) length of the nth curve.
1129: (8)                   Parameters
1130: (8)                   ----------
1131: (8)                   n
1132: (12)                      The index of the desired curve.
1133: (8)                   sample_points
1134: (12)                      The number of points to sample to find the length.
1135: (8)                   Returns
1136: (8)                   -------
1137: (8)                   length : :class:`float`
1138: (12)                      The length of the nth curve.
1139: (8)                   """
1140: (8)                   _, length = self.get_nth_curve_function_with_length(n, sample_points)
1141: (8)                   return length
1142: (4)               def get_nth_curve_function_with_length(
1143: (8)                   self,
1144: (8)                   n: int,
1145: (8)                   sample_points: int | None = None,
1146: (4)               ) -> tuple[Callable[[float], Point3D], float]:
1147: (8)                   """Returns the expression of the nth curve along with its (approximate) length.
1148: (8)                   Parameters
1149: (8)                   ----------
1150: (8)                   n
1151: (12)                      The index of the desired curve.
1152: (8)                   sample_points
1153: (12)                      The number of points to sample to find the length.
1154: (8)                   Returns
1155: (8)                   -------
1156: (8)                   curve : Callable[[float], Point3D]
1157: (12)                      The function for the nth curve.
1158: (8)                   length : :class:`float`
1159: (12)                      The length of the nth curve.
1160: (8)                   """
1161: (8)                   curve = self.get_nth_curve_function(n)
1162: (8)                   norms = self.get_nth_curve_length_pieces(n, sample_points=sample_points)
1163: (8)                   length = np.sum(norms)
1164: (8)                   return curve, length
1165: (4)               def get_num_curves(self) -> int:
1166: (8)                   """Returns the number of curves of the vmobject.
1167: (8)                   Returns
1168: (8)                   -------
1169: (8)                   int
1170: (12)                      number of curves of the vmobject.
1171: (8)                   """
1172: (8)                   nppcc = self.n_points_per_cubic_curve
1173: (8)                   return len(self.points) // nppcc
1174: (4)               def get_curve_functions(
1175: (8)                   self,
1176: (4)               ) -> Generator[Callable[[float], Point3D]]:
1177: (8)                   """Gets the functions for the curves of the mobject.
1178: (8)                   Returns
1179: (8)                   -------
1180: (8)                   Generator[Callable[[float], Point3D]]
1181: (12)                      The functions for the curves.
1182: (8)                   """
1183: (8)                   num_curves = self.get_num_curves()
1184: (8)                   for n in range(num_curves):
1185: (12)                      yield self.get_nth_curve_function(n)
1186: (4)               def get_curve_functions_with_lengths(
1187: (8)                   self, **kwargs
1188: (4)               ) -> Generator[tuple[Callable[[float], Point3D], float]]:
1189: (8)                   """Gets the functions and lengths of the curves for the mobject.
1190: (8)                   Parameters
1191: (8)                   ----------
1192: (8)                   **kwargs
1193: (12)                      The keyword arguments passed to :meth:`get_nth_curve_function_with_length`
1194: (8)                   Returns
1195: (8)                   -------
1196: (8)                   Generator[tuple[Callable[[float], Point3D], float]]
1197: (12)                      The functions and lengths of the curves.
1198: (8)                   """
1199: (8)                   num_curves = self.get_num_curves()
1200: (8)                   for n in range(num_curves):
1201: (12)                      yield self.get_nth_curve_function_with_length(n, **kwargs)
1202: (4)               def point_from_proportion(self, alpha: float) -> Point3D:
1203: (8)                   """Gets the point at a proportion along the path of the :class:`VMobject`.
1204: (8)                   Parameters
1205: (8)                   ----------
1206: (8)                   alpha
1207: (12)                      The proportion along the the path of the :class:`VMobject`.
1208: (8)                   Returns
1209: (8)                   -------
1210: (8)                   :class:`numpy.ndarray`
1211: (12)                      The point on the :class:`VMobject`.
1212: (8)                   Raises
1213: (8)                   ------
1214: (8)                   :exc:`ValueError`
1215: (12)                      If ``alpha`` is not between 0 and 1.
1216: (8)                   :exc:`Exception`
1217: (12)                      If the :class:`VMobject` has no points.
1218: (8)                   Example
1219: (8)                   -------
1220: (8)                   .. manim:: PointFromProportion
1221: (12)                      :save_last_frame:
1222: (12)                      class PointFromProportion(Scene):
1223: (16)                          def construct(self):
1224: (20)                              line = Line(2*DL, 2*UR)
1225: (20)                              self.add(line)
1226: (20)                              colors = (RED, BLUE, YELLOW)
1227: (20)                              proportions = (1/4, 1/2, 3/4)
1228: (20)                              for color, proportion in zip(colors, proportions):
1229: (24)                                  self.add(Dot(color=color).move_to(
1230: (32)                                          line.point_from_proportion(proportion)
1231: (24)                                  ))
1232: (8)                   """
1233: (8)                   if alpha < 0 or alpha > 1:
1234: (12)                      raise ValueError(f"Alpha {alpha} not between 0 and 1.")
1235: (8)                   self.throw_error_if_no_points()
1236: (8)                   if alpha == 1:
1237: (12)                      return self.points[-1]
1238: (8)                   curves_and_lengths = tuple(self.get_curve_functions_with_lengths())
1239: (8)                   target_length = alpha * sum(length for _, length in curves_and_lengths)
1240: (8)                   current_length = 0
1241: (8)                   for curve, length in curves_and_lengths:
1242: (12)                      if current_length + length >= target_length:
1243: (16)                          if length != 0:
1244: (20)                              residue = (target_length - current_length) / length
1245: (16)                          else:
1246: (20)                              residue = 0
1247: (16)                          return curve(residue)
1248: (12)                      current_length += length
1249: (8)                   raise Exception(
1250: (12)                      "Not sure how you reached here, please file a bug report at https://github.com/ManimCommunity/manim/issues/new/choose"
1251: (8)                   )
1252: (4)               def proportion_from_point(
1253: (8)                   self,
1254: (8)                   point: Iterable[float | int],
1255: (4)               ) -> float:
1256: (8)                   """Returns the proportion along the path of the :class:`VMobject`
1257: (8)                   a particular given point is at.
1258: (8)                   Parameters
1259: (8)                   ----------
1260: (8)                   point
1261: (12)                      The Cartesian coordinates of the point which may or may not lie on the :class:`VMobject`
1262: (8)                   Returns
1263: (8)                   -------
1264: (8)                   float
1265: (12)                      The proportion along the path of the :class:`VMobject`.
1266: (8)                   Raises
1267: (8)                   ------
1268: (8)                   :exc:`ValueError`
1269: (12)                      If ``point`` does not lie on the curve.
1270: (8)                   :exc:`Exception`
1271: (12)                      If the :class:`VMobject` has no points.
1272: (8)                   """
1273: (8)                   self.throw_error_if_no_points()
1274: (8)                   # Iterate over each bezier curve that the ``VMobject`` is composed of, checking
1275: (8)                   # if the point lies on that curve. If it does not lie on that curve, add
1276: (8)                   # the whole length of the curve to ``target_length`` and move onto the next
1277: (8)                   # curve. If the point does lie on the curve, add how far along the curve
1278: (8)                   # the point is to ``target_length``.
1279: (8)                   # Then, divide ``target_length`` by the total arc length of the shape to get
1280: (8)                   # the proportion along the ``VMobject`` the point is at.
1281: (8)                   num_curves = self.get_num_curves()
1282: (8)                   total_length = self.get_arc_length()
1283: (8)                   target_length = 0
1284: (8)                   for n in range(num_curves):
1285: (12)                      control_points = self.get_nth_curve_points(n)
1286: (12)                      length = self.get_nth_curve_length(n)
1287: (12)                      proportions_along_bezier = proportions_along_bezier_curve_for_point(
1288: (16)                          point,
1289: (16)                          control_points,
1290: (12)                      )
1291: (12)                      if len(proportions_along_bezier) > 0:
1292: (16)                          proportion_along_nth_curve = max(proportions_along_bezier)
1293: (16)                          target_length += length * proportion_along_nth_curve
1294: (16)                          break
1295: (12)                      target_length += length
1296: (8)                   else:
1297: (12)                      raise ValueError(f"Point {point} does not lie on this curve.")
1298: (8)                   alpha = target_length / total_length
1299: (8)                   return alpha
1300: (4)               def get_anchors_and_handles(self) -> list[Point3D_Array]:
1301: (8)                   """Returns anchors1, handles1, handles2, anchors2,
1302: (8)                   where (anchors1[i], handles1[i], handles2[i], anchors2[i])
1303: (8)                   will be four points defining a cubic bezier curve
1304: (8)                   for any i in range(0, len(anchors1))
1305: (8)                   Returns
1306: (8)                   -------
1307: (8)                   `list[Point3D_Array]`
1308: (12)                      Iterable of the anchors and handles.
1309: (8)                   """
1310: (8)                   nppcc = self.n_points_per_cubic_curve
1311: (8)                   return [self.points[i::nppcc] for i in range(nppcc)]
1312: (4)               def get_start_anchors(self) -> Point3D_Array:
1313: (8)                   """Returns the start anchors of the bezier curves.
1314: (8)                   Returns
1315: (8)                   -------
1316: (8)                   Point3D_Array
1317: (12)                      Starting anchors
1318: (8)                   """
1319: (8)                   return self.points[:: self.n_points_per_cubic_curve]
1320: (4)               def get_end_anchors(self) -> Point3D_Array:
1321: (8)                   """Return the end anchors of the bezier curves.
1322: (8)                   Returns
1323: (8)                   -------
1324: (8)                   Point3D_Array
1325: (12)                      Starting anchors
1326: (8)                   """
1327: (8)                   nppcc = self.n_points_per_cubic_curve
1328: (8)                   return self.points[nppcc - 1 :: nppcc]
1329: (4)               def get_anchors(self) -> Point3D_Array:
1330: (8)                   """Returns the anchors of the curves forming the VMobject.
1331: (8)                   Returns
1332: (8)                   -------
1333: (8)                   Point3D_Array
1334: (12)                      The anchors.
1335: (8)                   """
1336: (8)                   if self.points.shape[0] == 1:
1337: (12)                      return self.points
1338: (8)                   s = self.get_start_anchors()
1339: (8)                   e = self.get_end_anchors()
1340: (8)                   return list(it.chain.from_iterable(zip(s, e)))
1341: (4)               def get_points_defining_boundary(self) -> Point3D_Array:
1342: (8)                   # Probably returns all anchors, but this is weird regarding  the name of the method.
1343: (8)                   return np.array(
1344: (12)                      tuple(it.chain(*(sm.get_anchors() for sm in self.get_family())))
1345: (8)                   )
1346: (4)               def get_arc_length(self, sample_points_per_curve: int | None = None) -> float:
1347: (8)                   """Return the approximated length of the whole curve.
1348: (8)                   Parameters
1349: (8)                   ----------
1350: (8)                   sample_points_per_curve
1351: (12)                      Number of sample points per curve used to approximate the length. More points result in a better approximation.
1352: (8)                   Returns
1353: (8)                   -------
1354: (8)                   float
1355: (12)                      The length of the :class:`VMobject`.
1356: (8)                   """
1357: (8)                   return sum(
1358: (12)                      length
1359: (12)                      for _, length in self.get_curve_functions_with_lengths(
1360: (16)                          sample_points=sample_points_per_curve,
1361: (12)                      )
1362: (8)                   )
1363: (4)               # Alignment
1364: (4)               def align_points(self, vmobject: VMobject) -> Self:
1365: (8)                   """Adds points to self and vmobject so that they both have the same number of subpaths, with
1366: (8)                   corresponding subpaths each containing the same number of points.
1367: (8)                   Points are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting
1368: (8)                   of a single point repeated.
1369: (8)                   Parameters
1370: (8)                   ----------
1371: (8)                   vmobject
1372: (12)                      The object to align points with.
1373: (8)                   Returns
1374: (8)                   -------
1375: (8)                   :class:`VMobject`
1376: (11)                     ``self``
1377: (8)                   """
1378: (8)                   self.align_rgbas(vmobject)
1379: (8)                   # TODO: This shortcut can be a bit over eager. What if they have the same length, but different subpath lengths?
1380: (8)                   if self.get_num_points() == vmobject.get_num_points():
1381: (12)                      return
1382: (8)                   for mob in self, vmobject:
1383: (12)                      # If there are no points, add one to
1384: (12)                      # wherever the "center" is
1385: (12)                      if mob.has_no_points():
1386: (16)                          mob.start_new_path(mob.get_center())
1387: (12)                      # If there's only one point, turn it into
1388: (12)                      # a null curve
1389: (12)                      if mob.has_new_path_started():
1390: (16)                          mob.add_line_to(mob.get_last_point())
1391: (8)                   # Figure out what the subpaths are
1392: (8)                   subpaths1 = self.get_subpaths()
1393: (8)                   subpaths2 = vmobject.get_subpaths()
1394: (8)                   n_subpaths = max(len(subpaths1), len(subpaths2))
1395: (8)                   # Start building new ones
1396: (8)                   new_path1 = np.zeros((0, self.dim))
1397: (8)                   new_path2 = np.zeros((0, self.dim))
1398: (8)                   nppcc = self.n_points_per_cubic_curve
1399: (8)                   def get_nth_subpath(path_list, n):
1400: (12)                      if n >= len(path_list):
1401: (16)                          # Create a null path at the very end
1402: (16)                          return [path_list[-1][-1]] * nppcc
1403: (12)                      path = path_list[n]
1404: (12)                      # Check for useless points at the end of the path and remove them
1405: (12)                      # https://github.com/ManimCommunity/manim/issues/1959
1406: (12)                      while len(path) > nppcc:
1407: (16)                          # If the last nppc points are all equal to the preceding point
1408: (16)                          if self.consider_points_equals(path[-nppcc:], path[-nppcc - 1]):
1409: (20)                              path = path[:-nppcc]
1410: (16)                          else:
1411: (20)                              break
1412: (12)                      return path
1413: (8)                   for n in range(n_subpaths):
1414: (12)                      # For each pair of subpaths, add points until they are the same length
1415: (12)                      sp1 = get_nth_subpath(subpaths1, n)
1416: (12)                      sp2 = get_nth_subpath(subpaths2, n)
1417: (12)                      diff1 = max(0, (len(sp2) - len(sp1)) // nppcc)
1418: (12)                      diff2 = max(0, (len(sp1) - len(sp2)) // nppcc)
1419: (12)                      sp1 = self.insert_n_curves_to_point_list(diff1, sp1)
1420: (12)                      sp2 = self.insert_n_curves_to_point_list(diff2, sp2)
1421: (12)                      new_path1 = np.append(new_path1, sp1, axis=0)
1422: (12)                      new_path2 = np.append(new_path2, sp2, axis=0)
1423: (8)                   self.set_points(new_path1)
1424: (8)                   vmobject.set_points(new_path2)
1425: (8)                   return self
1426: (4)               def insert_n_curves(self, n: int) -> Self:
1427: (8)                   """Inserts n curves to the bezier curves of the vmobject.
1428: (8)                   Parameters
1429: (8)                   ----------
1430: (8)                   n
1431: (12)                      Number of curves to insert.
1432: (8)                   Returns
1433: (8)                   -------
1434: (8)                   :class:`VMobject`
1435: (12)                      ``self``
1436: (8)                   """
1437: (8)                   new_path_point = None
1438: (8)                   if self.has_new_path_started():
1439: (12)                      new_path_point = self.get_last_point()
1440: (8)                   new_points = self.insert_n_curves_to_point_list(n, self.points)
1441: (8)                   self.set_points(new_points)
1442: (8)                   if new_path_point is not None:
1443: (12)                      self.append_points([new_path_point])
1444: (8)                   return self
1445: (4)               def insert_n_curves_to_point_list(
1446: (8)                   self, n: int, points: Point3D_Array
1447: (4)               ) -> npt.NDArray[BezierPoints]:
1448: (8)                   """Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.
1449: (8)                   Parameters
1450: (8)                   ----------
1451: (8)                   n
1452: (12)                      Number of desired curves.
1453: (8)                   points
1454: (12)                      Starting points.
1455: (8)                   Returns
1456: (8)                   -------
1457: (12)                      Points generated.
1458: (8)                   """
1459: (8)                   if len(points) == 1:
1460: (12)                      nppcc = self.n_points_per_cubic_curve
1461: (12)                      return np.repeat(points, nppcc * n, 0)
1462: (8)                   bezier_quads = self.get_cubic_bezier_tuples_from_points(points)
1463: (8)                   curr_num = len(bezier_quads)
1464: (8)                   target_num = curr_num + n
1465: (8)                   # This is an array with values ranging from 0
1466: (8)                   # up to curr_num,  with repeats such that
1467: (8)                   # it's total length is target_num.  For example,
1468: (8)                   # with curr_num = 10, target_num = 15, this would
1469: (8)                   # be [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]
1470: (8)                   repeat_indices = (np.arange(target_num, dtype="i") * curr_num) // target_num
1471: (8)                   # If the nth term of this list is k, it means
1472: (8)                   # that the nth curve of our path should be split
1473: (8)                   # into k pieces.
1474: (8)                   # In the above example our array had the following elements
1475: (8)                   # [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]
1476: (8)                   # We have two 0s, one 1, two 2s and so on.
1477: (8)                   # The split factors array would hence be:
1478: (8)                   # [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]
1479: (8)                   split_factors = np.zeros(curr_num, dtype="i")
1480: (8)                   for val in repeat_indices:
1481: (12)                      split_factors[val] += 1
1482: (8)                   new_points = np.zeros((0, self.dim))
1483: (8)                   for quad, sf in zip(bezier_quads, split_factors):
1484: (12)                      # What was once a single cubic curve defined
1485: (12)                      # by "quad" will now be broken into sf
1486: (12)                      # smaller cubic curves
1487: (12)                      alphas = np.linspace(0, 1, sf + 1)
1488: (12)                      for a1, a2 in zip(alphas, alphas[1:]):
1489: (16)                          new_points = np.append(
1490: (20)                              new_points,
1491: (20)                              partial_bezier_points(quad, a1, a2),
1492: (20)                              axis=0,
1493: (16)                          )
1494: (8)                   return new_points
1495: (4)               def align_rgbas(self, vmobject: VMobject) -> Self:
1496: (8)                   attrs = ["fill_rgbas", "stroke_rgbas", "background_stroke_rgbas"]
1497: (8)                   for attr in attrs:
1498: (12)                      a1 = getattr(self, attr)
1499: (12)                      a2 = getattr(vmobject, attr)
1500: (12)                      if len(a1) > len(a2):
1501: (16)                          new_a2 = stretch_array_to_length(a2, len(a1))
1502: (16)                          setattr(vmobject, attr, new_a2)
1503: (12)                      elif len(a2) > len(a1):
1504: (16)                          new_a1 = stretch_array_to_length(a1, len(a2))
1505: (16)                          setattr(self, attr, new_a1)
1506: (8)                   return self
1507: (4)               def get_point_mobject(self, center: Point3D | None = None) -> VectorizedPoint:
1508: (8)                   if center is None:
1509: (12)                      center = self.get_center()
1510: (8)                   point = VectorizedPoint(center)
1511: (8)                   point.match_style(self)
1512: (8)                   return point
1513: (4)               def interpolate_color(
1514: (8)                   self, mobject1: VMobject, mobject2: VMobject, alpha: float
1515: (4)               ) -> None:
1516: (8)                   attrs = [
1517: (12)                      "fill_rgbas",
1518: (12)                      "stroke_rgbas",
1519: (12)                      "background_stroke_rgbas",
1520: (12)                      "stroke_width",
1521: (12)                      "background_stroke_width",
1522: (12)                      "sheen_direction",
1523: (12)                      "sheen_factor",
1524: (8)                   ]
1525: (8)                   for attr in attrs:
1526: (12)                      setattr(
1527: (16)                          self,
1528: (16)                          attr,
1529: (16)                          interpolate(getattr(mobject1, attr), getattr(mobject2, attr), alpha),
1530: (12)                      )
1531: (12)                      if alpha == 1.0:
1532: (16)                          val = getattr(mobject2, attr)
1533: (16)                          if isinstance(val, np.ndarray):
1534: (20)                              val = val.copy()
1535: (16)                          setattr(self, attr, val)
1536: (4)               def pointwise_become_partial(
1537: (8)                   self,
1538: (8)                   vmobject: VMobject,
1539: (8)                   a: float,
1540: (8)                   b: float,
1541: (4)               ) -> Self:
1542: (8)                   """Given two bounds a and b, transforms the points of the self vmobject into the points of the vmobject
1543: (8)                   passed as parameter with respect to the bounds. Points here stand for control points of the bezier curves (anchors and handles)
1544: (8)                   Parameters
1545: (8)                   ----------
1546: (8)                   vmobject
1547: (12)                      The vmobject that will serve as a model.
1548: (8)                   a
1549: (12)                      upper-bound.
1550: (8)                   b
1551: (12)                      lower-bound
1552: (8)                   Returns
1553: (8)                   -------
1554: (8)                   :class:`VMobject`
1555: (12)                      ``self``
1556: (8)                   """
1557: (8)                   assert isinstance(vmobject, VMobject)
1558: (8)                   # Partial curve includes three portions:
1559: (8)                   # - A middle section, which matches the curve exactly
1560: (8)                   # - A start, which is some ending portion of an inner cubic
1561: (8)                   # - An end, which is the starting portion of a later inner cubic
1562: (8)                   if a <= 0 and b >= 1:
1563: (12)                      self.set_points(vmobject.points)
1564: (12)                      return self
1565: (8)                   bezier_quads = vmobject.get_cubic_bezier_tuples()
1566: (8)                   num_cubics = len(bezier_quads)
1567: (8)                   # The following two lines will compute which bezier curves of the given mobject need to be processed.
1568: (8)                   # The residue basically indicates de proportion of the selected bezier curve that have to be selected.
1569: (8)                   # Ex : if lower_index is 3, and lower_residue is 0.4, then the algorithm will append to the points 0.4 of the third bezier curve
1570: (8)                   lower_index, lower_residue = integer_interpolate(0, num_cubics, a)
1571: (8)                   upper_index, upper_residue = integer_interpolate(0, num_cubics, b)
1572: (8)                   self.clear_points()
1573: (8)                   if num_cubics == 0:
1574: (12)                      return self
1575: (8)                   if lower_index == upper_index:
1576: (12)                      self.append_points(
1577: (16)                          partial_bezier_points(
1578: (20)                              bezier_quads[lower_index],
1579: (20)                              lower_residue,
1580: (20)                              upper_residue,
1581: (16)                          ),
1582: (12)                      )
1583: (8)                   else:
1584: (12)                      self.append_points(
1585: (16)                          partial_bezier_points(bezier_quads[lower_index], lower_residue, 1),
1586: (12)                      )
1587: (12)                      for quad in bezier_quads[lower_index + 1 : upper_index]:
1588: (16)                          self.append_points(quad)
1589: (12)                      self.append_points(
1590: (16)                          partial_bezier_points(bezier_quads[upper_index], 0, upper_residue),
1591: (12)                      )
1592: (8)                   return self
1593: (4)               def get_subcurve(self, a: float, b: float) -> Self:
1594: (8)                   """Returns the subcurve of the VMobject between the interval [a, b].
1595: (8)                   The curve is a VMobject itself.
1596: (8)                   Parameters
1597: (8)                   ----------
1598: (8)                   a
1599: (12)                      The lower bound.
1600: (8)                   b
1601: (12)                      The upper bound.
1602: (8)                   Returns
1603: (8)                   -------
1604: (8)                   VMobject
1605: (12)                      The subcurve between of [a, b]
1606: (8)                   """
1607: (8)                   if self.is_closed() and a > b:
1608: (12)                      vmob = self.copy()
1609: (12)                      vmob.pointwise_become_partial(self, a, 1)
1610: (12)                      vmob2 = self.copy()
1611: (12)                      vmob2.pointwise_become_partial(self, 0, b)
1612: (12)                      vmob.append_vectorized_mobject(vmob2)
1613: (8)                   else:
1614: (12)                      vmob = self.copy()
1615: (12)                      vmob.pointwise_become_partial(self, a, b)
1616: (8)                   return vmob
1617: (4)               def get_direction(self) -> Literal["CW", "CCW"]:
1618: (8)                   """Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.
1619: (8)                   The direction of points determines in which direction the
1620: (8)                   object is drawn, clockwise or counterclockwise.
1621: (8)                   Examples
1622: (8)                   --------
1623: (8)                   The default direction of a :class:`~.Circle` is counterclockwise::
1624: (12)                      >>> from manim import Circle
1625: (12)                      >>> Circle().get_direction()
1626: (12)                      'CCW'
1627: (8)                   Returns
1628: (8)                   -------
1629: (8)                   :class:`str`
1630: (12)                      Either ``"CW"`` or ``"CCW"``.
1631: (8)                   """
1632: (8)                   return shoelace_direction(self.get_start_anchors())
1633: (4)               def reverse_direction(self) -> Self:
1634: (8)                   """Reverts the point direction by inverting the point order.
1635: (8)                   Returns
1636: (8)                   -------
1637: (8)                   :class:`VMobject`
1638: (12)                      Returns self.
1639: (8)                   Examples
1640: (8)                   --------
1641: (8)                   .. manim:: ChangeOfDirection
1642: (12)                      class ChangeOfDirection(Scene):
1643: (16)                          def construct(self):
1644: (20)                              ccw = RegularPolygon(5)
1645: (20)                              ccw.shift(LEFT)
1646: (20)                              cw = RegularPolygon(5)
1647: (20)                              cw.shift(RIGHT).reverse_direction()
1648: (20)                              self.play(Create(ccw), Create(cw),
1649: (20)                              run_time=4)
1650: (8)                   """
1651: (8)                   self.points = self.points[::-1]
1652: (8)                   return self
1653: (4)               def force_direction(self, target_direction: Literal["CW", "CCW"]) -> Self:
1654: (8)                   """Makes sure that points are either directed clockwise or
1655: (8)                   counterclockwise.
1656: (8)                   Parameters
1657: (8)                   ----------
1658: (8)                   target_direction
1659: (12)                      Either ``"CW"`` or ``"CCW"``.
1660: (8)                   """
1661: (8)                   if target_direction not in ("CW", "CCW"):
1662: (12)                      raise ValueError('Invalid input for force_direction. Use "CW" or "CCW"')
1663: (8)                   if self.get_direction() != target_direction:
1664: (12)                      # Since we already assured the input is CW or CCW,
1665: (12)                      # and the directions don't match, we just reverse
1666: (12)                      self.reverse_direction()
1667: (8)                   return self
1668: (0)           class VGroup(VMobject, metaclass=ConvertToOpenGL):
1669: (4)               """A group of vectorized mobjects.
1670: (4)               This can be used to group multiple :class:`~.VMobject` instances together
1671: (4)               in order to scale, move, ... them together.
1672: (4)               Notes
1673: (4)               -----
1674: (4)               When adding the same mobject more than once, repetitions are ignored.
1675: (4)               Use :meth:`.Mobject.copy` to create a separate copy which can then
1676: (4)               be added to the group.
1677: (4)               Examples
1678: (4)               --------
1679: (4)               To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the
1680: (4)               :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you
1681: (4)               can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or
1682: (4)               `-` and `-=` operators:
1683: (8)                   >>> from manim import Triangle, Square, VGroup
1684: (8)                   >>> vg = VGroup()
1685: (8)                   >>> triangle, square = Triangle(), Square()
1686: (8)                   >>> vg.add(triangle)
1687: (8)                   VGroup(Triangle)
1688: (8)                   >>> vg + square   # a new VGroup is constructed
1689: (8)                   VGroup(Triangle, Square)
1690: (8)                   >>> vg            # not modified
1691: (8)                   VGroup(Triangle)
1692: (8)                   >>> vg += square; vg  # modifies vg
1693: (8)                   VGroup(Triangle, Square)
1694: (8)                   >>> vg.remove(triangle)
1695: (8)                   VGroup(Square)
1696: (8)                   >>> vg - square; # a new VGroup is constructed
1697: (8)                   VGroup()
1698: (8)                   >>> vg   # not modified
1699: (8)                   VGroup(Square)
1700: (8)                   >>> vg -= square; vg # modifies vg
1701: (8)                   VGroup()
1702: (4)               .. manim:: ArcShapeIris
1703: (8)                   :save_last_frame:
1704: (8)                   class ArcShapeIris(Scene):
1705: (12)                      def construct(self):
1706: (16)                          colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]
1707: (16)                          radius = [1 + rad * 0.1 for rad in range(len(colors))]
1708: (16)                          circles_group = VGroup()
1709: (16)                          # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]
1710: (16)                          circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)
1711: (36)                                              for rad, col in zip(radius, colors)])
1712: (16)                          self.add(circles_group)
1713: (4)               """
1714: (4)               def __init__(self, *vmobjects, **kwargs):
1715: (8)                   super().__init__(**kwargs)
1716: (8)                   self.add(*vmobjects)
1717: (4)               def __repr__(self) -> str:
1718: (8)                   return f'{self.__class__.__name__}({", ".join(str(mob) for mob in self.submobjects)})'
1719: (4)               def __str__(self) -> str:
1720: (8)                   return (
1721: (12)                      f"{self.__class__.__name__} of {len(self.submobjects)} "
1722: (12)                      f"submobject{'s' if len(self.submobjects) > 0 else ''}"
1723: (8)                   )
1724: (4)               def add(self, *vmobjects: VMobject) -> Self:
1725: (8)                   """Checks if all passed elements are an instance of VMobject and then add them to submobjects
1726: (8)                   Parameters
1727: (8)                   ----------
1728: (8)                   vmobjects
1729: (12)                      List of VMobject to add
1730: (8)                   Returns
1731: (8)                   -------
1732: (8)                   :class:`VGroup`
1733: (8)                   Raises
1734: (8)                   ------
1735: (8)                   TypeError
1736: (12)                      If one element of the list is not an instance of VMobject
1737: (8)                   Examples
1738: (8)                   --------
1739: (8)                   .. manim:: AddToVGroup
1740: (12)                      class AddToVGroup(Scene):
1741: (16)                          def construct(self):
1742: (20)                              circle_red = Circle(color=RED)
1743: (20)                              circle_green = Circle(color=GREEN)
1744: (20)                              circle_blue = Circle(color=BLUE)
1745: (20)                              circle_red.shift(LEFT)
1746: (20)                              circle_blue.shift(RIGHT)
1747: (20)                              gr = VGroup(circle_red, circle_green)
1748: (20)                              gr2 = VGroup(circle_blue) # Constructor uses add directly
1749: (20)                              self.add(gr,gr2)
1750: (20)                              self.wait()
1751: (20)                              gr += gr2 # Add group to another
1752: (20)                              self.play(
1753: (24)                                  gr.animate.shift(DOWN),
1754: (20)                              )
1755: (20)                              gr -= gr2 # Remove group
1756: (20)                              self.play( # Animate groups separately
1757: (24)                                  gr.animate.shift(LEFT),
1758: (24)                                  gr2.animate.shift(UP),
1759: (20)                              )
1760: (20)                              self.play( #Animate groups without modification
1761: (24)                                  (gr+gr2).animate.shift(RIGHT)
1762: (20)                              )
1763: (20)                              self.play( # Animate group without component
1764: (24)                                  (gr-circle_red).animate.shift(RIGHT)
1765: (20)                              )
1766: (8)                   """
1767: (8)                   for m in vmobjects:
1768: (12)                      if not isinstance(m, (VMobject, OpenGLVMobject)):
1769: (16)                          raise TypeError(
1770: (20)                              f"All submobjects of {self.__class__.__name__} must be of type VMobject. "
1771: (20)                              f"Got {repr(m)} ({type(m).__name__}) instead. "
1772: (20)                              "You can try using `Group` instead."
1773: (16)                          )
1774: (8)                   return super().add(*vmobjects)
1775: (4)               def __add__(self, vmobject: VMobject) -> Self:
1776: (8)                   return VGroup(*self.submobjects, vmobject)
1777: (4)               def __iadd__(self, vmobject: VMobject) -> Self:
1778: (8)                   return self.add(vmobject)
1779: (4)               def __sub__(self, vmobject: VMobject) -> Self:
1780: (8)                   copy = VGroup(*self.submobjects)
1781: (8)                   copy.remove(vmobject)
1782: (8)                   return copy
1783: (4)               def __isub__(self, vmobject: VMobject) -> Self:
1784: (8)                   return self.remove(vmobject)
1785: (4)               def __setitem__(self, key: int, value: VMobject | Sequence[VMobject]) -> None:
1786: (8)                   """Override the [] operator for item assignment.
1787: (8)                   Parameters
1788: (8)                   ----------
1789: (8)                   key
1790: (12)                      The index of the submobject to be assigned
1791: (8)                   value
1792: (12)                      The vmobject value to assign to the key
1793: (8)                   Returns
1794: (8)                   -------
1795: (8)                   None
1796: (8)                   Tests
1797: (8)                   -----
1798: (8)                   Check that item assignment does not raise error::
1799: (12)                      >>> vgroup = VGroup(VMobject())
1800: (12)                      >>> new_obj = VMobject()
1801: (12)                      >>> vgroup[0] = new_obj
1802: (8)                   """
1803: (8)                   if not all(isinstance(m, (VMobject, OpenGLVMobject)) for m in value):
1804: (12)                      raise TypeError("All submobjects must be of type VMobject")
1805: (8)                   self.submobjects[key] = value
1806: (0)           class VDict(VMobject, metaclass=ConvertToOpenGL):
1807: (4)               """A VGroup-like class, also offering submobject access by
1808: (4)               key, like a python dict
1809: (4)               Parameters
1810: (4)               ----------
1811: (4)               mapping_or_iterable
1812: (12)                      The parameter specifying the key-value mapping of keys and mobjects.
1813: (4)               show_keys
1814: (12)                      Whether to also display the key associated with
1815: (12)                      the mobject. This might be useful when debugging,
1816: (12)                      especially when there are a lot of mobjects in the
1817: (12)                      :class:`VDict`. Defaults to False.
1818: (4)               kwargs
1819: (12)                      Other arguments to be passed to `Mobject`.
1820: (4)               Attributes
1821: (4)               ----------
1822: (4)               show_keys : :class:`bool`
1823: (12)                      Whether to also display the key associated with
1824: (12)                      the mobject. This might be useful when debugging,
1825: (12)                      especially when there are a lot of mobjects in the
1826: (12)                      :class:`VDict`. When displayed, the key is towards
1827: (12)                      the left of the mobject.
1828: (12)                      Defaults to False.
1829: (4)               submob_dict : :class:`dict`
1830: (12)                      Is the actual python dictionary that is used to bind
1831: (12)                      the keys to the mobjects.
1832: (4)               Examples
1833: (4)               --------
1834: (4)               .. manim:: ShapesWithVDict
1835: (8)                   class ShapesWithVDict(Scene):
1836: (12)                      def construct(self):
1837: (16)                          square = Square().set_color(RED)
1838: (16)                          circle = Circle().set_color(YELLOW).next_to(square, UP)
1839: (16)                          # create dict from list of tuples each having key-mobject pair
1840: (16)                          pairs = [("s", square), ("c", circle)]
1841: (16)                          my_dict = VDict(pairs, show_keys=True)
1842: (16)                          # display it just like a VGroup
1843: (16)                          self.play(Create(my_dict))
1844: (16)                          self.wait()
1845: (16)                          text = Tex("Some text").set_color(GREEN).next_to(square, DOWN)
1846: (16)                          # add a key-value pair by wrapping it in a single-element list of tuple
1847: (16)                          # after attrs branch is merged, it will be easier like `.add(t=text)`
1848: (16)                          my_dict.add([("t", text)])
1849: (16)                          self.wait()
1850: (16)                          rect = Rectangle().next_to(text, DOWN)
1851: (16)                          # can also do key assignment like a python dict
1852: (16)                          my_dict["r"] = rect
1853: (16)                          # access submobjects like a python dict
1854: (16)                          my_dict["t"].set_color(PURPLE)
1855: (16)                          self.play(my_dict["t"].animate.scale(3))
1856: (16)                          self.wait()
1857: (16)                          # also supports python dict styled reassignment
1858: (16)                          my_dict["t"] = Tex("Some other text").set_color(BLUE)
1859: (16)                          self.wait()
1860: (16)                          # remove submobject by key
1861: (16)                          my_dict.remove("t")
1862: (16)                          self.wait()
1863: (16)                          self.play(Uncreate(my_dict["s"]))
1864: (16)                          self.wait()
1865: (16)                          self.play(FadeOut(my_dict["c"]))
1866: (16)                          self.wait()
1867: (16)                          self.play(FadeOut(my_dict["r"], shift=DOWN))
1868: (16)                          self.wait()
1869: (16)                          # you can also make a VDict from an existing dict of mobjects
1870: (16)                          plain_dict = {
1871: (20)                              1: Integer(1).shift(DOWN),
1872: (20)                              2: Integer(2).shift(2 * DOWN),
1873: (20)                              3: Integer(3).shift(3 * DOWN),
1874: (16)                          }
1875: (16)                          vdict_from_plain_dict = VDict(plain_dict)
1876: (16)                          vdict_from_plain_dict.shift(1.5 * (UP + LEFT))
1877: (16)                          self.play(Create(vdict_from_plain_dict))
1878: (16)                          # you can even use zip
1879: (16)                          vdict_using_zip = VDict(zip(["s", "c", "r"], [Square(), Circle(), Rectangle()]))
1880: (16)                          vdict_using_zip.shift(1.5 * RIGHT)
1881: (16)                          self.play(Create(vdict_using_zip))
1882: (16)                          self.wait()
1883: (4)               """
1884: (4)               def __init__(
1885: (8)                   self,
1886: (8)                   mapping_or_iterable: (
1887: (12)                      Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]
1888: (8)                   ) = {},
1889: (8)                   show_keys: bool = False,
1890: (8)                   **kwargs,
1891: (4)               ) -> None:
1892: (8)                   super().__init__(**kwargs)
1893: (8)                   self.show_keys = show_keys
1894: (8)                   self.submob_dict = {}
1895: (8)                   self.add(mapping_or_iterable)
1896: (4)               def __repr__(self) -> str:
1897: (8)                   return f"{self.__class__.__name__}({repr(self.submob_dict)})"
1898: (4)               def add(
1899: (8)                   self,
1900: (8)                   mapping_or_iterable: (
1901: (12)                      Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]
1902: (8)                   ),
1903: (4)               ) -> Self:
1904: (8)                   """Adds the key-value pairs to the :class:`VDict` object.
1905: (8)                   Also, it internally adds the value to the `submobjects` :class:`list`
1906: (8)                   of :class:`~.Mobject`, which is responsible for actual on-screen display.
1907: (8)                   Parameters
1908: (8)                   ---------
1909: (8)                   mapping_or_iterable
1910: (12)                      The parameter specifying the key-value mapping of keys and mobjects.
1911: (8)                   Returns
1912: (8)                   -------
1913: (8)                   :class:`VDict`
1914: (12)                      Returns the :class:`VDict` object on which this method was called.
1915: (8)                   Examples
1916: (8)                   --------
1917: (8)                   Normal usage::
1918: (12)                      square_obj = Square()
1919: (12)                      my_dict.add([('s', square_obj)])
1920: (8)                   """
1921: (8)                   for key, value in dict(mapping_or_iterable).items():
1922: (12)                      self.add_key_value_pair(key, value)
1923: (8)                   return self
1924: (4)               def remove(self, key: Hashable) -> Self:
1925: (8)                   """Removes the mobject from the :class:`VDict` object having the key `key`
1926: (8)                   Also, it internally removes the mobject from the `submobjects` :class:`list`
1927: (8)                   of :class:`~.Mobject`, (which is responsible for removing it from the screen)
1928: (8)                   Parameters
1929: (8)                   ----------
1930: (8)                   key
1931: (12)                      The key of the submoject to be removed.
1932: (8)                   Returns
1933: (8)                   -------
1934: (8)                   :class:`VDict`
1935: (12)                      Returns the :class:`VDict` object on which this method was called.
1936: (8)                   Examples
1937: (8)                   --------
1938: (8)                   Normal usage::
1939: (12)                      my_dict.remove('square')
1940: (8)                   """
1941: (8)                   if key not in self.submob_dict:
1942: (12)                      raise KeyError("The given key '%s' is not present in the VDict" % str(key))
1943: (8)                   super().remove(self.submob_dict[key])
1944: (8)                   del self.submob_dict[key]
1945: (8)                   return self
1946: (4)               def __getitem__(self, key: Hashable):
1947: (8)                   """Override the [] operator for item retrieval.
1948: (8)                   Parameters
1949: (8)                   ----------
1950: (8)                   key
1951: (11)                     The key of the submoject to be accessed
1952: (8)                   Returns
1953: (8)                   -------
1954: (8)                   :class:`VMobject`
1955: (11)                     The submobject corresponding to the key `key`
1956: (8)                   Examples
1957: (8)                   --------
1958: (8)                   Normal usage::
1959: (11)                     self.play(Create(my_dict['s']))
1960: (8)                   """
1961: (8)                   submob = self.submob_dict[key]
1962: (8)                   return submob
1963: (4)               def __setitem__(self, key: Hashable, value: VMobject) -> None:
1964: (8)                   """Override the [] operator for item assignment.
1965: (8)                   Parameters
1966: (8)                   ----------
1967: (8)                   key
1968: (12)                      The key of the submoject to be assigned
1969: (8)                   value
1970: (12)                      The submobject to bind the key to
1971: (8)                   Returns
1972: (8)                   -------
1973: (8)                   None
1974: (8)                   Examples
1975: (8)                   --------
1976: (8)                   Normal usage::
1977: (12)                      square_obj = Square()
1978: (12)                      my_dict['sq'] = square_obj
1979: (8)                   """
1980: (8)                   if key in self.submob_dict:
1981: (12)                      self.remove(key)
1982: (8)                   self.add([(key, value)])
1983: (4)               def __delitem__(self, key: Hashable):
1984: (8)                   """Override the del operator for deleting an item.
1985: (8)                   Parameters
1986: (8)                   ----------
1987: (8)                   key
1988: (12)                      The key of the submoject to be deleted
1989: (8)                   Returns
1990: (8)                   -------
1991: (8)                   None
1992: (8)                   Examples
1993: (8)                   --------
1994: (8)                   ::
1995: (12)                      >>> from manim import *
1996: (12)                      >>> my_dict = VDict({'sq': Square()})
1997: (12)                      >>> 'sq' in my_dict
1998: (12)                      True
1999: (12)                      >>> del my_dict['sq']
2000: (12)                      >>> 'sq' in my_dict
2001: (12)                      False
2002: (8)                   Notes
2003: (8)                   -----
2004: (8)                   Removing an item from a VDict does not remove that item from any Scene
2005: (8)                   that the VDict is part of.
2006: (8)                   """
2007: (8)                   del self.submob_dict[key]
2008: (4)               def __contains__(self, key: Hashable):
2009: (8)                   """Override the in operator.
2010: (8)                   Parameters
2011: (8)                   ----------
2012: (8)                   key
2013: (12)                      The key to check membership of.
2014: (8)                   Returns
2015: (8)                   -------
2016: (8)                   :class:`bool`
2017: (8)                   Examples
2018: (8)                   --------
2019: (8)                   ::
2020: (12)                      >>> from manim import *
2021: (12)                      >>> my_dict = VDict({'sq': Square()})
2022: (12)                      >>> 'sq' in my_dict
2023: (12)                      True
2024: (8)                   """
2025: (8)                   return key in self.submob_dict
2026: (4)               def get_all_submobjects(self) -> list[list]:
2027: (8)                   """To get all the submobjects associated with a particular :class:`VDict` object
2028: (8)                   Returns
2029: (8)                   -------
2030: (8)                   :class:`dict_values`
2031: (12)                      All the submobjects associated with the :class:`VDict` object
2032: (8)                   Examples
2033: (8)                   --------
2034: (8)                   Normal usage::
2035: (12)                      for submob in my_dict.get_all_submobjects():
2036: (16)                          self.play(Create(submob))
2037: (8)                   """
2038: (8)                   submobjects = self.submob_dict.values()
2039: (8)                   return submobjects
2040: (4)               def add_key_value_pair(self, key: Hashable, value: VMobject) -> None:
2041: (8)                   """A utility function used by :meth:`add` to add the key-value pair
2042: (8)                   to :attr:`submob_dict`. Not really meant to be used externally.
2043: (8)                   Parameters
2044: (8)                   ----------
2045: (8)                   key
2046: (12)                      The key of the submobject to be added.
2047: (8)                   value
2048: (12)                      The mobject associated with the key
2049: (8)                   Returns
2050: (8)                   -------
2051: (8)                   None
2052: (8)                   Raises
2053: (8)                   ------
2054: (8)                   TypeError
2055: (12)                      If the value is not an instance of VMobject
2056: (8)                   Examples
2057: (8)                   --------
2058: (8)                   Normal usage::
2059: (12)                      square_obj = Square()
2060: (12)                      self.add_key_value_pair('s', square_obj)
2061: (8)                   """
2062: (8)                   if not isinstance(value, (VMobject, OpenGLVMobject)):
2063: (12)                      raise TypeError("All submobjects must be of type VMobject")
2064: (8)                   mob = value
2065: (8)                   if self.show_keys:
2066: (12)                      # This import is here and not at the top to avoid circular import
2067: (12)                      from manim.mobject.text.tex_mobject import Tex
2068: (12)                      key_text = Tex(str(key)).next_to(value, LEFT)
2069: (12)                      mob.add(key_text)
2070: (8)                   self.submob_dict[key] = mob
2071: (8)                   super().add(value)
2072: (0)           class VectorizedPoint(VMobject, metaclass=ConvertToOpenGL):
2073: (4)               def __init__(
2074: (8)                   self,
2075: (8)                   location: Point3D = ORIGIN,
2076: (8)                   color: ManimColor = BLACK,
2077: (8)                   fill_opacity: float = 0,
2078: (8)                   stroke_width: float = 0,
2079: (8)                   artificial_width: float = 0.01,
2080: (8)                   artificial_height: float = 0.01,
2081: (8)                   **kwargs,
2082: (4)               ) -> None:
2083: (8)                   self.artificial_width = artificial_width
2084: (8)                   self.artificial_height = artificial_height
2085: (8)                   super().__init__(
2086: (12)                      color=color,
2087: (12)                      fill_opacity=fill_opacity,
2088: (12)                      stroke_width=stroke_width,
2089: (12)                      **kwargs,
2090: (8)                   )
2091: (8)                   self.set_points(np.array([location]))
2092: (4)               basecls = OpenGLVMobject if config.renderer == RendererType.OPENGL else VMobject
2093: (4)               @basecls.width.getter
2094: (4)               def width(self) -> float:
2095: (8)                   return self.artificial_width
2096: (4)               @basecls.height.getter
2097: (4)               def height(self) -> float:
2098: (8)                   return self.artificial_height
2099: (4)               def get_location(self) -> Point3D:
2100: (8)                   return np.array(self.points[0])
2101: (4)               def set_location(self, new_loc: Point3D):
2102: (8)                   self.set_points(np.array([new_loc]))
2103: (0)           class CurvesAsSubmobjects(VGroup):
2104: (4)               """Convert a curve's elements to submobjects.
2105: (4)               Examples
2106: (4)               --------
2107: (4)               .. manim:: LineGradientExample
2108: (8)                   :save_last_frame:
2109: (8)                   class LineGradientExample(Scene):
2110: (12)                      def construct(self):
2111: (16)                          curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)
2112: (16)                          new_curve = CurvesAsSubmobjects(curve)
2113: (16)                          new_curve.set_color_by_gradient(BLUE, RED)
2114: (16)                          self.add(new_curve.shift(UP), curve)
2115: (4)               """
2116: (4)               def __init__(self, vmobject: VMobject, **kwargs) -> None:
2117: (8)                   super().__init__(**kwargs)
2118: (8)                   tuples = vmobject.get_cubic_bezier_tuples()
2119: (8)                   for tup in tuples:
2120: (12)                      part = VMobject()
2121: (12)                      part.set_points(tup)
2122: (12)                      part.match_style(vmobject)
2123: (12)                      self.add(part)
2124: (4)               def point_from_proportion(self, alpha: float) -> Point3D:
2125: (8)                   """Gets the point at a proportion along the path of the :class:`CurvesAsSubmobjects`.
2126: (8)                   Parameters
2127: (8)                   ----------
2128: (8)                   alpha
2129: (12)                      The proportion along the the path of the :class:`CurvesAsSubmobjects`.
2130: (8)                   Returns
2131: (8)                   -------
2132: (8)                   :class:`numpy.ndarray`
2133: (12)                      The point on the :class:`CurvesAsSubmobjects`.
2134: (8)                   Raises
2135: (8)                   ------
2136: (8)                   :exc:`ValueError`
2137: (12)                      If ``alpha`` is not between 0 and 1.
2138: (8)                   :exc:`Exception`
2139: (12)                      If the :class:`CurvesAsSubmobjects` has no submobjects, or no submobject has points.
2140: (8)                   """
2141: (8)                   if alpha < 0 or alpha > 1:
2142: (12)                      raise ValueError(f"Alpha {alpha} not between 0 and 1.")
2143: (8)                   self._throw_error_if_no_submobjects()
2144: (8)                   submobjs_with_pts = self._get_submobjects_with_points()
2145: (8)                   if alpha == 1:
2146: (12)                      return submobjs_with_pts[-1].points[-1]
2147: (8)                   submobjs_arc_lengths = tuple(
2148: (12)                      part.get_arc_length() for part in submobjs_with_pts
2149: (8)                   )
2150: (8)                   total_length = sum(submobjs_arc_lengths)
2151: (8)                   target_length = alpha * total_length
2152: (8)                   current_length = 0
2153: (8)                   for i, part in enumerate(submobjs_with_pts):
2154: (12)                      part_length = submobjs_arc_lengths[i]
2155: (12)                      if current_length + part_length >= target_length:
2156: (16)                          residue = (target_length - current_length) / part_length
2157: (16)                          return part.point_from_proportion(residue)
2158: (12)                      current_length += part_length
2159: (4)               def _throw_error_if_no_submobjects(self):
2160: (8)                   if len(self.submobjects) == 0:
2161: (12)                      caller_name = sys._getframe(1).f_code.co_name
2162: (12)                      raise Exception(
2163: (16)                          f"Cannot call CurvesAsSubmobjects. {caller_name} for a CurvesAsSubmobject with no submobjects"
2164: (12)                      )
2165: (4)               def _get_submobjects_with_points(self):
2166: (8)                   submobjs_with_pts = tuple(
2167: (12)                      part for part in self.submobjects if len(part.points) > 0
2168: (8)                   )
2169: (8)                   if len(submobjs_with_pts) == 0:
2170: (12)                      caller_name = sys._getframe(1).f_code.co_name
2171: (12)                      raise Exception(
2172: (16)                          f"Cannot call CurvesAsSubmobjects. {caller_name} for a CurvesAsSubmobject whose submobjects have no points"
2173: (12)                      )
2174: (8)                   return submobjs_with_pts
2175: (0)           class DashedVMobject(VMobject, metaclass=ConvertToOpenGL):
2176: (4)               """A :class:`VMobject` composed of dashes instead of lines.
2177: (4)               Parameters
2178: (4)               ----------
2179: (8)                   vmobject
2180: (12)                      The object that will get dashed
2181: (8)                   num_dashes
2182: (12)                      Number of dashes to add.
2183: (8)                   dashed_ratio
2184: (12)                      Ratio of dash to empty space.
2185: (8)                   dash_offset
2186: (12)                      Shifts the starting point of dashes along the
2187: (12)                      path. Value 1 shifts by one full dash length.
2188: (8)                   equal_lengths
2189: (12)                      If ``True``, dashes will be (approximately) equally long.
2190: (12)                      If ``False``, dashes will be split evenly in the curve's
2191: (12)                      input t variable (legacy behavior).
2192: (4)               Examples
2193: (4)               --------
2194: (4)               .. manim:: DashedVMobjectExample
2195: (8)                   :save_last_frame:
2196: (8)                   class DashedVMobjectExample(Scene):
2197: (12)                      def construct(self):
2198: (16)                          r = 0.5
2199: (16)                          top_row = VGroup()  # Increasing num_dashes
2200: (16)                          for dashes in range(1, 12):
2201: (20)                              circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)
2202: (20)                              top_row.add(circ)
2203: (16)                          middle_row = VGroup()  # Increasing dashed_ratio
2204: (16)                          for ratio in np.arange(1 / 11, 1, 1 / 11):
2205: (20)                              circ = DashedVMobject(
2206: (24)                                  Circle(radius=r, color=WHITE), dashed_ratio=ratio
2207: (20)                              )
2208: (20)                              middle_row.add(circ)
2209: (16)                          func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)
2210: (16)                          func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)
2211: (16)                          func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)
2212: (16)                          bottom_row = VGroup(func_even,func_stretched)
2213: (16)                          top_row.arrange(buff=0.3)
2214: (16)                          middle_row.arrange()
2215: (16)                          bottom_row.arrange(buff=1)
2216: (16)                          everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)
2217: (16)                          self.add(everything)
2218: (4)               """
2219: (4)               def __init__(
2220: (8)                   self,
2221: (8)                   vmobject: VMobject,
2222: (8)                   num_dashes: int = 15,
2223: (8)                   dashed_ratio: float = 0.5,
2224: (8)                   dash_offset: float = 0,
2225: (8)                   color: ManimColor = WHITE,
2226: (8)                   equal_lengths: bool = True,
2227: (8)                   **kwargs,
2228: (4)               ) -> None:
2229: (8)                   self.dashed_ratio = dashed_ratio
2230: (8)                   self.num_dashes = num_dashes
2231: (8)                   super().__init__(color=color, **kwargs)
2232: (8)                   r = self.dashed_ratio
2233: (8)                   n = self.num_dashes
2234: (8)                   if n > 0:
2235: (12)                      # Assuming total length is 1
2236: (12)                      dash_len = r / n
2237: (12)                      if vmobject.is_closed():
2238: (16)                          void_len = (1 - r) / n
2239: (12)                      else:
2240: (16)                          if n == 1:
2241: (20)                              void_len = 1 - r
2242: (16)                          else:
2243: (20)                              void_len = (1 - r) / (n - 1)
2244: (12)                      period = dash_len + void_len
2245: (12)                      phase_shift = (dash_offset % 1) * period
2246: (12)                      if vmobject.is_closed():
2247: (16)                          # closed curves have equal amount of dashes and voids
2248: (16)                          pattern_len = 1
2249: (12)                      else:
2250: (16)                          # open curves start and end with a dash, so the whole dash pattern with the last void is longer
2251: (16)                          pattern_len = 1 + void_len
2252: (12)                      dash_starts = [((i * period + phase_shift) % pattern_len) for i in range(n)]
2253: (12)                      dash_ends = [
2254: (16)                          ((i * period + dash_len + phase_shift) % pattern_len) for i in range(n)
2255: (12)                      ]
2256: (12)                      # closed shapes can handle overflow at the 0-point
2257: (12)                      # open shapes need special treatment for it
2258: (12)                      if not vmobject.is_closed():
2259: (16)                          # due to phase shift being [0...1] range, always the last dash element needs attention for overflow
2260: (16)                          # if an entire dash moves out of the shape end:
2261: (16)                          if dash_ends[-1] > 1 and dash_starts[-1] > 1:
2262: (20)                              # remove the last element since it is out-of-bounds
2263: (20)                              dash_ends.pop()
2264: (20)                              dash_starts.pop()
2265: (16)                          elif dash_ends[-1] < dash_len:  # if it overflowed
2266: (20)                              if (
2267: (24)                                  dash_starts[-1] < 1
2268: (20)                              ):  # if the beginning of the piece is still in range
2269: (24)                                  dash_starts.append(0)
2270: (24)                                  dash_ends.append(dash_ends[-1])
2271: (24)                                  dash_ends[-2] = 1
2272: (20)                              else:
2273: (24)                                  dash_starts[-1] = 0
2274: (16)                          elif dash_starts[-1] > (1 - dash_len):
2275: (20)                              dash_ends[-1] = 1
2276: (12)                      if equal_lengths:
2277: (16)                          # calculate the entire length by adding up short line-pieces
2278: (16)                          norms = np.array(0)
2279: (16)                          for k in range(vmobject.get_num_curves()):
2280: (20)                              norms = np.append(norms, vmobject.get_nth_curve_length_pieces(k))
2281: (16)                          # add up length-pieces in array form
2282: (16)                          length_vals = np.cumsum(norms)
2283: (16)                          ref_points = np.linspace(0, 1, length_vals.size)
2284: (16)                          curve_length = length_vals[-1]
2285: (16)                          self.add(
2286: (20)                              *(
2287: (24)                                  vmobject.get_subcurve(
2288: (28)                                      np.interp(
2289: (32)                                          dash_starts[i] * curve_length,
2290: (32)                                          length_vals,
2291: (32)                                          ref_points,
2292: (28)                                      ),
2293: (28)                                      np.interp(
2294: (32)                                          dash_ends[i] * curve_length,
2295: (32)                                          length_vals,
2296: (32)                                          ref_points,
2297: (28)                                      ),
2298: (24)                                  )
2299: (24)                                  for i in range(len(dash_starts))
2300: (20)                              )
2301: (16)                          )
2302: (12)                      else:
2303: (16)                          self.add(
2304: (20)                              *(
2305: (24)                                  vmobject.get_subcurve(
2306: (28)                                      dash_starts[i],
2307: (28)                                      dash_ends[i],
2308: (24)                                  )
2309: (24)                                  for i in range(len(dash_starts))
2310: (20)                              )
2311: (16)                          )
2312: (8)                   # Family is already taken care of by get_subcurve
2313: (8)                   # implementation
2314: (8)                   if config.renderer == RendererType.OPENGL:
2315: (12)                      self.match_style(vmobject, recurse=False)
2316: (8)                   else:
2317: (12)                      self.match_style(vmobject, family=False)

----------------------------------------

File 48 - . \utils.py:

1: (0)              """Utilities for working with mobjects."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "get_mobject_class",
5: (4)                  "get_point_mobject_class",
6: (4)                  "get_vectorized_mobject_class",
7: (0)              ]
8: (0)              from .._config import config
9: (0)              from ..constants import RendererType
10: (0)             from .mobject import Mobject
11: (0)             from .opengl.opengl_mobject import OpenGLMobject
12: (0)             from .opengl.opengl_point_cloud_mobject import OpenGLPMobject
13: (0)             from .opengl.opengl_vectorized_mobject import OpenGLVMobject
14: (0)             from .types.point_cloud_mobject import PMobject
15: (0)             from .types.vectorized_mobject import VMobject
16: (0)             def get_mobject_class() -> type:
17: (4)                 """Gets the base mobject class, depending on the currently active renderer.
18: (4)                 .. NOTE::
19: (8)                     This method is intended to be used in the code base of Manim itself
20: (8)                     or in plugins where code should work independent of the selected
21: (8)                     renderer.
22: (4)                 Examples
23: (4)                 --------
24: (4)                 The function has to be explicitly imported. We test that
25: (4)                 the name of the returned class is one of the known mobject
26: (4)                 base classes::
27: (8)                     >>> from manim.mobject.utils import get_mobject_class
28: (8)                     >>> get_mobject_class().__name__ in ['Mobject', 'OpenGLMobject']
29: (8)                     True
30: (4)                 """
31: (4)                 if config.renderer == RendererType.CAIRO:
32: (8)                     return Mobject
33: (4)                 if config.renderer == RendererType.OPENGL:
34: (8)                     return OpenGLMobject
35: (4)                 raise NotImplementedError(
36: (8)                     "Base mobjects are not implemented for the active renderer."
37: (4)                 )
38: (0)             def get_vectorized_mobject_class() -> type:
39: (4)                 """Gets the vectorized mobject class, depending on the currently
40: (4)                 active renderer.
41: (4)                 .. NOTE::
42: (8)                     This method is intended to be used in the code base of Manim itself
43: (8)                     or in plugins where code should work independent of the selected
44: (8)                     renderer.
45: (4)                 Examples
46: (4)                 --------
47: (4)                 The function has to be explicitly imported. We test that
48: (4)                 the name of the returned class is one of the known mobject
49: (4)                 base classes::
50: (8)                     >>> from manim.mobject.utils import get_vectorized_mobject_class
51: (8)                     >>> get_vectorized_mobject_class().__name__ in ['VMobject', 'OpenGLVMobject']
52: (8)                     True
53: (4)                 """
54: (4)                 if config.renderer == RendererType.CAIRO:
55: (8)                     return VMobject
56: (4)                 if config.renderer == RendererType.OPENGL:
57: (8)                     return OpenGLVMobject
58: (4)                 raise NotImplementedError(
59: (8)                     "Vectorized mobjects are not implemented for the active renderer."
60: (4)                 )
61: (0)             def get_point_mobject_class() -> type:
62: (4)                 """Gets the point cloud mobject class, depending on the currently
63: (4)                 active renderer.
64: (4)                 .. NOTE::
65: (8)                     This method is intended to be used in the code base of Manim itself
66: (8)                     or in plugins where code should work independent of the selected
67: (8)                     renderer.
68: (4)                 Examples
69: (4)                 --------
70: (4)                 The function has to be explicitly imported. We test that
71: (4)                 the name of the returned class is one of the known mobject
72: (4)                 base classes::
73: (8)                     >>> from manim.mobject.utils import get_point_mobject_class
74: (8)                     >>> get_point_mobject_class().__name__ in ['PMobject', 'OpenGLPMobject']
75: (8)                     True
76: (4)                 """
77: (4)                 if config.renderer == RendererType.CAIRO:
78: (8)                     return PMobject
79: (4)                 if config.renderer == RendererType.OPENGL:
80: (8)                     return OpenGLPMobject
81: (4)                 raise NotImplementedError(
82: (8)                     "Point cloud mobjects are not implemented for the active renderer."
83: (4)                 )

----------------------------------------

File 49 - . \vector_field.py:

1: (0)              """Mobjects representing vector fields."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "VectorField",
5: (4)                  "ArrowVectorField",
6: (4)                  "StreamLines",
7: (0)              ]
8: (0)              import itertools as it
9: (0)              import random
10: (0)             from math import ceil, floor
11: (0)             from typing import Callable, Iterable, Sequence
12: (0)             import numpy as np
13: (0)             from PIL import Image
14: (0)             from manim.animation.updaters.update import UpdateFromAlphaFunc
15: (0)             from manim.mobject.geometry.line import Vector
16: (0)             from manim.mobject.graphing.coordinate_systems import CoordinateSystem
17: (0)             from .. import config
18: (0)             from ..animation.composition import AnimationGroup, Succession
19: (0)             from ..animation.creation import Create
20: (0)             from ..animation.indication import ShowPassingFlash
21: (0)             from ..constants import OUT, RIGHT, UP, RendererType
22: (0)             from ..mobject.mobject import Mobject
23: (0)             from ..mobject.types.vectorized_mobject import VGroup
24: (0)             from ..mobject.utils import get_vectorized_mobject_class
25: (0)             from ..utils.bezier import interpolate, inverse_interpolate
26: (0)             from ..utils.color import (
27: (4)                 BLUE_E,
28: (4)                 GREEN,
29: (4)                 RED,
30: (4)                 YELLOW,
31: (4)                 ManimColor,
32: (4)                 ParsableManimColor,
33: (4)                 color_to_rgb,
34: (4)                 rgb_to_color,
35: (0)             )
36: (0)             from ..utils.rate_functions import ease_out_sine, linear
37: (0)             from ..utils.simple_functions import sigmoid
38: (0)             DEFAULT_SCALAR_FIELD_COLORS: list = [BLUE_E, GREEN, YELLOW, RED]
39: (0)             class VectorField(VGroup):
40: (4)                 """A vector field.
41: (4)                 Vector fields are based on a function defining a vector at every position.
42: (4)                 This class does by default not include any visible elements but provides
43: (4)                 methods to move other :class:`~.Mobject` s along the vector field.
44: (4)                 Parameters
45: (4)                 ----------
46: (4)                 func
47: (8)                     The function defining the rate of change at every position of the `VectorField`.
48: (4)                 color
49: (8)                     The color of the vector field. If set, position-specific coloring is disabled.
50: (4)                 color_scheme
51: (8)                     A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.
52: (4)                 min_color_scheme_value
53: (8)                     The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.
54: (4)                 max_color_scheme_value
55: (8)                     The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.
56: (4)                 colors
57: (8)                     The colors defining the color gradient of the vector field.
58: (4)                 kwargs
59: (8)                     Additional arguments to be passed to the :class:`~.VGroup` constructor
60: (4)                 """
61: (4)                 def __init__(
62: (8)                     self,
63: (8)                     func: Callable[[np.ndarray], np.ndarray],
64: (8)                     color: ParsableManimColor | None = None,
65: (8)                     color_scheme: Callable[[np.ndarray], float] | None = None,
66: (8)                     min_color_scheme_value: float = 0,
67: (8)                     max_color_scheme_value: float = 2,
68: (8)                     colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,
69: (8)                     **kwargs,
70: (4)                 ):
71: (8)                     super().__init__(**kwargs)
72: (8)                     self.func = func
73: (8)                     if color is None:
74: (12)                        self.single_color = False
75: (12)                        if color_scheme is None:
76: (16)                            def color_scheme(p):
77: (20)                                return np.linalg.norm(p)
78: (12)                        self.color_scheme = color_scheme  # TODO maybe other default for direction?
79: (12)                        self.rgbs = np.array(list(map(color_to_rgb, colors)))
80: (12)                        def pos_to_rgb(pos: np.ndarray) -> tuple[float, float, float, float]:
81: (16)                            vec = self.func(pos)
82: (16)                            color_value = np.clip(
83: (20)                                self.color_scheme(vec),
84: (20)                                min_color_scheme_value,
85: (20)                                max_color_scheme_value,
86: (16)                            )
87: (16)                            alpha = inverse_interpolate(
88: (20)                                min_color_scheme_value,
89: (20)                                max_color_scheme_value,
90: (20)                                color_value,
91: (16)                            )
92: (16)                            alpha *= len(self.rgbs) - 1
93: (16)                            c1 = self.rgbs[int(alpha)]
94: (16)                            c2 = self.rgbs[min(int(alpha + 1), len(self.rgbs) - 1)]
95: (16)                            alpha %= 1
96: (16)                            return interpolate(c1, c2, alpha)
97: (12)                        self.pos_to_rgb = pos_to_rgb
98: (12)                        self.pos_to_color = lambda pos: rgb_to_color(self.pos_to_rgb(pos))
99: (8)                     else:
100: (12)                       self.single_color = True
101: (12)                       self.color = ManimColor.parse(color)
102: (8)                    self.submob_movement_updater = None
103: (4)                @staticmethod
104: (4)                def shift_func(
105: (8)                    func: Callable[[np.ndarray], np.ndarray],
106: (8)                    shift_vector: np.ndarray,
107: (4)                ) -> Callable[[np.ndarray], np.ndarray]:
108: (8)                    """Shift a vector field function.
109: (8)                    Parameters
110: (8)                    ----------
111: (8)                    func
112: (12)                       The function defining a vector field.
113: (8)                    shift_vector
114: (12)                       The shift to be applied to the vector field.
115: (8)                    Returns
116: (8)                    -------
117: (8)                    `Callable[[np.ndarray], np.ndarray]`
118: (12)                       The shifted vector field function.
119: (8)                    """
120: (8)                    return lambda p: func(p - shift_vector)
121: (4)                @staticmethod
122: (4)                def scale_func(
123: (8)                    func: Callable[[np.ndarray], np.ndarray],
124: (8)                    scalar: float,
125: (4)                ) -> Callable[[np.ndarray], np.ndarray]:
126: (8)                    """Scale a vector field function.
127: (8)                    Parameters
128: (8)                    ----------
129: (8)                    func
130: (12)                       The function defining a vector field.
131: (8)                    scalar
132: (12)                       The scalar to be applied to the vector field.
133: (8)                    Examples
134: (8)                    --------
135: (8)                    .. manim:: ScaleVectorFieldFunction
136: (12)                       class ScaleVectorFieldFunction(Scene):
137: (16)                           def construct(self):
138: (20)                               func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP
139: (20)                               vector_field = ArrowVectorField(func)
140: (20)                               self.add(vector_field)
141: (20)                               self.wait()
142: (20)                               func = VectorField.scale_func(func, 0.5)
143: (20)                               self.play(vector_field.animate.become(ArrowVectorField(func)))
144: (20)                               self.wait()
145: (8)                    Returns
146: (8)                    -------
147: (8)                    `Callable[[np.ndarray], np.ndarray]`
148: (12)                       The scaled vector field function.
149: (8)                    """
150: (8)                    return lambda p: func(p * scalar)
151: (4)                def fit_to_coordinate_system(self, coordinate_system: CoordinateSystem):
152: (8)                    """Scale the vector field to fit a coordinate system.
153: (8)                    This method is useful when the vector field is defined in a coordinate system
154: (8)                    different from the one used to display the vector field.
155: (8)                    This method can only be used once because it transforms the origin of each vector.
156: (8)                    Parameters
157: (8)                    ----------
158: (8)                    coordinate_system
159: (12)                       The coordinate system to fit the vector field to.
160: (8)                    """
161: (8)                    self.apply_function(lambda pos: coordinate_system.coords_to_point(*pos))
162: (4)                def nudge(
163: (8)                    self,
164: (8)                    mob: Mobject,
165: (8)                    dt: float = 1,
166: (8)                    substeps: int = 1,
167: (8)                    pointwise: bool = False,
168: (4)                ) -> VectorField:
169: (8)                    """Nudge a :class:`~.Mobject` along the vector field.
170: (8)                    Parameters
171: (8)                    ----------
172: (8)                    mob
173: (12)                       The mobject to move along the vector field
174: (8)                    dt
175: (12)                       A scalar to the amount the mobject is moved along the vector field.
176: (12)                       The actual distance is based on the magnitude of the vector field.
177: (8)                    substeps
178: (12)                       The amount of steps the whole nudge is divided into. Higher values
179: (12)                       give more accurate approximations.
180: (8)                    pointwise
181: (12)                       Whether to move the mobject along the vector field. If `False` the
182: (12)                       vector field takes effect on the center of the given
183: (12)                       :class:`~.Mobject`. If `True` the vector field takes effect on the
184: (12)                       points of the individual points of the :class:`~.Mobject`,
185: (12)                       potentially distorting it.
186: (8)                    Returns
187: (8)                    -------
188: (8)                    VectorField
189: (12)                       This vector field.
190: (8)                    Examples
191: (8)                    --------
192: (8)                    .. manim:: Nudging
193: (12)                       class Nudging(Scene):
194: (16)                           def construct(self):
195: (20)                               func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP
196: (20)                               vector_field = ArrowVectorField(
197: (24)                                   func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2
198: (20)                               )
199: (20)                               self.add(vector_field)
200: (20)                               circle = Circle(radius=2).shift(LEFT)
201: (20)                               self.add(circle.copy().set_color(GRAY))
202: (20)                               dot = Dot().move_to(circle)
203: (20)                               vector_field.nudge(circle, -2, 60, True)
204: (20)                               vector_field.nudge(dot, -2, 60)
205: (20)                               circle.add_updater(vector_field.get_nudge_updater(pointwise=True))
206: (20)                               dot.add_updater(vector_field.get_nudge_updater())
207: (20)                               self.add(circle, dot)
208: (20)                               self.wait(6)
209: (8)                    """
210: (8)                    def runge_kutta(self, p: Sequence[float], step_size: float) -> float:
211: (12)                       """Returns the change in position of a point along a vector field.
212: (12)                       Parameters
213: (12)                       ----------
214: (12)                       p
215: (15)                          The position of each point being moved along the vector field.
216: (12)                       step_size
217: (15)                          A scalar that is used to determine how much a point is shifted in a single step.
218: (12)                       Returns
219: (12)                       -------
220: (12)                       float
221: (15)                          How much the point is shifted.
222: (12)                       """
223: (12)                       k_1 = self.func(p)
224: (12)                       k_2 = self.func(p + step_size * (k_1 * 0.5))
225: (12)                       k_3 = self.func(p + step_size * (k_2 * 0.5))
226: (12)                       k_4 = self.func(p + step_size * k_3)
227: (12)                       return step_size / 6.0 * (k_1 + 2.0 * k_2 + 2.0 * k_3 + k_4)
228: (8)                    step_size = dt / substeps
229: (8)                    for _ in range(substeps):
230: (12)                       if pointwise:
231: (16)                           mob.apply_function(lambda p: p + runge_kutta(self, p, step_size))
232: (12)                       else:
233: (16)                           mob.shift(runge_kutta(self, mob.get_center(), step_size))
234: (8)                    return self
235: (4)                def nudge_submobjects(
236: (8)                    self,
237: (8)                    dt: float = 1,
238: (8)                    substeps: int = 1,
239: (8)                    pointwise: bool = False,
240: (4)                ) -> VectorField:
241: (8)                    """Apply a nudge along the vector field to all submobjects.
242: (8)                    Parameters
243: (8)                    ----------
244: (8)                    dt
245: (12)                       A scalar to the amount the mobject is moved along the vector field.
246: (12)                       The actual distance is based on the magnitude of the vector field.
247: (8)                    substeps
248: (12)                       The amount of steps the whole nudge is divided into. Higher values
249: (12)                       give more accurate approximations.
250: (8)                    pointwise
251: (12)                       Whether to move the mobject along the vector field. See :meth:`nudge` for details.
252: (8)                    Returns
253: (8)                    -------
254: (8)                    VectorField
255: (12)                       This vector field.
256: (8)                    """
257: (8)                    for mob in self.submobjects:
258: (12)                       self.nudge(mob, dt, substeps, pointwise)
259: (8)                    return self
260: (4)                def get_nudge_updater(
261: (8)                    self,
262: (8)                    speed: float = 1,
263: (8)                    pointwise: bool = False,
264: (4)                ) -> Callable[[Mobject, float], Mobject]:
265: (8)                    """Get an update function to move a :class:`~.Mobject` along the vector field.
266: (8)                    When used with :meth:`~.Mobject.add_updater`, the mobject will move along the vector field, where its speed is determined by the magnitude of the vector field.
267: (8)                    Parameters
268: (8)                    ----------
269: (8)                    speed
270: (12)                       At `speed=1` the distance a mobject moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of such a mobject.
271: (8)                    pointwise
272: (12)                       Whether to move the mobject along the vector field. See :meth:`nudge` for details.
273: (8)                    Returns
274: (8)                    -------
275: (8)                    Callable[[Mobject, float], Mobject]
276: (12)                       The update function.
277: (8)                    """
278: (8)                    return lambda mob, dt: self.nudge(mob, dt * speed, pointwise=pointwise)
279: (4)                def start_submobject_movement(
280: (8)                    self,
281: (8)                    speed: float = 1,
282: (8)                    pointwise: bool = False,
283: (4)                ) -> VectorField:
284: (8)                    """Start continuously moving all submobjects along the vector field.
285: (8)                    Calling this method multiple times will result in removing the previous updater created by this method.
286: (8)                    Parameters
287: (8)                    ----------
288: (8)                    speed
289: (12)                       The speed at which to move the submobjects. See :meth:`get_nudge_updater` for details.
290: (8)                    pointwise
291: (12)                       Whether to move the mobject along the vector field. See :meth:`nudge` for details.
292: (8)                    Returns
293: (8)                    -------
294: (8)                    VectorField
295: (12)                       This vector field.
296: (8)                    """
297: (8)                    self.stop_submobject_movement()
298: (8)                    self.submob_movement_updater = lambda mob, dt: mob.nudge_submobjects(
299: (12)                       dt * speed,
300: (12)                       pointwise=pointwise,
301: (8)                    )
302: (8)                    self.add_updater(self.submob_movement_updater)
303: (8)                    return self
304: (4)                def stop_submobject_movement(self) -> VectorField:
305: (8)                    """Stops the continuous movement started using :meth:`start_submobject_movement`.
306: (8)                    Returns
307: (8)                    -------
308: (8)                    VectorField
309: (12)                       This vector field.
310: (8)                    """
311: (8)                    self.remove_updater(self.submob_movement_updater)
312: (8)                    self.submob_movement_updater = None
313: (8)                    return self
314: (4)                def get_colored_background_image(self, sampling_rate: int = 5) -> Image.Image:
315: (8)                    """Generate an image that displays the vector field.
316: (8)                    The color at each position is calculated by passing the positing through a
317: (8)                    series of steps:
318: (8)                    Calculate the vector field function at that position, map that vector to a
319: (8)                    single value using `self.color_scheme` and finally generate a color from
320: (8)                    that value using the color gradient.
321: (8)                    Parameters
322: (8)                    ----------
323: (8)                    sampling_rate
324: (12)                       The stepsize at which pixels get included in the image. Lower values give
325: (12)                       more accurate results, but may take a long time to compute.
326: (8)                    Returns
327: (8)                    -------
328: (8)                    Image.Imgae
329: (12)                       The vector field image.
330: (8)                    """
331: (8)                    if self.single_color:
332: (12)                       raise ValueError(
333: (16)                           "There is no point in generating an image if the vector field uses a single color.",
334: (12)                       )
335: (8)                    ph = int(config["pixel_height"] / sampling_rate)
336: (8)                    pw = int(config["pixel_width"] / sampling_rate)
337: (8)                    fw = config["frame_width"]
338: (8)                    fh = config["frame_height"]
339: (8)                    points_array = np.zeros((ph, pw, 3))
340: (8)                    x_array = np.linspace(-fw / 2, fw / 2, pw)
341: (8)                    y_array = np.linspace(fh / 2, -fh / 2, ph)
342: (8)                    x_array = x_array.reshape((1, len(x_array)))
343: (8)                    y_array = y_array.reshape((len(y_array), 1))
344: (8)                    x_array = x_array.repeat(ph, axis=0)
345: (8)                    y_array.repeat(pw, axis=1)  # TODO why not y_array = y_array.repeat(...)?
346: (8)                    points_array[:, :, 0] = x_array
347: (8)                    points_array[:, :, 1] = y_array
348: (8)                    rgbs = np.apply_along_axis(self.pos_to_rgb, 2, points_array)
349: (8)                    return Image.fromarray((rgbs * 255).astype("uint8"))
350: (4)                def get_vectorized_rgba_gradient_function(
351: (8)                    self,
352: (8)                    start: float,
353: (8)                    end: float,
354: (8)                    colors: Iterable[ParsableManimColor],
355: (4)                ):
356: (8)                    """
357: (8)                    Generates a gradient of rgbas as a numpy array
358: (8)                    Parameters
359: (8)                    ----------
360: (8)                    start
361: (12)                       start value used for inverse interpolation at :func:`~.inverse_interpolate`
362: (8)                    end
363: (12)                       end value used for inverse interpolation at :func:`~.inverse_interpolate`
364: (8)                    colors
365: (12)                       list of colors to generate the gradient
366: (8)                    Returns
367: (8)                    -------
368: (12)                       function to generate the gradients as numpy arrays representing rgba values
369: (8)                    """
370: (8)                    rgbs = np.array([color_to_rgb(c) for c in colors])
371: (8)                    def func(values, opacity=1):
372: (12)                       alphas = inverse_interpolate(start, end, np.array(values))
373: (12)                       alphas = np.clip(alphas, 0, 1)
374: (12)                       scaled_alphas = alphas * (len(rgbs) - 1)
375: (12)                       indices = scaled_alphas.astype(int)
376: (12)                       next_indices = np.clip(indices + 1, 0, len(rgbs) - 1)
377: (12)                       inter_alphas = scaled_alphas % 1
378: (12)                       inter_alphas = inter_alphas.repeat(3).reshape((len(indices), 3))
379: (12)                       result = interpolate(rgbs[indices], rgbs[next_indices], inter_alphas)
380: (12)                       result = np.concatenate(
381: (16)                           (result, np.full([len(result), 1], opacity)),
382: (16)                           axis=1,
383: (12)                       )
384: (12)                       return result
385: (8)                    return func
386: (0)            class ArrowVectorField(VectorField):
387: (4)                """A :class:`VectorField` represented by a set of change vectors.
388: (4)                Vector fields are always based on a function defining the :class:`~.Vector` at every position.
389: (4)                The values of this functions is displayed as a grid of vectors.
390: (4)                By default the color of each vector is determined by it's magnitude.
391: (4)                Other color schemes can be used however.
392: (4)                Parameters
393: (4)                ----------
394: (4)                func
395: (8)                    The function defining the rate of change at every position of the vector field.
396: (4)                color
397: (8)                    The color of the vector field. If set, position-specific coloring is disabled.
398: (4)                color_scheme
399: (8)                    A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.
400: (4)                min_color_scheme_value
401: (8)                    The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.
402: (4)                max_color_scheme_value
403: (8)                    The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.
404: (4)                colors
405: (8)                    The colors defining the color gradient of the vector field.
406: (4)                x_range
407: (8)                    A sequence of x_min, x_max, delta_x
408: (4)                y_range
409: (8)                    A sequence of y_min, y_max, delta_y
410: (4)                z_range
411: (8)                    A sequence of z_min, z_max, delta_z
412: (4)                three_dimensions
413: (8)                    Enables three_dimensions. Default set to False, automatically turns True if
414: (8)                    z_range is not None.
415: (4)                length_func
416: (8)                    The function determining the displayed size of the vectors. The actual size
417: (8)                    of the vector is passed, the returned value will be used as display size for the
418: (8)                    vector. By default this is used to cap the displayed size of vectors to reduce the clutter.
419: (4)                opacity
420: (8)                    The opacity of the arrows.
421: (4)                vector_config
422: (8)                    Additional arguments to be passed to the :class:`~.Vector` constructor
423: (4)                kwargs
424: (8)                    Additional arguments to be passed to the :class:`~.VGroup` constructor
425: (4)                Examples
426: (4)                --------
427: (4)                .. manim:: BasicUsage
428: (8)                    :save_last_frame:
429: (8)                    class BasicUsage(Scene):
430: (12)                       def construct(self):
431: (16)                           func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3
432: (16)                           self.add(ArrowVectorField(func))
433: (4)                .. manim:: SizingAndSpacing
434: (8)                    class SizingAndSpacing(Scene):
435: (12)                       def construct(self):
436: (16)                           func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
437: (16)                           vf = ArrowVectorField(func, x_range=[-7, 7, 1])
438: (16)                           self.add(vf)
439: (16)                           self.wait()
440: (16)                           length_func = lambda x: x / 3
441: (16)                           vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)
442: (16)                           self.play(vf.animate.become(vf2))
443: (16)                           self.wait()
444: (4)                .. manim:: Coloring
445: (8)                    :save_last_frame:
446: (8)                    class Coloring(Scene):
447: (12)                       def construct(self):
448: (16)                           func = lambda pos: pos - LEFT * 5
449: (16)                           colors = [RED, YELLOW, BLUE, DARK_GRAY]
450: (16)                           min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)
451: (16)                           max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)
452: (16)                           vf = ArrowVectorField(
453: (20)                               func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors
454: (16)                           )
455: (16)                           self.add(vf, min_radius, max_radius)
456: (4)                """
457: (4)                def __init__(
458: (8)                    self,
459: (8)                    func: Callable[[np.ndarray], np.ndarray],
460: (8)                    color: ParsableManimColor | None = None,
461: (8)                    color_scheme: Callable[[np.ndarray], float] | None = None,
462: (8)                    min_color_scheme_value: float = 0,
463: (8)                    max_color_scheme_value: float = 2,
464: (8)                    colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,
465: (8)                    # Determining Vector positions:
466: (8)                    x_range: Sequence[float] = None,
467: (8)                    y_range: Sequence[float] = None,
468: (8)                    z_range: Sequence[float] = None,
469: (8)                    three_dimensions: bool = False,  # Automatically True if z_range is set
470: (8)                    # Takes in actual norm, spits out displayed norm
471: (8)                    length_func: Callable[[float], float] = lambda norm: 0.45 * sigmoid(norm),
472: (8)                    opacity: float = 1.0,
473: (8)                    vector_config: dict | None = None,
474: (8)                    **kwargs,
475: (4)                ):
476: (8)                    self.x_range = x_range or [
477: (12)                       floor(-config["frame_width"] / 2),
478: (12)                       ceil(config["frame_width"] / 2),
479: (8)                    ]
480: (8)                    self.y_range = y_range or [
481: (12)                       floor(-config["frame_height"] / 2),
482: (12)                       ceil(config["frame_height"] / 2),
483: (8)                    ]
484: (8)                    self.ranges = [self.x_range, self.y_range]
485: (8)                    if three_dimensions or z_range:
486: (12)                       self.z_range = z_range or self.y_range.copy()
487: (12)                       self.ranges += [self.z_range]
488: (8)                    else:
489: (12)                       self.ranges += [[0, 0]]
490: (8)                    for i in range(len(self.ranges)):
491: (12)                       if len(self.ranges[i]) == 2:
492: (16)                           self.ranges[i] += [0.5]
493: (12)                       self.ranges[i][1] += self.ranges[i][2]
494: (8)                    self.x_range, self.y_range, self.z_range = self.ranges
495: (8)                    super().__init__(
496: (12)                       func,
497: (12)                       color,
498: (12)                       color_scheme,
499: (12)                       min_color_scheme_value,
500: (12)                       max_color_scheme_value,
501: (12)                       colors,
502: (12)                       **kwargs,
503: (8)                    )
504: (8)                    self.length_func = length_func
505: (8)                    self.opacity = opacity
506: (8)                    if vector_config is None:
507: (12)                       vector_config = {}
508: (8)                    self.vector_config = vector_config
509: (8)                    self.func = func
510: (8)                    x_range = np.arange(*self.x_range)
511: (8)                    y_range = np.arange(*self.y_range)
512: (8)                    z_range = np.arange(*self.z_range)
513: (8)                    self.add(
514: (12)                       *[
515: (16)                           self.get_vector(x * RIGHT + y * UP + z * OUT)
516: (16)                           for x, y, z in it.product(x_range, y_range, z_range)
517: (12)                       ]
518: (8)                    )
519: (8)                    self.set_opacity(self.opacity)
520: (4)                def get_vector(self, point: np.ndarray):
521: (8)                    """Creates a vector in the vector field.
522: (8)                    The created vector is based on the function of the vector field and is
523: (8)                    rooted in the given point. Color and length fit the specifications of
524: (8)                    this vector field.
525: (8)                    Parameters
526: (8)                    ----------
527: (8)                    point
528: (12)                       The root point of the vector.
529: (8)                    """
530: (8)                    output = np.array(self.func(point))
531: (8)                    norm = np.linalg.norm(output)
532: (8)                    if norm != 0:
533: (12)                       output *= self.length_func(norm) / norm
534: (8)                    vect = Vector(output, **self.vector_config)
535: (8)                    vect.shift(point)
536: (8)                    if self.single_color:
537: (12)                       vect.set_color(self.color)
538: (8)                    else:
539: (12)                       vect.set_color(self.pos_to_color(point))
540: (8)                    return vect
541: (0)            class StreamLines(VectorField):
542: (4)                """StreamLines represent the flow of a :class:`VectorField` using the trace of moving agents.
543: (4)                Vector fields are always based on a function defining the vector at every position.
544: (4)                The values of this functions is displayed by moving many agents along the vector field
545: (4)                and showing their trace.
546: (4)                Parameters
547: (4)                ----------
548: (4)                func
549: (8)                    The function defining the rate of change at every position of the vector field.
550: (4)                color
551: (8)                    The color of the vector field. If set, position-specific coloring is disabled.
552: (4)                color_scheme
553: (8)                    A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.
554: (4)                min_color_scheme_value
555: (8)                    The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.
556: (4)                max_color_scheme_value
557: (8)                    The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.
558: (4)                colors
559: (8)                    The colors defining the color gradient of the vector field.
560: (4)                x_range
561: (8)                    A sequence of x_min, x_max, delta_x
562: (4)                y_range
563: (8)                    A sequence of y_min, y_max, delta_y
564: (4)                z_range
565: (8)                    A sequence of z_min, z_max, delta_z
566: (4)                three_dimensions
567: (8)                    Enables three_dimensions. Default set to False, automatically turns True if
568: (8)                    z_range is not None.
569: (4)                noise_factor
570: (8)                    The amount by which the starting position of each agent is altered along each axis. Defaults to :code:`delta_y / 2` if not defined.
571: (4)                n_repeats
572: (8)                    The number of agents generated at each starting point.
573: (4)                dt
574: (8)                    The factor by which the distance an agent moves per step is stretched. Lower values result in a better approximation of the trajectories in the vector field.
575: (4)                virtual_time
576: (8)                    The time the agents get to move in the vector field. Higher values therefore result in longer stream lines. However, this whole time gets simulated upon creation.
577: (4)                max_anchors_per_line
578: (8)                    The maximum number of anchors per line. Lines with more anchors get reduced in complexity, not in length.
579: (4)                padding
580: (8)                    The distance agents can move out of the generation area before being terminated.
581: (4)                stroke_width
582: (8)                    The stroke with of the stream lines.
583: (4)                opacity
584: (8)                    The opacity of the stream lines.
585: (4)                Examples
586: (4)                --------
587: (4)                .. manim:: BasicUsage
588: (8)                    :save_last_frame:
589: (8)                    class BasicUsage(Scene):
590: (12)                       def construct(self):
591: (16)                           func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3
592: (16)                           self.add(StreamLines(func))
593: (4)                .. manim:: SpawningAndFlowingArea
594: (8)                    :save_last_frame:
595: (8)                    class SpawningAndFlowingArea(Scene):
596: (12)                       def construct(self):
597: (16)                           func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5
598: (16)                           stream_lines = StreamLines(
599: (20)                               func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1
600: (16)                           )
601: (16)                           spawning_area = Rectangle(width=6, height=4)
602: (16)                           flowing_area = Rectangle(width=8, height=6)
603: (16)                           labels = [Tex("Spawning Area"), Tex("Flowing Area").shift(DOWN * 2.5)]
604: (16)                           for lbl in labels:
605: (20)                               lbl.add_background_rectangle(opacity=0.6, buff=0.05)
606: (16)                           self.add(stream_lines, spawning_area, flowing_area, *labels)
607: (4)                """
608: (4)                def __init__(
609: (8)                    self,
610: (8)                    func: Callable[[np.ndarray], np.ndarray],
611: (8)                    color: ParsableManimColor | None = None,
612: (8)                    color_scheme: Callable[[np.ndarray], float] | None = None,
613: (8)                    min_color_scheme_value: float = 0,
614: (8)                    max_color_scheme_value: float = 2,
615: (8)                    colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,
616: (8)                    # Determining stream line starting positions:
617: (8)                    x_range: Sequence[float] = None,
618: (8)                    y_range: Sequence[float] = None,
619: (8)                    z_range: Sequence[float] = None,
620: (8)                    three_dimensions: bool = False,
621: (8)                    noise_factor: float | None = None,
622: (8)                    n_repeats=1,
623: (8)                    # Determining how lines are drawn
624: (8)                    dt=0.05,
625: (8)                    virtual_time=3,
626: (8)                    max_anchors_per_line=100,
627: (8)                    padding=3,
628: (8)                    # Determining stream line appearance:
629: (8)                    stroke_width=1,
630: (8)                    opacity=1,
631: (8)                    **kwargs,
632: (4)                ):
633: (8)                    self.x_range = x_range or [
634: (12)                       floor(-config["frame_width"] / 2),
635: (12)                       ceil(config["frame_width"] / 2),
636: (8)                    ]
637: (8)                    self.y_range = y_range or [
638: (12)                       floor(-config["frame_height"] / 2),
639: (12)                       ceil(config["frame_height"] / 2),
640: (8)                    ]
641: (8)                    self.ranges = [self.x_range, self.y_range]
642: (8)                    if three_dimensions or z_range:
643: (12)                       self.z_range = z_range or self.y_range.copy()
644: (12)                       self.ranges += [self.z_range]
645: (8)                    else:
646: (12)                       self.ranges += [[0, 0]]
647: (8)                    for i in range(len(self.ranges)):
648: (12)                       if len(self.ranges[i]) == 2:
649: (16)                           self.ranges[i] += [0.5]
650: (12)                       self.ranges[i][1] += self.ranges[i][2]
651: (8)                    self.x_range, self.y_range, self.z_range = self.ranges
652: (8)                    super().__init__(
653: (12)                       func,
654: (12)                       color,
655: (12)                       color_scheme,
656: (12)                       min_color_scheme_value,
657: (12)                       max_color_scheme_value,
658: (12)                       colors,
659: (12)                       **kwargs,
660: (8)                    )
661: (8)                    self.noise_factor = (
662: (12)                       noise_factor if noise_factor is not None else self.y_range[2] / 2
663: (8)                    )
664: (8)                    self.n_repeats = n_repeats
665: (8)                    self.virtual_time = virtual_time
666: (8)                    self.max_anchors_per_line = max_anchors_per_line
667: (8)                    self.padding = padding
668: (8)                    self.stroke_width = stroke_width
669: (8)                    half_noise = self.noise_factor / 2
670: (8)                    np.random.seed(0)
671: (8)                    start_points = np.array(
672: (12)                       [
673: (16)                           (x - half_noise) * RIGHT
674: (16)                           + (y - half_noise) * UP
675: (16)                           + (z - half_noise) * OUT
676: (16)                           + self.noise_factor * np.random.random(3)
677: (16)                           for n in range(self.n_repeats)
678: (16)                           for x in np.arange(*self.x_range)
679: (16)                           for y in np.arange(*self.y_range)
680: (16)                           for z in np.arange(*self.z_range)
681: (12)                       ],
682: (8)                    )
683: (8)                    def outside_box(p):
684: (12)                       return (
685: (16)                           p[0] < self.x_range[0] - self.padding
686: (16)                           or p[0] > self.x_range[1] + self.padding - self.x_range[2]
687: (16)                           or p[1] < self.y_range[0] - self.padding
688: (16)                           or p[1] > self.y_range[1] + self.padding - self.y_range[2]
689: (16)                           or p[2] < self.z_range[0] - self.padding
690: (16)                           or p[2] > self.z_range[1] + self.padding - self.z_range[2]
691: (12)                       )
692: (8)                    max_steps = ceil(virtual_time / dt) + 1
693: (8)                    if not self.single_color:
694: (12)                       self.background_img = self.get_colored_background_image()
695: (12)                       if config["renderer"] == RendererType.OPENGL:
696: (16)                           self.values_to_rgbas = self.get_vectorized_rgba_gradient_function(
697: (20)                               min_color_scheme_value,
698: (20)                               max_color_scheme_value,
699: (20)                               colors,
700: (16)                           )
701: (8)                    for point in start_points:
702: (12)                       points = [point]
703: (12)                       for _ in range(max_steps):
704: (16)                           last_point = points[-1]
705: (16)                           new_point = last_point + dt * func(last_point)
706: (16)                           if outside_box(new_point):
707: (20)                               break
708: (16)                           points.append(new_point)
709: (12)                       step = max_steps
710: (12)                       if not step:
711: (16)                           continue
712: (12)                       line = get_vectorized_mobject_class()()
713: (12)                       line.duration = step * dt
714: (12)                       step = max(1, int(len(points) / self.max_anchors_per_line))
715: (12)                       line.set_points_smoothly(points[::step])
716: (12)                       if self.single_color:
717: (16)                           line.set_stroke(
718: (20)                               color=self.color, width=self.stroke_width, opacity=opacity
719: (16)                           )
720: (12)                       else:
721: (16)                           if config.renderer == RendererType.OPENGL:
722: (20)                               # scaled for compatibility with cairo
723: (20)                               line.set_stroke(width=self.stroke_width / 4.0)
724: (20)                               norms = np.array(
725: (24)                                   [np.linalg.norm(self.func(point)) for point in line.points],
726: (20)                               )
727: (20)                               line.set_rgba_array_direct(
728: (24)                                   self.values_to_rgbas(norms, opacity),
729: (24)                                   name="stroke_rgba",
730: (20)                               )
731: (16)                           else:
732: (20)                               if np.any(self.z_range != np.array([0, 0.5, 0.5])):
733: (24)                                   line.set_stroke(
734: (28)                                       [self.pos_to_color(p) for p in line.get_anchors()],
735: (24)                                   )
736: (20)                               else:
737: (24)                                   line.color_using_background_image(self.background_img)
738: (20)                               line.set_stroke(width=self.stroke_width, opacity=opacity)
739: (12)                       self.add(line)
740: (8)                    self.stream_lines = [*self.submobjects]
741: (4)                def create(
742: (8)                    self,
743: (8)                    lag_ratio: float | None = None,
744: (8)                    run_time: Callable[[float], float] | None = None,
745: (8)                    **kwargs,
746: (4)                ) -> AnimationGroup:
747: (8)                    """The creation animation of the stream lines.
748: (8)                    The stream lines appear in random order.
749: (8)                    Parameters
750: (8)                    ----------
751: (8)                    lag_ratio
752: (12)                       The lag ratio of the animation.
753: (12)                       If undefined, it will be selected so that the total animation length is 1.5 times the run time of each stream line creation.
754: (8)                    run_time
755: (12)                       The run time of every single stream line creation. The runtime of the whole animation might be longer due to the `lag_ratio`.
756: (12)                       If undefined, the virtual time of the stream lines is used as run time.
757: (8)                    Returns
758: (8)                    -------
759: (8)                    :class:`~.AnimationGroup`
760: (12)                       The creation animation of the stream lines.
761: (8)                    Examples
762: (8)                    --------
763: (8)                    .. manim:: StreamLineCreation
764: (12)                       class StreamLineCreation(Scene):
765: (16)                           def construct(self):
766: (20)                               func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos
767: (20)                               stream_lines = StreamLines(
768: (24)                                   func,
769: (24)                                   color=YELLOW,
770: (24)                                   x_range=[-7, 7, 1],
771: (24)                                   y_range=[-4, 4, 1],
772: (24)                                   stroke_width=3,
773: (24)                                   virtual_time=1,  # use shorter lines
774: (24)                                   max_anchors_per_line=5,  # better performance with fewer anchors
775: (20)                               )
776: (20)                               self.play(stream_lines.create())  # uses virtual_time as run_time
777: (20)                               self.wait()
778: (8)                    """
779: (8)                    if run_time is None:
780: (12)                       run_time = self.virtual_time
781: (8)                    if lag_ratio is None:
782: (12)                       lag_ratio = run_time / 2 / len(self.submobjects)
783: (8)                    animations = [
784: (12)                       Create(line, run_time=run_time, **kwargs) for line in self.stream_lines
785: (8)                    ]
786: (8)                    random.shuffle(animations)
787: (8)                    return AnimationGroup(*animations, lag_ratio=lag_ratio)
788: (4)                def start_animation(
789: (8)                    self,
790: (8)                    warm_up: bool = True,
791: (8)                    flow_speed: float = 1,
792: (8)                    time_width: float = 0.3,
793: (8)                    rate_func: Callable[[float], float] = linear,
794: (8)                    line_animation_class: type[ShowPassingFlash] = ShowPassingFlash,
795: (8)                    **kwargs,
796: (4)                ) -> None:
797: (8)                    """Animates the stream lines using an updater.
798: (8)                    The stream lines will continuously flow
799: (8)                    Parameters
800: (8)                    ----------
801: (8)                    warm_up
802: (12)                       If `True` the animation is initialized line by line. Otherwise it starts with all lines shown.
803: (8)                    flow_speed
804: (12)                       At `flow_speed=1` the distance the flow moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of this flow.
805: (8)                    time_width
806: (12)                       The proportion of the stream line shown while being animated
807: (8)                    rate_func
808: (12)                       The rate function of each stream line flashing
809: (8)                    line_animation_class
810: (12)                       The animation class being used
811: (8)                    Examples
812: (8)                    --------
813: (8)                    .. manim:: ContinuousMotion
814: (12)                       class ContinuousMotion(Scene):
815: (16)                           def construct(self):
816: (20)                               func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
817: (20)                               stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)
818: (20)                               self.add(stream_lines)
819: (20)                               stream_lines.start_animation(warm_up=False, flow_speed=1.5)
820: (20)                               self.wait(stream_lines.virtual_time / stream_lines.flow_speed)
821: (8)                    """
822: (8)                    for line in self.stream_lines:
823: (12)                       run_time = line.duration / flow_speed
824: (12)                       line.anim = line_animation_class(
825: (16)                           line,
826: (16)                           run_time=run_time,
827: (16)                           rate_func=rate_func,
828: (16)                           time_width=time_width,
829: (16)                           **kwargs,
830: (12)                       )
831: (12)                       line.anim.begin()
832: (12)                       line.time = random.random() * self.virtual_time
833: (12)                       if warm_up:
834: (16)                           line.time *= -1
835: (12)                       self.add(line.anim.mobject)
836: (8)                    def updater(mob, dt):
837: (12)                       for line in mob.stream_lines:
838: (16)                           line.time += dt * flow_speed
839: (16)                           if line.time >= self.virtual_time:
840: (20)                               line.time -= self.virtual_time
841: (16)                           line.anim.interpolate(np.clip(line.time / line.anim.run_time, 0, 1))
842: (8)                    self.add_updater(updater)
843: (8)                    self.flow_animation = updater
844: (8)                    self.flow_speed = flow_speed
845: (8)                    self.time_width = time_width
846: (4)                def end_animation(self) -> AnimationGroup:
847: (8)                    """End the stream line animation smoothly.
848: (8)                    Returns an animation resulting in fully displayed stream lines without a noticeable cut.
849: (8)                    Returns
850: (8)                    -------
851: (8)                    :class:`~.AnimationGroup`
852: (12)                       The animation fading out the running stream animation.
853: (8)                    Raises
854: (8)                    ------
855: (8)                    ValueError
856: (12)                       if no stream line animation is running
857: (8)                    Examples
858: (8)                    --------
859: (8)                    .. manim:: EndAnimation
860: (12)                       class EndAnimation(Scene):
861: (16)                           def construct(self):
862: (20)                               func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
863: (20)                               stream_lines = StreamLines(
864: (24)                                   func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE
865: (20)                               )
866: (20)                               self.add(stream_lines)
867: (20)                               stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)
868: (20)                               self.wait(1)
869: (20)                               self.play(stream_lines.end_animation())
870: (8)                    """
871: (8)                    if self.flow_animation is None:
872: (12)                       raise ValueError("You have to start the animation before fading it out.")
873: (8)                    def hide_and_wait(mob, alpha):
874: (12)                       if alpha == 0:
875: (16)                           mob.set_stroke(opacity=0)
876: (12)                       elif alpha == 1:
877: (16)                           mob.set_stroke(opacity=1)
878: (8)                    def finish_updater_cycle(line, alpha):
879: (12)                       line.time += dt * self.flow_speed
880: (12)                       line.anim.interpolate(min(line.time / line.anim.run_time, 1))
881: (12)                       if alpha == 1:
882: (16)                           self.remove(line.anim.mobject)
883: (16)                           line.anim.finish()
884: (8)                    max_run_time = self.virtual_time / self.flow_speed
885: (8)                    creation_rate_func = ease_out_sine
886: (8)                    creation_staring_speed = creation_rate_func(0.001) * 1000
887: (8)                    creation_run_time = (
888: (12)                       max_run_time / (1 + self.time_width) * creation_staring_speed
889: (8)                    )
890: (8)                    # creation_run_time is calculated so that the creation animation starts at the same speed
891: (8)                    # as the regular line flash animation but eases out.
892: (8)                    dt = 1 / config["frame_rate"]
893: (8)                    animations = []
894: (8)                    self.remove_updater(self.flow_animation)
895: (8)                    self.flow_animation = None
896: (8)                    for line in self.stream_lines:
897: (12)                       create = Create(
898: (16)                           line,
899: (16)                           run_time=creation_run_time,
900: (16)                           rate_func=creation_rate_func,
901: (12)                       )
902: (12)                       if line.time <= 0:
903: (16)                           animations.append(
904: (20)                               Succession(
905: (24)                                   UpdateFromAlphaFunc(
906: (28)                                       line,
907: (28)                                       hide_and_wait,
908: (28)                                       run_time=-line.time / self.flow_speed,
909: (24)                                   ),
910: (24)                                   create,
911: (20)                               ),
912: (16)                           )
913: (16)                           self.remove(line.anim.mobject)
914: (16)                           line.anim.finish()
915: (12)                       else:
916: (16)                           remaining_time = max_run_time - line.time / self.flow_speed
917: (16)                           animations.append(
918: (20)                               Succession(
919: (24)                                   UpdateFromAlphaFunc(
920: (28)                                       line,
921: (28)                                       finish_updater_cycle,
922: (28)                                       run_time=remaining_time,
923: (24)                                   ),
924: (24)                                   create,
925: (20)                               ),
926: (16)                           )
927: (8)                    return AnimationGroup(*animations)
928: (0)            # TODO: Variant of StreamLines that is able to respond to changes in the vector field function

----------------------------------------

File 50 - . \value_tracker.py:

1: (0)              """Simple mobjects that can be used for storing (and updating) a value."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["ValueTracker", "ComplexValueTracker"]
4: (0)              import numpy as np
5: (0)              from manim.mobject.mobject import Mobject
6: (0)              from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
7: (0)              from manim.utils.paths import straight_path
8: (0)              class ValueTracker(Mobject, metaclass=ConvertToOpenGL):
9: (4)                  """A mobject that can be used for tracking (real-valued) parameters.
10: (4)                 Useful for animating parameter changes.
11: (4)                 Not meant to be displayed.  Instead the position encodes some
12: (4)                 number, often one which another animation or continual_animation
13: (4)                 uses for its update function, and by treating it as a mobject it can
14: (4)                 still be animated and manipulated just like anything else.
15: (4)                 This value changes continuously when animated using the :attr:`animate` syntax.
16: (4)                 Examples
17: (4)                 --------
18: (4)                 .. manim:: ValueTrackerExample
19: (8)                     class ValueTrackerExample(Scene):
20: (12)                        def construct(self):
21: (16)                            number_line = NumberLine()
22: (16)                            pointer = Vector(DOWN)
23: (16)                            label = MathTex("x").add_updater(lambda m: m.next_to(pointer, UP))
24: (16)                            tracker = ValueTracker(0)
25: (16)                            pointer.add_updater(
26: (20)                                lambda m: m.next_to(
27: (32)                                            number_line.n2p(tracker.get_value()),
28: (32)                                            UP
29: (28)                                        )
30: (16)                            )
31: (16)                            self.add(number_line, pointer,label)
32: (16)                            tracker += 1.5
33: (16)                            self.wait(1)
34: (16)                            tracker -= 4
35: (16)                            self.wait(0.5)
36: (16)                            self.play(tracker.animate.set_value(5))
37: (16)                            self.wait(0.5)
38: (16)                            self.play(tracker.animate.set_value(3))
39: (16)                            self.play(tracker.animate.increment_value(-2))
40: (16)                            self.wait(0.5)
41: (4)                 .. note::
42: (8)                     You can also link ValueTrackers to updaters. In this case, you have to make sure that the
43: (8)                     ValueTracker is added to the scene by ``add``
44: (4)                 .. manim:: ValueTrackerExample
45: (8)                     class ValueTrackerExample(Scene):
46: (12)                        def construct(self):
47: (16)                            tracker = ValueTracker(0)
48: (16)                            label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))
49: (16)                            self.add(label)
50: (16)                            self.add(tracker)
51: (16)                            tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))
52: (16)                            self.wait(2)
53: (4)                 """
54: (4)                 def __init__(self, value=0, **kwargs):
55: (8)                     super().__init__(**kwargs)
56: (8)                     self.set(points=np.zeros((1, 3)))
57: (8)                     self.set_value(value)
58: (4)                 def get_value(self) -> float:
59: (8)                     """Get the current value of this ValueTracker."""
60: (8)                     return self.points[0, 0]
61: (4)                 def set_value(self, value: float):
62: (8)                     """Sets a new scalar value to the ValueTracker"""
63: (8)                     self.points[0, 0] = value
64: (8)                     return self
65: (4)                 def increment_value(self, d_value: float):
66: (8)                     """Increments (adds) a scalar value  to the ValueTracker"""
67: (8)                     self.set_value(self.get_value() + d_value)
68: (8)                     return self
69: (4)                 def __bool__(self):
70: (8)                     """Return whether the value of this value tracker evaluates as true."""
71: (8)                     return bool(self.get_value())
72: (4)                 def __iadd__(self, d_value: float):
73: (8)                     """adds ``+=`` syntax to increment the value of the ValueTracker"""
74: (8)                     self.increment_value(d_value)
75: (8)                     return self
76: (4)                 def __ifloordiv__(self, d_value: float):
77: (8)                     """Set the value of this value tracker to the floor division of the current value by ``d_value``."""
78: (8)                     self.set_value(self.get_value() // d_value)
79: (8)                     return self
80: (4)                 def __imod__(self, d_value: float):
81: (8)                     """Set the value of this value tracker to the current value modulo ``d_value``."""
82: (8)                     self.set_value(self.get_value() % d_value)
83: (8)                     return self
84: (4)                 def __imul__(self, d_value: float):
85: (8)                     """Set the value of this value tracker to the product of the current value and ``d_value``."""
86: (8)                     self.set_value(self.get_value() * d_value)
87: (8)                     return self
88: (4)                 def __ipow__(self, d_value: float):
89: (8)                     """Set the value of this value tracker to the current value raised to the power of ``d_value``."""
90: (8)                     self.set_value(self.get_value() ** d_value)
91: (8)                     return self
92: (4)                 def __isub__(self, d_value: float):
93: (8)                     """adds ``-=`` syntax to decrement the value of the ValueTracker"""
94: (8)                     self.increment_value(-d_value)
95: (8)                     return self
96: (4)                 def __itruediv__(self, d_value: float):
97: (8)                     """Sets the value of this value tracker to the current value divided by ``d_value``."""
98: (8)                     self.set_value(self.get_value() / d_value)
99: (8)                     return self
100: (4)                def interpolate(self, mobject1, mobject2, alpha, path_func=straight_path()):
101: (8)                    """
102: (8)                    Turns self into an interpolation between mobject1
103: (8)                    and mobject2.
104: (8)                    """
105: (8)                    self.set(points=path_func(mobject1.points, mobject2.points, alpha))
106: (8)                    return self
107: (0)            class ComplexValueTracker(ValueTracker):
108: (4)                """Tracks a complex-valued parameter.
109: (4)                When the value is set through :attr:`animate`, the value will take a straight path from the
110: (4)                source point to the destination point.
111: (4)                Examples
112: (4)                --------
113: (4)                .. manim:: ComplexValueTrackerExample
114: (8)                    class ComplexValueTrackerExample(Scene):
115: (12)                       def construct(self):
116: (16)                           tracker = ComplexValueTracker(-2+1j)
117: (16)                           dot = Dot().add_updater(
118: (20)                               lambda x: x.move_to(tracker.points)
119: (16)                           )
120: (16)                           self.add(NumberPlane(), dot)
121: (16)                           self.play(tracker.animate.set_value(3+2j))
122: (16)                           self.play(tracker.animate.set_value(tracker.get_value() * 1j))
123: (16)                           self.play(tracker.animate.set_value(tracker.get_value() - 2j))
124: (16)                           self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))
125: (4)                """
126: (4)                def get_value(self):
127: (8)                    """Get the current value of this value tracker as a complex number.
128: (8)                    The value is internally stored as a points array [a, b, 0]. This can be accessed directly
129: (8)                    to represent the value geometrically, see the usage example."""
130: (8)                    return complex(*self.points[0, :2])
131: (4)                def set_value(self, z):
132: (8)                    """Sets a new complex value to the ComplexValueTracker"""
133: (8)                    z = complex(z)
134: (8)                    self.points[0, :2] = (z.real, z.imag)
135: (8)                    return self

----------------------------------------

File 51 - . \SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRYCOMBINER_aligner_20_characters_for_pythons_codes.py:

1: (0)              import os
2: (0)              from datetime import datetime
3: (0)              def get_file_info(root_folder):
4: (4)                  file_info_list = []
5: (4)                  for root, dirs, files in os.walk(root_folder):
6: (8)                      for file in files:
7: (12)                         try:
8: (16)                             # Check if the file is a Python file
9: (16)                             if file.endswith('.py'):
10: (20)                                file_path = os.path.join(root, file)
11: (20)                                # Get file times
12: (20)                                creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
13: (20)                                modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))
14: (20)                                # Get file extension
15: (20)                                file_extension = os.path.splitext(file)[1].lower()
16: (20)                                # Append file info to list
17: (20)                                file_info_list.append([file, file_path, creation_time, modified_time, file_extension, root])
18: (12)                        except Exception as e:
19: (16)                            print(f"Error processing file {file}: {e}")
20: (4)                 # Sort the files by multiple criteria
21: (4)                 file_info_list.sort(key=lambda x: (x[2], x[3], len(x[0]), x[4]))  # Sort by creation, modification time, name length, extension
22: (4)                 return file_info_list
23: (0)             def process_file(file_info_list):
24: (4)                 combined_output = []
25: (4)                 for idx, (file_name, file_path, creation_time, modified_time, file_extension, root) in enumerate(file_info_list):
26: (8)                     with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
27: (12)                        content = f.read()
28: (12)                        # Remove Python comments and blank lines
29: (10)                      ###  content = "\n".join([line for line in content.split('\n') if line.strip() and not line.strip().startswith("#")])
30: (12)                        content = "\n".join([line for line in content.split('\n') if line.strip() ])###and not line.strip().startswith("#")
31: (12)                        # Replace tabs with spaces
32: (12)                        content = content.replace('\t', '    ')
33: (12)                        # Process each line
34: (12)                        processed_lines = []
35: (12)                        for i, line in enumerate(content.split('\n')):
36: (16)                            # Count the number of starting blank spaces
37: (16)                            leading_spaces = len(line) - len(line.lstrip(' '))
38: (16)                            # Create the line with line number and leading spaces count
39: (16)                            line_number_str = f"{i+1}: ({leading_spaces})"
40: (16)                            # Calculate padding to align the original code at the 61st character
41: (16)                            padding = ' ' * (20 - len(line_number_str))
42: (16)                            processed_line = f"{line_number_str}{padding}{line}"
43: (16)                            processed_lines.append(processed_line)
44: (12)                        content_with_line_numbers = "\n".join(processed_lines)
45: (12)                        # Add file listing order and line number
46: (12)                        combined_output.append(f"File {idx + 1} - {root} \\{file_name}:\n")
47: (12)                        combined_output.append(content_with_line_numbers)
48: (12)                        combined_output.append("\n" + "-"*40 + "\n")
49: (4)                 return combined_output
50: (0)             # Set the root folder path
51: (0)             root_folder_path = '.'  # Set this to the desired folder
52: (0)             # Get file information and process files
53: (0)             file_info_list = get_file_info(root_folder_path)
54: (0)             combined_output = process_file(file_info_list)
55: (0)             # Save the processed data to an output file
56: (0)             output_file = 'WITHRELPATH_COMMENTSKEPT_SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRY_combined_python_files_20_chars.txt'
57: (0)             with open(output_file, 'w', encoding='utf-8') as logfile:
58: (4)                 logfile.write("\n".join(combined_output))
59: (0)             print(f"Processed file info logged to {output_file}")

----------------------------------------
