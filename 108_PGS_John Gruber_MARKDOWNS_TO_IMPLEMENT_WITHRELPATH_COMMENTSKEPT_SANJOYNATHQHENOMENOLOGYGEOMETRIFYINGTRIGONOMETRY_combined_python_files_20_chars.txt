File 1 - . \__init__.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # - Documentation: https://python-markdown.github.io/
4: (0)              # - GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # - PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # - Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # - Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # - Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             Python-Markdown provides two public functions ([`markdown.markdown`][] and [`markdown.markdownFromFile`][])
16: (0)             both of which wrap the public class [`markdown.Markdown`][]. All submodules support these public functions
17: (0)             and class and/or provide extension support.
18: (0)             Modules:
19: (4)                 core: Core functionality.
20: (4)                 preprocessors: Pre-processors.
21: (4)                 blockparser: Core Markdown block parser.
22: (4)                 blockprocessors: Block processors.
23: (4)                 treeprocessors: Tree processors.
24: (4)                 inlinepatterns: Inline patterns.
25: (4)                 postprocessors: Post-processors.
26: (4)                 serializers: Serializers.
27: (4)                 util: Utility functions.
28: (4)                 htmlparser: HTML parser.
29: (4)                 test_tools: Testing utilities.
30: (4)                 extensions: Markdown extensions.
31: (0)             """
32: (0)             from __future__ import annotations
33: (0)             from .core import Markdown, markdown, markdownFromFile
34: (0)             from .__meta__ import __version__, __version_info__  # noqa
35: (0)             # For backward compatibility as some extensions expect it...
36: (0)             from .extensions import Extension  # noqa
37: (0)             __all__ = ['Markdown', 'markdown', 'markdownFromFile']

----------------------------------------

File 2 - . \__main__.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             from __future__ import annotations
15: (0)             import sys
16: (0)             import optparse
17: (0)             import codecs
18: (0)             import warnings
19: (0)             import markdown
20: (0)             try:
21: (4)                 # We use `unsafe_load` because users may need to pass in actual Python
22: (4)                 # objects. As this is only available from the CLI, the user has much
23: (4)                 # worse problems if an attacker can use this as an attach vector.
24: (4)                 from yaml import unsafe_load as yaml_load
25: (0)             except ImportError:  # pragma: no cover
26: (4)                 try:
27: (8)                     # Fall back to PyYAML <5.1
28: (8)                     from yaml import load as yaml_load
29: (4)                 except ImportError:
30: (8)                     # Fall back to JSON
31: (8)                     from json import load as yaml_load
32: (0)             import logging
33: (0)             from logging import DEBUG, WARNING, CRITICAL
34: (0)             logger = logging.getLogger('MARKDOWN')
35: (0)             def parse_options(args=None, values=None):
36: (4)                 """
37: (4)                 Define and parse `optparse` options for command-line usage.
38: (4)                 """
39: (4)                 usage = """%prog [options] [INPUTFILE]
40: (7)                    (STDIN is assumed if no INPUTFILE is given)"""
41: (4)                 desc = "A Python implementation of John Gruber's Markdown. " \
42: (11)                       "https://Python-Markdown.github.io/"
43: (4)                 ver = "%%prog %s" % markdown.__version__
44: (4)                 parser = optparse.OptionParser(usage=usage, description=desc, version=ver)
45: (4)                 parser.add_option("-f", "--file", dest="filename", default=None,
46: (22)                                  help="Write output to OUTPUT_FILE. Defaults to STDOUT.",
47: (22)                                  metavar="OUTPUT_FILE")
48: (4)                 parser.add_option("-e", "--encoding", dest="encoding",
49: (22)                                  help="Encoding for input and output files.",)
50: (4)                 parser.add_option("-o", "--output_format", dest="output_format",
51: (22)                                  default='xhtml', metavar="OUTPUT_FORMAT",
52: (22)                                  help="Use output format 'xhtml' (default) or 'html'.")
53: (4)                 parser.add_option("-n", "--no_lazy_ol", dest="lazy_ol",
54: (22)                                  action='store_false', default=True,
55: (22)                                  help="Observe number of first item of ordered lists.")
56: (4)                 parser.add_option("-x", "--extension", action="append", dest="extensions",
57: (22)                                  help="Load extension EXTENSION.", metavar="EXTENSION")
58: (4)                 parser.add_option("-c", "--extension_configs",
59: (22)                                  dest="configfile", default=None,
60: (22)                                  help="Read extension configurations from CONFIG_FILE. "
61: (22)                                  "CONFIG_FILE must be of JSON or YAML format. YAML "
62: (22)                                  "format requires that a python YAML library be "
63: (22)                                  "installed. The parsed JSON or YAML must result in a "
64: (22)                                  "python dictionary which would be accepted by the "
65: (22)                                  "'extension_configs' keyword on the markdown.Markdown "
66: (22)                                  "class. The extensions must also be loaded with the "
67: (22)                                  "`--extension` option.",
68: (22)                                  metavar="CONFIG_FILE")
69: (4)                 parser.add_option("-q", "--quiet", default=CRITICAL,
70: (22)                                  action="store_const", const=CRITICAL+10, dest="verbose",
71: (22)                                  help="Suppress all warnings.")
72: (4)                 parser.add_option("-v", "--verbose",
73: (22)                                  action="store_const", const=WARNING, dest="verbose",
74: (22)                                  help="Print all warnings.")
75: (4)                 parser.add_option("--noisy",
76: (22)                                  action="store_const", const=DEBUG, dest="verbose",
77: (22)                                  help="Print debug messages.")
78: (4)                 (options, args) = parser.parse_args(args, values)
79: (4)                 if len(args) == 0:
80: (8)                     input_file = None
81: (4)                 else:
82: (8)                     input_file = args[0]
83: (4)                 if not options.extensions:
84: (8)                     options.extensions = []
85: (4)                 extension_configs = {}
86: (4)                 if options.configfile:
87: (8)                     with codecs.open(
88: (12)                        options.configfile, mode="r", encoding=options.encoding
89: (8)                     ) as fp:
90: (12)                        try:
91: (16)                            extension_configs = yaml_load(fp)
92: (12)                        except Exception as e:
93: (16)                            message = "Failed parsing extension config file: %s" % \
94: (26)                                      options.configfile
95: (16)                            e.args = (message,) + e.args[1:]
96: (16)                            raise
97: (4)                 opts = {
98: (8)                     'input': input_file,
99: (8)                     'output': options.filename,
100: (8)                    'extensions': options.extensions,
101: (8)                    'extension_configs': extension_configs,
102: (8)                    'encoding': options.encoding,
103: (8)                    'output_format': options.output_format,
104: (8)                    'lazy_ol': options.lazy_ol
105: (4)                }
106: (4)                return opts, options.verbose
107: (0)            def run():  # pragma: no cover
108: (4)                """Run Markdown from the command line."""
109: (4)                # Parse options and adjust logging level if necessary
110: (4)                options, logging_level = parse_options()
111: (4)                if not options:
112: (8)                    sys.exit(2)
113: (4)                logger.setLevel(logging_level)
114: (4)                console_handler = logging.StreamHandler()
115: (4)                logger.addHandler(console_handler)
116: (4)                if logging_level <= WARNING:
117: (8)                    # Ensure deprecation warnings get displayed
118: (8)                    warnings.filterwarnings('default')
119: (8)                    logging.captureWarnings(True)
120: (8)                    warn_logger = logging.getLogger('py.warnings')
121: (8)                    warn_logger.addHandler(console_handler)
122: (4)                # Run
123: (4)                markdown.markdownFromFile(**options)
124: (0)            if __name__ == '__main__':  # pragma: no cover
125: (4)                # Support running module as a command line command.
126: (4)                #     python -m markdown [options] [args]
127: (4)                run()

----------------------------------------

File 3 - . \__meta__.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             # __version_info__ format:
15: (0)             #     (major, minor, patch, dev/alpha/beta/rc/final, #)
16: (0)             #     (1, 1, 2, 'dev', 0) => "1.1.2.dev0"
17: (0)             #     (1, 1, 2, 'alpha', 1) => "1.1.2a1"
18: (0)             #     (1, 2, 0, 'beta', 2) => "1.2b2"
19: (0)             #     (1, 2, 0, 'rc', 4) => "1.2rc4"
20: (0)             #     (1, 2, 0, 'final', 0) => "1.2"
21: (0)             from __future__ import annotations
22: (0)             __version_info__ = (3, 7, 0, 'final', 0)
23: (0)             def _get_version(version_info):
24: (4)                 " Returns a PEP 440-compliant version number from `version_info`. "
25: (4)                 assert len(version_info) == 5
26: (4)                 assert version_info[3] in ('dev', 'alpha', 'beta', 'rc', 'final')
27: (4)                 parts = 2 if version_info[2] == 0 else 3
28: (4)                 v = '.'.join(map(str, version_info[:parts]))
29: (4)                 if version_info[3] == 'dev':
30: (8)                     v += '.dev' + str(version_info[4])
31: (4)                 elif version_info[3] != 'final':
32: (8)                     mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'rc'}
33: (8)                     v += mapping[version_info[3]] + str(version_info[4])
34: (4)                 return v
35: (0)             __version__ = _get_version(__version_info__)

----------------------------------------

File 4 - . \blockparser.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             The block parser handles basic parsing of Markdown blocks.  It doesn't concern
16: (0)             itself with inline elements such as `**bold**` or `*italics*`, but rather just
17: (0)             catches blocks, lists, quotes, etc.
18: (0)             The `BlockParser` is made up of a bunch of `BlockProcessors`, each handling a
19: (0)             different type of block. Extensions may add/replace/remove `BlockProcessors`
20: (0)             as they need to alter how Markdown blocks are parsed.
21: (0)             """
22: (0)             from __future__ import annotations
23: (0)             import xml.etree.ElementTree as etree
24: (0)             from typing import TYPE_CHECKING, Iterable, Any
25: (0)             from . import util
26: (0)             if TYPE_CHECKING:  # pragma: no cover
27: (4)                 from markdown import Markdown
28: (4)                 from .blockprocessors import BlockProcessor
29: (0)             class State(list):
30: (4)                 """ Track the current and nested state of the parser.
31: (4)                 This utility class is used to track the state of the `BlockParser` and
32: (4)                 support multiple levels if nesting. It's just a simple API wrapped around
33: (4)                 a list. Each time a state is set, that state is appended to the end of the
34: (4)                 list. Each time a state is reset, that state is removed from the end of
35: (4)                 the list.
36: (4)                 Therefore, each time a state is set for a nested block, that state must be
37: (4)                 reset when we back out of that level of nesting or the state could be
38: (4)                 corrupted.
39: (4)                 While all the methods of a list object are available, only the three
40: (4)                 defined below need be used.
41: (4)                 """
42: (4)                 def set(self, state: Any):
43: (8)                     """ Set a new state. """
44: (8)                     self.append(state)
45: (4)                 def reset(self) -> None:
46: (8)                     """ Step back one step in nested state. """
47: (8)                     self.pop()
48: (4)                 def isstate(self, state: Any) -> bool:
49: (8)                     """ Test that top (current) level is of given state. """
50: (8)                     if len(self):
51: (12)                        return self[-1] == state
52: (8)                     else:
53: (12)                        return False
54: (0)             class BlockParser:
55: (4)                 """ Parse Markdown blocks into an `ElementTree` object.
56: (4)                 A wrapper class that stitches the various `BlockProcessors` together,
57: (4)                 looping through them and creating an `ElementTree` object.
58: (4)                 """
59: (4)                 def __init__(self, md: Markdown):
60: (8)                     """ Initialize the block parser.
61: (8)                     Arguments:
62: (12)                        md: A Markdown instance.
63: (8)                     Attributes:
64: (12)                        BlockParser.md (Markdown): A Markdown instance.
65: (12)                        BlockParser.state (State): Tracks the nesting level of current location in document being parsed.
66: (12)                        BlockParser.blockprocessors (util.Registry): A collection of
67: (16)                            [`blockprocessors`][markdown.blockprocessors].
68: (8)                     """
69: (8)                     self.blockprocessors: util.Registry[BlockProcessor] = util.Registry()
70: (8)                     self.state = State()
71: (8)                     self.md = md
72: (4)                 def parseDocument(self, lines: Iterable[str]) -> etree.ElementTree:
73: (8)                     """ Parse a Markdown document into an `ElementTree`.
74: (8)                     Given a list of lines, an `ElementTree` object (not just a parent
75: (8)                     `Element`) is created and the root element is passed to the parser
76: (8)                     as the parent. The `ElementTree` object is returned.
77: (8)                     This should only be called on an entire document, not pieces.
78: (8)                     Arguments:
79: (12)                        lines: A list of lines (strings).
80: (8)                     Returns:
81: (12)                        An element tree.
82: (8)                     """
83: (8)                     # Create an `ElementTree` from the lines
84: (8)                     self.root = etree.Element(self.md.doc_tag)
85: (8)                     self.parseChunk(self.root, '\n'.join(lines))
86: (8)                     return etree.ElementTree(self.root)
87: (4)                 def parseChunk(self, parent: etree.Element, text: str) -> None:
88: (8)                     """ Parse a chunk of Markdown text and attach to given `etree` node.
89: (8)                     While the `text` argument is generally assumed to contain multiple
90: (8)                     blocks which will be split on blank lines, it could contain only one
91: (8)                     block. Generally, this method would be called by extensions when
92: (8)                     block parsing is required.
93: (8)                     The `parent` `etree` Element passed in is altered in place.
94: (8)                     Nothing is returned.
95: (8)                     Arguments:
96: (12)                        parent: The parent element.
97: (12)                        text: The text to parse.
98: (8)                     """
99: (8)                     self.parseBlocks(parent, text.split('\n\n'))
100: (4)                def parseBlocks(self, parent: etree.Element, blocks: list[str]) -> None:
101: (8)                    """ Process blocks of Markdown text and attach to given `etree` node.
102: (8)                    Given a list of `blocks`, each `blockprocessor` is stepped through
103: (8)                    until there are no blocks left. While an extension could potentially
104: (8)                    call this method directly, it's generally expected to be used
105: (8)                    internally.
106: (8)                    This is a public method as an extension may need to add/alter
107: (8)                    additional `BlockProcessors` which call this method to recursively
108: (8)                    parse a nested block.
109: (8)                    Arguments:
110: (12)                       parent: The parent element.
111: (12)                       blocks: The blocks of text to parse.
112: (8)                    """
113: (8)                    while blocks:
114: (12)                       for processor in self.blockprocessors:
115: (16)                           if processor.test(parent, blocks[0]):
116: (20)                               if processor.run(parent, blocks) is not False:
117: (24)                                   # run returns True or None
118: (24)                                   break

----------------------------------------

File 5 - . \blockprocessors.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             A block processor parses blocks of text and adds new elements to the ElementTree. Blocks of text,
16: (0)             separated from other text by blank lines, may have a different syntax and produce a differently
17: (0)             structured tree than other Markdown. Block processors excel at handling code formatting, equation
18: (0)             layouts, tables, etc.
19: (0)             """
20: (0)             from __future__ import annotations
21: (0)             import logging
22: (0)             import re
23: (0)             import xml.etree.ElementTree as etree
24: (0)             from typing import TYPE_CHECKING, Any
25: (0)             from . import util
26: (0)             from .blockparser import BlockParser
27: (0)             if TYPE_CHECKING:  # pragma: no cover
28: (4)                 from markdown import Markdown
29: (0)             logger = logging.getLogger('MARKDOWN')
30: (0)             def build_block_parser(md: Markdown, **kwargs: Any) -> BlockParser:
31: (4)                 """ Build the default block parser used by Markdown. """
32: (4)                 parser = BlockParser(md)
33: (4)                 parser.blockprocessors.register(EmptyBlockProcessor(parser), 'empty', 100)
34: (4)                 parser.blockprocessors.register(ListIndentProcessor(parser), 'indent', 90)
35: (4)                 parser.blockprocessors.register(CodeBlockProcessor(parser), 'code', 80)
36: (4)                 parser.blockprocessors.register(HashHeaderProcessor(parser), 'hashheader', 70)
37: (4)                 parser.blockprocessors.register(SetextHeaderProcessor(parser), 'setextheader', 60)
38: (4)                 parser.blockprocessors.register(HRProcessor(parser), 'hr', 50)
39: (4)                 parser.blockprocessors.register(OListProcessor(parser), 'olist', 40)
40: (4)                 parser.blockprocessors.register(UListProcessor(parser), 'ulist', 30)
41: (4)                 parser.blockprocessors.register(BlockQuoteProcessor(parser), 'quote', 20)
42: (4)                 parser.blockprocessors.register(ReferenceProcessor(parser), 'reference', 15)
43: (4)                 parser.blockprocessors.register(ParagraphProcessor(parser), 'paragraph', 10)
44: (4)                 return parser
45: (0)             class BlockProcessor:
46: (4)                 """ Base class for block processors.
47: (4)                 Each subclass will provide the methods below to work with the source and
48: (4)                 tree. Each processor will need to define it's own `test` and `run`
49: (4)                 methods. The `test` method should return True or False, to indicate
50: (4)                 whether the current block should be processed by this processor. If the
51: (4)                 test passes, the parser will call the processors `run` method.
52: (4)                 Attributes:
53: (8)                     BlockProcessor.parser (BlockParser): The `BlockParser` instance this is attached to.
54: (8)                     BlockProcessor.tab_length (int): The tab length set on the `Markdown` instance.
55: (4)                 """
56: (4)                 def __init__(self, parser: BlockParser):
57: (8)                     self.parser = parser
58: (8)                     self.tab_length = parser.md.tab_length
59: (4)                 def lastChild(self, parent: etree.Element) -> etree.Element | None:
60: (8)                     """ Return the last child of an `etree` element. """
61: (8)                     if len(parent):
62: (12)                        return parent[-1]
63: (8)                     else:
64: (12)                        return None
65: (4)                 def detab(self, text: str, length: int | None = None) -> tuple[str, str]:
66: (8)                     """ Remove a tab from the front of each line of the given text. """
67: (8)                     if length is None:
68: (12)                        length = self.tab_length
69: (8)                     newtext = []
70: (8)                     lines = text.split('\n')
71: (8)                     for line in lines:
72: (12)                        if line.startswith(' ' * length):
73: (16)                            newtext.append(line[length:])
74: (12)                        elif not line.strip():
75: (16)                            newtext.append('')
76: (12)                        else:
77: (16)                            break
78: (8)                     return '\n'.join(newtext), '\n'.join(lines[len(newtext):])
79: (4)                 def looseDetab(self, text: str, level: int = 1) -> str:
80: (8)                     """ Remove a tab from front of lines but allowing dedented lines. """
81: (8)                     lines = text.split('\n')
82: (8)                     for i in range(len(lines)):
83: (12)                        if lines[i].startswith(' '*self.tab_length*level):
84: (16)                            lines[i] = lines[i][self.tab_length*level:]
85: (8)                     return '\n'.join(lines)
86: (4)                 def test(self, parent: etree.Element, block: str) -> bool:
87: (8)                     """ Test for block type. Must be overridden by subclasses.
88: (8)                     As the parser loops through processors, it will call the `test`
89: (8)                     method on each to determine if the given block of text is of that
90: (8)                     type. This method must return a boolean `True` or `False`. The
91: (8)                     actual method of testing is left to the needs of that particular
92: (8)                     block type. It could be as simple as `block.startswith(some_string)`
93: (8)                     or a complex regular expression. As the block type may be different
94: (8)                     depending on the parent of the block (i.e. inside a list), the parent
95: (8)                     `etree` element is also provided and may be used as part of the test.
96: (8)                     Keyword arguments:
97: (12)                        parent: An `etree` element which will be the parent of the block.
98: (12)                        block: A block of text from the source which has been split at blank lines.
99: (8)                     """
100: (8)                    pass  # pragma: no cover
101: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> bool | None:
102: (8)                    """ Run processor. Must be overridden by subclasses.
103: (8)                    When the parser determines the appropriate type of a block, the parser
104: (8)                    will call the corresponding processor's `run` method. This method
105: (8)                    should parse the individual lines of the block and append them to
106: (8)                    the `etree`.
107: (8)                    Note that both the `parent` and `etree` keywords are pointers
108: (8)                    to instances of the objects which should be edited in place. Each
109: (8)                    processor must make changes to the existing objects as there is no
110: (8)                    mechanism to return new/different objects to replace them.
111: (8)                    This means that this method should be adding `SubElements` or adding text
112: (8)                    to the parent, and should remove (`pop`) or add (`insert`) items to
113: (8)                    the list of blocks.
114: (8)                    If `False` is returned, this will have the same effect as returning `False`
115: (8)                    from the `test` method.
116: (8)                    Keyword arguments:
117: (12)                       parent: An `etree` element which is the parent of the current block.
118: (12)                       blocks: A list of all remaining blocks of the document.
119: (8)                    """
120: (8)                    pass  # pragma: no cover
121: (0)            class ListIndentProcessor(BlockProcessor):
122: (4)                """ Process children of list items.
123: (4)                Example
124: (8)                    * a list item
125: (12)                       process this part
126: (12)                       or this part
127: (4)                """
128: (4)                ITEM_TYPES = ['li']
129: (4)                """ List of tags used for list items. """
130: (4)                LIST_TYPES = ['ul', 'ol']
131: (4)                """ Types of lists this processor can operate on. """
132: (4)                def __init__(self, *args):
133: (8)                    super().__init__(*args)
134: (8)                    self.INDENT_RE = re.compile(r'^(([ ]{%s})+)' % self.tab_length)
135: (4)                def test(self, parent: etree.Element, block: str) -> bool:
136: (8)                    return block.startswith(' '*self.tab_length) and \
137: (12)                       not self.parser.state.isstate('detabbed') and \
138: (12)                       (parent.tag in self.ITEM_TYPES or
139: (16)                           (len(parent) and parent[-1] is not None and
140: (20)                               (parent[-1].tag in self.LIST_TYPES)))
141: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> None:
142: (8)                    block = blocks.pop(0)
143: (8)                    level, sibling = self.get_level(parent, block)
144: (8)                    block = self.looseDetab(block, level)
145: (8)                    self.parser.state.set('detabbed')
146: (8)                    if parent.tag in self.ITEM_TYPES:
147: (12)                       # It's possible that this parent has a `ul` or `ol` child list
148: (12)                       # with a member.  If that is the case, then that should be the
149: (12)                       # parent.  This is intended to catch the edge case of an indented
150: (12)                       # list whose first member was parsed previous to this point
151: (12)                       # see `OListProcessor`
152: (12)                       if len(parent) and parent[-1].tag in self.LIST_TYPES:
153: (16)                           self.parser.parseBlocks(parent[-1], [block])
154: (12)                       else:
155: (16)                           # The parent is already a `li`. Just parse the child block.
156: (16)                           self.parser.parseBlocks(parent, [block])
157: (8)                    elif sibling.tag in self.ITEM_TYPES:
158: (12)                       # The sibling is a `li`. Use it as parent.
159: (12)                       self.parser.parseBlocks(sibling, [block])
160: (8)                    elif len(sibling) and sibling[-1].tag in self.ITEM_TYPES:
161: (12)                       # The parent is a list (`ol` or `ul`) which has children.
162: (12)                       # Assume the last child `li` is the parent of this block.
163: (12)                       if sibling[-1].text:
164: (16)                           # If the parent `li` has text, that text needs to be moved to a `p`
165: (16)                           # The `p` must be 'inserted' at beginning of list in the event
166: (16)                           # that other children already exist i.e.; a nested sub-list.
167: (16)                           p = etree.Element('p')
168: (16)                           p.text = sibling[-1].text
169: (16)                           sibling[-1].text = ''
170: (16)                           sibling[-1].insert(0, p)
171: (12)                       self.parser.parseChunk(sibling[-1], block)
172: (8)                    else:
173: (12)                       self.create_item(sibling, block)
174: (8)                    self.parser.state.reset()
175: (4)                def create_item(self, parent: etree.Element, block: str) -> None:
176: (8)                    """ Create a new `li` and parse the block with it as the parent. """
177: (8)                    li = etree.SubElement(parent, 'li')
178: (8)                    self.parser.parseBlocks(li, [block])
179: (4)                def get_level(self, parent: etree.Element, block: str) -> tuple[int, etree.Element]:
180: (8)                    """ Get level of indentation based on list level. """
181: (8)                    # Get indent level
182: (8)                    m = self.INDENT_RE.match(block)
183: (8)                    if m:
184: (12)                       indent_level = len(m.group(1))/self.tab_length
185: (8)                    else:
186: (12)                       indent_level = 0
187: (8)                    if self.parser.state.isstate('list'):
188: (12)                       # We're in a tight-list - so we already are at correct parent.
189: (12)                       level = 1
190: (8)                    else:
191: (12)                       # We're in a loose-list - so we need to find parent.
192: (12)                       level = 0
193: (8)                    # Step through children of tree to find matching indent level.
194: (8)                    while indent_level > level:
195: (12)                       child = self.lastChild(parent)
196: (12)                       if (child is not None and
197: (15)                          (child.tag in self.LIST_TYPES or child.tag in self.ITEM_TYPES)):
198: (16)                           if child.tag in self.LIST_TYPES:
199: (20)                               level += 1
200: (16)                           parent = child
201: (12)                       else:
202: (16)                           # No more child levels. If we're short of `indent_level`,
203: (16)                           # we have a code block. So we stop here.
204: (16)                           break
205: (8)                    return level, parent
206: (0)            class CodeBlockProcessor(BlockProcessor):
207: (4)                """ Process code blocks. """
208: (4)                def test(self, parent: etree.Element, block: str) -> bool:
209: (8)                    return block.startswith(' '*self.tab_length)
210: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> None:
211: (8)                    sibling = self.lastChild(parent)
212: (8)                    block = blocks.pop(0)
213: (8)                    theRest = ''
214: (8)                    if (sibling is not None and sibling.tag == "pre" and
215: (11)                      len(sibling) and sibling[0].tag == "code"):
216: (12)                       # The previous block was a code block. As blank lines do not start
217: (12)                       # new code blocks, append this block to the previous, adding back
218: (12)                       # line breaks removed from the split into a list.
219: (12)                       code = sibling[0]
220: (12)                       block, theRest = self.detab(block)
221: (12)                       code.text = util.AtomicString(
222: (16)                           '{}\n{}\n'.format(code.text, util.code_escape(block.rstrip()))
223: (12)                       )
224: (8)                    else:
225: (12)                       # This is a new code block. Create the elements and insert text.
226: (12)                       pre = etree.SubElement(parent, 'pre')
227: (12)                       code = etree.SubElement(pre, 'code')
228: (12)                       block, theRest = self.detab(block)
229: (12)                       code.text = util.AtomicString('%s\n' % util.code_escape(block.rstrip()))
230: (8)                    if theRest:
231: (12)                       # This block contained unindented line(s) after the first indented
232: (12)                       # line. Insert these lines as the first block of the master blocks
233: (12)                       # list for future processing.
234: (12)                       blocks.insert(0, theRest)
235: (0)            class BlockQuoteProcessor(BlockProcessor):
236: (4)                """ Process blockquotes. """
237: (4)                RE = re.compile(r'(^|\n)[ ]{0,3}>[ ]?(.*)')
238: (4)                def test(self, parent: etree.Element, block: str) -> bool:
239: (8)                    return bool(self.RE.search(block)) and not util.nearing_recursion_limit()
240: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> None:
241: (8)                    block = blocks.pop(0)
242: (8)                    m = self.RE.search(block)
243: (8)                    if m:
244: (12)                       before = block[:m.start()]  # Lines before blockquote
245: (12)                       # Pass lines before blockquote in recursively for parsing first.
246: (12)                       self.parser.parseBlocks(parent, [before])
247: (12)                       # Remove `> ` from beginning of each line.
248: (12)                       block = '\n'.join(
249: (16)                           [self.clean(line) for line in block[m.start():].split('\n')]
250: (12)                       )
251: (8)                    sibling = self.lastChild(parent)
252: (8)                    if sibling is not None and sibling.tag == "blockquote":
253: (12)                       # Previous block was a blockquote so set that as this blocks parent
254: (12)                       quote = sibling
255: (8)                    else:
256: (12)                       # This is a new blockquote. Create a new parent element.
257: (12)                       quote = etree.SubElement(parent, 'blockquote')
258: (8)                    # Recursively parse block with blockquote as parent.
259: (8)                    # change parser state so blockquotes embedded in lists use `p` tags
260: (8)                    self.parser.state.set('blockquote')
261: (8)                    self.parser.parseChunk(quote, block)
262: (8)                    self.parser.state.reset()
263: (4)                def clean(self, line: str) -> str:
264: (8)                    """ Remove `>` from beginning of a line. """
265: (8)                    m = self.RE.match(line)
266: (8)                    if line.strip() == ">":
267: (12)                       return ""
268: (8)                    elif m:
269: (12)                       return m.group(2)
270: (8)                    else:
271: (12)                       return line
272: (0)            class OListProcessor(BlockProcessor):
273: (4)                """ Process ordered list blocks. """
274: (4)                TAG: str = 'ol'
275: (4)                """ The tag used for the the wrapping element. """
276: (4)                STARTSWITH: str = '1'
277: (4)                """
278: (4)                The integer (as a string ) with which the list starts. For example, if a list is initialized as
279: (4)                `3. Item`, then the `ol` tag will be assigned an HTML attribute of `starts="3"`. Default: `"1"`.
280: (4)                """
281: (4)                LAZY_OL: bool = True
282: (4)                """ Ignore `STARTSWITH` if `True`. """
283: (4)                SIBLING_TAGS: list[str] = ['ol', 'ul']
284: (4)                """
285: (4)                Markdown does not require the type of a new list item match the previous list item type.
286: (4)                This is the list of types which can be mixed.
287: (4)                """
288: (4)                def __init__(self, parser: BlockParser):
289: (8)                    super().__init__(parser)
290: (8)                    # Detect an item (`1. item`). `group(1)` contains contents of item.
291: (8)                    self.RE = re.compile(r'^[ ]{0,%d}\d+\.[ ]+(.*)' % (self.tab_length - 1))
292: (8)                    # Detect items on secondary lines. they can be of either list type.
293: (8)                    self.CHILD_RE = re.compile(r'^[ ]{0,%d}((\d+\.)|[*+-])[ ]+(.*)' %
294: (35)                                              (self.tab_length - 1))
295: (8)                    # Detect indented (nested) items of either type
296: (8)                    self.INDENT_RE = re.compile(r'^[ ]{%d,%d}((\d+\.)|[*+-])[ ]+.*' %
297: (36)                                               (self.tab_length, self.tab_length * 2 - 1))
298: (4)                def test(self, parent: etree.Element, block: str) -> bool:
299: (8)                    return bool(self.RE.match(block))
300: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> None:
301: (8)                    # Check for multiple items in one block.
302: (8)                    items = self.get_items(blocks.pop(0))
303: (8)                    sibling = self.lastChild(parent)
304: (8)                    if sibling is not None and sibling.tag in self.SIBLING_TAGS:
305: (12)                       # Previous block was a list item, so set that as parent
306: (12)                       lst = sibling
307: (12)                       # make sure previous item is in a `p` - if the item has text,
308: (12)                       # then it isn't in a `p`
309: (12)                       if lst[-1].text:
310: (16)                           # since it's possible there are other children for this
311: (16)                           # sibling, we can't just `SubElement` the `p`, we need to
312: (16)                           # insert it as the first item.
313: (16)                           p = etree.Element('p')
314: (16)                           p.text = lst[-1].text
315: (16)                           lst[-1].text = ''
316: (16)                           lst[-1].insert(0, p)
317: (12)                       # if the last item has a tail, then the tail needs to be put in a `p`
318: (12)                       # likely only when a header is not followed by a blank line
319: (12)                       lch = self.lastChild(lst[-1])
320: (12)                       if lch is not None and lch.tail:
321: (16)                           p = etree.SubElement(lst[-1], 'p')
322: (16)                           p.text = lch.tail.lstrip()
323: (16)                           lch.tail = ''
324: (12)                       # parse first block differently as it gets wrapped in a `p`.
325: (12)                       li = etree.SubElement(lst, 'li')
326: (12)                       self.parser.state.set('looselist')
327: (12)                       firstitem = items.pop(0)
328: (12)                       self.parser.parseBlocks(li, [firstitem])
329: (12)                       self.parser.state.reset()
330: (8)                    elif parent.tag in ['ol', 'ul']:
331: (12)                       # this catches the edge case of a multi-item indented list whose
332: (12)                       # first item is in a blank parent-list item:
333: (12)                       #     * * subitem1
334: (12)                       #         * subitem2
335: (12)                       # see also `ListIndentProcessor`
336: (12)                       lst = parent
337: (8)                    else:
338: (12)                       # This is a new list so create parent with appropriate tag.
339: (12)                       lst = etree.SubElement(parent, self.TAG)
340: (12)                       # Check if a custom start integer is set
341: (12)                       if not self.LAZY_OL and self.STARTSWITH != '1':
342: (16)                           lst.attrib['start'] = self.STARTSWITH
343: (8)                    self.parser.state.set('list')
344: (8)                    # Loop through items in block, recursively parsing each with the
345: (8)                    # appropriate parent.
346: (8)                    for item in items:
347: (12)                       if item.startswith(' '*self.tab_length):
348: (16)                           # Item is indented. Parse with last item as parent
349: (16)                           self.parser.parseBlocks(lst[-1], [item])
350: (12)                       else:
351: (16)                           # New item. Create `li` and parse with it as parent
352: (16)                           li = etree.SubElement(lst, 'li')
353: (16)                           self.parser.parseBlocks(li, [item])
354: (8)                    self.parser.state.reset()
355: (4)                def get_items(self, block: str) -> list[str]:
356: (8)                    """ Break a block into list items. """
357: (8)                    items = []
358: (8)                    for line in block.split('\n'):
359: (12)                       m = self.CHILD_RE.match(line)
360: (12)                       if m:
361: (16)                           # This is a new list item
362: (16)                           # Check first item for the start index
363: (16)                           if not items and self.TAG == 'ol':
364: (20)                               # Detect the integer value of first list item
365: (20)                               INTEGER_RE = re.compile(r'(\d+)')
366: (20)                               self.STARTSWITH = INTEGER_RE.match(m.group(1)).group()
367: (16)                           # Append to the list
368: (16)                           items.append(m.group(3))
369: (12)                       elif self.INDENT_RE.match(line):
370: (16)                           # This is an indented (possibly nested) item.
371: (16)                           if items[-1].startswith(' '*self.tab_length):
372: (20)                               # Previous item was indented. Append to that item.
373: (20)                               items[-1] = '{}\n{}'.format(items[-1], line)
374: (16)                           else:
375: (20)                               items.append(line)
376: (12)                       else:
377: (16)                           # This is another line of previous item. Append to that item.
378: (16)                           items[-1] = '{}\n{}'.format(items[-1], line)
379: (8)                    return items
380: (0)            class UListProcessor(OListProcessor):
381: (4)                """ Process unordered list blocks. """
382: (4)                TAG: str = 'ul'
383: (4)                """ The tag used for the the wrapping element. """
384: (4)                def __init__(self, parser: BlockParser):
385: (8)                    super().__init__(parser)
386: (8)                    # Detect an item (`1. item`). `group(1)` contains contents of item.
387: (8)                    self.RE = re.compile(r'^[ ]{0,%d}[*+-][ ]+(.*)' % (self.tab_length - 1))
388: (0)            class HashHeaderProcessor(BlockProcessor):
389: (4)                """ Process Hash Headers. """
390: (4)                # Detect a header at start of any line in block
391: (4)                RE = re.compile(r'(?:^|\n)(?P<level>#{1,6})(?P<header>(?:\\.|[^\\])*?)#*(?:\n|$)')
392: (4)                def test(self, parent: etree.Element, block: str) -> bool:
393: (8)                    return bool(self.RE.search(block))
394: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> None:
395: (8)                    block = blocks.pop(0)
396: (8)                    m = self.RE.search(block)
397: (8)                    if m:
398: (12)                       before = block[:m.start()]  # All lines before header
399: (12)                       after = block[m.end():]     # All lines after header
400: (12)                       if before:
401: (16)                           # As the header was not the first line of the block and the
402: (16)                           # lines before the header must be parsed first,
403: (16)                           # recursively parse this lines as a block.
404: (16)                           self.parser.parseBlocks(parent, [before])
405: (12)                       # Create header using named groups from RE
406: (12)                       h = etree.SubElement(parent, 'h%d' % len(m.group('level')))
407: (12)                       h.text = m.group('header').strip()
408: (12)                       if after:
409: (16)                           # Insert remaining lines as first block for future parsing.
410: (16)                           if self.parser.state.isstate('looselist'):
411: (20)                               # This is a weird edge case where a header is a child of a loose list
412: (20)                               # and there is no blank line after the header. To ensure proper
413: (20)                               # parsing, the line(s) after need to be detabbed. See #1443.
414: (20)                               after = self.looseDetab(after)
415: (16)                           blocks.insert(0, after)
416: (8)                    else:  # pragma: no cover
417: (12)                       # This should never happen, but just in case...
418: (12)                       logger.warn("We've got a problem header: %r" % block)
419: (0)            class SetextHeaderProcessor(BlockProcessor):
420: (4)                """ Process Setext-style Headers. """
421: (4)                # Detect Setext-style header. Must be first 2 lines of block.
422: (4)                RE = re.compile(r'^.*?\n[=-]+[ ]*(\n|$)', re.MULTILINE)
423: (4)                def test(self, parent: etree.Element, block: str) -> bool:
424: (8)                    return bool(self.RE.match(block))
425: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> None:
426: (8)                    lines = blocks.pop(0).split('\n')
427: (8)                    # Determine level. `=` is 1 and `-` is 2.
428: (8)                    if lines[1].startswith('='):
429: (12)                       level = 1
430: (8)                    else:
431: (12)                       level = 2
432: (8)                    h = etree.SubElement(parent, 'h%d' % level)
433: (8)                    h.text = lines[0].strip()
434: (8)                    if len(lines) > 2:
435: (12)                       # Block contains additional lines. Add to  master blocks for later.
436: (12)                       blocks.insert(0, '\n'.join(lines[2:]))
437: (0)            class HRProcessor(BlockProcessor):
438: (4)                """ Process Horizontal Rules. """
439: (4)                # Python's `re` module doesn't officially support atomic grouping. However you can fake it.
440: (4)                # See https://stackoverflow.com/a/13577411/866026
441: (4)                RE = r'^[ ]{0,3}(?=(?P<atomicgroup>(-+[ ]{0,2}){3,}|(_+[ ]{0,2}){3,}|(\*+[ ]{0,2}){3,}))(?P=atomicgroup)[ ]*$'
442: (4)                # Detect hr on any line of a block.
443: (4)                SEARCH_RE = re.compile(RE, re.MULTILINE)
444: (4)                def test(self, parent: etree.Element, block: str) -> bool:
445: (8)                    m = self.SEARCH_RE.search(block)
446: (8)                    if m:
447: (12)                       # Save match object on class instance so we can use it later.
448: (12)                       self.match = m
449: (12)                       return True
450: (8)                    return False
451: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> None:
452: (8)                    block = blocks.pop(0)
453: (8)                    match = self.match
454: (8)                    # Check for lines in block before `hr`.
455: (8)                    prelines = block[:match.start()].rstrip('\n')
456: (8)                    if prelines:
457: (12)                       # Recursively parse lines before `hr` so they get parsed first.
458: (12)                       self.parser.parseBlocks(parent, [prelines])
459: (8)                    # create hr
460: (8)                    etree.SubElement(parent, 'hr')
461: (8)                    # check for lines in block after `hr`.
462: (8)                    postlines = block[match.end():].lstrip('\n')
463: (8)                    if postlines:
464: (12)                       # Add lines after `hr` to master blocks for later parsing.
465: (12)                       blocks.insert(0, postlines)
466: (0)            class EmptyBlockProcessor(BlockProcessor):
467: (4)                """ Process blocks that are empty or start with an empty line. """
468: (4)                def test(self, parent: etree.Element, block: str) -> bool:
469: (8)                    return not block or block.startswith('\n')
470: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> None:
471: (8)                    block = blocks.pop(0)
472: (8)                    filler = '\n\n'
473: (8)                    if block:
474: (12)                       # Starts with empty line
475: (12)                       # Only replace a single line.
476: (12)                       filler = '\n'
477: (12)                       # Save the rest for later.
478: (12)                       theRest = block[1:]
479: (12)                       if theRest:
480: (16)                           # Add remaining lines to master blocks for later.
481: (16)                           blocks.insert(0, theRest)
482: (8)                    sibling = self.lastChild(parent)
483: (8)                    if (sibling is not None and sibling.tag == 'pre' and
484: (11)                      len(sibling) and sibling[0].tag == 'code'):
485: (12)                       # Last block is a code block. Append to preserve whitespace.
486: (12)                       sibling[0].text = util.AtomicString(
487: (16)                           '{}{}'.format(sibling[0].text, filler)
488: (12)                       )
489: (0)            class ReferenceProcessor(BlockProcessor):
490: (4)                """ Process link references. """
491: (4)                RE = re.compile(
492: (8)                    r'^[ ]{0,3}\[([^\[\]]*)\]:[ ]*\n?[ ]*([^\s]+)[ ]*(?:\n[ ]*)?((["\'])(.*)\4[ ]*|\((.*)\)[ ]*)?$', re.MULTILINE
493: (4)                )
494: (4)                def test(self, parent: etree.Element, block: str) -> bool:
495: (8)                    return True
496: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> bool:
497: (8)                    block = blocks.pop(0)
498: (8)                    m = self.RE.search(block)
499: (8)                    if m:
500: (12)                       id = m.group(1).strip().lower()
501: (12)                       link = m.group(2).lstrip('<').rstrip('>')
502: (12)                       title = m.group(5) or m.group(6)
503: (12)                       self.parser.md.references[id] = (link, title)
504: (12)                       if block[m.end():].strip():
505: (16)                           # Add any content after match back to blocks as separate block
506: (16)                           blocks.insert(0, block[m.end():].lstrip('\n'))
507: (12)                       if block[:m.start()].strip():
508: (16)                           # Add any content before match back to blocks as separate block
509: (16)                           blocks.insert(0, block[:m.start()].rstrip('\n'))
510: (12)                       return True
511: (8)                    # No match. Restore block.
512: (8)                    blocks.insert(0, block)
513: (8)                    return False
514: (0)            class ParagraphProcessor(BlockProcessor):
515: (4)                """ Process Paragraph blocks. """
516: (4)                def test(self, parent: etree.Element, block: str) -> bool:
517: (8)                    return True
518: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> None:
519: (8)                    block = blocks.pop(0)
520: (8)                    if block.strip():
521: (12)                       # Not a blank block. Add to parent, otherwise throw it away.
522: (12)                       if self.parser.state.isstate('list'):
523: (16)                           # The parent is a tight-list.
524: (16)                           #
525: (16)                           # Check for any children. This will likely only happen in a
526: (16)                           # tight-list when a header isn't followed by a blank line.
527: (16)                           # For example:
528: (16)                           #
529: (16)                           #     * # Header
530: (16)                           #     Line 2 of list item - not part of header.
531: (16)                           sibling = self.lastChild(parent)
532: (16)                           if sibling is not None:
533: (20)                               # Insert after sibling.
534: (20)                               if sibling.tail:
535: (24)                                   sibling.tail = '{}\n{}'.format(sibling.tail, block)
536: (20)                               else:
537: (24)                                   sibling.tail = '\n%s' % block
538: (16)                           else:
539: (20)                               # Append to parent.text
540: (20)                               if parent.text:
541: (24)                                   parent.text = '{}\n{}'.format(parent.text, block)
542: (20)                               else:
543: (24)                                   parent.text = block.lstrip()
544: (12)                       else:
545: (16)                           # Create a regular paragraph
546: (16)                           p = etree.SubElement(parent, 'p')
547: (16)                           p.text = block.lstrip()

----------------------------------------

File 6 - . \core.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             from __future__ import annotations
15: (0)             import codecs
16: (0)             import sys
17: (0)             import logging
18: (0)             import importlib
19: (0)             from typing import TYPE_CHECKING, Any, BinaryIO, Callable, ClassVar, Mapping, Sequence
20: (0)             from . import util
21: (0)             from .preprocessors import build_preprocessors
22: (0)             from .blockprocessors import build_block_parser
23: (0)             from .treeprocessors import build_treeprocessors
24: (0)             from .inlinepatterns import build_inlinepatterns
25: (0)             from .postprocessors import build_postprocessors
26: (0)             from .extensions import Extension
27: (0)             from .serializers import to_html_string, to_xhtml_string
28: (0)             from .util import BLOCK_LEVEL_ELEMENTS
29: (0)             if TYPE_CHECKING:  # pragma: no cover
30: (4)                 from xml.etree.ElementTree import Element
31: (0)             __all__ = ['Markdown', 'markdown', 'markdownFromFile']
32: (0)             logger = logging.getLogger('MARKDOWN')
33: (0)             class Markdown:
34: (4)                 """
35: (4)                 A parser which converts Markdown to HTML.
36: (4)                 Attributes:
37: (8)                     Markdown.tab_length (int): The number of spaces which correspond to a single tab. Default: `4`.
38: (8)                     Markdown.ESCAPED_CHARS (list[str]): List of characters which get the backslash escape treatment.
39: (8)                     Markdown.block_level_elements (list[str]): List of HTML tags which get treated as block-level elements.
40: (12)                        See [`markdown.util.BLOCK_LEVEL_ELEMENTS`][] for the full list of elements.
41: (8)                     Markdown.registeredExtensions (list[Extension]): List of extensions which have called
42: (12)                        [`registerExtension`][markdown.Markdown.registerExtension] during setup.
43: (8)                     Markdown.doc_tag (str): Element used to wrap document. Default: `div`.
44: (8)                     Markdown.stripTopLevelTags (bool): Indicates whether the `doc_tag` should be removed. Default: 'True'.
45: (8)                     Markdown.references (dict[str, tuple[str, str]]): A mapping of link references found in a parsed document
46: (13)                         where the key is the reference name and the value is a tuple of the URL and title.
47: (8)                     Markdown.htmlStash (util.HtmlStash): The instance of the `HtmlStash` used by an instance of this class.
48: (8)                     Markdown.output_formats (dict[str, Callable[xml.etree.ElementTree.Element]]): A mapping of known output
49: (13)                         formats by name and their respective serializers. Each serializer must be a callable which accepts an
50: (12)                        [`Element`][xml.etree.ElementTree.Element] and returns a `str`.
51: (8)                     Markdown.output_format (str): The output format set by
52: (12)                        [`set_output_format`][markdown.Markdown.set_output_format].
53: (8)                     Markdown.serializer (Callable[xml.etree.ElementTree.Element]): The serializer set by
54: (12)                        [`set_output_format`][markdown.Markdown.set_output_format].
55: (8)                     Markdown.preprocessors (util.Registry): A collection of [`preprocessors`][markdown.preprocessors].
56: (8)                     Markdown.parser (blockparser.BlockParser): A collection of [`blockprocessors`][markdown.blockprocessors].
57: (8)                     Markdown.inlinePatterns (util.Registry): A collection of [`inlinepatterns`][markdown.inlinepatterns].
58: (8)                     Markdown.treeprocessors (util.Registry): A collection of [`treeprocessors`][markdown.treeprocessors].
59: (8)                     Markdown.postprocessors (util.Registry): A collection of [`postprocessors`][markdown.postprocessors].
60: (4)                 """
61: (4)                 doc_tag = "div"     # Element used to wrap document - later removed
62: (4)                 output_formats: ClassVar[dict[str, Callable[[Element], str]]] = {
63: (8)                     'html':   to_html_string,
64: (8)                     'xhtml':  to_xhtml_string,
65: (4)                 }
66: (4)                 """
67: (4)                 A mapping of known output formats by name and their respective serializers. Each serializer must be a
68: (4)                 callable which accepts an [`Element`][xml.etree.ElementTree.Element] and returns a `str`.
69: (4)                 """
70: (4)                 def __init__(self, **kwargs):
71: (8)                     """
72: (8)                     Creates a new Markdown instance.
73: (8)                     Keyword Arguments:
74: (12)                        extensions (list[Extension | str]): A list of extensions.
75: (16)                            If an item is an instance of a subclass of [`markdown.extensions.Extension`][],
76: (16)                            the instance will be used as-is. If an item is of type `str`, it is passed
77: (16)                            to [`build_extension`][markdown.Markdown.build_extension] with its corresponding
78: (16)                            `extension_configs` and the returned instance  of [`markdown.extensions.Extension`][]
79: (16)                            is used.
80: (12)                        extension_configs (dict[str, dict[str, Any]]): Configuration settings for extensions.
81: (12)                        output_format (str): Format of output. Supported formats are:
82: (16)                            * `xhtml`: Outputs XHTML style tags. Default.
83: (16)                            * `html`: Outputs HTML style tags.
84: (12)                        tab_length (int): Length of tabs in the source. Default: `4`
85: (8)                     """
86: (8)                     self.tab_length: int = kwargs.get('tab_length', 4)
87: (8)                     self.ESCAPED_CHARS: list[str] = [
88: (12)                        '\\', '`', '*', '_', '{', '}', '[', ']', '(', ')', '>', '#', '+', '-', '.', '!'
89: (8)                     ]
90: (8)                     """ List of characters which get the backslash escape treatment. """
91: (8)                     self.block_level_elements: list[str] = BLOCK_LEVEL_ELEMENTS.copy()
92: (8)                     self.registeredExtensions: list[Extension] = []
93: (8)                     self.docType = ""  # TODO: Maybe delete this. It does not appear to be used anymore.
94: (8)                     self.stripTopLevelTags: bool = True
95: (8)                     self.build_parser()
96: (8)                     self.references: dict[str, tuple[str, str]] = {}
97: (8)                     self.htmlStash: util.HtmlStash = util.HtmlStash()
98: (8)                     self.registerExtensions(extensions=kwargs.get('extensions', []),
99: (32)                                            configs=kwargs.get('extension_configs', {}))
100: (8)                    self.set_output_format(kwargs.get('output_format', 'xhtml'))
101: (8)                    self.reset()
102: (4)                def build_parser(self) -> Markdown:
103: (8)                    """
104: (8)                    Build the parser from the various parts.
105: (8)                    Assigns a value to each of the following attributes on the class instance:
106: (8)                    * **`Markdown.preprocessors`** ([`Registry`][markdown.util.Registry]) -- A collection of
107: (10)                     [`preprocessors`][markdown.preprocessors].
108: (8)                    * **`Markdown.parser`** ([`BlockParser`][markdown.blockparser.BlockParser]) -- A collection of
109: (10)                     [`blockprocessors`][markdown.blockprocessors].
110: (8)                    * **`Markdown.inlinePatterns`** ([`Registry`][markdown.util.Registry]) -- A collection of
111: (10)                     [`inlinepatterns`][markdown.inlinepatterns].
112: (8)                    * **`Markdown.treeprocessors`** ([`Registry`][markdown.util.Registry]) -- A collection of
113: (10)                     [`treeprocessors`][markdown.treeprocessors].
114: (8)                    * **`Markdown.postprocessors`** ([`Registry`][markdown.util.Registry]) -- A collection of
115: (10)                     [`postprocessors`][markdown.postprocessors].
116: (8)                    This method could be redefined in a subclass to build a custom parser which is made up of a different
117: (8)                    combination of processors and patterns.
118: (8)                    """
119: (8)                    self.preprocessors = build_preprocessors(self)
120: (8)                    self.parser = build_block_parser(self)
121: (8)                    self.inlinePatterns = build_inlinepatterns(self)
122: (8)                    self.treeprocessors = build_treeprocessors(self)
123: (8)                    self.postprocessors = build_postprocessors(self)
124: (8)                    return self
125: (4)                def registerExtensions(
126: (8)                    self,
127: (8)                    extensions: Sequence[Extension | str],
128: (8)                    configs: Mapping[str, dict[str, Any]]
129: (4)                ) -> Markdown:
130: (8)                    """
131: (8)                    Load a list of extensions into an instance of the `Markdown` class.
132: (8)                    Arguments:
133: (12)                       extensions (list[Extension | str]): A list of extensions.
134: (16)                           If an item is an instance of a subclass of [`markdown.extensions.Extension`][],
135: (16)                           the instance will be used as-is. If an item is of type `str`, it is passed
136: (16)                           to [`build_extension`][markdown.Markdown.build_extension] with its corresponding `configs` and the
137: (16)                           returned instance  of [`markdown.extensions.Extension`][] is used.
138: (12)                       configs (dict[str, dict[str, Any]]): Configuration settings for extensions.
139: (8)                    """
140: (8)                    for ext in extensions:
141: (12)                       if isinstance(ext, str):
142: (16)                           ext = self.build_extension(ext, configs.get(ext, {}))
143: (12)                       if isinstance(ext, Extension):
144: (16)                           ext.extendMarkdown(self)
145: (16)                           logger.debug(
146: (20)                               'Successfully loaded extension "%s.%s".'
147: (20)                               % (ext.__class__.__module__, ext.__class__.__name__)
148: (16)                           )
149: (12)                       elif ext is not None:
150: (16)                           raise TypeError(
151: (20)                               'Extension "{}.{}" must be of type: "{}.{}"'.format(
152: (24)                                   ext.__class__.__module__, ext.__class__.__name__,
153: (24)                                   Extension.__module__, Extension.__name__
154: (20)                               )
155: (16)                           )
156: (8)                    return self
157: (4)                def build_extension(self, ext_name: str, configs: Mapping[str, Any]) -> Extension:
158: (8)                    """
159: (8)                    Build extension from a string name, then return an instance using the given `configs`.
160: (8)                    Arguments:
161: (12)                       ext_name: Name of extension as a string.
162: (12)                       configs: Configuration settings for extension.
163: (8)                    Returns:
164: (12)                       An instance of the extension with the given configuration settings.
165: (8)                    First attempt to load an entry point. The string name must be registered as an entry point in the
166: (8)                    `markdown.extensions` group which points to a subclass of the [`markdown.extensions.Extension`][] class.
167: (8)                    If multiple distributions have registered the same name, the first one found is returned.
168: (8)                    If no entry point is found, assume dot notation (`path.to.module:ClassName`). Load the specified class and
169: (8)                    return an instance. If no class is specified, import the module and call a `makeExtension` function and return
170: (8)                    the [`markdown.extensions.Extension`][] instance returned by that function.
171: (8)                    """
172: (8)                    configs = dict(configs)
173: (8)                    entry_points = [ep for ep in util.get_installed_extensions() if ep.name == ext_name]
174: (8)                    if entry_points:
175: (12)                       ext = entry_points[0].load()
176: (12)                       return ext(**configs)
177: (8)                    # Get class name (if provided): `path.to.module:ClassName`
178: (8)                    ext_name, class_name = ext_name.split(':', 1) if ':' in ext_name else (ext_name, '')
179: (8)                    try:
180: (12)                       module = importlib.import_module(ext_name)
181: (12)                       logger.debug(
182: (16)                           'Successfully imported extension module "%s".' % ext_name
183: (12)                       )
184: (8)                    except ImportError as e:
185: (12)                       message = 'Failed loading extension "%s".' % ext_name
186: (12)                       e.args = (message,) + e.args[1:]
187: (12)                       raise
188: (8)                    if class_name:
189: (12)                       # Load given class name from module.
190: (12)                       return getattr(module, class_name)(**configs)
191: (8)                    else:
192: (12)                       # Expect  `makeExtension()` function to return a class.
193: (12)                       try:
194: (16)                           return module.makeExtension(**configs)
195: (12)                       except AttributeError as e:
196: (16)                           message = e.args[0]
197: (16)                           message = "Failed to initiate extension " \
198: (26)                                     "'%s': %s" % (ext_name, message)
199: (16)                           e.args = (message,) + e.args[1:]
200: (16)                           raise
201: (4)                def registerExtension(self, extension: Extension) -> Markdown:
202: (8)                    """
203: (8)                    Register an extension as having a resettable state.
204: (8)                    Arguments:
205: (12)                       extension: An instance of the extension to register.
206: (8)                    This should get called once by an extension during setup. A "registered" extension's
207: (8)                    `reset` method is called by [`Markdown.reset()`][markdown.Markdown.reset]. Not all extensions have or need a
208: (8)                    resettable state, and so it should not be assumed that all extensions are "registered."
209: (8)                    """
210: (8)                    self.registeredExtensions.append(extension)
211: (8)                    return self
212: (4)                def reset(self) -> Markdown:
213: (8)                    """
214: (8)                    Resets all state variables to prepare the parser instance for new input.
215: (8)                    Called once upon creation of a class instance. Should be called manually between calls
216: (8)                    to [`Markdown.convert`][markdown.Markdown.convert].
217: (8)                    """
218: (8)                    self.htmlStash.reset()
219: (8)                    self.references.clear()
220: (8)                    for extension in self.registeredExtensions:
221: (12)                       if hasattr(extension, 'reset'):
222: (16)                           extension.reset()
223: (8)                    return self
224: (4)                def set_output_format(self, format: str) -> Markdown:
225: (8)                    """
226: (8)                    Set the output format for the class instance.
227: (8)                    Arguments:
228: (12)                       format: Must be a known value in `Markdown.output_formats`.
229: (8)                    """
230: (8)                    self.output_format = format.lower().rstrip('145')  # ignore number
231: (8)                    try:
232: (12)                       self.serializer = self.output_formats[self.output_format]
233: (8)                    except KeyError as e:
234: (12)                       valid_formats = list(self.output_formats.keys())
235: (12)                       valid_formats.sort()
236: (12)                       message = 'Invalid Output Format: "%s". Use one of %s.' \
237: (16)                           % (self.output_format,
238: (19)                              '"' + '", "'.join(valid_formats) + '"')
239: (12)                       e.args = (message,) + e.args[1:]
240: (12)                       raise
241: (8)                    return self
242: (4)                # Note: the `tag` argument is type annotated `Any` as ElementTree uses many various objects as tags.
243: (4)                # As there is no standardization in ElementTree, the type of a given tag is unpredictable.
244: (4)                def is_block_level(self, tag: Any) -> bool:
245: (8)                    """
246: (8)                    Check if the given `tag` is a block level HTML tag.
247: (8)                    Returns `True` for any string listed in `Markdown.block_level_elements`. A `tag` which is
248: (8)                    not a string always returns `False`.
249: (8)                    """
250: (8)                    if isinstance(tag, str):
251: (12)                       return tag.lower().rstrip('/') in self.block_level_elements
252: (8)                    # Some ElementTree tags are not strings, so return False.
253: (8)                    return False
254: (4)                def convert(self, source: str) -> str:
255: (8)                    """
256: (8)                    Convert a Markdown string to a string in the specified output format.
257: (8)                    Arguments:
258: (12)                       source: Markdown formatted text as Unicode or ASCII string.
259: (8)                    Returns:
260: (12)                       A string in the specified output format.
261: (8)                    Markdown parsing takes place in five steps:
262: (8)                    1. A bunch of [`preprocessors`][markdown.preprocessors] munge the input text.
263: (8)                    2. A [`BlockParser`][markdown.blockparser.BlockParser] parses the high-level structural elements of the
264: (11)                      pre-processed text into an [`ElementTree`][xml.etree.ElementTree.ElementTree] object.
265: (8)                    3. A bunch of [`treeprocessors`][markdown.treeprocessors] are run against the
266: (11)                      [`ElementTree`][xml.etree.ElementTree.ElementTree] object. One such `treeprocessor`
267: (11)                      ([`markdown.treeprocessors.InlineProcessor`][]) runs [`inlinepatterns`][markdown.inlinepatterns]
268: (11)                      against the [`ElementTree`][xml.etree.ElementTree.ElementTree] object, parsing inline markup.
269: (8)                    4. Some [`postprocessors`][markdown.postprocessors] are run against the text after the
270: (11)                      [`ElementTree`][xml.etree.ElementTree.ElementTree] object has been serialized into text.
271: (8)                    5. The output is returned as a string.
272: (8)                    """
273: (8)                    # Fix up the source text
274: (8)                    if not source.strip():
275: (12)                       return ''  # a blank Unicode string
276: (8)                    try:
277: (12)                       source = str(source)
278: (8)                    except UnicodeDecodeError as e:  # pragma: no cover
279: (12)                       # Customize error message while maintaining original traceback
280: (12)                       e.reason += '. -- Note: Markdown only accepts Unicode input!'
281: (12)                       raise
282: (8)                    # Split into lines and run the line preprocessors.
283: (8)                    self.lines = source.split("\n")
284: (8)                    for prep in self.preprocessors:
285: (12)                       self.lines = prep.run(self.lines)
286: (8)                    # Parse the high-level elements.
287: (8)                    root = self.parser.parseDocument(self.lines).getroot()
288: (8)                    # Run the tree-processors
289: (8)                    for treeprocessor in self.treeprocessors:
290: (12)                       newRoot = treeprocessor.run(root)
291: (12)                       if newRoot is not None:
292: (16)                           root = newRoot
293: (8)                    # Serialize _properly_.  Strip top-level tags.
294: (8)                    output = self.serializer(root)
295: (8)                    if self.stripTopLevelTags:
296: (12)                       try:
297: (16)                           start = output.index(
298: (20)                               '<%s>' % self.doc_tag) + len(self.doc_tag) + 2
299: (16)                           end = output.rindex('</%s>' % self.doc_tag)
300: (16)                           output = output[start:end].strip()
301: (12)                       except ValueError as e:  # pragma: no cover
302: (16)                           if output.strip().endswith('<%s />' % self.doc_tag):
303: (20)                               # We have an empty document
304: (20)                               output = ''
305: (16)                           else:
306: (20)                               # We have a serious problem
307: (20)                               raise ValueError('Markdown failed to strip top-level '
308: (37)                                                'tags. Document=%r' % output.strip()) from e
309: (8)                    # Run the text post-processors
310: (8)                    for pp in self.postprocessors:
311: (12)                       output = pp.run(output)
312: (8)                    return output.strip()
313: (4)                def convertFile(
314: (8)                    self,
315: (8)                    input: str | BinaryIO | None = None,
316: (8)                    output: str | BinaryIO | None = None,
317: (8)                    encoding: str | None = None,
318: (4)                ) -> Markdown:
319: (8)                    """
320: (8)                    Converts a Markdown file and returns the HTML as a Unicode string.
321: (8)                    Decodes the file using the provided encoding (defaults to `utf-8`),
322: (8)                    passes the file content to markdown, and outputs the HTML to either
323: (8)                    the provided stream or the file with provided name, using the same
324: (8)                    encoding as the source file. The
325: (8)                    [`xmlcharrefreplace`](https://docs.python.org/3/library/codecs.html#error-handlers)
326: (8)                    error handler is used when encoding the output.
327: (8)                    **Note:** This is the only place that decoding and encoding of Unicode
328: (8)                    takes place in Python-Markdown.  (All other code is Unicode-in /
329: (8)                    Unicode-out.)
330: (8)                    Arguments:
331: (12)                       input: File object or path. Reads from `stdin` if `None`.
332: (12)                       output: File object or path. Writes to `stdout` if `None`.
333: (12)                       encoding: Encoding of input and output files. Defaults to `utf-8`.
334: (8)                    """
335: (8)                    encoding = encoding or "utf-8"
336: (8)                    # Read the source
337: (8)                    if input:
338: (12)                       if isinstance(input, str):
339: (16)                           input_file = codecs.open(input, mode="r", encoding=encoding)
340: (12)                       else:
341: (16)                           input_file = codecs.getreader(encoding)(input)
342: (12)                       text = input_file.read()
343: (12)                       input_file.close()
344: (8)                    else:
345: (12)                       text = sys.stdin.read()
346: (8)                    text = text.lstrip('\ufeff')  # remove the byte-order mark
347: (8)                    # Convert
348: (8)                    html = self.convert(text)
349: (8)                    # Write to file or stdout
350: (8)                    if output:
351: (12)                       if isinstance(output, str):
352: (16)                           output_file = codecs.open(output, "w",
353: (42)                                                     encoding=encoding,
354: (42)                                                     errors="xmlcharrefreplace")
355: (16)                           output_file.write(html)
356: (16)                           output_file.close()
357: (12)                       else:
358: (16)                           writer = codecs.getwriter(encoding)
359: (16)                           output_file = writer(output, errors="xmlcharrefreplace")
360: (16)                           output_file.write(html)
361: (16)                           # Don't close here. User may want to write more.
362: (8)                    else:
363: (12)                       # Encode manually and write bytes to stdout.
364: (12)                       html = html.encode(encoding, "xmlcharrefreplace")
365: (12)                       sys.stdout.buffer.write(html)
366: (8)                    return self
367: (0)            """
368: (0)            EXPORTED FUNCTIONS
369: (0)            =============================================================================
370: (0)            Those are the two functions we really mean to export: `markdown()` and
371: (0)            `markdownFromFile()`.
372: (0)            """
373: (0)            def markdown(text: str, **kwargs: Any) -> str:
374: (4)                """
375: (4)                Convert a markdown string to HTML and return HTML as a Unicode string.
376: (4)                This is a shortcut function for [`Markdown`][markdown.Markdown] class to cover the most
377: (4)                basic use case.  It initializes an instance of [`Markdown`][markdown.Markdown], loads the
378: (4)                necessary extensions and runs the parser on the given text.
379: (4)                Arguments:
380: (8)                    text: Markdown formatted text as Unicode or ASCII string.
381: (4)                Keyword arguments:
382: (8)                    **kwargs: Any arguments accepted by the Markdown class.
383: (4)                Returns:
384: (8)                    A string in the specified output format.
385: (4)                """
386: (4)                md = Markdown(**kwargs)
387: (4)                return md.convert(text)
388: (0)            def markdownFromFile(**kwargs: Any):
389: (4)                """
390: (4)                Read Markdown text from a file and write output to a file or a stream.
391: (4)                This is a shortcut function which initializes an instance of [`Markdown`][markdown.Markdown],
392: (4)                and calls the [`convertFile`][markdown.Markdown.convertFile] method rather than
393: (4)                [`convert`][markdown.Markdown.convert].
394: (4)                Keyword arguments:
395: (8)                    input (str | BinaryIO): A file name or readable object.
396: (8)                    output (str | BinaryIO): A file name or writable object.
397: (8)                    encoding (str): Encoding of input and output.
398: (8)                    **kwargs: Any arguments accepted by the `Markdown` class.
399: (4)                """
400: (4)                md = Markdown(**kwargs)
401: (4)                md.convertFile(kwargs.get('input', None),
402: (19)                              kwargs.get('output', None),
403: (19)                              kwargs.get('encoding', None))

----------------------------------------

File 7 - . \htmlparser.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             This module imports a copy of [`html.parser.HTMLParser`][] and modifies it heavily through monkey-patches.
16: (0)             A copy is imported rather than the module being directly imported as this ensures that the user can import
17: (0)             and  use the unmodified library for their own needs.
18: (0)             """
19: (0)             from __future__ import annotations
20: (0)             import re
21: (0)             import importlib.util
22: (0)             import sys
23: (0)             from typing import TYPE_CHECKING, Sequence
24: (0)             if TYPE_CHECKING:  # pragma: no cover
25: (4)                 from markdown import Markdown
26: (0)             # Import a copy of the html.parser lib as `htmlparser` so we can monkeypatch it.
27: (0)             # Users can still do `from html import parser` and get the default behavior.
28: (0)             spec = importlib.util.find_spec('html.parser')
29: (0)             htmlparser = importlib.util.module_from_spec(spec)
30: (0)             spec.loader.exec_module(htmlparser)
31: (0)             sys.modules['htmlparser'] = htmlparser
32: (0)             # Monkeypatch `HTMLParser` to only accept `?>` to close Processing Instructions.
33: (0)             htmlparser.piclose = re.compile(r'\?>')
34: (0)             # Monkeypatch `HTMLParser` to only recognize entity references with a closing semicolon.
35: (0)             htmlparser.entityref = re.compile(r'&([a-zA-Z][-.a-zA-Z0-9]*);')
36: (0)             # Monkeypatch `HTMLParser` to no longer support partial entities. We are always feeding a complete block,
37: (0)             # so the 'incomplete' functionality is unnecessary. As the `entityref` regex is run right before incomplete,
38: (0)             # and the two regex are the same, then incomplete will simply never match and we avoid the logic within.
39: (0)             htmlparser.incomplete = htmlparser.entityref
40: (0)             # Monkeypatch `HTMLParser` to not accept a backtick in a tag name, attribute name, or bare value.
41: (0)             htmlparser.locatestarttagend_tolerant = re.compile(r"""
42: (2)               <[a-zA-Z][^`\t\n\r\f />\x00]*       # tag name <= added backtick here
43: (2)               (?:[\s/]*                           # optional whitespace before attribute name
44: (4)                 (?:(?<=['"\s/])[^`\s/>][^\s/=>]*  # attribute name <= added backtick here
45: (6)                   (?:\s*=+\s*                     # value indicator
46: (8)                     (?:'[^']*'                    # LITA-enclosed value
47: (10)                      |"[^"]*"                    # LIT-enclosed value
48: (10)                      |(?!['"])[^`>\s]*           # bare value <= added backtick here
49: (9)                      )
50: (9)                      (?:\s*,)*                    # possibly followed by a comma
51: (7)                    )?(?:\s|/(?!>))*
52: (5)                  )*
53: (3)                )?
54: (2)               \s*                                 # trailing whitespace
55: (0)             """, re.VERBOSE)
56: (0)             # Match a blank line at the start of a block of text (two newlines).
57: (0)             # The newlines may be preceded by additional whitespace.
58: (0)             blank_line_re = re.compile(r'^([ ]*\n){2}')
59: (0)             class HTMLExtractor(htmlparser.HTMLParser):
60: (4)                 """
61: (4)                 Extract raw HTML from text.
62: (4)                 The raw HTML is stored in the [`htmlStash`][markdown.util.HtmlStash] of the
63: (4)                 [`Markdown`][markdown.Markdown] instance passed to `md` and the remaining text
64: (4)                 is stored in `cleandoc` as a list of strings.
65: (4)                 """
66: (4)                 def __init__(self, md: Markdown, *args, **kwargs):
67: (8)                     if 'convert_charrefs' not in kwargs:
68: (12)                        kwargs['convert_charrefs'] = False
69: (8)                     # Block tags that should contain no content (self closing)
70: (8)                     self.empty_tags = set(['hr'])
71: (8)                     self.lineno_start_cache = [0]
72: (8)                     # This calls self.reset
73: (8)                     super().__init__(*args, **kwargs)
74: (8)                     self.md = md
75: (4)                 def reset(self):
76: (8)                     """Reset this instance.  Loses all unprocessed data."""
77: (8)                     self.inraw = False
78: (8)                     self.intail = False
79: (8)                     self.stack: list[str] = []  # When `inraw==True`, stack contains a list of tags
80: (8)                     self._cache: list[str] = []
81: (8)                     self.cleandoc: list[str] = []
82: (8)                     self.lineno_start_cache = [0]
83: (8)                     super().reset()
84: (4)                 def close(self):
85: (8)                     """Handle any buffered data."""
86: (8)                     super().close()
87: (8)                     if len(self.rawdata):
88: (12)                        # Temp fix for https://bugs.python.org/issue41989
89: (12)                        # TODO: remove this when the bug is fixed in all supported Python versions.
90: (12)                        if self.convert_charrefs and not self.cdata_elem:  # pragma: no cover
91: (16)                            self.handle_data(htmlparser.unescape(self.rawdata))
92: (12)                        else:
93: (16)                            self.handle_data(self.rawdata)
94: (8)                     # Handle any unclosed tags.
95: (8)                     if len(self._cache):
96: (12)                        self.cleandoc.append(self.md.htmlStash.store(''.join(self._cache)))
97: (12)                        self._cache = []
98: (4)                 @property
99: (4)                 def line_offset(self) -> int:
100: (8)                    """Returns char index in `self.rawdata` for the start of the current line. """
101: (8)                    for ii in range(len(self.lineno_start_cache)-1, self.lineno-1):
102: (12)                       last_line_start_pos = self.lineno_start_cache[ii]
103: (12)                       lf_pos = self.rawdata.find('\n', last_line_start_pos)
104: (12)                       if lf_pos == -1:
105: (16)                           # No more newlines found. Use end of raw data as start of line beyond end.
106: (16)                           lf_pos = len(self.rawdata)
107: (12)                       self.lineno_start_cache.append(lf_pos+1)
108: (8)                    return self.lineno_start_cache[self.lineno-1]
109: (4)                def at_line_start(self) -> bool:
110: (8)                    """
111: (8)                    Returns True if current position is at start of line.
112: (8)                    Allows for up to three blank spaces at start of line.
113: (8)                    """
114: (8)                    if self.offset == 0:
115: (12)                       return True
116: (8)                    if self.offset > 3:
117: (12)                       return False
118: (8)                    # Confirm up to first 3 chars are whitespace
119: (8)                    return self.rawdata[self.line_offset:self.line_offset + self.offset].strip() == ''
120: (4)                def get_endtag_text(self, tag: str) -> str:
121: (8)                    """
122: (8)                    Returns the text of the end tag.
123: (8)                    If it fails to extract the actual text from the raw data, it builds a closing tag with `tag`.
124: (8)                    """
125: (8)                    # Attempt to extract actual tag from raw source text
126: (8)                    start = self.line_offset + self.offset
127: (8)                    m = htmlparser.endendtag.search(self.rawdata, start)
128: (8)                    if m:
129: (12)                       return self.rawdata[start:m.end()]
130: (8)                    else:  # pragma: no cover
131: (12)                       # Failed to extract from raw data. Assume well formed and lowercase.
132: (12)                       return '</{}>'.format(tag)
133: (4)                def handle_starttag(self, tag: str, attrs: Sequence[tuple[str, str]]):
134: (8)                    # Handle tags that should always be empty and do not specify a closing tag
135: (8)                    if tag in self.empty_tags:
136: (12)                       self.handle_startendtag(tag, attrs)
137: (12)                       return
138: (8)                    if self.md.is_block_level(tag) and (self.intail or (self.at_line_start() and not self.inraw)):
139: (12)                       # Started a new raw block. Prepare stack.
140: (12)                       self.inraw = True
141: (12)                       self.cleandoc.append('\n')
142: (8)                    text = self.get_starttag_text()
143: (8)                    if self.inraw:
144: (12)                       self.stack.append(tag)
145: (12)                       self._cache.append(text)
146: (8)                    else:
147: (12)                       self.cleandoc.append(text)
148: (12)                       if tag in self.CDATA_CONTENT_ELEMENTS:
149: (16)                           # This is presumably a standalone tag in a code span (see #1036).
150: (16)                           self.clear_cdata_mode()
151: (4)                def handle_endtag(self, tag: str):
152: (8)                    text = self.get_endtag_text(tag)
153: (8)                    if self.inraw:
154: (12)                       self._cache.append(text)
155: (12)                       if tag in self.stack:
156: (16)                           # Remove tag from stack
157: (16)                           while self.stack:
158: (20)                               if self.stack.pop() == tag:
159: (24)                                   break
160: (12)                       if len(self.stack) == 0:
161: (16)                           # End of raw block.
162: (16)                           if blank_line_re.match(self.rawdata[self.line_offset + self.offset + len(text):]):
163: (20)                               # Preserve blank line and end of raw block.
164: (20)                               self._cache.append('\n')
165: (16)                           else:
166: (20)                               # More content exists after `endtag`.
167: (20)                               self.intail = True
168: (16)                           # Reset stack.
169: (16)                           self.inraw = False
170: (16)                           self.cleandoc.append(self.md.htmlStash.store(''.join(self._cache)))
171: (16)                           # Insert blank line between this and next line.
172: (16)                           self.cleandoc.append('\n\n')
173: (16)                           self._cache = []
174: (8)                    else:
175: (12)                       self.cleandoc.append(text)
176: (4)                def handle_data(self, data: str):
177: (8)                    if self.intail and '\n' in data:
178: (12)                       self.intail = False
179: (8)                    if self.inraw:
180: (12)                       self._cache.append(data)
181: (8)                    else:
182: (12)                       self.cleandoc.append(data)
183: (4)                def handle_empty_tag(self, data: str, is_block: bool):
184: (8)                    """ Handle empty tags (`<data>`). """
185: (8)                    if self.inraw or self.intail:
186: (12)                       # Append this to the existing raw block
187: (12)                       self._cache.append(data)
188: (8)                    elif self.at_line_start() and is_block:
189: (12)                       # Handle this as a standalone raw block
190: (12)                       if blank_line_re.match(self.rawdata[self.line_offset + self.offset + len(data):]):
191: (16)                           # Preserve blank line after tag in raw block.
192: (16)                           data += '\n'
193: (12)                       else:
194: (16)                           # More content exists after tag.
195: (16)                           self.intail = True
196: (12)                       item = self.cleandoc[-1] if self.cleandoc else ''
197: (12)                       # If we only have one newline before block element, add another
198: (12)                       if not item.endswith('\n\n') and item.endswith('\n'):
199: (16)                           self.cleandoc.append('\n')
200: (12)                       self.cleandoc.append(self.md.htmlStash.store(data))
201: (12)                       # Insert blank line between this and next line.
202: (12)                       self.cleandoc.append('\n\n')
203: (8)                    else:
204: (12)                       self.cleandoc.append(data)
205: (4)                def handle_startendtag(self, tag: str, attrs):
206: (8)                    self.handle_empty_tag(self.get_starttag_text(), is_block=self.md.is_block_level(tag))
207: (4)                def handle_charref(self, name: str):
208: (8)                    self.handle_empty_tag('&#{};'.format(name), is_block=False)
209: (4)                def handle_entityref(self, name: str):
210: (8)                    self.handle_empty_tag('&{};'.format(name), is_block=False)
211: (4)                def handle_comment(self, data: str):
212: (8)                    self.handle_empty_tag('<!--{}-->'.format(data), is_block=True)
213: (4)                def handle_decl(self, data: str):
214: (8)                    self.handle_empty_tag('<!{}>'.format(data), is_block=True)
215: (4)                def handle_pi(self, data: str):
216: (8)                    self.handle_empty_tag('<?{}?>'.format(data), is_block=True)
217: (4)                def unknown_decl(self, data: str):
218: (8)                    end = ']]>' if data.startswith('CDATA[') else ']>'
219: (8)                    self.handle_empty_tag('<![{}{}'.format(data, end), is_block=True)
220: (4)                def parse_pi(self, i: int) -> int:
221: (8)                    if self.at_line_start() or self.intail:
222: (12)                       return super().parse_pi(i)
223: (8)                    # This is not the beginning of a raw block so treat as plain data
224: (8)                    # and avoid consuming any tags which may follow (see #1066).
225: (8)                    self.handle_data('<?')
226: (8)                    return i + 2
227: (4)                def parse_html_declaration(self, i: int) -> int:
228: (8)                    if self.at_line_start() or self.intail:
229: (12)                       return super().parse_html_declaration(i)
230: (8)                    # This is not the beginning of a raw block so treat as plain data
231: (8)                    # and avoid consuming any tags which may follow (see #1066).
232: (8)                    self.handle_data('<!')
233: (8)                    return i + 2
234: (4)                def parse_bogus_comment(self, i: int, report: int = 0) -> int:
235: (8)                    # Override the default behavior so that bogus comments get passed
236: (8)                    # through unaltered by setting `report` to `0` (see #1425).
237: (8)                    pos = super().parse_bogus_comment(i, report)
238: (8)                    if pos == -1:  # pragma: no cover
239: (12)                       return -1
240: (8)                    self.handle_empty_tag(self.rawdata[i:pos], is_block=False)
241: (8)                    return pos
242: (4)                # The rest has been copied from base class in standard lib to address #1036.
243: (4)                # As `__startag_text` is private, all references to it must be in this subclass.
244: (4)                # The last few lines of `parse_starttag` are reversed so that `handle_starttag`
245: (4)                # can override `cdata_mode` in certain situations (in a code span).
246: (4)                __starttag_text: str | None = None
247: (4)                def get_starttag_text(self) -> str:
248: (8)                    """Return full source of start tag: `<...>`."""
249: (8)                    return self.__starttag_text
250: (4)                def parse_starttag(self, i: int) -> int:  # pragma: no cover
251: (8)                    self.__starttag_text = None
252: (8)                    endpos = self.check_for_whole_start_tag(i)
253: (8)                    if endpos < 0:
254: (12)                       return endpos
255: (8)                    rawdata = self.rawdata
256: (8)                    self.__starttag_text = rawdata[i:endpos]
257: (8)                    # Now parse the data between `i+1` and `j` into a tag and `attrs`
258: (8)                    attrs = []
259: (8)                    match = htmlparser.tagfind_tolerant.match(rawdata, i+1)
260: (8)                    assert match, 'unexpected call to parse_starttag()'
261: (8)                    k = match.end()
262: (8)                    self.lasttag = tag = match.group(1).lower()
263: (8)                    while k < endpos:
264: (12)                       m = htmlparser.attrfind_tolerant.match(rawdata, k)
265: (12)                       if not m:
266: (16)                           break
267: (12)                       attrname, rest, attrvalue = m.group(1, 2, 3)
268: (12)                       if not rest:
269: (16)                           attrvalue = None
270: (12)                       elif attrvalue[:1] == '\'' == attrvalue[-1:] or \
271: (17)                            attrvalue[:1] == '"' == attrvalue[-1:]:  # noqa: E127
272: (16)                           attrvalue = attrvalue[1:-1]
273: (12)                       if attrvalue:
274: (16)                           attrvalue = htmlparser.unescape(attrvalue)
275: (12)                       attrs.append((attrname.lower(), attrvalue))
276: (12)                       k = m.end()
277: (8)                    end = rawdata[k:endpos].strip()
278: (8)                    if end not in (">", "/>"):
279: (12)                       lineno, offset = self.getpos()
280: (12)                       if "\n" in self.__starttag_text:
281: (16)                           lineno = lineno + self.__starttag_text.count("\n")
282: (16)                           offset = len(self.__starttag_text) \
283: (25)                                    - self.__starttag_text.rfind("\n")  # noqa: E127
284: (12)                       else:
285: (16)                           offset = offset + len(self.__starttag_text)
286: (12)                       self.handle_data(rawdata[i:endpos])
287: (12)                       return endpos
288: (8)                    if end.endswith('/>'):
289: (12)                       # XHTML-style empty tag: `<span attr="value" />`
290: (12)                       self.handle_startendtag(tag, attrs)
291: (8)                    else:
292: (12)                       # *** set `cdata_mode` first so we can override it in `handle_starttag` (see #1036) ***
293: (12)                       if tag in self.CDATA_CONTENT_ELEMENTS:
294: (16)                           self.set_cdata_mode(tag)
295: (12)                       self.handle_starttag(tag, attrs)
296: (8)                    return endpos

----------------------------------------

File 8 - . \inlinepatterns.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             In version 3.0, a new, more flexible inline processor was added, [`markdown.inlinepatterns.InlineProcessor`][].   The
16: (0)             original inline patterns, which inherit from [`markdown.inlinepatterns.Pattern`][] or one of its children are still
17: (0)             supported, though users are encouraged to migrate.
18: (0)             The new `InlineProcessor` provides two major enhancements to `Patterns`:
19: (0)             1. Inline Processors no longer need to match the entire block, so regular expressions no longer need to start with
20: (2)               `r'^(.*?)'` and end with `r'(.*?)%'`. This runs faster. The returned [`Match`][re.Match] object will only contain
21: (3)                what is explicitly matched in the pattern, and extension pattern groups now start with `m.group(1)`.
22: (0)             2.  The `handleMatch` method now takes an additional input called `data`, which is the entire block under analysis,
23: (4)                 not just what is matched with the specified pattern. The method now returns the element *and* the indexes relative
24: (4)                 to `data` that the return element is replacing (usually `m.start(0)` and `m.end(0)`).  If the boundaries are
25: (4)                 returned as `None`, it is assumed that the match did not take place, and nothing will be altered in `data`.
26: (4)                 This allows handling of more complex constructs than regular expressions can handle, e.g., matching nested
27: (4)                 brackets, and explicit control of the span "consumed" by the processor.
28: (0)             """
29: (0)             from __future__ import annotations
30: (0)             from . import util
31: (0)             from typing import TYPE_CHECKING, Any, Collection, NamedTuple
32: (0)             import re
33: (0)             import xml.etree.ElementTree as etree
34: (0)             from html import entities
35: (0)             if TYPE_CHECKING:  # pragma: no cover
36: (4)                 from markdown import Markdown
37: (0)             def build_inlinepatterns(md: Markdown, **kwargs: Any) -> util.Registry[InlineProcessor]:
38: (4)                 """
39: (4)                 Build the default set of inline patterns for Markdown.
40: (4)                 The order in which processors and/or patterns are applied is very important - e.g. if we first replace
41: (4)                 `http://.../` links with `<a>` tags and _then_ try to replace inline HTML, we would end up with a mess. So, we
42: (4)                 apply the expressions in the following order:
43: (4)                 * backticks and escaped characters have to be handled before everything else so that we can preempt any markdown
44: (6)                   patterns by escaping them;
45: (4)                 * then we handle the various types of links (auto-links must be handled before inline HTML);
46: (4)                 * then we handle inline HTML.  At this point we will simply replace all inline HTML strings with a placeholder
47: (6)                   and add the actual HTML to a stash;
48: (4)                 * finally we apply strong, emphasis, etc.
49: (4)                 """
50: (4)                 inlinePatterns = util.Registry()
51: (4)                 inlinePatterns.register(BacktickInlineProcessor(BACKTICK_RE), 'backtick', 190)
52: (4)                 inlinePatterns.register(EscapeInlineProcessor(ESCAPE_RE, md), 'escape', 180)
53: (4)                 inlinePatterns.register(ReferenceInlineProcessor(REFERENCE_RE, md), 'reference', 170)
54: (4)                 inlinePatterns.register(LinkInlineProcessor(LINK_RE, md), 'link', 160)
55: (4)                 inlinePatterns.register(ImageInlineProcessor(IMAGE_LINK_RE, md), 'image_link', 150)
56: (4)                 inlinePatterns.register(
57: (8)                     ImageReferenceInlineProcessor(IMAGE_REFERENCE_RE, md), 'image_reference', 140
58: (4)                 )
59: (4)                 inlinePatterns.register(
60: (8)                     ShortReferenceInlineProcessor(REFERENCE_RE, md), 'short_reference', 130
61: (4)                 )
62: (4)                 inlinePatterns.register(
63: (8)                     ShortImageReferenceInlineProcessor(IMAGE_REFERENCE_RE, md), 'short_image_ref', 125
64: (4)                 )
65: (4)                 inlinePatterns.register(AutolinkInlineProcessor(AUTOLINK_RE, md), 'autolink', 120)
66: (4)                 inlinePatterns.register(AutomailInlineProcessor(AUTOMAIL_RE, md), 'automail', 110)
67: (4)                 inlinePatterns.register(SubstituteTagInlineProcessor(LINE_BREAK_RE, 'br'), 'linebreak', 100)
68: (4)                 inlinePatterns.register(HtmlInlineProcessor(HTML_RE, md), 'html', 90)
69: (4)                 inlinePatterns.register(HtmlInlineProcessor(ENTITY_RE, md), 'entity', 80)
70: (4)                 inlinePatterns.register(SimpleTextInlineProcessor(NOT_STRONG_RE), 'not_strong', 70)
71: (4)                 inlinePatterns.register(AsteriskProcessor(r'\*'), 'em_strong', 60)
72: (4)                 inlinePatterns.register(UnderscoreProcessor(r'_'), 'em_strong2', 50)
73: (4)                 return inlinePatterns
74: (0)             # The actual regular expressions for patterns
75: (0)             # -----------------------------------------------------------------------------
76: (0)             NOIMG = r'(?<!\!)'
77: (0)             """ Match not an image. Partial regular expression which matches if not preceded by `!`. """
78: (0)             BACKTICK_RE = r'(?:(?<!\\)((?:\\{2})+)(?=`+)|(?<!\\)(`+)(.+?)(?<!`)\2(?!`))'
79: (0)             """ Match backtick quoted string (`` `e=f()` `` or ``` ``e=f("`")`` ```). """
80: (0)             ESCAPE_RE = r'\\(.)'
81: (0)             """ Match a backslash escaped character (`\\<` or `\\*`). """
82: (0)             EMPHASIS_RE = r'(\*)([^\*]+)\1'
83: (0)             """ Match emphasis with an asterisk (`*emphasis*`). """
84: (0)             STRONG_RE = r'(\*{2})(.+?)\1'
85: (0)             """ Match strong with an asterisk (`**strong**`). """
86: (0)             SMART_STRONG_RE = r'(?<!\w)(_{2})(?!_)(.+?)(?<!_)\1(?!\w)'
87: (0)             """ Match strong with underscore while ignoring middle word underscores (`__smart__strong__`). """
88: (0)             SMART_EMPHASIS_RE = r'(?<!\w)(_)(?!_)(.+?)(?<!_)\1(?!\w)'
89: (0)             """ Match emphasis with underscore while ignoring middle word underscores (`_smart_emphasis_`). """
90: (0)             SMART_STRONG_EM_RE = r'(?<!\w)(\_)\1(?!\1)(.+?)(?<!\w)\1(?!\1)(.+?)\1{3}(?!\w)'
91: (0)             """ Match strong emphasis with underscores (`__strong _em__`). """
92: (0)             EM_STRONG_RE = r'(\*)\1{2}(.+?)\1(.*?)\1{2}'
93: (0)             """ Match emphasis strong with asterisk (`***strongem***` or `***em*strong**`). """
94: (0)             EM_STRONG2_RE = r'(_)\1{2}(.+?)\1(.*?)\1{2}'
95: (0)             """ Match emphasis strong with underscores (`___emstrong___` or `___em_strong__`). """
96: (0)             STRONG_EM_RE = r'(\*)\1{2}(.+?)\1{2}(.*?)\1'
97: (0)             """ Match strong emphasis with asterisk (`***strong**em*`). """
98: (0)             STRONG_EM2_RE = r'(_)\1{2}(.+?)\1{2}(.*?)\1'
99: (0)             """ Match strong emphasis with underscores (`___strong__em_`). """
100: (0)            STRONG_EM3_RE = r'(\*)\1(?!\1)([^*]+?)\1(?!\1)(.+?)\1{3}'
101: (0)            """ Match strong emphasis with asterisk (`**strong*em***`). """
102: (0)            LINK_RE = NOIMG + r'\['
103: (0)            """ Match start of in-line link (`[text](url)` or `[text](<url>)` or `[text](url "title")`). """
104: (0)            IMAGE_LINK_RE = r'\!\['
105: (0)            """ Match start of in-line image link (`![alttxt](url)` or `![alttxt](<url>)`). """
106: (0)            REFERENCE_RE = LINK_RE
107: (0)            """ Match start of reference link (`[Label][3]`). """
108: (0)            IMAGE_REFERENCE_RE = IMAGE_LINK_RE
109: (0)            """ Match start of image reference (`![alt text][2]`). """
110: (0)            NOT_STRONG_RE = r'((^|(?<=\s))(\*{1,3}|_{1,3})(?=\s|$))'
111: (0)            """ Match a stand-alone `*` or `_`. """
112: (0)            AUTOLINK_RE = r'<((?:[Ff]|[Hh][Tt])[Tt][Pp][Ss]?://[^<>]*)>'
113: (0)            """ Match an automatic link (`<http://www.example.com>`). """
114: (0)            AUTOMAIL_RE = r'<([^<> !]+@[^@<> ]+)>'
115: (0)            """ Match an automatic email link (`<me@example.com>`). """
116: (0)            HTML_RE = r'(<(\/?[a-zA-Z][^<>@ ]*( [^<>]*)?|!--(?:(?!<!--|-->).)*--)>)'
117: (0)            """ Match an HTML tag (`<...>`). """
118: (0)            ENTITY_RE = r'(&(?:\#[0-9]+|\#x[0-9a-fA-F]+|[a-zA-Z0-9]+);)'
119: (0)            """ Match an HTML entity (`&#38;` (decimal) or `&#x26;` (hex) or `&amp;` (named)). """
120: (0)            LINE_BREAK_RE = r'  \n'
121: (0)            """ Match two spaces at end of line. """
122: (0)            def dequote(string: str) -> str:
123: (4)                """Remove quotes from around a string."""
124: (4)                if ((string.startswith('"') and string.endswith('"')) or
125: (7)                   (string.startswith("'") and string.endswith("'"))):
126: (8)                    return string[1:-1]
127: (4)                else:
128: (8)                    return string
129: (0)            class EmStrongItem(NamedTuple):
130: (4)                """Emphasis/strong pattern item."""
131: (4)                pattern: re.Pattern[str]
132: (4)                builder: str
133: (4)                tags: str
134: (0)            # The pattern classes
135: (0)            # -----------------------------------------------------------------------------
136: (0)            class Pattern:  # pragma: no cover
137: (4)                """
138: (4)                Base class that inline patterns subclass.
139: (4)                Inline patterns are handled by means of `Pattern` subclasses, one per regular expression.
140: (4)                Each pattern object uses a single regular expression and must support the following methods:
141: (4)                [`getCompiledRegExp`][markdown.inlinepatterns.Pattern.getCompiledRegExp] and
142: (4)                [`handleMatch`][markdown.inlinepatterns.Pattern.handleMatch].
143: (4)                All the regular expressions used by `Pattern` subclasses must capture the whole block.  For this
144: (4)                reason, they all start with `^(.*)` and end with `(.*)!`.  When passing a regular expression on
145: (4)                class initialization, the `^(.*)` and `(.*)!` are added automatically and the regular expression
146: (4)                is pre-compiled.
147: (4)                It is strongly suggested that the newer style [`markdown.inlinepatterns.InlineProcessor`][] that
148: (4)                use a more efficient and flexible search approach be used instead. However, the older style
149: (4)                `Pattern` remains for backward compatibility with many existing third-party extensions.
150: (4)                """
151: (4)                ANCESTOR_EXCLUDES: Collection[str] = tuple()
152: (4)                """
153: (4)                A collection of elements which are undesirable ancestors. The processor will be skipped if it
154: (4)                would cause the content to be a descendant of one of the listed tag names.
155: (4)                """
156: (4)                compiled_re: re.Pattern[str]
157: (4)                md: Markdown | None
158: (4)                def __init__(self, pattern: str, md: Markdown | None = None):
159: (8)                    """
160: (8)                    Create an instant of an inline pattern.
161: (8)                    Arguments:
162: (12)                       pattern: A regular expression that matches a pattern.
163: (12)                       md: An optional pointer to the instance of `markdown.Markdown` and is available as
164: (16)                           `self.md` on the class instance.
165: (8)                    """
166: (8)                    self.pattern = pattern
167: (8)                    self.compiled_re = re.compile(r"^(.*?)%s(.*)$" % pattern,
168: (38)                                                 re.DOTALL | re.UNICODE)
169: (8)                    self.md = md
170: (4)                def getCompiledRegExp(self) -> re.Pattern:
171: (8)                    """ Return a compiled regular expression. """
172: (8)                    return self.compiled_re
173: (4)                def handleMatch(self, m: re.Match[str]) -> etree.Element | str:
174: (8)                    """Return a ElementTree element from the given match.
175: (8)                    Subclasses should override this method.
176: (8)                    Arguments:
177: (12)                       m: A match object containing a match of the pattern.
178: (8)                    Returns: An ElementTree Element object.
179: (8)                    """
180: (8)                    pass  # pragma: no cover
181: (4)                def type(self) -> str:
182: (8)                    """ Return class name, to define pattern type """
183: (8)                    return self.__class__.__name__
184: (4)                def unescape(self, text: str) -> str:
185: (8)                    """ Return unescaped text given text with an inline placeholder. """
186: (8)                    try:
187: (12)                       stash = self.md.treeprocessors['inline'].stashed_nodes
188: (8)                    except KeyError:  # pragma: no cover
189: (12)                       return text
190: (8)                    def get_stash(m):
191: (12)                       id = m.group(1)
192: (12)                       if id in stash:
193: (16)                           value = stash.get(id)
194: (16)                           if isinstance(value, str):
195: (20)                               return value
196: (16)                           else:
197: (20)                               # An `etree` Element - return text content only
198: (20)                               return ''.join(value.itertext())
199: (8)                    return util.INLINE_PLACEHOLDER_RE.sub(get_stash, text)
200: (0)            class InlineProcessor(Pattern):
201: (4)                """
202: (4)                Base class that inline processors subclass.
203: (4)                This is the newer style inline processor that uses a more
204: (4)                efficient and flexible search approach.
205: (4)                """
206: (4)                def __init__(self, pattern: str, md: Markdown | None = None):
207: (8)                    """
208: (8)                    Create an instant of an inline processor.
209: (8)                    Arguments:
210: (12)                       pattern: A regular expression that matches a pattern.
211: (12)                       md: An optional pointer to the instance of `markdown.Markdown` and is available as
212: (16)                           `self.md` on the class instance.
213: (8)                    """
214: (8)                    self.pattern = pattern
215: (8)                    self.compiled_re = re.compile(pattern, re.DOTALL | re.UNICODE)
216: (8)                    # API for Markdown to pass `safe_mode` into instance
217: (8)                    self.safe_mode = False
218: (8)                    self.md = md
219: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | str | None, int | None, int | None]:
220: (8)                    """Return a ElementTree element from the given match and the
221: (8)                    start and end index of the matched text.
222: (8)                    If `start` and/or `end` are returned as `None`, it will be
223: (8)                    assumed that the processor did not find a valid region of text.
224: (8)                    Subclasses should override this method.
225: (8)                    Arguments:
226: (12)                       m: A re match object containing a match of the pattern.
227: (12)                       data: The buffer currently under analysis.
228: (8)                    Returns:
229: (12)                       el: The ElementTree element, text or None.
230: (12)                       start: The start of the region that has been matched or None.
231: (12)                       end: The end of the region that has been matched or None.
232: (8)                    """
233: (8)                    pass  # pragma: no cover
234: (0)            class SimpleTextPattern(Pattern):  # pragma: no cover
235: (4)                """ Return a simple text of `group(2)` of a Pattern. """
236: (4)                def handleMatch(self, m: re.Match[str]) -> str:
237: (8)                    """ Return string content of `group(2)` of a matching pattern. """
238: (8)                    return m.group(2)
239: (0)            class SimpleTextInlineProcessor(InlineProcessor):
240: (4)                """ Return a simple text of `group(1)` of a Pattern. """
241: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[str, int, int]:
242: (8)                    """ Return string content of `group(1)` of a matching pattern. """
243: (8)                    return m.group(1), m.start(0), m.end(0)
244: (0)            class EscapeInlineProcessor(InlineProcessor):
245: (4)                """ Return an escaped character. """
246: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[str | None, int, int]:
247: (8)                    """
248: (8)                    If the character matched by `group(1)` of a pattern is in [`ESCAPED_CHARS`][markdown.Markdown.ESCAPED_CHARS]
249: (8)                    then return the integer representing the character's Unicode code point (as returned by [`ord`][]) wrapped
250: (8)                    in [`util.STX`][markdown.util.STX] and [`util.ETX`][markdown.util.ETX].
251: (8)                    If the matched character is not in [`ESCAPED_CHARS`][markdown.Markdown.ESCAPED_CHARS], then return `None`.
252: (8)                    """
253: (8)                    char = m.group(1)
254: (8)                    if char in self.md.ESCAPED_CHARS:
255: (12)                       return '{}{}{}'.format(util.STX, ord(char), util.ETX), m.start(0), m.end(0)
256: (8)                    else:
257: (12)                       return None, m.start(0), m.end(0)
258: (0)            class SimpleTagPattern(Pattern):  # pragma: no cover
259: (4)                """
260: (4)                Return element of type `tag` with a text attribute of `group(3)`
261: (4)                of a Pattern.
262: (4)                """
263: (4)                def __init__(self, pattern: str, tag: str):
264: (8)                    """
265: (8)                    Create an instant of an simple tag pattern.
266: (8)                    Arguments:
267: (12)                       pattern: A regular expression that matches a pattern.
268: (12)                       tag: Tag of element.
269: (8)                    """
270: (8)                    Pattern.__init__(self, pattern)
271: (8)                    self.tag = tag
272: (8)                    """ The tag of the rendered element. """
273: (4)                def handleMatch(self, m: re.Match[str]) -> etree.Element:
274: (8)                    """
275: (8)                    Return [`Element`][xml.etree.ElementTree.Element] of type `tag` with the string in `group(3)` of a
276: (8)                    matching pattern as the Element's text.
277: (8)                    """
278: (8)                    el = etree.Element(self.tag)
279: (8)                    el.text = m.group(3)
280: (8)                    return el
281: (0)            class SimpleTagInlineProcessor(InlineProcessor):
282: (4)                """
283: (4)                Return element of type `tag` with a text attribute of `group(2)`
284: (4)                of a Pattern.
285: (4)                """
286: (4)                def __init__(self, pattern: str, tag: str):
287: (8)                    """
288: (8)                    Create an instant of an simple tag processor.
289: (8)                    Arguments:
290: (12)                       pattern: A regular expression that matches a pattern.
291: (12)                       tag: Tag of element.
292: (8)                    """
293: (8)                    InlineProcessor.__init__(self, pattern)
294: (8)                    self.tag = tag
295: (8)                    """ The tag of the rendered element. """
296: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:  # pragma: no cover
297: (8)                    """
298: (8)                    Return [`Element`][xml.etree.ElementTree.Element] of type `tag` with the string in `group(2)` of a
299: (8)                    matching pattern as the Element's text.
300: (8)                    """
301: (8)                    el = etree.Element(self.tag)
302: (8)                    el.text = m.group(2)
303: (8)                    return el, m.start(0), m.end(0)
304: (0)            class SubstituteTagPattern(SimpleTagPattern):  # pragma: no cover
305: (4)                """ Return an element of type `tag` with no children. """
306: (4)                def handleMatch(self, m: re.Match[str]) -> etree.Element:
307: (8)                    """ Return empty [`Element`][xml.etree.ElementTree.Element] of type `tag`. """
308: (8)                    return etree.Element(self.tag)
309: (0)            class SubstituteTagInlineProcessor(SimpleTagInlineProcessor):
310: (4)                """ Return an element of type `tag` with no children. """
311: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:
312: (8)                    """ Return empty [`Element`][xml.etree.ElementTree.Element] of type `tag`. """
313: (8)                    return etree.Element(self.tag), m.start(0), m.end(0)
314: (0)            class BacktickInlineProcessor(InlineProcessor):
315: (4)                """ Return a `<code>` element containing the escaped matching text. """
316: (4)                def __init__(self, pattern: str):
317: (8)                    InlineProcessor.__init__(self, pattern)
318: (8)                    self.ESCAPED_BSLASH = '{}{}{}'.format(util.STX, ord('\\'), util.ETX)
319: (8)                    self.tag = 'code'
320: (8)                    """ The tag of the rendered element. """
321: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | str, int, int]:
322: (8)                    """
323: (8)                    If the match contains `group(3)` of a pattern, then return a `code`
324: (8)                    [`Element`][xml.etree.ElementTree.Element] which contains HTML escaped text (with
325: (8)                    [`code_escape`][markdown.util.code_escape]) as an [`AtomicString`][markdown.util.AtomicString].
326: (8)                    If the match does not contain `group(3)` then return the text of `group(1)` backslash escaped.
327: (8)                    """
328: (8)                    if m.group(3):
329: (12)                       el = etree.Element(self.tag)
330: (12)                       el.text = util.AtomicString(util.code_escape(m.group(3).strip()))
331: (12)                       return el, m.start(0), m.end(0)
332: (8)                    else:
333: (12)                       return m.group(1).replace('\\\\', self.ESCAPED_BSLASH), m.start(0), m.end(0)
334: (0)            class DoubleTagPattern(SimpleTagPattern):  # pragma: no cover
335: (4)                """Return a ElementTree element nested in tag2 nested in tag1.
336: (4)                Useful for strong emphasis etc.
337: (4)                """
338: (4)                def handleMatch(self, m: re.Match[str]) -> etree.Element:
339: (8)                    """
340: (8)                    Return [`Element`][xml.etree.ElementTree.Element] in following format:
341: (8)                    `<tag1><tag2>group(3)</tag2>group(4)</tag2>` where `group(4)` is optional.
342: (8)                    """
343: (8)                    tag1, tag2 = self.tag.split(",")
344: (8)                    el1 = etree.Element(tag1)
345: (8)                    el2 = etree.SubElement(el1, tag2)
346: (8)                    el2.text = m.group(3)
347: (8)                    if len(m.groups()) == 5:
348: (12)                       el2.tail = m.group(4)
349: (8)                    return el1
350: (0)            class DoubleTagInlineProcessor(SimpleTagInlineProcessor):
351: (4)                """Return a ElementTree element nested in tag2 nested in tag1.
352: (4)                Useful for strong emphasis etc.
353: (4)                """
354: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:  # pragma: no cover
355: (8)                    """
356: (8)                    Return [`Element`][xml.etree.ElementTree.Element] in following format:
357: (8)                    `<tag1><tag2>group(2)</tag2>group(3)</tag2>` where `group(3)` is optional.
358: (8)                    """
359: (8)                    tag1, tag2 = self.tag.split(",")
360: (8)                    el1 = etree.Element(tag1)
361: (8)                    el2 = etree.SubElement(el1, tag2)
362: (8)                    el2.text = m.group(2)
363: (8)                    if len(m.groups()) == 3:
364: (12)                       el2.tail = m.group(3)
365: (8)                    return el1, m.start(0), m.end(0)
366: (0)            class HtmlInlineProcessor(InlineProcessor):
367: (4)                """ Store raw inline html and return a placeholder. """
368: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[str, int, int]:
369: (8)                    """ Store the text of `group(1)` of a pattern and return a placeholder string. """
370: (8)                    rawhtml = self.backslash_unescape(self.unescape(m.group(1)))
371: (8)                    place_holder = self.md.htmlStash.store(rawhtml)
372: (8)                    return place_holder, m.start(0), m.end(0)
373: (4)                def unescape(self, text: str) -> str:
374: (8)                    """ Return unescaped text given text with an inline placeholder. """
375: (8)                    try:
376: (12)                       stash = self.md.treeprocessors['inline'].stashed_nodes
377: (8)                    except KeyError:  # pragma: no cover
378: (12)                       return text
379: (8)                    def get_stash(m: re.Match[str]) -> str:
380: (12)                       id = m.group(1)
381: (12)                       value = stash.get(id)
382: (12)                       if value is not None:
383: (16)                           try:
384: (20)                               return self.md.serializer(value)
385: (16)                           except Exception:
386: (20)                               return r'\%s' % value
387: (8)                    return util.INLINE_PLACEHOLDER_RE.sub(get_stash, text)
388: (4)                def backslash_unescape(self, text: str) -> str:
389: (8)                    """ Return text with backslash escapes undone (backslashes are restored). """
390: (8)                    try:
391: (12)                       RE = self.md.treeprocessors['unescape'].RE
392: (8)                    except KeyError:  # pragma: no cover
393: (12)                       return text
394: (8)                    def _unescape(m: re.Match[str]) -> str:
395: (12)                       return chr(int(m.group(1)))
396: (8)                    return RE.sub(_unescape, text)
397: (0)            class AsteriskProcessor(InlineProcessor):
398: (4)                """Emphasis processor for handling strong and em matches inside asterisks."""
399: (4)                PATTERNS = [
400: (8)                    EmStrongItem(re.compile(EM_STRONG_RE, re.DOTALL | re.UNICODE), 'double', 'strong,em'),
401: (8)                    EmStrongItem(re.compile(STRONG_EM_RE, re.DOTALL | re.UNICODE), 'double', 'em,strong'),
402: (8)                    EmStrongItem(re.compile(STRONG_EM3_RE, re.DOTALL | re.UNICODE), 'double2', 'strong,em'),
403: (8)                    EmStrongItem(re.compile(STRONG_RE, re.DOTALL | re.UNICODE), 'single', 'strong'),
404: (8)                    EmStrongItem(re.compile(EMPHASIS_RE, re.DOTALL | re.UNICODE), 'single', 'em')
405: (4)                ]
406: (4)                """ The various strong and emphasis patterns handled by this processor. """
407: (4)                def build_single(self, m: re.Match[str], tag: str, idx: int) -> etree.Element:
408: (8)                    """Return single tag."""
409: (8)                    el1 = etree.Element(tag)
410: (8)                    text = m.group(2)
411: (8)                    self.parse_sub_patterns(text, el1, None, idx)
412: (8)                    return el1
413: (4)                def build_double(self, m: re.Match[str], tags: str, idx: int) -> etree.Element:
414: (8)                    """Return double tag."""
415: (8)                    tag1, tag2 = tags.split(",")
416: (8)                    el1 = etree.Element(tag1)
417: (8)                    el2 = etree.Element(tag2)
418: (8)                    text = m.group(2)
419: (8)                    self.parse_sub_patterns(text, el2, None, idx)
420: (8)                    el1.append(el2)
421: (8)                    if len(m.groups()) == 3:
422: (12)                       text = m.group(3)
423: (12)                       self.parse_sub_patterns(text, el1, el2, idx)
424: (8)                    return el1
425: (4)                def build_double2(self, m: re.Match[str], tags: str, idx: int) -> etree.Element:
426: (8)                    """Return double tags (variant 2): `<strong>text <em>text</em></strong>`."""
427: (8)                    tag1, tag2 = tags.split(",")
428: (8)                    el1 = etree.Element(tag1)
429: (8)                    el2 = etree.Element(tag2)
430: (8)                    text = m.group(2)
431: (8)                    self.parse_sub_patterns(text, el1, None, idx)
432: (8)                    text = m.group(3)
433: (8)                    el1.append(el2)
434: (8)                    self.parse_sub_patterns(text, el2, None, idx)
435: (8)                    return el1
436: (4)                def parse_sub_patterns(
437: (8)                    self, data: str, parent: etree.Element, last: etree.Element | None, idx: int
438: (4)                ) -> None:
439: (8)                    """
440: (8)                    Parses sub patterns.
441: (8)                    `data`: text to evaluate.
442: (8)                    `parent`: Parent to attach text and sub elements to.
443: (8)                    `last`: Last appended child to parent. Can also be None if parent has no children.
444: (8)                    `idx`: Current pattern index that was used to evaluate the parent.
445: (8)                    """
446: (8)                    offset = 0
447: (8)                    pos = 0
448: (8)                    length = len(data)
449: (8)                    while pos < length:
450: (12)                       # Find the start of potential emphasis or strong tokens
451: (12)                       if self.compiled_re.match(data, pos):
452: (16)                           matched = False
453: (16)                           # See if the we can match an emphasis/strong pattern
454: (16)                           for index, item in enumerate(self.PATTERNS):
455: (20)                               # Only evaluate patterns that are after what was used on the parent
456: (20)                               if index <= idx:
457: (24)                                   continue
458: (20)                               m = item.pattern.match(data, pos)
459: (20)                               if m:
460: (24)                                   # Append child nodes to parent
461: (24)                                   # Text nodes should be appended to the last
462: (24)                                   # child if present, and if not, it should
463: (24)                                   # be added as the parent's text node.
464: (24)                                   text = data[offset:m.start(0)]
465: (24)                                   if text:
466: (28)                                       if last is not None:
467: (32)                                           last.tail = text
468: (28)                                       else:
469: (32)                                           parent.text = text
470: (24)                                   el = self.build_element(m, item.builder, item.tags, index)
471: (24)                                   parent.append(el)
472: (24)                                   last = el
473: (24)                                   # Move our position past the matched hunk
474: (24)                                   offset = pos = m.end(0)
475: (24)                                   matched = True
476: (16)                           if not matched:
477: (20)                               # We matched nothing, move on to the next character
478: (20)                               pos += 1
479: (12)                       else:
480: (16)                           # Increment position as no potential emphasis start was found.
481: (16)                           pos += 1
482: (8)                    # Append any leftover text as a text node.
483: (8)                    text = data[offset:]
484: (8)                    if text:
485: (12)                       if last is not None:
486: (16)                           last.tail = text
487: (12)                       else:
488: (16)                           parent.text = text
489: (4)                def build_element(self, m: re.Match[str], builder: str, tags: str, index: int) -> etree.Element:
490: (8)                    """Element builder."""
491: (8)                    if builder == 'double2':
492: (12)                       return self.build_double2(m, tags, index)
493: (8)                    elif builder == 'double':
494: (12)                       return self.build_double(m, tags, index)
495: (8)                    else:
496: (12)                       return self.build_single(m, tags, index)
497: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:
498: (8)                    """Parse patterns."""
499: (8)                    el = None
500: (8)                    start = None
501: (8)                    end = None
502: (8)                    for index, item in enumerate(self.PATTERNS):
503: (12)                       m1 = item.pattern.match(data, m.start(0))
504: (12)                       if m1:
505: (16)                           start = m1.start(0)
506: (16)                           end = m1.end(0)
507: (16)                           el = self.build_element(m1, item.builder, item.tags, index)
508: (16)                           break
509: (8)                    return el, start, end
510: (0)            class UnderscoreProcessor(AsteriskProcessor):
511: (4)                """Emphasis processor for handling strong and em matches inside underscores."""
512: (4)                PATTERNS = [
513: (8)                    EmStrongItem(re.compile(EM_STRONG2_RE, re.DOTALL | re.UNICODE), 'double', 'strong,em'),
514: (8)                    EmStrongItem(re.compile(STRONG_EM2_RE, re.DOTALL | re.UNICODE), 'double', 'em,strong'),
515: (8)                    EmStrongItem(re.compile(SMART_STRONG_EM_RE, re.DOTALL | re.UNICODE), 'double2', 'strong,em'),
516: (8)                    EmStrongItem(re.compile(SMART_STRONG_RE, re.DOTALL | re.UNICODE), 'single', 'strong'),
517: (8)                    EmStrongItem(re.compile(SMART_EMPHASIS_RE, re.DOTALL | re.UNICODE), 'single', 'em')
518: (4)                ]
519: (4)                """ The various strong and emphasis patterns handled by this processor. """
520: (0)            class LinkInlineProcessor(InlineProcessor):
521: (4)                """ Return a link element from the given match. """
522: (4)                RE_LINK = re.compile(r'''\(\s*(?:(<[^<>]*>)\s*(?:('[^']*'|"[^"]*")\s*)?\))?''', re.DOTALL | re.UNICODE)
523: (4)                RE_TITLE_CLEAN = re.compile(r'\s')
524: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:
525: (8)                    """ Return an `a` [`Element`][xml.etree.ElementTree.Element] or `(None, None, None)`. """
526: (8)                    text, index, handled = self.getText(data, m.end(0))
527: (8)                    if not handled:
528: (12)                       return None, None, None
529: (8)                    href, title, index, handled = self.getLink(data, index)
530: (8)                    if not handled:
531: (12)                       return None, None, None
532: (8)                    el = etree.Element("a")
533: (8)                    el.text = text
534: (8)                    el.set("href", href)
535: (8)                    if title is not None:
536: (12)                       el.set("title", title)
537: (8)                    return el, m.start(0), index
538: (4)                def getLink(self, data: str, index: int) -> tuple[str, str | None, int, bool]:
539: (8)                    """Parse data between `()` of `[Text]()` allowing recursive `()`. """
540: (8)                    href = ''
541: (8)                    title: str | None = None
542: (8)                    handled = False
543: (8)                    m = self.RE_LINK.match(data, pos=index)
544: (8)                    if m and m.group(1):
545: (12)                       # Matches [Text](<link> "title")
546: (12)                       href = m.group(1)[1:-1].strip()
547: (12)                       if m.group(2):
548: (16)                           title = m.group(2)[1:-1]
549: (12)                       index = m.end(0)
550: (12)                       handled = True
551: (8)                    elif m:
552: (12)                       # Track bracket nesting and index in string
553: (12)                       bracket_count = 1
554: (12)                       backtrack_count = 1
555: (12)                       start_index = m.end()
556: (12)                       index = start_index
557: (12)                       last_bracket = -1
558: (12)                       # Primary (first found) quote tracking.
559: (12)                       quote: str | None = None
560: (12)                       start_quote = -1
561: (12)                       exit_quote = -1
562: (12)                       ignore_matches = False
563: (12)                       # Secondary (second found) quote tracking.
564: (12)                       alt_quote = None
565: (12)                       start_alt_quote = -1
566: (12)                       exit_alt_quote = -1
567: (12)                       # Track last character
568: (12)                       last = ''
569: (12)                       for pos in range(index, len(data)):
570: (16)                           c = data[pos]
571: (16)                           if c == '(':
572: (20)                               # Count nested (
573: (20)                               # Don't increment the bracket count if we are sure we're in a title.
574: (20)                               if not ignore_matches:
575: (24)                                   bracket_count += 1
576: (20)                               elif backtrack_count > 0:
577: (24)                                   backtrack_count -= 1
578: (16)                           elif c == ')':
579: (20)                               # Match nested ) to (
580: (20)                               # Don't decrement if we are sure we are in a title that is unclosed.
581: (20)                               if ((exit_quote != -1 and quote == last) or (exit_alt_quote != -1 and alt_quote == last)):
582: (24)                                   bracket_count = 0
583: (20)                               elif not ignore_matches:
584: (24)                                   bracket_count -= 1
585: (20)                               elif backtrack_count > 0:
586: (24)                                   backtrack_count -= 1
587: (24)                                   # We've found our backup end location if the title doesn't resolve.
588: (24)                                   if backtrack_count == 0:
589: (28)                                       last_bracket = index + 1
590: (16)                           elif c in ("'", '"'):
591: (20)                               # Quote has started
592: (20)                               if not quote:
593: (24)                                   # We'll assume we are now in a title.
594: (24)                                   # Brackets are quoted, so no need to match them (except for the final one).
595: (24)                                   ignore_matches = True
596: (24)                                   backtrack_count = bracket_count
597: (24)                                   bracket_count = 1
598: (24)                                   start_quote = index + 1
599: (24)                                   quote = c
600: (20)                               # Secondary quote (in case the first doesn't resolve): [text](link'"title")
601: (20)                               elif c != quote and not alt_quote:
602: (24)                                   start_alt_quote = index + 1
603: (24)                                   alt_quote = c
604: (20)                               # Update primary quote match
605: (20)                               elif c == quote:
606: (24)                                   exit_quote = index + 1
607: (20)                               # Update secondary quote match
608: (20)                               elif alt_quote and c == alt_quote:
609: (24)                                   exit_alt_quote = index + 1
610: (16)                           index += 1
611: (16)                           # Link is closed, so let's break out of the loop
612: (16)                           if bracket_count == 0:
613: (20)                               # Get the title if we closed a title string right before link closed
614: (20)                               if exit_quote >= 0 and quote == last:
615: (24)                                   href = data[start_index:start_quote - 1]
616: (24)                                   title = ''.join(data[start_quote:exit_quote - 1])
617: (20)                               elif exit_alt_quote >= 0 and alt_quote == last:
618: (24)                                   href = data[start_index:start_alt_quote - 1]
619: (24)                                   title = ''.join(data[start_alt_quote:exit_alt_quote - 1])
620: (20)                               else:
621: (24)                                   href = data[start_index:index - 1]
622: (20)                               break
623: (16)                           if c != ' ':
624: (20)                               last = c
625: (12)                       # We have a scenario: `[test](link"notitle)`
626: (12)                       # When we enter a string, we stop tracking bracket resolution in the main counter,
627: (12)                       # but we do keep a backup counter up until we discover where we might resolve all brackets
628: (12)                       # if the title string fails to resolve.
629: (12)                       if bracket_count != 0 and backtrack_count == 0:
630: (16)                           href = data[start_index:last_bracket - 1]
631: (16)                           index = last_bracket
632: (16)                           bracket_count = 0
633: (12)                       handled = bracket_count == 0
634: (8)                    if title is not None:
635: (12)                       title = self.RE_TITLE_CLEAN.sub(' ', dequote(self.unescape(title.strip())))
636: (8)                    href = self.unescape(href).strip()
637: (8)                    return href, title, index, handled
638: (4)                def getText(self, data: str, index: int) -> tuple[str, int, bool]:
639: (8)                    """Parse the content between `[]` of the start of an image or link
640: (8)                    resolving nested square brackets.
641: (8)                    """
642: (8)                    bracket_count = 1
643: (8)                    text = []
644: (8)                    for pos in range(index, len(data)):
645: (12)                       c = data[pos]
646: (12)                       if c == ']':
647: (16)                           bracket_count -= 1
648: (12)                       elif c == '[':
649: (16)                           bracket_count += 1
650: (12)                       index += 1
651: (12)                       if bracket_count == 0:
652: (16)                           break
653: (12)                       text.append(c)
654: (8)                    return ''.join(text), index, bracket_count == 0
655: (0)            class ImageInlineProcessor(LinkInlineProcessor):
656: (4)                """ Return a `img` element from the given match. """
657: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:
658: (8)                    """ Return an `img` [`Element`][xml.etree.ElementTree.Element] or `(None, None, None)`. """
659: (8)                    text, index, handled = self.getText(data, m.end(0))
660: (8)                    if not handled:
661: (12)                       return None, None, None
662: (8)                    src, title, index, handled = self.getLink(data, index)
663: (8)                    if not handled:
664: (12)                       return None, None, None
665: (8)                    el = etree.Element("img")
666: (8)                    el.set("src", src)
667: (8)                    if title is not None:
668: (12)                       el.set("title", title)
669: (8)                    el.set('alt', self.unescape(text))
670: (8)                    return el, m.start(0), index
671: (0)            class ReferenceInlineProcessor(LinkInlineProcessor):
672: (4)                """ Match to a stored reference and return link element. """
673: (4)                NEWLINE_CLEANUP_RE = re.compile(r'\s+', re.MULTILINE)
674: (4)                RE_LINK = re.compile(r'\s?\[([^\]]*)\]', re.DOTALL | re.UNICODE)
675: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:
676: (8)                    """
677: (8)                    Return [`Element`][xml.etree.ElementTree.Element] returned by `makeTag` method or `(None, None, None)`.
678: (8)                    """
679: (8)                    text, index, handled = self.getText(data, m.end(0))
680: (8)                    if not handled:
681: (12)                       return None, None, None
682: (8)                    id, end, handled = self.evalId(data, index, text)
683: (8)                    if not handled:
684: (12)                       return None, None, None
685: (8)                    # Clean up line breaks in id
686: (8)                    id = self.NEWLINE_CLEANUP_RE.sub(' ', id)
687: (8)                    if id not in self.md.references:  # ignore undefined refs
688: (12)                       return None, m.start(0), end
689: (8)                    href, title = self.md.references[id]
690: (8)                    return self.makeTag(href, title, text), m.start(0), end
691: (4)                def evalId(self, data: str, index: int, text: str) -> tuple[str | None, int, bool]:
692: (8)                    """
693: (8)                    Evaluate the id portion of `[ref][id]`.
694: (8)                    If `[ref][]` use `[ref]`.
695: (8)                    """
696: (8)                    m = self.RE_LINK.match(data, pos=index)
697: (8)                    if not m:
698: (12)                       return None, index, False
699: (8)                    else:
700: (12)                       id = m.group(1).lower()
701: (12)                       end = m.end(0)
702: (12)                       if not id:
703: (16)                           id = text.lower()
704: (8)                    return id, end, True
705: (4)                def makeTag(self, href: str, title: str, text: str) -> etree.Element:
706: (8)                    """ Return an `a` [`Element`][xml.etree.ElementTree.Element]. """
707: (8)                    el = etree.Element('a')
708: (8)                    el.set('href', href)
709: (8)                    if title:
710: (12)                       el.set('title', title)
711: (8)                    el.text = text
712: (8)                    return el
713: (0)            class ShortReferenceInlineProcessor(ReferenceInlineProcessor):
714: (4)                """Short form of reference: `[google]`. """
715: (4)                def evalId(self, data: str, index: int, text: str) -> tuple[str, int, bool]:
716: (8)                    """Evaluate the id of `[ref]`.  """
717: (8)                    return text.lower(), index, True
718: (0)            class ImageReferenceInlineProcessor(ReferenceInlineProcessor):
719: (4)                """ Match to a stored reference and return `img` element. """
720: (4)                def makeTag(self, href: str, title: str, text: str) -> etree.Element:
721: (8)                    """ Return an `img` [`Element`][xml.etree.ElementTree.Element]. """
722: (8)                    el = etree.Element("img")
723: (8)                    el.set("src", href)
724: (8)                    if title:
725: (12)                       el.set("title", title)
726: (8)                    el.set("alt", self.unescape(text))
727: (8)                    return el
728: (0)            class ShortImageReferenceInlineProcessor(ImageReferenceInlineProcessor):
729: (4)                """ Short form of image reference: `![ref]`. """
730: (4)                def evalId(self, data: str, index: int, text: str) -> tuple[str, int, bool]:
731: (8)                    """Evaluate the id of `[ref]`.  """
732: (8)                    return text.lower(), index, True
733: (0)            class AutolinkInlineProcessor(InlineProcessor):
734: (4)                """ Return a link Element given an auto-link (`<http://example/com>`). """
735: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:
736: (8)                    """ Return an `a` [`Element`][xml.etree.ElementTree.Element] of `group(1)`. """
737: (8)                    el = etree.Element("a")
738: (8)                    el.set('href', self.unescape(m.group(1)))
739: (8)                    el.text = util.AtomicString(m.group(1))
740: (8)                    return el, m.start(0), m.end(0)
741: (0)            class AutomailInlineProcessor(InlineProcessor):
742: (4)                """
743: (4)                Return a `mailto` link Element given an auto-mail link (`<foo@example.com>`).
744: (4)                """
745: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:
746: (8)                    """ Return an [`Element`][xml.etree.ElementTree.Element] containing a `mailto` link  of `group(1)`. """
747: (8)                    el = etree.Element('a')
748: (8)                    email = self.unescape(m.group(1))
749: (8)                    if email.startswith("mailto:"):
750: (12)                       email = email[len("mailto:"):]
751: (8)                    def codepoint2name(code: int) -> str:
752: (12)                       """Return entity definition by code, or the code if not defined."""
753: (12)                       entity = entities.codepoint2name.get(code)
754: (12)                       if entity:
755: (16)                           return "{}{};".format(util.AMP_SUBSTITUTE, entity)
756: (12)                       else:
757: (16)                           return "%s#%d;" % (util.AMP_SUBSTITUTE, code)
758: (8)                    letters = [codepoint2name(ord(letter)) for letter in email]
759: (8)                    el.text = util.AtomicString(''.join(letters))
760: (8)                    mailto = "mailto:" + email
761: (8)                    mailto = "".join([util.AMP_SUBSTITUTE + '#%d;' %
762: (26)                                     ord(letter) for letter in mailto])
763: (8)                    el.set('href', mailto)
764: (8)                    return el, m.start(0), m.end(0)

----------------------------------------

File 9 - . \postprocessors.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             Post-processors run on the text of the entire document after is has been serialized into a string.
16: (0)             Postprocessors should be used to work with the text just before output. Usually, they are used add
17: (0)             back sections that were extracted in a preprocessor, fix up outgoing encodings, or wrap the whole
18: (0)             document.
19: (0)             """
20: (0)             from __future__ import annotations
21: (0)             from collections import OrderedDict
22: (0)             from typing import TYPE_CHECKING, Any
23: (0)             from . import util
24: (0)             import re
25: (0)             if TYPE_CHECKING:  # pragma: no cover
26: (4)                 from markdown import Markdown
27: (0)             def build_postprocessors(md: Markdown, **kwargs: Any) -> util.Registry[Postprocessor]:
28: (4)                 """ Build the default postprocessors for Markdown. """
29: (4)                 postprocessors = util.Registry()
30: (4)                 postprocessors.register(RawHtmlPostprocessor(md), 'raw_html', 30)
31: (4)                 postprocessors.register(AndSubstitutePostprocessor(), 'amp_substitute', 20)
32: (4)                 return postprocessors
33: (0)             class Postprocessor(util.Processor):
34: (4)                 """
35: (4)                 Postprocessors are run after the ElementTree it converted back into text.
36: (4)                 Each Postprocessor implements a `run` method that takes a pointer to a
37: (4)                 text string, modifies it as necessary and returns a text string.
38: (4)                 Postprocessors must extend `Postprocessor`.
39: (4)                 """
40: (4)                 def run(self, text: str) -> str:
41: (8)                     """
42: (8)                     Subclasses of `Postprocessor` should implement a `run` method, which
43: (8)                     takes the html document as a single text string and returns a
44: (8)                     (possibly modified) string.
45: (8)                     """
46: (8)                     pass  # pragma: no cover
47: (0)             class RawHtmlPostprocessor(Postprocessor):
48: (4)                 """ Restore raw html to the document. """
49: (4)                 BLOCK_LEVEL_REGEX = re.compile(r'^\<\/?([^ >]+)')
50: (4)                 def run(self, text: str) -> str:
51: (8)                     """ Iterate over html stash and restore html. """
52: (8)                     replacements = OrderedDict()
53: (8)                     for i in range(self.md.htmlStash.html_counter):
54: (12)                        html = self.stash_to_string(self.md.htmlStash.rawHtmlBlocks[i])
55: (12)                        if self.isblocklevel(html):
56: (16)                            replacements["<p>{}</p>".format(
57: (20)                                self.md.htmlStash.get_placeholder(i))] = html
58: (12)                        replacements[self.md.htmlStash.get_placeholder(i)] = html
59: (8)                     def substitute_match(m: re.Match[str]) -> str:
60: (12)                        key = m.group(0)
61: (12)                        if key not in replacements:
62: (16)                            if key[3:-4] in replacements:
63: (20)                                return f'<p>{ replacements[key[3:-4]] }</p>'
64: (16)                            else:
65: (20)                                return key
66: (12)                        return replacements[key]
67: (8)                     if replacements:
68: (12)                        base_placeholder = util.HTML_PLACEHOLDER % r'([0-9]+)'
69: (12)                        pattern = re.compile(f'<p>{ base_placeholder }</p>|{ base_placeholder }')
70: (12)                        processed_text = pattern.sub(substitute_match, text)
71: (8)                     else:
72: (12)                        return text
73: (8)                     if processed_text == text:
74: (12)                        return processed_text
75: (8)                     else:
76: (12)                        return self.run(processed_text)
77: (4)                 def isblocklevel(self, html: str) -> bool:
78: (8)                     """ Check is block of HTML is block-level. """
79: (8)                     m = self.BLOCK_LEVEL_REGEX.match(html)
80: (8)                     if m:
81: (12)                        if m.group(1)[0] in ('!', '?', '@', '%'):
82: (16)                            # Comment, PHP etc...
83: (16)                            return True
84: (12)                        return self.md.is_block_level(m.group(1))
85: (8)                     return False
86: (4)                 def stash_to_string(self, text: str) -> str:
87: (8)                     """ Convert a stashed object to a string. """
88: (8)                     return str(text)
89: (0)             class AndSubstitutePostprocessor(Postprocessor):
90: (4)                 """ Restore valid entities """
91: (4)                 def run(self, text: str) -> str:
92: (8)                     text = text.replace(util.AMP_SUBSTITUTE, "&")
93: (8)                     return text
94: (0)             @util.deprecated(
95: (4)                 "This class is deprecated and will be removed in the future; "
96: (4)                 "use [`UnescapeTreeprocessor`][markdown.treeprocessors.UnescapeTreeprocessor] instead."
97: (0)             )
98: (0)             class UnescapePostprocessor(Postprocessor):
99: (4)                 """ Restore escaped chars. """
100: (4)                RE = re.compile(r'{}(\d+){}'.format(util.STX, util.ETX))
101: (4)                def unescape(self, m: re.Match[str]) -> str:
102: (8)                    return chr(int(m.group(1)))
103: (4)                def run(self, text: str) -> str:
104: (8)                    return self.RE.sub(self.unescape, text)

----------------------------------------

File 10 - . \preprocessors.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             Preprocessors work on source text before it is broken down into its individual parts.
16: (0)             This is an excellent place to clean up bad characters or to extract portions for later
17: (0)             processing that the parser may otherwise choke on.
18: (0)             """
19: (0)             from __future__ import annotations
20: (0)             from typing import TYPE_CHECKING, Any
21: (0)             from . import util
22: (0)             from .htmlparser import HTMLExtractor
23: (0)             import re
24: (0)             if TYPE_CHECKING:  # pragma: no cover
25: (4)                 from markdown import Markdown
26: (0)             def build_preprocessors(md: Markdown, **kwargs: Any) -> util.Registry[Preprocessor]:
27: (4)                 """ Build and return the default set of preprocessors used by Markdown. """
28: (4)                 preprocessors = util.Registry()
29: (4)                 preprocessors.register(NormalizeWhitespace(md), 'normalize_whitespace', 30)
30: (4)                 preprocessors.register(HtmlBlockPreprocessor(md), 'html_block', 20)
31: (4)                 return preprocessors
32: (0)             class Preprocessor(util.Processor):
33: (4)                 """
34: (4)                 Preprocessors are run after the text is broken into lines.
35: (4)                 Each preprocessor implements a `run` method that takes a pointer to a
36: (4)                 list of lines of the document, modifies it as necessary and returns
37: (4)                 either the same pointer or a pointer to a new list.
38: (4)                 Preprocessors must extend `Preprocessor`.
39: (4)                 """
40: (4)                 def run(self, lines: list[str]) -> list[str]:
41: (8)                     """
42: (8)                     Each subclass of `Preprocessor` should override the `run` method, which
43: (8)                     takes the document as a list of strings split by newlines and returns
44: (8)                     the (possibly modified) list of lines.
45: (8)                     """
46: (8)                     pass  # pragma: no cover
47: (0)             class NormalizeWhitespace(Preprocessor):
48: (4)                 """ Normalize whitespace for consistent parsing. """
49: (4)                 def run(self, lines: list[str]) -> list[str]:
50: (8)                     source = '\n'.join(lines)
51: (8)                     source = source.replace(util.STX, "").replace(util.ETX, "")
52: (8)                     source = source.replace("\r\n", "\n").replace("\r", "\n") + "\n\n"
53: (8)                     source = source.expandtabs(self.md.tab_length)
54: (8)                     source = re.sub(r'(?<=\n) +\n', '\n', source)
55: (8)                     return source.split('\n')
56: (0)             class HtmlBlockPreprocessor(Preprocessor):
57: (4)                 """
58: (4)                 Remove html blocks from the text and store them for later retrieval.
59: (4)                 The raw HTML is stored in the [`htmlStash`][markdown.util.HtmlStash] of the
60: (4)                 [`Markdown`][markdown.Markdown] instance.
61: (4)                 """
62: (4)                 def run(self, lines: list[str]) -> list[str]:
63: (8)                     source = '\n'.join(lines)
64: (8)                     parser = HTMLExtractor(self.md)
65: (8)                     parser.feed(source)
66: (8)                     parser.close()
67: (8)                     return ''.join(parser.cleandoc).split('\n')

----------------------------------------

File 11 - . \serializers.py:

1: (0)              # Add x/html serialization to `Elementree`
2: (0)              # Taken from ElementTree 1.3 preview with slight modifications
3: (0)              #
4: (0)              # Copyright (c) 1999-2007 by Fredrik Lundh.  All rights reserved.
5: (0)              #
6: (0)              # fredrik@pythonware.com
7: (0)              # https://www.pythonware.com/
8: (0)              #
9: (0)              # --------------------------------------------------------------------
10: (0)             # The ElementTree toolkit is
11: (0)             #
12: (0)             # Copyright (c) 1999-2007 by Fredrik Lundh
13: (0)             #
14: (0)             # By obtaining, using, and/or copying this software and/or its
15: (0)             # associated documentation, you agree that you have read, understood,
16: (0)             # and will comply with the following terms and conditions:
17: (0)             #
18: (0)             # Permission to use, copy, modify, and distribute this software and
19: (0)             # its associated documentation for any purpose and without fee is
20: (0)             # hereby granted, provided that the above copyright notice appears in
21: (0)             # all copies, and that both that copyright notice and this permission
22: (0)             # notice appear in supporting documentation, and that the name of
23: (0)             # Secret Labs AB or the author not be used in advertising or publicity
24: (0)             # pertaining to distribution of the software without specific, written
25: (0)             # prior permission.
26: (0)             #
27: (0)             # SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
28: (0)             # TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
29: (0)             # ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
30: (0)             # BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
31: (0)             # DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
32: (0)             # WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
33: (0)             # ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
34: (0)             # OF THIS SOFTWARE.
35: (0)             # --------------------------------------------------------------------
36: (0)             """
37: (0)             Python-Markdown provides two serializers which render [`ElementTree.Element`][xml.etree.ElementTree.Element]
38: (0)             objects to a string of HTML. Both functions wrap the same underlying code with only a few minor
39: (0)             differences as outlined below:
40: (0)             1. Empty (self-closing) tags are rendered as `<tag>` for HTML and as `<tag />` for XHTML.
41: (0)             2. Boolean attributes are rendered as `attrname` for HTML and as `attrname="attrname"` for XHTML.
42: (0)             """
43: (0)             from __future__ import annotations
44: (0)             from xml.etree.ElementTree import ProcessingInstruction
45: (0)             from xml.etree.ElementTree import Comment, ElementTree, Element, QName, HTML_EMPTY
46: (0)             import re
47: (0)             from typing import Callable, Literal, NoReturn
48: (0)             __all__ = ['to_html_string', 'to_xhtml_string']
49: (0)             RE_AMP = re.compile(r'&(?!(?:\#[0-9]+|\#x[0-9a-f]+|[0-9a-z]+);)', re.I)
50: (0)             def _raise_serialization_error(text: str) -> NoReturn:  # pragma: no cover
51: (4)                 raise TypeError(
52: (8)                     "cannot serialize {!r} (type {})".format(text, type(text).__name__)
53: (8)                     )
54: (0)             def _escape_cdata(text) -> str:
55: (4)                 # escape character data
56: (4)                 try:
57: (8)                     # it's worth avoiding do-nothing calls for strings that are
58: (8)                     # shorter than 500 character, or so.  assume that's, by far,
59: (8)                     # the most common case in most applications.
60: (8)                     if "&" in text:
61: (12)                        # Only replace & when not part of an entity
62: (12)                        text = RE_AMP.sub('&amp;', text)
63: (8)                     if "<" in text:
64: (12)                        text = text.replace("<", "&lt;")
65: (8)                     if ">" in text:
66: (12)                        text = text.replace(">", "&gt;")
67: (8)                     return text
68: (4)                 except (TypeError, AttributeError):  # pragma: no cover
69: (8)                     _raise_serialization_error(text)
70: (0)             def _escape_attrib(text: str) -> str:
71: (4)                 # escape attribute value
72: (4)                 try:
73: (8)                     if "&" in text:
74: (12)                        # Only replace & when not part of an entity
75: (12)                        text = RE_AMP.sub('&amp;', text)
76: (8)                     if "<" in text:
77: (12)                        text = text.replace("<", "&lt;")
78: (8)                     if ">" in text:
79: (12)                        text = text.replace(">", "&gt;")
80: (8)                     if "\"" in text:
81: (12)                        text = text.replace("\"", "&quot;")
82: (8)                     if "\n" in text:
83: (12)                        text = text.replace("\n", "&#10;")
84: (8)                     return text
85: (4)                 except (TypeError, AttributeError):  # pragma: no cover
86: (8)                     _raise_serialization_error(text)
87: (0)             def _escape_attrib_html(text: str) -> str:
88: (4)                 # escape attribute value
89: (4)                 try:
90: (8)                     if "&" in text:
91: (12)                        # Only replace & when not part of an entity
92: (12)                        text = RE_AMP.sub('&amp;', text)
93: (8)                     if "<" in text:
94: (12)                        text = text.replace("<", "&lt;")
95: (8)                     if ">" in text:
96: (12)                        text = text.replace(">", "&gt;")
97: (8)                     if "\"" in text:
98: (12)                        text = text.replace("\"", "&quot;")
99: (8)                     return text
100: (4)                except (TypeError, AttributeError):  # pragma: no cover
101: (8)                    _raise_serialization_error(text)
102: (0)            def _serialize_html(write: Callable[[str], None], elem: Element, format: Literal["html", "xhtml"]) -> None:
103: (4)                tag = elem.tag
104: (4)                text = elem.text
105: (4)                if tag is Comment:
106: (8)                    write("<!--%s-->" % _escape_cdata(text))
107: (4)                elif tag is ProcessingInstruction:
108: (8)                    write("<?%s?>" % _escape_cdata(text))
109: (4)                elif tag is None:
110: (8)                    if text:
111: (12)                       write(_escape_cdata(text))
112: (8)                    for e in elem:
113: (12)                       _serialize_html(write, e, format)
114: (4)                else:
115: (8)                    namespace_uri = None
116: (8)                    if isinstance(tag, QName):
117: (12)                       # `QNAME` objects store their data as a string: `{uri}tag`
118: (12)                       if tag.text[:1] == "{":
119: (16)                           namespace_uri, tag = tag.text[1:].split("}", 1)
120: (12)                       else:
121: (16)                           raise ValueError('QName objects must define a tag.')
122: (8)                    write("<" + tag)
123: (8)                    items = elem.items()
124: (8)                    if items:
125: (12)                       items = sorted(items)  # lexical order
126: (12)                       for k, v in items:
127: (16)                           if isinstance(k, QName):
128: (20)                               # Assume a text only `QName`
129: (20)                               k = k.text
130: (16)                           if isinstance(v, QName):
131: (20)                               # Assume a text only `QName`
132: (20)                               v = v.text
133: (16)                           else:
134: (20)                               v = _escape_attrib_html(v)
135: (16)                           if k == v and format == 'html':
136: (20)                               # handle boolean attributes
137: (20)                               write(" %s" % v)
138: (16)                           else:
139: (20)                               write(' {}="{}"'.format(k, v))
140: (8)                    if namespace_uri:
141: (12)                       write(' xmlns="%s"' % (_escape_attrib(namespace_uri)))
142: (8)                    if format == "xhtml" and tag.lower() in HTML_EMPTY:
143: (12)                       write(" />")
144: (8)                    else:
145: (12)                       write(">")
146: (12)                       if text:
147: (16)                           if tag.lower() in ["script", "style"]:
148: (20)                               write(text)
149: (16)                           else:
150: (20)                               write(_escape_cdata(text))
151: (12)                       for e in elem:
152: (16)                           _serialize_html(write, e, format)
153: (12)                       if tag.lower() not in HTML_EMPTY:
154: (16)                           write("</" + tag + ">")
155: (4)                if elem.tail:
156: (8)                    write(_escape_cdata(elem.tail))
157: (0)            def _write_html(root: Element, format: Literal["html", "xhtml"] = "html") -> str:
158: (4)                assert root is not None
159: (4)                data: list[str] = []
160: (4)                write = data.append
161: (4)                _serialize_html(write, root, format)
162: (4)                return "".join(data)
163: (0)            # --------------------------------------------------------------------
164: (0)            # public functions
165: (0)            def to_html_string(element: Element) -> str:
166: (4)                """ Serialize element and its children to a string of HTML5. """
167: (4)                return _write_html(ElementTree(element).getroot(), format="html")
168: (0)            def to_xhtml_string(element: Element) -> str:
169: (4)                """ Serialize element and its children to a string of XHTML. """
170: (4)                return _write_html(ElementTree(element).getroot(), format="xhtml")

----------------------------------------

File 12 - . \test_tools.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """ A collection of tools for testing the Markdown code base and extensions. """
15: (0)             from __future__ import annotations
16: (0)             import os
17: (0)             import sys
18: (0)             import unittest
19: (0)             import textwrap
20: (0)             from typing import Any
21: (0)             from . import markdown, Markdown, util
22: (0)             try:
23: (4)                 import tidylib
24: (0)             except ImportError:
25: (4)                 tidylib = None
26: (0)             __all__ = ['TestCase', 'LegacyTestCase', 'Kwargs']
27: (0)             class TestCase(unittest.TestCase):
28: (4)                 """
29: (4)                 A [`unittest.TestCase`][] subclass with helpers for testing Markdown output.
30: (4)                 Define `default_kwargs` as a `dict` of keywords to pass to Markdown for each
31: (4)                 test. The defaults can be overridden on individual tests.
32: (4)                 The `assertMarkdownRenders` method accepts the source text, the expected
33: (4)                 output, and any keywords to pass to Markdown. The `default_kwargs` are used
34: (4)                 except where overridden by `kwargs`. The output and expected output are passed
35: (4)                 to `TestCase.assertMultiLineEqual`. An `AssertionError` is raised with a diff
36: (4)                 if the actual output does not equal the expected output.
37: (4)                 The `dedent` method is available to dedent triple-quoted strings if
38: (4)                 necessary.
39: (4)                 In all other respects, behaves as `unittest.TestCase`.
40: (4)                 """
41: (4)                 default_kwargs: dict[str, Any] = {}
42: (4)                 """ Default options to pass to Markdown for each test. """
43: (4)                 def assertMarkdownRenders(self, source, expected, expected_attrs=None, **kwargs):
44: (8)                     """
45: (8)                     Test that source Markdown text renders to expected output with given keywords.
46: (8)                     `expected_attrs` accepts a `dict`. Each key should be the name of an attribute
47: (8)                     on the `Markdown` instance and the value should be the expected value after
48: (8)                     the source text is parsed by Markdown. After the expected output is tested,
49: (8)                     the expected value for each attribute is compared against the actual
50: (8)                     attribute of the `Markdown` instance using `TestCase.assertEqual`.
51: (8)                     """
52: (8)                     expected_attrs = expected_attrs or {}
53: (8)                     kws = self.default_kwargs.copy()
54: (8)                     kws.update(kwargs)
55: (8)                     md = Markdown(**kws)
56: (8)                     output = md.convert(source)
57: (8)                     self.assertMultiLineEqual(output, expected)
58: (8)                     for key, value in expected_attrs.items():
59: (12)                        self.assertEqual(getattr(md, key), value)
60: (4)                 def dedent(self, text):
61: (8)                     """
62: (8)                     Dedent text.
63: (8)                     """
64: (8)                     # TODO: If/when actual output ends with a newline, then use:
65: (8)                     #     return textwrap.dedent(text.strip('/n'))
66: (8)                     return textwrap.dedent(text).strip()
67: (0)             class recursionlimit:
68: (4)                 """
69: (4)                 A context manager which temporarily modifies the Python recursion limit.
70: (4)                 The testing framework, coverage, etc. may add an arbitrary number of levels to the depth. To maintain consistency
71: (4)                 in the tests, the current stack depth is determined when called, then added to the provided limit.
72: (4)                 Example usage:
73: (4)                 ``` python
74: (4)                 with recursionlimit(20):
75: (8)                     # test code here
76: (4)                 ```
77: (4)                 See <https://stackoverflow.com/a/50120316/866026>.
78: (4)                 """
79: (4)                 def __init__(self, limit):
80: (8)                     self.limit = util._get_stack_depth() + limit
81: (8)                     self.old_limit = sys.getrecursionlimit()
82: (4)                 def __enter__(self):
83: (8)                     sys.setrecursionlimit(self.limit)
84: (4)                 def __exit__(self, type, value, tb):
85: (8)                     sys.setrecursionlimit(self.old_limit)
86: (0)             #########################
87: (0)             # Legacy Test Framework #
88: (0)             #########################
89: (0)             class Kwargs(dict):
90: (4)                 """ A `dict` like class for holding keyword arguments. """
91: (4)                 pass
92: (0)             def _normalize_whitespace(text):
93: (4)                 """ Normalize whitespace for a string of HTML using `tidylib`. """
94: (4)                 output, errors = tidylib.tidy_fragment(text, options={
95: (8)                     'drop_empty_paras': 0,
96: (8)                     'fix_backslash': 0,
97: (8)                     'fix_bad_comments': 0,
98: (8)                     'fix_uri': 0,
99: (8)                     'join_styles': 0,
100: (8)                    'lower_literals': 0,
101: (8)                    'merge_divs': 0,
102: (8)                    'output_xhtml': 1,
103: (8)                    'quote_ampersand': 0,
104: (8)                    'newline': 'LF'
105: (4)                })
106: (4)                return output
107: (0)            class LegacyTestMeta(type):
108: (4)                def __new__(cls, name, bases, dct):
109: (8)                    def generate_test(infile, outfile, normalize, kwargs):
110: (12)                       def test(self):
111: (16)                           with open(infile, encoding="utf-8") as f:
112: (20)                               input = f.read()
113: (16)                           with open(outfile, encoding="utf-8") as f:
114: (20)                               # Normalize line endings
115: (20)                               # (on Windows, git may have altered line endings).
116: (20)                               expected = f.read().replace("\r\n", "\n")
117: (16)                           output = markdown(input, **kwargs)
118: (16)                           if tidylib and normalize:
119: (20)                               try:
120: (24)                                   expected = _normalize_whitespace(expected)
121: (24)                                   output = _normalize_whitespace(output)
122: (20)                               except OSError:
123: (24)                                   self.skipTest("Tidylib's c library not available.")
124: (16)                           elif normalize:
125: (20)                               self.skipTest('Tidylib not available.')
126: (16)                           self.assertMultiLineEqual(output, expected)
127: (12)                       return test
128: (8)                    location = dct.get('location', '')
129: (8)                    exclude = dct.get('exclude', [])
130: (8)                    normalize = dct.get('normalize', False)
131: (8)                    input_ext = dct.get('input_ext', '.txt')
132: (8)                    output_ext = dct.get('output_ext', '.html')
133: (8)                    kwargs = dct.get('default_kwargs', Kwargs())
134: (8)                    if os.path.isdir(location):
135: (12)                       for file in os.listdir(location):
136: (16)                           infile = os.path.join(location, file)
137: (16)                           if os.path.isfile(infile):
138: (20)                               tname, ext = os.path.splitext(file)
139: (20)                               if ext == input_ext:
140: (24)                                   outfile = os.path.join(location, tname + output_ext)
141: (24)                                   tname = tname.replace(' ', '_').replace('-', '_')
142: (24)                                   kws = kwargs.copy()
143: (24)                                   if tname in dct:
144: (28)                                       kws.update(dct[tname])
145: (24)                                   test_name = 'test_%s' % tname
146: (24)                                   if tname not in exclude:
147: (28)                                       dct[test_name] = generate_test(infile, outfile, normalize, kws)
148: (24)                                   else:
149: (28)                                       dct[test_name] = unittest.skip('Excluded')(lambda: None)
150: (8)                    return type.__new__(cls, name, bases, dct)
151: (0)            class LegacyTestCase(unittest.TestCase, metaclass=LegacyTestMeta):
152: (4)                """
153: (4)                A [`unittest.TestCase`][] subclass for running Markdown's legacy file-based tests.
154: (4)                A subclass should define various properties which point to a directory of
155: (4)                text-based test files and define various behaviors/defaults for those tests.
156: (4)                The following properties are supported:
157: (4)                Attributes:
158: (8)                    location (str): A path to the directory of test files. An absolute path is preferred.
159: (8)                    exclude (list[str]): A list of tests to exclude. Each test name should comprise the filename
160: (12)                       without an extension.
161: (8)                    normalize (bool): A boolean value indicating if the HTML should be normalized. Default: `False`.
162: (8)                    input_ext (str): A string containing the file extension of input files. Default: `.txt`.
163: (8)                    output_ext (str): A string containing the file extension of expected output files. Default: `html`.
164: (8)                    default_kwargs (Kwargs[str, Any]): The default set of keyword arguments for all test files in the directory.
165: (4)                In addition, properties can be defined for each individual set of test files within
166: (4)                the directory. The property should be given the name of the file without the file
167: (4)                extension. Any spaces and dashes in the filename should be replaced with
168: (4)                underscores. The value of the property should be a `Kwargs` instance which
169: (4)                contains the keyword arguments that should be passed to `Markdown` for that
170: (4)                test file. The keyword arguments will "update" the `default_kwargs`.
171: (4)                When the class instance is created, it will walk the given directory and create
172: (4)                a separate `Unitttest` for each set of test files using the naming scheme:
173: (4)                `test_filename`. One `Unittest` will be run for each set of input and output files.
174: (4)                """
175: (4)                pass

----------------------------------------

File 13 - . \treeprocessors.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             Tree processors manipulate the tree created by block processors. They can even create an entirely
16: (0)             new `ElementTree` object. This is an excellent place for creating summaries, adding collected
17: (0)             references, or last minute adjustments.
18: (0)             """
19: (0)             from __future__ import annotations
20: (0)             import re
21: (0)             import xml.etree.ElementTree as etree
22: (0)             from typing import TYPE_CHECKING, Any
23: (0)             from . import util
24: (0)             from . import inlinepatterns
25: (0)             if TYPE_CHECKING:  # pragma: no cover
26: (4)                 from markdown import Markdown
27: (0)             def build_treeprocessors(md: Markdown, **kwargs: Any) -> util.Registry[Treeprocessor]:
28: (4)                 """ Build the default  `treeprocessors` for Markdown. """
29: (4)                 treeprocessors = util.Registry()
30: (4)                 treeprocessors.register(InlineProcessor(md), 'inline', 20)
31: (4)                 treeprocessors.register(PrettifyTreeprocessor(md), 'prettify', 10)
32: (4)                 treeprocessors.register(UnescapeTreeprocessor(md), 'unescape', 0)
33: (4)                 return treeprocessors
34: (0)             def isString(s: object) -> bool:
35: (4)                 """ Return `True` if object is a string but not an  [`AtomicString`][markdown.util.AtomicString]. """
36: (4)                 if not isinstance(s, util.AtomicString):
37: (8)                     return isinstance(s, str)
38: (4)                 return False
39: (0)             class Treeprocessor(util.Processor):
40: (4)                 """
41: (4)                 `Treeprocessor`s are run on the `ElementTree` object before serialization.
42: (4)                 Each `Treeprocessor` implements a `run` method that takes a pointer to an
43: (4)                 `Element` and modifies it as necessary.
44: (4)                 `Treeprocessors` must extend `markdown.Treeprocessor`.
45: (4)                 """
46: (4)                 def run(self, root: etree.Element) -> etree.Element | None:
47: (8)                     """
48: (8)                     Subclasses of `Treeprocessor` should implement a `run` method, which
49: (8)                     takes a root `Element`. This method can return another `Element`
50: (8)                     object, and the existing root `Element` will be replaced, or it can
51: (8)                     modify the current tree and return `None`.
52: (8)                     """
53: (8)                     pass  # pragma: no cover
54: (0)             class InlineProcessor(Treeprocessor):
55: (4)                 """
56: (4)                 A `Treeprocessor` that traverses a tree, applying inline patterns.
57: (4)                 """
58: (4)                 def __init__(self, md: Markdown):
59: (8)                     self.__placeholder_prefix = util.INLINE_PLACEHOLDER_PREFIX
60: (8)                     self.__placeholder_suffix = util.ETX
61: (8)                     self.__placeholder_length = 4 + len(self.__placeholder_prefix) \
62: (38)                                                  + len(self.__placeholder_suffix)
63: (8)                     self.__placeholder_re = util.INLINE_PLACEHOLDER_RE
64: (8)                     self.md = md
65: (8)                     self.inlinePatterns = md.inlinePatterns
66: (8)                     self.ancestors: list[str] = []
67: (4)                 def __makePlaceholder(self, type: str) -> tuple[str, str]:
68: (8)                     """ Generate a placeholder """
69: (8)                     id = "%04d" % len(self.stashed_nodes)
70: (8)                     hash = util.INLINE_PLACEHOLDER % id
71: (8)                     return hash, id
72: (4)                 def __findPlaceholder(self, data: str, index: int) -> tuple[str | None, int]:
73: (8)                     """
74: (8)                     Extract id from data string, start from index.
75: (8)                     Arguments:
76: (12)                        data: String.
77: (12)                        index: Index, from which we start search.
78: (8)                     Returns:
79: (12)                        Placeholder id and string index, after the found placeholder.
80: (8)                     """
81: (8)                     m = self.__placeholder_re.search(data, index)
82: (8)                     if m:
83: (12)                        return m.group(1), m.end()
84: (8)                     else:
85: (12)                        return None, index + 1
86: (4)                 def __stashNode(self, node: etree.Element | str, type: str) -> str:
87: (8)                     """ Add node to stash. """
88: (8)                     placeholder, id = self.__makePlaceholder(type)
89: (8)                     self.stashed_nodes[id] = node
90: (8)                     return placeholder
91: (4)                 def __handleInline(self, data: str, patternIndex: int = 0) -> str:
92: (8)                     """
93: (8)                     Process string with inline patterns and replace it with placeholders.
94: (8)                     Arguments:
95: (12)                        data: A line of Markdown text.
96: (12)                        patternIndex: The index of the `inlinePattern` to start with.
97: (8)                     Returns:
98: (12)                        String with placeholders.
99: (8)                     """
100: (8)                    if not isinstance(data, util.AtomicString):
101: (12)                       startIndex = 0
102: (12)                       count = len(self.inlinePatterns)
103: (12)                       while patternIndex < count:
104: (16)                           data, matched, startIndex = self.__applyPattern(
105: (20)                               self.inlinePatterns[patternIndex], data, patternIndex, startIndex
106: (16)                           )
107: (16)                           if not matched:
108: (20)                               patternIndex += 1
109: (8)                    return data
110: (4)                def __processElementText(self, node: etree.Element, subnode: etree.Element, isText: bool = True) -> None:
111: (8)                    """
112: (8)                    Process placeholders in `Element.text` or `Element.tail`
113: (8)                    of Elements popped from `self.stashed_nodes`.
114: (8)                    Arguments:
115: (12)                       node: Parent node.
116: (12)                       subnode: Processing node.
117: (12)                       isText: Boolean variable, True - it's text, False - it's a tail.
118: (8)                    """
119: (8)                    if isText:
120: (12)                       text = subnode.text
121: (12)                       subnode.text = None
122: (8)                    else:
123: (12)                       text = subnode.tail
124: (12)                       subnode.tail = None
125: (8)                    childResult = self.__processPlaceholders(text, subnode, isText)
126: (8)                    if not isText and node is not subnode:
127: (12)                       pos = list(node).index(subnode) + 1
128: (8)                    else:
129: (12)                       pos = 0
130: (8)                    childResult.reverse()
131: (8)                    for newChild in childResult:
132: (12)                       node.insert(pos, newChild[0])
133: (4)                def __processPlaceholders(
134: (8)                    self,
135: (8)                    data: str | None,
136: (8)                    parent: etree.Element,
137: (8)                    isText: bool = True
138: (4)                ) -> list[tuple[etree.Element, list[str]]]:
139: (8)                    """
140: (8)                    Process string with placeholders and generate `ElementTree` tree.
141: (8)                    Arguments:
142: (12)                       data: String with placeholders instead of `ElementTree` elements.
143: (12)                       parent: Element, which contains processing inline data.
144: (12)                       isText: Boolean variable, True - it's text, False - it's a tail.
145: (8)                    Returns:
146: (12)                       List with `ElementTree` elements with applied inline patterns.
147: (8)                    """
148: (8)                    def linkText(text: str | None) -> None:
149: (12)                       if text:
150: (16)                           if result:
151: (20)                               if result[-1][0].tail:
152: (24)                                   result[-1][0].tail += text
153: (20)                               else:
154: (24)                                   result[-1][0].tail = text
155: (16)                           elif not isText:
156: (20)                               if parent.tail:
157: (24)                                   parent.tail += text
158: (20)                               else:
159: (24)                                   parent.tail = text
160: (16)                           else:
161: (20)                               if parent.text:
162: (24)                                   parent.text += text
163: (20)                               else:
164: (24)                                   parent.text = text
165: (8)                    result = []
166: (8)                    strartIndex = 0
167: (8)                    while data:
168: (12)                       index = data.find(self.__placeholder_prefix, strartIndex)
169: (12)                       if index != -1:
170: (16)                           id, phEndIndex = self.__findPlaceholder(data, index)
171: (16)                           if id in self.stashed_nodes:
172: (20)                               node = self.stashed_nodes.get(id)
173: (20)                               if index > 0:
174: (24)                                   text = data[strartIndex:index]
175: (24)                                   linkText(text)
176: (20)                               if not isinstance(node, str):  # it's Element
177: (24)                                   for child in [node] + list(node):
178: (28)                                       if child.tail:
179: (32)                                           if child.tail.strip():
180: (36)                                               self.__processElementText(
181: (40)                                                   node, child, False
182: (36)                                               )
183: (28)                                       if child.text:
184: (32)                                           if child.text.strip():
185: (36)                                               self.__processElementText(child, child)
186: (20)                               else:  # it's just a string
187: (24)                                   linkText(node)
188: (24)                                   strartIndex = phEndIndex
189: (24)                                   continue
190: (20)                               strartIndex = phEndIndex
191: (20)                               result.append((node, self.ancestors[:]))
192: (16)                           else:  # wrong placeholder
193: (20)                               end = index + len(self.__placeholder_prefix)
194: (20)                               linkText(data[strartIndex:end])
195: (20)                               strartIndex = end
196: (12)                       else:
197: (16)                           text = data[strartIndex:]
198: (16)                           if isinstance(data, util.AtomicString):
199: (20)                               # We don't want to loose the `AtomicString`
200: (20)                               text = util.AtomicString(text)
201: (16)                           linkText(text)
202: (16)                           data = ""
203: (8)                    return result
204: (4)                def __applyPattern(
205: (8)                    self,
206: (8)                    pattern: inlinepatterns.Pattern,
207: (8)                    data: str,
208: (8)                    patternIndex: int,
209: (8)                    startIndex: int = 0
210: (4)                ) -> tuple[str, bool, int]:
211: (8)                    """
212: (8)                    Check if the line fits the pattern, create the necessary
213: (8)                    elements, add it to `stashed_nodes`.
214: (8)                    Arguments:
215: (12)                       data: The text to be processed.
216: (12)                       pattern: The pattern to be checked.
217: (12)                       patternIndex: Index of current pattern.
218: (12)                       startIndex: String index, from which we start searching.
219: (8)                    Returns:
220: (12)                       String with placeholders instead of `ElementTree` elements.
221: (8)                    """
222: (8)                    new_style = isinstance(pattern, inlinepatterns.InlineProcessor)
223: (8)                    for exclude in pattern.ANCESTOR_EXCLUDES:
224: (12)                       if exclude.lower() in self.ancestors:
225: (16)                           return data, False, 0
226: (8)                    if new_style:
227: (12)                       match = None
228: (12)                       # Since `handleMatch` may reject our first match,
229: (12)                       # we iterate over the buffer looking for matches
230: (12)                       # until we can't find any more.
231: (12)                       for match in pattern.getCompiledRegExp().finditer(data, startIndex):
232: (16)                           node, start, end = pattern.handleMatch(match, data)
233: (16)                           if start is None or end is None:
234: (20)                               startIndex += match.end(0)
235: (20)                               match = None
236: (20)                               continue
237: (16)                           break
238: (8)                    else:  # pragma: no cover
239: (12)                       match = pattern.getCompiledRegExp().match(data[startIndex:])
240: (12)                       leftData = data[:startIndex]
241: (8)                    if not match:
242: (12)                       return data, False, 0
243: (8)                    if not new_style:  # pragma: no cover
244: (12)                       node = pattern.handleMatch(match)
245: (12)                       start = match.start(0)
246: (12)                       end = match.end(0)
247: (8)                    if node is None:
248: (12)                       return data, True, end
249: (8)                    if not isinstance(node, str):
250: (12)                       if not isinstance(node.text, util.AtomicString):
251: (16)                           # We need to process current node too
252: (16)                           for child in [node] + list(node):
253: (20)                               if not isString(node):
254: (24)                                   if child.text:
255: (28)                                       self.ancestors.append(child.tag.lower())
256: (28)                                       child.text = self.__handleInline(
257: (32)                                           child.text, patternIndex + 1
258: (28)                                       )
259: (28)                                       self.ancestors.pop()
260: (24)                                   if child.tail:
261: (28)                                       child.tail = self.__handleInline(
262: (32)                                           child.tail, patternIndex
263: (28)                                       )
264: (8)                    placeholder = self.__stashNode(node, pattern.type())
265: (8)                    if new_style:
266: (12)                       return "{}{}{}".format(data[:start],
267: (35)                                              placeholder, data[end:]), True, 0
268: (8)                    else:  # pragma: no cover
269: (12)                       return "{}{}{}{}".format(leftData,
270: (37)                                                match.group(1),
271: (37)                                                placeholder, match.groups()[-1]), True, 0
272: (4)                def __build_ancestors(self, parent: etree.Element | None, parents: list[str]) -> None:
273: (8)                    """Build the ancestor list."""
274: (8)                    ancestors = []
275: (8)                    while parent is not None:
276: (12)                       if parent is not None:
277: (16)                           ancestors.append(parent.tag.lower())
278: (12)                       parent = self.parent_map.get(parent)
279: (8)                    ancestors.reverse()
280: (8)                    parents.extend(ancestors)
281: (4)                def run(self, tree: etree.Element, ancestors: list[str] | None = None) -> etree.Element:
282: (8)                    """Apply inline patterns to a parsed Markdown tree.
283: (8)                    Iterate over `Element`, find elements with inline tag, apply inline
284: (8)                    patterns and append newly created Elements to tree.  To avoid further
285: (8)                    processing of string with inline patterns, instead of normal string,
286: (8)                    use subclass [`AtomicString`][markdown.util.AtomicString]:
287: (12)                       node.text = markdown.util.AtomicString("This will not be processed.")
288: (8)                    Arguments:
289: (12)                       tree: `Element` object, representing Markdown tree.
290: (12)                       ancestors: List of parent tag names that precede the tree node (if needed).
291: (8)                    Returns:
292: (12)                       An element tree object with applied inline patterns.
293: (8)                    """
294: (8)                    self.stashed_nodes: dict[str, etree.Element | str] = {}
295: (8)                    # Ensure a valid parent list, but copy passed in lists
296: (8)                    # to ensure we don't have the user accidentally change it on us.
297: (8)                    tree_parents = [] if ancestors is None else ancestors[:]
298: (8)                    self.parent_map = {c: p for p in tree.iter() for c in p}
299: (8)                    stack = [(tree, tree_parents)]
300: (8)                    while stack:
301: (12)                       currElement, parents = stack.pop()
302: (12)                       self.ancestors = parents
303: (12)                       self.__build_ancestors(currElement, self.ancestors)
304: (12)                       insertQueue = []
305: (12)                       for child in currElement:
306: (16)                           if child.text and not isinstance(
307: (20)                               child.text, util.AtomicString
308: (16)                           ):
309: (20)                               self.ancestors.append(child.tag.lower())
310: (20)                               text = child.text
311: (20)                               child.text = None
312: (20)                               lst = self.__processPlaceholders(
313: (24)                                   self.__handleInline(text), child
314: (20)                               )
315: (20)                               for item in lst:
316: (24)                                   self.parent_map[item[0]] = child
317: (20)                               stack += lst
318: (20)                               insertQueue.append((child, lst))
319: (20)                               self.ancestors.pop()
320: (16)                           if child.tail:
321: (20)                               tail = self.__handleInline(child.tail)
322: (20)                               dumby = etree.Element('d')
323: (20)                               child.tail = None
324: (20)                               tailResult = self.__processPlaceholders(tail, dumby, False)
325: (20)                               if dumby.tail:
326: (24)                                   child.tail = dumby.tail
327: (20)                               pos = list(currElement).index(child) + 1
328: (20)                               tailResult.reverse()
329: (20)                               for newChild in tailResult:
330: (24)                                   self.parent_map[newChild[0]] = currElement
331: (24)                                   currElement.insert(pos, newChild[0])
332: (16)                           if len(child):
333: (20)                               self.parent_map[child] = currElement
334: (20)                               stack.append((child, self.ancestors[:]))
335: (12)                       for element, lst in insertQueue:
336: (16)                           for i, obj in enumerate(lst):
337: (20)                               newChild = obj[0]
338: (20)                               element.insert(i, newChild)
339: (8)                    return tree
340: (0)            class PrettifyTreeprocessor(Treeprocessor):
341: (4)                """ Add line breaks to the html document. """
342: (4)                def _prettifyETree(self, elem: etree.Element) -> None:
343: (8)                    """ Recursively add line breaks to `ElementTree` children. """
344: (8)                    i = "\n"
345: (8)                    if self.md.is_block_level(elem.tag) and elem.tag not in ['code', 'pre']:
346: (12)                       if (not elem.text or not elem.text.strip()) \
347: (20)                               and len(elem) and self.md.is_block_level(elem[0].tag):
348: (16)                           elem.text = i
349: (12)                       for e in elem:
350: (16)                           if self.md.is_block_level(e.tag):
351: (20)                               self._prettifyETree(e)
352: (8)                    if not elem.tail or not elem.tail.strip():
353: (12)                       elem.tail = i
354: (4)                def run(self, root: etree.Element) -> None:
355: (8)                    """ Add line breaks to `Element` object and its children. """
356: (8)                    self._prettifyETree(root)
357: (8)                    # Do `<br />`'s separately as they are often in the middle of
358: (8)                    # inline content and missed by `_prettifyETree`.
359: (8)                    brs = root.iter('br')
360: (8)                    for br in brs:
361: (12)                       if not br.tail or not br.tail.strip():
362: (16)                           br.tail = '\n'
363: (12)                       else:
364: (16)                           br.tail = '\n%s' % br.tail
365: (8)                    # Clean up extra empty lines at end of code blocks.
366: (8)                    pres = root.iter('pre')
367: (8)                    for pre in pres:
368: (12)                       if len(pre) and pre[0].tag == 'code':
369: (16)                           code = pre[0]
370: (16)                           # Only prettify code containing text only
371: (16)                           if not len(code) and code.text is not None:
372: (20)                               code.text = util.AtomicString(code.text.rstrip() + '\n')
373: (0)            class UnescapeTreeprocessor(Treeprocessor):
374: (4)                """ Restore escaped chars """
375: (4)                RE = re.compile(r'{}(\d+){}'.format(util.STX, util.ETX))
376: (4)                def _unescape(self, m: re.Match[str]) -> str:
377: (8)                    return chr(int(m.group(1)))
378: (4)                def unescape(self, text: str) -> str:
379: (8)                    return self.RE.sub(self._unescape, text)
380: (4)                def run(self, root: etree.Element) -> None:
381: (8)                    """ Loop over all elements and unescape all text. """
382: (8)                    for elem in root.iter():
383: (12)                       # Unescape text content
384: (12)                       if elem.text and not elem.tag == 'code':
385: (16)                           elem.text = self.unescape(elem.text)
386: (12)                       # Unescape tail content
387: (12)                       if elem.tail:
388: (16)                           elem.tail = self.unescape(elem.tail)
389: (12)                       # Unescape attribute values
390: (12)                       for key, value in elem.items():
391: (16)                           elem.set(key, self.unescape(value))

----------------------------------------

File 14 - . \util.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             This module contains various contacts, classes and functions which get referenced and used
16: (0)             throughout the code base.
17: (0)             """
18: (0)             from __future__ import annotations
19: (0)             import re
20: (0)             import sys
21: (0)             import warnings
22: (0)             from functools import wraps, lru_cache
23: (0)             from itertools import count
24: (0)             from typing import TYPE_CHECKING, Generic, Iterator, NamedTuple, TypeVar, TypedDict, overload
25: (0)             if TYPE_CHECKING:  # pragma: no cover
26: (4)                 from markdown import Markdown
27: (4)                 import xml.etree.ElementTree as etree
28: (0)             _T = TypeVar('_T')
29: (0)             """
30: (0)             Constants you might want to modify
31: (0)             -----------------------------------------------------------------------------
32: (0)             """
33: (0)             BLOCK_LEVEL_ELEMENTS: list[str] = [
34: (4)                 # Elements which are invalid to wrap in a `<p>` tag.
35: (4)                 # See https://w3c.github.io/html/grouping-content.html#the-p-element
36: (4)                 'address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl',
37: (4)                 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3',
38: (4)                 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav', 'ol',
39: (4)                 'p', 'pre', 'section', 'table', 'ul',
40: (4)                 # Other elements which Markdown should not be mucking up the contents of.
41: (4)                 'canvas', 'colgroup', 'dd', 'body', 'dt', 'group', 'html', 'iframe', 'li', 'legend',
42: (4)                 'math', 'map', 'noscript', 'output', 'object', 'option', 'progress', 'script',
43: (4)                 'style', 'summary', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'tr', 'video'
44: (0)             ]
45: (0)             """
46: (0)             List of HTML tags which get treated as block-level elements. Same as the `block_level_elements`
47: (0)             attribute of the [`Markdown`][markdown.Markdown] class. Generally one should use the
48: (0)             attribute on the class. This remains for compatibility with older extensions.
49: (0)             """
50: (0)             # Placeholders
51: (0)             STX = '\u0002'
52: (0)             """ "Start of Text" marker for placeholder templates. """
53: (0)             ETX = '\u0003'
54: (0)             """ "End of Text" marker for placeholder templates. """
55: (0)             INLINE_PLACEHOLDER_PREFIX = STX+"klzzwxh:"
56: (0)             """ Prefix for inline placeholder template. """
57: (0)             INLINE_PLACEHOLDER = INLINE_PLACEHOLDER_PREFIX + "%s" + ETX
58: (0)             """ Placeholder template for stashed inline text. """
59: (0)             INLINE_PLACEHOLDER_RE = re.compile(INLINE_PLACEHOLDER % r'([0-9]+)')
60: (0)             """ Regular Expression which matches inline placeholders. """
61: (0)             AMP_SUBSTITUTE = STX+"amp"+ETX
62: (0)             """ Placeholder template for HTML entities. """
63: (0)             HTML_PLACEHOLDER = STX + "wzxhzdk:%s" + ETX
64: (0)             """ Placeholder template for raw HTML. """
65: (0)             HTML_PLACEHOLDER_RE = re.compile(HTML_PLACEHOLDER % r'([0-9]+)')
66: (0)             """ Regular expression which matches HTML placeholders. """
67: (0)             TAG_PLACEHOLDER = STX + "hzzhzkh:%s" + ETX
68: (0)             """ Placeholder template for tags. """
69: (0)             # Constants you probably do not need to change
70: (0)             # -----------------------------------------------------------------------------
71: (0)             RTL_BIDI_RANGES = (
72: (4)                 ('\u0590', '\u07FF'),
73: (4)                 # Hebrew (0590-05FF), Arabic (0600-06FF),
74: (4)                 # Syriac (0700-074F), Arabic supplement (0750-077F),
75: (4)                 # Thaana (0780-07BF), Nko (07C0-07FF).
76: (4)                 ('\u2D30', '\u2D7F')  # Tifinagh
77: (0)             )
78: (0)             # AUXILIARY GLOBAL FUNCTIONS
79: (0)             # =============================================================================
80: (0)             @lru_cache(maxsize=None)
81: (0)             def get_installed_extensions():
82: (4)                 """ Return all entry_points in the `markdown.extensions` group. """
83: (4)                 if sys.version_info >= (3, 10):
84: (8)                     from importlib import metadata
85: (4)                 else:  # `<PY310` use backport
86: (8)                     import importlib_metadata as metadata
87: (4)                 # Only load extension entry_points once.
88: (4)                 return metadata.entry_points(group='markdown.extensions')
89: (0)             def deprecated(message: str, stacklevel: int = 2):
90: (4)                 """
91: (4)                 Raise a [`DeprecationWarning`][] when wrapped function/method is called.
92: (4)                 Usage:
93: (4)                 ```python
94: (4)                 @deprecated("This method will be removed in version X; use Y instead.")
95: (4)                 def some_method():
96: (8)                     pass
97: (4)                 ```
98: (4)                 """
99: (4)                 def wrapper(func):
100: (8)                    @wraps(func)
101: (8)                    def deprecated_func(*args, **kwargs):
102: (12)                       warnings.warn(
103: (16)                           f"'{func.__name__}' is deprecated. {message}",
104: (16)                           category=DeprecationWarning,
105: (16)                           stacklevel=stacklevel
106: (12)                       )
107: (12)                       return func(*args, **kwargs)
108: (8)                    return deprecated_func
109: (4)                return wrapper
110: (0)            def parseBoolValue(value: str | None, fail_on_errors: bool = True, preserve_none: bool = False) -> bool | None:
111: (4)                """Parses a string representing a boolean value. If parsing was successful,
112: (7)                   returns `True` or `False`. If `preserve_none=True`, returns `True`, `False`,
113: (7)                   or `None`. If parsing was not successful, raises `ValueError`, or, if
114: (7)                   `fail_on_errors=False`, returns `None`."""
115: (4)                if not isinstance(value, str):
116: (8)                    if preserve_none and value is None:
117: (12)                       return value
118: (8)                    return bool(value)
119: (4)                elif preserve_none and value.lower() == 'none':
120: (8)                    return None
121: (4)                elif value.lower() in ('true', 'yes', 'y', 'on', '1'):
122: (8)                    return True
123: (4)                elif value.lower() in ('false', 'no', 'n', 'off', '0', 'none'):
124: (8)                    return False
125: (4)                elif fail_on_errors:
126: (8)                    raise ValueError('Cannot parse bool value: %r' % value)
127: (0)            def code_escape(text: str) -> str:
128: (4)                """HTML escape a string of code."""
129: (4)                if "&" in text:
130: (8)                    text = text.replace("&", "&amp;")
131: (4)                if "<" in text:
132: (8)                    text = text.replace("<", "&lt;")
133: (4)                if ">" in text:
134: (8)                    text = text.replace(">", "&gt;")
135: (4)                return text
136: (0)            def _get_stack_depth(size: int = 2) -> int:
137: (4)                """Get current stack depth, performantly.
138: (4)                """
139: (4)                frame = sys._getframe(size)
140: (4)                for size in count(size):
141: (8)                    frame = frame.f_back
142: (8)                    if not frame:
143: (12)                       return size
144: (0)            def nearing_recursion_limit() -> bool:
145: (4)                """Return true if current stack depth is within 100 of maximum limit."""
146: (4)                return sys.getrecursionlimit() - _get_stack_depth() < 100
147: (0)            # MISC AUXILIARY CLASSES
148: (0)            # =============================================================================
149: (0)            class AtomicString(str):
150: (4)                """A string which should not be further processed."""
151: (4)                pass
152: (0)            class Processor:
153: (4)                """ The base class for all processors.
154: (4)                Attributes:
155: (8)                    Processor.md: The `Markdown` instance passed in an initialization.
156: (4)                Arguments:
157: (8)                    md: The `Markdown` instance this processor is a part of.
158: (4)                """
159: (4)                def __init__(self, md: Markdown | None = None):
160: (8)                    self.md = md
161: (0)            if TYPE_CHECKING:  # pragma: no cover
162: (4)                class TagData(TypedDict):
163: (8)                    tag: str
164: (8)                    attrs: dict[str, str]
165: (8)                    left_index: int
166: (8)                    right_index: int
167: (0)            class HtmlStash:
168: (4)                """
169: (4)                This class is used for stashing HTML objects that we extract
170: (4)                in the beginning and replace with place-holders.
171: (4)                """
172: (4)                def __init__(self):
173: (8)                    """ Create an `HtmlStash`. """
174: (8)                    self.html_counter = 0  # for counting inline html segments
175: (8)                    self.rawHtmlBlocks: list[str | etree.Element] = []
176: (8)                    self.tag_counter = 0
177: (8)                    self.tag_data: list[TagData] = []  # list of dictionaries in the order tags appear
178: (4)                def store(self, html: str | etree.Element) -> str:
179: (8)                    """
180: (8)                    Saves an HTML segment for later reinsertion.  Returns a
181: (8)                    placeholder string that needs to be inserted into the
182: (8)                    document.
183: (8)                    Keyword arguments:
184: (12)                       html: An html segment.
185: (8)                    Returns:
186: (12)                       A placeholder string.
187: (8)                    """
188: (8)                    self.rawHtmlBlocks.append(html)
189: (8)                    placeholder = self.get_placeholder(self.html_counter)
190: (8)                    self.html_counter += 1
191: (8)                    return placeholder
192: (4)                def reset(self) -> None:
193: (8)                    """ Clear the stash. """
194: (8)                    self.html_counter = 0
195: (8)                    self.rawHtmlBlocks = []
196: (4)                def get_placeholder(self, key: int) -> str:
197: (8)                    return HTML_PLACEHOLDER % key
198: (4)                def store_tag(self, tag: str, attrs: dict[str, str], left_index: int, right_index: int) -> str:
199: (8)                    """Store tag data and return a placeholder."""
200: (8)                    self.tag_data.append({'tag': tag, 'attrs': attrs,
201: (30)                                         'left_index': left_index,
202: (30)                                         'right_index': right_index})
203: (8)                    placeholder = TAG_PLACEHOLDER % str(self.tag_counter)
204: (8)                    self.tag_counter += 1  # equal to the tag's index in `self.tag_data`
205: (8)                    return placeholder
206: (0)            # Used internally by `Registry` for each item in its sorted list.
207: (0)            # Provides an easier to read API when editing the code later.
208: (0)            # For example, `item.name` is more clear than `item[0]`.
209: (0)            class _PriorityItem(NamedTuple):
210: (4)                name: str
211: (4)                priority: float
212: (0)            class Registry(Generic[_T]):
213: (4)                """
214: (4)                A priority sorted registry.
215: (4)                A `Registry` instance provides two public methods to alter the data of the
216: (4)                registry: `register` and `deregister`. Use `register` to add items and
217: (4)                `deregister` to remove items. See each method for specifics.
218: (4)                When registering an item, a "name" and a "priority" must be provided. All
219: (4)                items are automatically sorted by "priority" from highest to lowest. The
220: (4)                "name" is used to remove ("deregister") and get items.
221: (4)                A `Registry` instance it like a list (which maintains order) when reading
222: (4)                data. You may iterate over the items, get an item and get a count (length)
223: (4)                of all items. You may also check that the registry contains an item.
224: (4)                When getting an item you may use either the index of the item or the
225: (4)                string-based "name". For example:
226: (8)                    registry = Registry()
227: (8)                    registry.register(SomeItem(), 'itemname', 20)
228: (8)                    # Get the item by index
229: (8)                    item = registry[0]
230: (8)                    # Get the item by name
231: (8)                    item = registry['itemname']
232: (4)                When checking that the registry contains an item, you may use either the
233: (4)                string-based "name", or a reference to the actual item. For example:
234: (8)                    someitem = SomeItem()
235: (8)                    registry.register(someitem, 'itemname', 20)
236: (8)                    # Contains the name
237: (8)                    assert 'itemname' in registry
238: (8)                    # Contains the item instance
239: (8)                    assert someitem in registry
240: (4)                The method `get_index_for_name` is also available to obtain the index of
241: (4)                an item using that item's assigned "name".
242: (4)                """
243: (4)                def __init__(self):
244: (8)                    self._data: dict[str, _T] = {}
245: (8)                    self._priority: list[_PriorityItem] = []
246: (8)                    self._is_sorted = False
247: (4)                def __contains__(self, item: str | _T) -> bool:
248: (8)                    if isinstance(item, str):
249: (12)                       # Check if an item exists by this name.
250: (12)                       return item in self._data.keys()
251: (8)                    # Check if this instance exists.
252: (8)                    return item in self._data.values()
253: (4)                def __iter__(self) -> Iterator[_T]:
254: (8)                    self._sort()
255: (8)                    return iter([self._data[k] for k, p in self._priority])
256: (4)                @overload
257: (4)                def __getitem__(self, key: str | int) -> _T:  # pragma: no cover
258: (8)                    ...
259: (4)                @overload
260: (4)                def __getitem__(self, key: slice) -> Registry[_T]:  # pragma: no cover
261: (8)                    ...
262: (4)                def __getitem__(self, key: str | int | slice) -> _T | Registry[_T]:
263: (8)                    self._sort()
264: (8)                    if isinstance(key, slice):
265: (12)                       data: Registry[_T] = Registry()
266: (12)                       for k, p in self._priority[key]:
267: (16)                           data.register(self._data[k], k, p)
268: (12)                       return data
269: (8)                    if isinstance(key, int):
270: (12)                       return self._data[self._priority[key].name]
271: (8)                    return self._data[key]
272: (4)                def __len__(self) -> int:
273: (8)                    return len(self._priority)
274: (4)                def __repr__(self):
275: (8)                    return '<{}({})>'.format(self.__class__.__name__, list(self))
276: (4)                def get_index_for_name(self, name: str) -> int:
277: (8)                    """
278: (8)                    Return the index of the given name.
279: (8)                    """
280: (8)                    if name in self:
281: (12)                       self._sort()
282: (12)                       return self._priority.index(
283: (16)                           [x for x in self._priority if x.name == name][0]
284: (12)                       )
285: (8)                    raise ValueError('No item named "{}" exists.'.format(name))
286: (4)                def register(self, item: _T, name: str, priority: float) -> None:
287: (8)                    """
288: (8)                    Add an item to the registry with the given name and priority.
289: (8)                    Arguments:
290: (12)                       item: The item being registered.
291: (12)                       name: A string used to reference the item.
292: (12)                       priority: An integer or float used to sort against all items.
293: (8)                    If an item is registered with a "name" which already exists, the
294: (8)                    existing item is replaced with the new item. Treat carefully as the
295: (8)                    old item is lost with no way to recover it. The new item will be
296: (8)                    sorted according to its priority and will **not** retain the position
297: (8)                    of the old item.
298: (8)                    """
299: (8)                    if name in self:
300: (12)                       # Remove existing item of same name first
301: (12)                       self.deregister(name)
302: (8)                    self._is_sorted = False
303: (8)                    self._data[name] = item
304: (8)                    self._priority.append(_PriorityItem(name, priority))
305: (4)                def deregister(self, name: str, strict: bool = True) -> None:
306: (8)                    """
307: (8)                    Remove an item from the registry.
308: (8)                    Set `strict=False` to fail silently. Otherwise a [`ValueError`][] is raised for an unknown `name`.
309: (8)                    """
310: (8)                    try:
311: (12)                       index = self.get_index_for_name(name)
312: (12)                       del self._priority[index]
313: (12)                       del self._data[name]
314: (8)                    except ValueError:
315: (12)                       if strict:
316: (16)                           raise
317: (4)                def _sort(self) -> None:
318: (8)                    """
319: (8)                    Sort the registry by priority from highest to lowest.
320: (8)                    This method is called internally and should never be explicitly called.
321: (8)                    """
322: (8)                    if not self._is_sorted:
323: (12)                       self._priority.sort(key=lambda item: item.priority, reverse=True)
324: (12)                       self._is_sorted = True

----------------------------------------

File 15 - .\extensions \__init__.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             Markdown accepts an [`Extension`][markdown.extensions.Extension] instance for each extension. Therefore, each extension
16: (0)             must to define a class that extends [`Extension`][markdown.extensions.Extension] and over-rides the
17: (0)             [`extendMarkdown`][markdown.extensions.Extension.extendMarkdown] method. Within this class one can manage configuration
18: (0)             options for their extension and attach the various processors and patterns which make up an extension to the
19: (0)             [`Markdown`][markdown.Markdown] instance.
20: (0)             """
21: (0)             from __future__ import annotations
22: (0)             from typing import TYPE_CHECKING, Any, Iterable, Mapping
23: (0)             from ..util import parseBoolValue
24: (0)             if TYPE_CHECKING:  # pragma: no cover
25: (4)                 from markdown import Markdown
26: (0)             class Extension:
27: (4)                 """ Base class for extensions to subclass. """
28: (4)                 config: Mapping[str, list] = {}
29: (4)                 """
30: (4)                 Default configuration for an extension.
31: (4)                 This attribute is to be defined in a subclass and must be of the following format:
32: (4)                 ``` python
33: (4)                 config = {
34: (8)                     'key': ['value', 'description']
35: (4)                 }
36: (4)                 ```
37: (4)                 Note that [`setConfig`][markdown.extensions.Extension.setConfig] will raise a [`KeyError`][]
38: (4)                 if a default is not set for each option.
39: (4)                 """
40: (4)                 def __init__(self, **kwargs):
41: (8)                     """ Initiate Extension and set up configs. """
42: (8)                     self.setConfigs(kwargs)
43: (4)                 def getConfig(self, key: str, default: Any = '') -> Any:
44: (8)                     """
45: (8)                     Return a single configuration option value.
46: (8)                     Arguments:
47: (12)                        key: The configuration option name.
48: (12)                        default: Default value to return if key is not set.
49: (8)                     Returns:
50: (12)                        Value of stored configuration option.
51: (8)                     """
52: (8)                     if key in self.config:
53: (12)                        return self.config[key][0]
54: (8)                     else:
55: (12)                        return default
56: (4)                 def getConfigs(self) -> dict[str, Any]:
57: (8)                     """
58: (8)                     Return all configuration options.
59: (8)                     Returns:
60: (12)                        All configuration options.
61: (8)                     """
62: (8)                     return {key: self.getConfig(key) for key in self.config.keys()}
63: (4)                 def getConfigInfo(self) -> list[tuple[str, str]]:
64: (8)                     """
65: (8)                     Return descriptions of all configuration options.
66: (8)                     Returns:
67: (12)                        All descriptions of configuration options.
68: (8)                     """
69: (8)                     return [(key, self.config[key][1]) for key in self.config.keys()]
70: (4)                 def setConfig(self, key: str, value: Any) -> None:
71: (8)                     """
72: (8)                     Set a configuration option.
73: (8)                     If the corresponding default value set in [`config`][markdown.extensions.Extension.config]
74: (8)                     is a `bool` value or `None`, then `value` is passed through
75: (8)                     [`parseBoolValue`][markdown.util.parseBoolValue] before being stored.
76: (8)                     Arguments:
77: (12)                        key: Name of configuration option to set.
78: (12)                        value: Value to assign to option.
79: (8)                     Raises:
80: (12)                        KeyError: If `key` is not known.
81: (8)                     """
82: (8)                     if isinstance(self.config[key][0], bool):
83: (12)                        value = parseBoolValue(value)
84: (8)                     if self.config[key][0] is None:
85: (12)                        value = parseBoolValue(value, preserve_none=True)
86: (8)                     self.config[key][0] = value
87: (4)                 def setConfigs(self, items: Mapping[str, Any] | Iterable[tuple[str, Any]]) -> None:
88: (8)                     """
89: (8)                     Loop through a collection of configuration options, passing each to
90: (8)                     [`setConfig`][markdown.extensions.Extension.setConfig].
91: (8)                     Arguments:
92: (12)                        items: Collection of configuration options.
93: (8)                     Raises:
94: (12)                        KeyError: for any unknown key.
95: (8)                     """
96: (8)                     if hasattr(items, 'items'):
97: (12)                        # it's a dict
98: (12)                        items = items.items()
99: (8)                     for key, value in items:
100: (12)                       self.setConfig(key, value)
101: (4)                def extendMarkdown(self, md: Markdown) -> None:
102: (8)                    """
103: (8)                    Add the various processors and patterns to the Markdown Instance.
104: (8)                    This method must be overridden by every extension.
105: (8)                    Arguments:
106: (12)                       md: The Markdown instance.
107: (8)                    """
108: (8)                    raise NotImplementedError(
109: (12)                       'Extension "%s.%s" must define an "extendMarkdown"'
110: (12)                       'method.' % (self.__class__.__module__, self.__class__.__name__)
111: (8)                    )

----------------------------------------

File 16 - .\extensions \abbr.py:

1: (0)              # Abbreviation Extension for Python-Markdown
2: (0)              # ==========================================
3: (0)              # This extension adds abbreviation handling to Python-Markdown.
4: (0)              # See https://Python-Markdown.github.io/extensions/abbreviations
5: (0)              # for documentation.
6: (0)              # Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/)
7: (0)              # and [Seemant Kulleen](http://www.kulleen.org/)
8: (0)              # All changes Copyright 2008-2014 The Python Markdown Project
9: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
10: (0)             """
11: (0)             This extension adds abbreviation handling to Python-Markdown.
12: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/abbreviations)
13: (0)             for details.
14: (0)             """
15: (0)             from __future__ import annotations
16: (0)             from . import Extension
17: (0)             from ..blockprocessors import BlockProcessor
18: (0)             from ..inlinepatterns import InlineProcessor
19: (0)             from ..treeprocessors import Treeprocessor
20: (0)             from ..util import AtomicString, deprecated
21: (0)             from typing import TYPE_CHECKING
22: (0)             import re
23: (0)             import xml.etree.ElementTree as etree
24: (0)             if TYPE_CHECKING:  # pragma: no cover
25: (4)                 from .. import Markdown
26: (4)                 from ..blockparsers import BlockParser
27: (0)             class AbbrExtension(Extension):
28: (4)                 """ Abbreviation Extension for Python-Markdown. """
29: (4)                 def __init__(self, **kwargs):
30: (8)                     """ Initiate Extension and set up configs. """
31: (8)                     self.config = {
32: (12)                        'glossary': [
33: (16)                            {},
34: (16)                            'A dictionary where the `key` is the abbreviation and the `value` is the definition.'
35: (16)                            "Default: `{}`"
36: (12)                        ],
37: (8)                     }
38: (8)                     """ Default configuration options. """
39: (8)                     super().__init__(**kwargs)
40: (8)                     self.abbrs = {}
41: (8)                     self.glossary = {}
42: (4)                 def reset(self):
43: (8)                     """ Clear all previously defined abbreviations. """
44: (8)                     self.abbrs.clear()
45: (8)                     if (self.glossary):
46: (12)                        self.abbrs.update(self.glossary)
47: (4)                 def reset_glossary(self):
48: (8)                     """ Clear all abbreviations from the glossary. """
49: (8)                     self.glossary.clear()
50: (4)                 def load_glossary(self, dictionary: dict[str, str]):
51: (8)                     """Adds `dictionary` to our glossary. Any abbreviations that already exist will be overwritten."""
52: (8)                     if dictionary:
53: (12)                        self.glossary = {**dictionary, **self.glossary}
54: (4)                 def extendMarkdown(self, md):
55: (8)                     """ Insert `AbbrTreeprocessor` and `AbbrBlockprocessor`. """
56: (8)                     if (self.config['glossary'][0]):
57: (12)                        self.load_glossary(self.config['glossary'][0])
58: (8)                     self.abbrs.update(self.glossary)
59: (8)                     md.registerExtension(self)
60: (8)                     md.treeprocessors.register(AbbrTreeprocessor(md, self.abbrs), 'abbr', 7)
61: (8)                     md.parser.blockprocessors.register(AbbrBlockprocessor(md.parser, self.abbrs), 'abbr', 16)
62: (0)             class AbbrTreeprocessor(Treeprocessor):
63: (4)                 """ Replace abbreviation text with `<abbr>` elements. """
64: (4)                 def __init__(self, md: Markdown | None = None, abbrs: dict | None = None):
65: (8)                     self.abbrs: dict = abbrs if abbrs is not None else {}
66: (8)                     self.RE: re.RegexObject | None = None
67: (8)                     super().__init__(md)
68: (4)                 def iter_element(self, el: etree.Element, parent: etree.Element | None = None) -> None:
69: (8)                     ''' Recursively iterate over elements, run regex on text and wrap matches in `abbr` tags. '''
70: (8)                     for child in reversed(el):
71: (12)                        self.iter_element(child, el)
72: (8)                     if text := el.text:
73: (12)                        for m in reversed(list(self.RE.finditer(text))):
74: (16)                            if self.abbrs[m.group(0)]:
75: (20)                                abbr = etree.Element('abbr', {'title': self.abbrs[m.group(0)]})
76: (20)                                abbr.text = AtomicString(m.group(0))
77: (20)                                abbr.tail = text[m.end():]
78: (20)                                el.insert(0, abbr)
79: (20)                                text = text[:m.start()]
80: (12)                        el.text = text
81: (8)                     if parent is not None and el.tail:
82: (12)                        tail = el.tail
83: (12)                        index = list(parent).index(el) + 1
84: (12)                        for m in reversed(list(self.RE.finditer(tail))):
85: (16)                            abbr = etree.Element('abbr', {'title': self.abbrs[m.group(0)]})
86: (16)                            abbr.text = AtomicString(m.group(0))
87: (16)                            abbr.tail = tail[m.end():]
88: (16)                            parent.insert(index, abbr)
89: (16)                            tail = tail[:m.start()]
90: (12)                        el.tail = tail
91: (4)                 def run(self, root: etree.Element) -> etree.Element | None:
92: (8)                     ''' Step through tree to find known abbreviations. '''
93: (8)                     if not self.abbrs:
94: (12)                        # No abbreviations defined. Skip running processor.
95: (12)                        return
96: (8)                     # Build and compile regex
97: (8)                     abbr_list = list(self.abbrs.keys())
98: (8)                     abbr_list.sort(key=len, reverse=True)
99: (8)                     self.RE = re.compile(f"\\b(?:{ '|'.join(re.escape(key) for key in abbr_list) })\\b")
100: (8)                    # Step through tree and modify on matches
101: (8)                    self.iter_element(root)
102: (0)            class AbbrBlockprocessor(BlockProcessor):
103: (4)                """ Parse text for abbreviation references. """
104: (4)                RE = re.compile(r'^[*]\[(?P<abbr>[^\\]*?)\][ ]?:[ ]*\n?[ ]*(?P<title>.*)$', re.MULTILINE)
105: (4)                def __init__(self, parser: BlockParser, abbrs: dict):
106: (8)                    self.abbrs: dict = abbrs
107: (8)                    super().__init__(parser)
108: (4)                def test(self, parent: etree.Element, block: str) -> bool:
109: (8)                    return True
110: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> bool:
111: (8)                    """
112: (8)                    Find and remove all abbreviation references from the text.
113: (8)                    Each reference is added to the abbreviation collection.
114: (8)                    """
115: (8)                    block = blocks.pop(0)
116: (8)                    m = self.RE.search(block)
117: (8)                    if m:
118: (12)                       abbr = m.group('abbr').strip()
119: (12)                       title = m.group('title').strip()
120: (12)                       if title and abbr:
121: (16)                           if title == "''" or title == '""':
122: (20)                               self.abbrs.pop(abbr)
123: (16)                           else:
124: (20)                               self.abbrs[abbr] = title
125: (16)                           if block[m.end():].strip():
126: (20)                               # Add any content after match back to blocks as separate block
127: (20)                               blocks.insert(0, block[m.end():].lstrip('\n'))
128: (16)                           if block[:m.start()].strip():
129: (20)                               # Add any content before match back to blocks as separate block
130: (20)                               blocks.insert(0, block[:m.start()].rstrip('\n'))
131: (16)                           return True
132: (8)                    # No match. Restore block.
133: (8)                    blocks.insert(0, block)
134: (8)                    return False
135: (0)            AbbrPreprocessor = deprecated("This class has been renamed to `AbbrBlockprocessor`.")(AbbrBlockprocessor)
136: (0)            @deprecated("This class will be removed in the future; use `AbbrTreeprocessor` instead.")
137: (0)            class AbbrInlineProcessor(InlineProcessor):
138: (4)                """ Abbreviation inline pattern. """
139: (4)                def __init__(self, pattern: str, title: str):
140: (8)                    super().__init__(pattern)
141: (8)                    self.title = title
142: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:
143: (8)                    abbr = etree.Element('abbr')
144: (8)                    abbr.text = AtomicString(m.group('abbr'))
145: (8)                    abbr.set('title', self.title)
146: (8)                    return abbr, m.start(0), m.end(0)
147: (0)            def makeExtension(**kwargs):  # pragma: no cover
148: (4)                return AbbrExtension(**kwargs)

----------------------------------------

File 17 - .\extensions \admonition.py:

1: (0)              # Admonition extension for Python-Markdown
2: (0)              # ========================================
3: (0)              # Adds rST-style admonitions. Inspired by [rST][] feature with the same name.
4: (0)              # [rST]: http://docutils.sourceforge.net/docs/ref/rst/directives.html#specific-admonitions
5: (0)              # See https://Python-Markdown.github.io/extensions/admonition
6: (0)              # for documentation.
7: (0)              # Original code Copyright [Tiago Serafim](https://www.tiagoserafim.com/).
8: (0)              # All changes Copyright The Python Markdown Project
9: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
10: (0)             """
11: (0)             Adds rST-style admonitions. Inspired by [rST][] feature with the same name.
12: (0)             [rST]: http://docutils.sourceforge.net/docs/ref/rst/directives.html#specific-admonitions
13: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/admonition)
14: (0)             for details.
15: (0)             """
16: (0)             from __future__ import annotations
17: (0)             from . import Extension
18: (0)             from ..blockprocessors import BlockProcessor
19: (0)             import xml.etree.ElementTree as etree
20: (0)             import re
21: (0)             from typing import TYPE_CHECKING
22: (0)             if TYPE_CHECKING:  # pragma: no cover
23: (4)                 from markdown import blockparser
24: (0)             class AdmonitionExtension(Extension):
25: (4)                 """ Admonition extension for Python-Markdown. """
26: (4)                 def extendMarkdown(self, md):
27: (8)                     """ Add Admonition to Markdown instance. """
28: (8)                     md.registerExtension(self)
29: (8)                     md.parser.blockprocessors.register(AdmonitionProcessor(md.parser), 'admonition', 105)
30: (0)             class AdmonitionProcessor(BlockProcessor):
31: (4)                 CLASSNAME = 'admonition'
32: (4)                 CLASSNAME_TITLE = 'admonition-title'
33: (4)                 RE = re.compile(r'(?:^|\n)!!! ?([\w\-]+(?: +[\w\-]+)*)(?: +"(.*?)")? *(?:\n|$)')
34: (4)                 RE_SPACES = re.compile('  +')
35: (4)                 def __init__(self, parser: blockparser.BlockParser):
36: (8)                     """Initialization."""
37: (8)                     super().__init__(parser)
38: (8)                     self.current_sibling: etree.Element | None = None
39: (8)                     self.content_indent = 0
40: (4)                 def parse_content(self, parent: etree.Element, block: str) -> tuple[etree.Element | None, str, str]:
41: (8)                     """Get sibling admonition.
42: (8)                     Retrieve the appropriate sibling element. This can get tricky when
43: (8)                     dealing with lists.
44: (8)                     """
45: (8)                     old_block = block
46: (8)                     the_rest = ''
47: (8)                     # We already acquired the block via test
48: (8)                     if self.current_sibling is not None:
49: (12)                        sibling = self.current_sibling
50: (12)                        block, the_rest = self.detab(block, self.content_indent)
51: (12)                        self.current_sibling = None
52: (12)                        self.content_indent = 0
53: (12)                        return sibling, block, the_rest
54: (8)                     sibling = self.lastChild(parent)
55: (8)                     if sibling is None or sibling.tag != 'div' or sibling.get('class', '').find(self.CLASSNAME) == -1:
56: (12)                        sibling = None
57: (8)                     else:
58: (12)                        # If the last child is a list and the content is sufficiently indented
59: (12)                        # to be under it, then the content's sibling is in the list.
60: (12)                        last_child = self.lastChild(sibling)
61: (12)                        indent = 0
62: (12)                        while last_child is not None:
63: (16)                            if (
64: (20)                                sibling is not None and block.startswith(' ' * self.tab_length * 2) and
65: (20)                                last_child is not None and last_child.tag in ('ul', 'ol', 'dl')
66: (16)                            ):
67: (20)                                # The expectation is that we'll find an `<li>` or `<dt>`.
68: (20)                                # We should get its last child as well.
69: (20)                                sibling = self.lastChild(last_child)
70: (20)                                last_child = self.lastChild(sibling) if sibling is not None else None
71: (20)                                # Context has been lost at this point, so we must adjust the
72: (20)                                # text's indentation level so it will be evaluated correctly
73: (20)                                # under the list.
74: (20)                                block = block[self.tab_length:]
75: (20)                                indent += self.tab_length
76: (16)                            else:
77: (20)                                last_child = None
78: (12)                        if not block.startswith(' ' * self.tab_length):
79: (16)                            sibling = None
80: (12)                        if sibling is not None:
81: (16)                            indent += self.tab_length
82: (16)                            block, the_rest = self.detab(old_block, indent)
83: (16)                            self.current_sibling = sibling
84: (16)                            self.content_indent = indent
85: (8)                     return sibling, block, the_rest
86: (4)                 def test(self, parent: etree.Element, block: str) -> bool:
87: (8)                     if self.RE.search(block):
88: (12)                        return True
89: (8)                     else:
90: (12)                        return self.parse_content(parent, block)[0] is not None
91: (4)                 def run(self, parent: etree.Element, blocks: list[str]) -> None:
92: (8)                     block = blocks.pop(0)
93: (8)                     m = self.RE.search(block)
94: (8)                     if m:
95: (12)                        if m.start() > 0:
96: (16)                            self.parser.parseBlocks(parent, [block[:m.start()]])
97: (12)                        block = block[m.end():]  # removes the first line
98: (12)                        block, theRest = self.detab(block)
99: (8)                     else:
100: (12)                       sibling, block, theRest = self.parse_content(parent, block)
101: (8)                    if m:
102: (12)                       klass, title = self.get_class_and_title(m)
103: (12)                       div = etree.SubElement(parent, 'div')
104: (12)                       div.set('class', '{} {}'.format(self.CLASSNAME, klass))
105: (12)                       if title:
106: (16)                           p = etree.SubElement(div, 'p')
107: (16)                           p.text = title
108: (16)                           p.set('class', self.CLASSNAME_TITLE)
109: (8)                    else:
110: (12)                       # Sibling is a list item, but we need to wrap it's content should be wrapped in <p>
111: (12)                       if sibling.tag in ('li', 'dd') and sibling.text:
112: (16)                           text = sibling.text
113: (16)                           sibling.text = ''
114: (16)                           p = etree.SubElement(sibling, 'p')
115: (16)                           p.text = text
116: (12)                       div = sibling
117: (8)                    self.parser.parseChunk(div, block)
118: (8)                    if theRest:
119: (12)                       # This block contained unindented line(s) after the first indented
120: (12)                       # line. Insert these lines as the first block of the master blocks
121: (12)                       # list for future processing.
122: (12)                       blocks.insert(0, theRest)
123: (4)                def get_class_and_title(self, match: re.Match[str]) -> tuple[str, str | None]:
124: (8)                    klass, title = match.group(1).lower(), match.group(2)
125: (8)                    klass = self.RE_SPACES.sub(' ', klass)
126: (8)                    if title is None:
127: (12)                       # no title was provided, use the capitalized class name as title
128: (12)                       # e.g.: `!!! note` will render
129: (12)                       # `<p class="admonition-title">Note</p>`
130: (12)                       title = klass.split(' ', 1)[0].capitalize()
131: (8)                    elif title == '':
132: (12)                       # an explicit blank title should not be rendered
133: (12)                       # e.g.: `!!! warning ""` will *not* render `p` with a title
134: (12)                       title = None
135: (8)                    return klass, title
136: (0)            def makeExtension(**kwargs):  # pragma: no cover
137: (4)                return AdmonitionExtension(**kwargs)

----------------------------------------

File 18 - .\extensions \attr_list.py:

1: (0)              # Attribute List Extension for Python-Markdown
2: (0)              # ============================================
3: (0)              # Adds attribute list syntax. Inspired by
4: (0)              # [Maruku](http://maruku.rubyforge.org/proposal.html#attribute_lists)'s
5: (0)              # feature of the same name.
6: (0)              # See https://Python-Markdown.github.io/extensions/attr_list
7: (0)              # for documentation.
8: (0)              # Original code Copyright 2011 [Waylan Limberg](http://achinghead.com/).
9: (0)              # All changes Copyright 2011-2014 The Python Markdown Project
10: (0)             # License: [BSD](https://opensource.org/licenses/bsd-license.php)
11: (0)             """
12: (1)              Adds attribute list syntax. Inspired by
13: (0)             [Maruku](http://maruku.rubyforge.org/proposal.html#attribute_lists)'s
14: (0)             feature of the same name.
15: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/attr_list)
16: (0)             for details.
17: (0)             """
18: (0)             from __future__ import annotations
19: (0)             from typing import TYPE_CHECKING
20: (0)             from . import Extension
21: (0)             from ..treeprocessors import Treeprocessor
22: (0)             import re
23: (0)             if TYPE_CHECKING:  # pragma: no cover
24: (4)                 from xml.etree.ElementTree import Element
25: (0)             def _handle_double_quote(s, t):
26: (4)                 k, v = t.split('=', 1)
27: (4)                 return k, v.strip('"')
28: (0)             def _handle_single_quote(s, t):
29: (4)                 k, v = t.split('=', 1)
30: (4)                 return k, v.strip("'")
31: (0)             def _handle_key_value(s, t):
32: (4)                 return t.split('=', 1)
33: (0)             def _handle_word(s, t):
34: (4)                 if t.startswith('.'):
35: (8)                     return '.', t[1:]
36: (4)                 if t.startswith('#'):
37: (8)                     return 'id', t[1:]
38: (4)                 return t, t
39: (0)             _scanner = re.Scanner([
40: (4)                 (r'[^ =}]+=".*?"', _handle_double_quote),
41: (4)                 (r"[^ =}]+='.*?'", _handle_single_quote),
42: (4)                 (r'[^ =}]+=[^ =}]+', _handle_key_value),
43: (4)                 (r'[^ =}]+', _handle_word),
44: (4)                 (r' ', None)
45: (0)             ])
46: (0)             def get_attrs_and_remainder(attrs_string: str) -> tuple[list[tuple[str, str]], str]:
47: (4)                 """ Parse attribute list and return a list of attribute tuples.
48: (4)                 Additionally, return any text that remained after a curly brace. In typical cases, its presence
49: (4)                 should mean that the input does not match the intended attribute list syntax.
50: (4)                 """
51: (4)                 attrs, remainder = _scanner.scan(attrs_string)
52: (4)                 # To keep historic behavior, discard all unparsable text prior to '}'.
53: (4)                 index = remainder.find('}')
54: (4)                 remainder = remainder[index:] if index != -1 else ''
55: (4)                 return attrs, remainder
56: (0)             def get_attrs(str: str) -> list[tuple[str, str]]:  # pragma: no cover
57: (4)                 """ Soft-deprecated. Prefer `get_attrs_and_remainder`. """
58: (4)                 return get_attrs_and_remainder(str)[0]
59: (0)             def isheader(elem: Element) -> bool:
60: (4)                 return elem.tag in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']
61: (0)             class AttrListTreeprocessor(Treeprocessor):
62: (4)                 BASE_RE = r'\{\:?[ ]*([^\}\n ][^\n]*)[ ]*\}'
63: (4)                 HEADER_RE = re.compile(r'[ ]+{}[ ]*$'.format(BASE_RE))
64: (4)                 BLOCK_RE = re.compile(r'\n[ ]*{}[ ]*$'.format(BASE_RE))
65: (4)                 INLINE_RE = re.compile(r'^{}'.format(BASE_RE))
66: (4)                 NAME_RE = re.compile(r'[^A-Z_a-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02ff'
67: (25)                                     r'\u0370-\u037d\u037f-\u1fff\u200c-\u200d'
68: (25)                                     r'\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff'
69: (25)                                     r'\uf900-\ufdcf\ufdf0-\ufffd'
70: (25)                                     r'\:\-\.0-9\u00b7\u0300-\u036f\u203f-\u2040]+')
71: (4)                 def run(self, doc: Element) -> None:
72: (8)                     for elem in doc.iter():
73: (12)                        if self.md.is_block_level(elem.tag):
74: (16)                            # Block level: check for `attrs` on last line of text
75: (16)                            RE = self.BLOCK_RE
76: (16)                            if isheader(elem) or elem.tag in ['dt', 'td', 'th']:
77: (20)                                # header, def-term, or table cell: check for attributes at end of element
78: (20)                                RE = self.HEADER_RE
79: (16)                            if len(elem) and elem.tag == 'li':
80: (20)                                # special case list items. children may include a `ul` or `ol`.
81: (20)                                pos = None
82: (20)                                # find the `ul` or `ol` position
83: (20)                                for i, child in enumerate(elem):
84: (24)                                    if child.tag in ['ul', 'ol']:
85: (28)                                        pos = i
86: (28)                                        break
87: (20)                                if pos is None and elem[-1].tail:
88: (24)                                    # use tail of last child. no `ul` or `ol`.
89: (24)                                    m = RE.search(elem[-1].tail)
90: (24)                                    if m:
91: (28)                                        if not self.assign_attrs(elem, m.group(1), strict=True):
92: (32)                                            elem[-1].tail = elem[-1].tail[:m.start()]
93: (20)                                elif pos is not None and pos > 0 and elem[pos-1].tail:
94: (24)                                    # use tail of last child before `ul` or `ol`
95: (24)                                    m = RE.search(elem[pos-1].tail)
96: (24)                                    if m:
97: (28)                                        if not self.assign_attrs(elem, m.group(1), strict=True):
98: (32)                                            elem[pos-1].tail = elem[pos-1].tail[:m.start()]
99: (20)                                elif elem.text:
100: (24)                                   # use text. `ul` is first child.
101: (24)                                   m = RE.search(elem.text)
102: (24)                                   if m:
103: (28)                                       if not self.assign_attrs(elem, m.group(1), strict=True):
104: (32)                                           elem.text = elem.text[:m.start()]
105: (16)                           elif len(elem) and elem[-1].tail:
106: (20)                               # has children. Get from tail of last child
107: (20)                               m = RE.search(elem[-1].tail)
108: (20)                               if m:
109: (24)                                   if not self.assign_attrs(elem, m.group(1), strict=True):
110: (28)                                       elem[-1].tail = elem[-1].tail[:m.start()]
111: (28)                                       if isheader(elem):
112: (32)                                           # clean up trailing #s
113: (32)                                           elem[-1].tail = elem[-1].tail.rstrip('#').rstrip()
114: (16)                           elif elem.text:
115: (20)                               # no children. Get from text.
116: (20)                               m = RE.search(elem.text)
117: (20)                               if m:
118: (24)                                   if not self.assign_attrs(elem, m.group(1), strict=True):
119: (28)                                       elem.text = elem.text[:m.start()]
120: (28)                                       if isheader(elem):
121: (32)                                           # clean up trailing #s
122: (32)                                           elem.text = elem.text.rstrip('#').rstrip()
123: (12)                       else:
124: (16)                           # inline: check for `attrs` at start of tail
125: (16)                           if elem.tail:
126: (20)                               m = self.INLINE_RE.match(elem.tail)
127: (20)                               if m:
128: (24)                                   remainder = self.assign_attrs(elem, m.group(1))
129: (24)                                   elem.tail = elem.tail[m.end():] + remainder
130: (4)                def assign_attrs(self, elem: Element, attrs_string: str, *, strict: bool = False) -> str:
131: (8)                    """ Assign `attrs` to element.
132: (8)                    If the `attrs_string` has an extra closing curly brace, the remaining text is returned.
133: (8)                    The `strict` argument controls whether to still assign `attrs` if there is a remaining `}`.
134: (8)                    """
135: (8)                    attrs, remainder = get_attrs_and_remainder(attrs_string)
136: (8)                    if strict and remainder:
137: (12)                       return remainder
138: (8)                    for k, v in attrs:
139: (12)                       if k == '.':
140: (16)                           # add to class
141: (16)                           cls = elem.get('class')
142: (16)                           if cls:
143: (20)                               elem.set('class', '{} {}'.format(cls, v))
144: (16)                           else:
145: (20)                               elem.set('class', v)
146: (12)                       else:
147: (16)                           # assign attribute `k` with `v`
148: (16)                           elem.set(self.sanitize_name(k), v)
149: (8)                    # The text that we initially over-matched will be put back.
150: (8)                    return remainder
151: (4)                def sanitize_name(self, name: str) -> str:
152: (8)                    """
153: (8)                    Sanitize name as 'an XML Name, minus the `:`.'
154: (8)                    See <https://www.w3.org/TR/REC-xml-names/#NT-NCName>.
155: (8)                    """
156: (8)                    return self.NAME_RE.sub('_', name)
157: (0)            class AttrListExtension(Extension):
158: (4)                """ Attribute List extension for Python-Markdown """
159: (4)                def extendMarkdown(self, md):
160: (8)                    md.treeprocessors.register(AttrListTreeprocessor(md), 'attr_list', 8)
161: (8)                    md.registerExtension(self)
162: (0)            def makeExtension(**kwargs):  # pragma: no cover
163: (4)                return AttrListExtension(**kwargs)

----------------------------------------

File 19 - .\extensions \codehilite.py:

1: (0)              # CodeHilite Extension for Python-Markdown
2: (0)              # ========================================
3: (0)              # Adds code/syntax highlighting to standard Python-Markdown code blocks.
4: (0)              # See https://Python-Markdown.github.io/extensions/code_hilite
5: (0)              # for documentation.
6: (0)              # Original code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).
7: (0)              # All changes Copyright 2008-2014 The Python Markdown Project
8: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
9: (0)              """
10: (0)             Adds code/syntax highlighting to standard Python-Markdown code blocks.
11: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/code_hilite)
12: (0)             for details.
13: (0)             """
14: (0)             from __future__ import annotations
15: (0)             from . import Extension
16: (0)             from ..treeprocessors import Treeprocessor
17: (0)             from ..util import parseBoolValue
18: (0)             from typing import TYPE_CHECKING, Callable, Any
19: (0)             if TYPE_CHECKING:  # pragma: no cover
20: (4)                 import xml.etree.ElementTree as etree
21: (0)             try:  # pragma: no cover
22: (4)                 from pygments import highlight
23: (4)                 from pygments.lexers import get_lexer_by_name, guess_lexer
24: (4)                 from pygments.formatters import get_formatter_by_name
25: (4)                 from pygments.util import ClassNotFound
26: (4)                 pygments = True
27: (0)             except ImportError:  # pragma: no cover
28: (4)                 pygments = False
29: (0)             def parse_hl_lines(expr: str) -> list[int]:
30: (4)                 """Support our syntax for emphasizing certain lines of code.
31: (4)                 `expr` should be like '1 2' to emphasize lines 1 and 2 of a code block.
32: (4)                 Returns a list of integers, the line numbers to emphasize.
33: (4)                 """
34: (4)                 if not expr:
35: (8)                     return []
36: (4)                 try:
37: (8)                     return list(map(int, expr.split()))
38: (4)                 except ValueError:  # pragma: no cover
39: (8)                     return []
40: (0)             # ------------------ The Main CodeHilite Class ----------------------
41: (0)             class CodeHilite:
42: (4)                 """
43: (4)                 Determine language of source code, and pass it on to the Pygments highlighter.
44: (4)                 Usage:
45: (4)                 ```python
46: (4)                 code = CodeHilite(src=some_code, lang='python')
47: (4)                 html = code.hilite()
48: (4)                 ```
49: (4)                 Arguments:
50: (8)                     src: Source string or any object with a `.readline` attribute.
51: (4)                 Keyword arguments:
52: (8)                     lang (str): String name of Pygments lexer to use for highlighting. Default: `None`.
53: (8)                     guess_lang (bool): Auto-detect which lexer to use.
54: (12)                        Ignored if `lang` is set to a valid value. Default: `True`.
55: (8)                     use_pygments (bool): Pass code to Pygments for code highlighting. If `False`, the code is
56: (12)                        instead wrapped for highlighting by a JavaScript library. Default: `True`.
57: (8)                     pygments_formatter (str): The name of a Pygments formatter or a formatter class used for
58: (12)                        highlighting the code blocks. Default: `html`.
59: (8)                     linenums (bool): An alias to Pygments `linenos` formatter option. Default: `None`.
60: (8)                     css_class (str): An alias to Pygments `cssclass` formatter option. Default: 'codehilite'.
61: (8)                     lang_prefix (str): Prefix prepended to the language. Default: "language-".
62: (4)                 Other Options:
63: (4)                 Any other options are accepted and passed on to the lexer and formatter. Therefore,
64: (4)                 valid options include any options which are accepted by the `html` formatter or
65: (4)                 whichever lexer the code's language uses. Note that most lexers do not have any
66: (4)                 options. However, a few have very useful options, such as PHP's `startinline` option.
67: (4)                 Any invalid options are ignored without error.
68: (4)                 * **Formatter options**: <https://pygments.org/docs/formatters/#HtmlFormatter>
69: (4)                 * **Lexer Options**: <https://pygments.org/docs/lexers/>
70: (4)                 Additionally, when Pygments is enabled, the code's language is passed to the
71: (4)                 formatter as an extra option `lang_str`, whose value being `{lang_prefix}{lang}`.
72: (4)                 This option has no effect to the Pygments' builtin formatters.
73: (4)                 Advanced Usage:
74: (4)                 ```python
75: (4)                 code = CodeHilite(
76: (8)                     src = some_code,
77: (8)                     lang = 'php',
78: (8)                     startinline = True,      # Lexer option. Snippet does not start with `<?php`.
79: (8)                     linenostart = 42,        # Formatter option. Snippet starts on line 42.
80: (8)                     hl_lines = [45, 49, 50], # Formatter option. Highlight lines 45, 49, and 50.
81: (8)                     linenos = 'inline'       # Formatter option. Avoid alignment problems.
82: (4)                 )
83: (4)                 html = code.hilite()
84: (4)                 ```
85: (4)                 """
86: (4)                 def __init__(self, src: str, **options):
87: (8)                     self.src = src
88: (8)                     self.lang: str | None = options.pop('lang', None)
89: (8)                     self.guess_lang: bool = options.pop('guess_lang', True)
90: (8)                     self.use_pygments: bool = options.pop('use_pygments', True)
91: (8)                     self.lang_prefix: str = options.pop('lang_prefix', 'language-')
92: (8)                     self.pygments_formatter: str | Callable = options.pop('pygments_formatter', 'html')
93: (8)                     if 'linenos' not in options:
94: (12)                        options['linenos'] = options.pop('linenums', None)
95: (8)                     if 'cssclass' not in options:
96: (12)                        options['cssclass'] = options.pop('css_class', 'codehilite')
97: (8)                     if 'wrapcode' not in options:
98: (12)                        # Override Pygments default
99: (12)                        options['wrapcode'] = True
100: (8)                    # Disallow use of `full` option
101: (8)                    options['full'] = False
102: (8)                    self.options = options
103: (4)                def hilite(self, shebang: bool = True) -> str:
104: (8)                    """
105: (8)                    Pass code to the [Pygments](https://pygments.org/) highlighter with
106: (8)                    optional line numbers. The output should then be styled with CSS to
107: (8)                    your liking. No styles are applied by default - only styling hooks
108: (8)                    (i.e.: `<span class="k">`).
109: (8)                    returns : A string of html.
110: (8)                    """
111: (8)                    self.src = self.src.strip('\n')
112: (8)                    if self.lang is None and shebang:
113: (12)                       self._parseHeader()
114: (8)                    if pygments and self.use_pygments:
115: (12)                       try:
116: (16)                           lexer = get_lexer_by_name(self.lang, **self.options)
117: (12)                       except ValueError:
118: (16)                           try:
119: (20)                               if self.guess_lang:
120: (24)                                   lexer = guess_lexer(self.src, **self.options)
121: (20)                               else:
122: (24)                                   lexer = get_lexer_by_name('text', **self.options)
123: (16)                           except ValueError:  # pragma: no cover
124: (20)                               lexer = get_lexer_by_name('text', **self.options)
125: (12)                       if not self.lang:
126: (16)                           # Use the guessed lexer's language instead
127: (16)                           self.lang = lexer.aliases[0]
128: (12)                       lang_str = f'{self.lang_prefix}{self.lang}'
129: (12)                       if isinstance(self.pygments_formatter, str):
130: (16)                           try:
131: (20)                               formatter = get_formatter_by_name(self.pygments_formatter, **self.options)
132: (16)                           except ClassNotFound:
133: (20)                               formatter = get_formatter_by_name('html', **self.options)
134: (12)                       else:
135: (16)                           formatter = self.pygments_formatter(lang_str=lang_str, **self.options)
136: (12)                       return highlight(self.src, lexer, formatter)
137: (8)                    else:
138: (12)                       # just escape and build markup usable by JavaScript highlighting libraries
139: (12)                       txt = self.src.replace('&', '&amp;')
140: (12)                       txt = txt.replace('<', '&lt;')
141: (12)                       txt = txt.replace('>', '&gt;')
142: (12)                       txt = txt.replace('"', '&quot;')
143: (12)                       classes = []
144: (12)                       if self.lang:
145: (16)                           classes.append('{}{}'.format(self.lang_prefix, self.lang))
146: (12)                       if self.options['linenos']:
147: (16)                           classes.append('linenums')
148: (12)                       class_str = ''
149: (12)                       if classes:
150: (16)                           class_str = ' class="{}"'.format(' '.join(classes))
151: (12)                       return '<pre class="{}"><code{}>{}\n</code></pre>\n'.format(
152: (16)                           self.options['cssclass'],
153: (16)                           class_str,
154: (16)                           txt
155: (12)                       )
156: (4)                def _parseHeader(self) -> None:
157: (8)                    """
158: (8)                    Determines language of a code block from shebang line and whether the
159: (8)                    said line should be removed or left in place. If the shebang line
160: (8)                    contains a path (even a single /) then it is assumed to be a real
161: (8)                    shebang line and left alone. However, if no path is given
162: (8)                    (e.i.: `#!python` or `:::python`) then it is assumed to be a mock shebang
163: (8)                    for language identification of a code fragment and removed from the
164: (8)                    code block prior to processing for code highlighting. When a mock
165: (8)                    shebang (e.i: `#!python`) is found, line numbering is turned on. When
166: (8)                    colons are found in place of a shebang (e.i.: `:::python`), line
167: (8)                    numbering is left in the current state - off by default.
168: (8)                    Also parses optional list of highlight lines, like:
169: (12)                       :::python hl_lines="1 3"
170: (8)                    """
171: (8)                    import re
172: (8)                    # split text into lines
173: (8)                    lines = self.src.split("\n")
174: (8)                    # pull first line to examine
175: (8)                    fl = lines.pop(0)
176: (8)                    c = re.compile(r'''
177: (12)                       (?:(?:^::+)|(?P<shebang>^[#]!)) # Shebang or 2 or more colons
178: (12)                       (?P<path>(?:/\w+)*[/ ])?        # Zero or 1 path
179: (12)                       (?P<lang>[\w#.+-]*)             # The language
180: (12)                       \s*                             # Arbitrary whitespace
181: (12)                       # Optional highlight lines, single- or double-quote-delimited
182: (12)                       (hl_lines=(?P<quot>"|')(?P<hl_lines>.*?)(?P=quot))?
183: (12)                       ''',  re.VERBOSE)
184: (8)                    # search first line for shebang
185: (8)                    m = c.search(fl)
186: (8)                    if m:
187: (12)                       # we have a match
188: (12)                       try:
189: (16)                           self.lang = m.group('lang').lower()
190: (12)                       except IndexError:  # pragma: no cover
191: (16)                           self.lang = None
192: (12)                       if m.group('path'):
193: (16)                           # path exists - restore first line
194: (16)                           lines.insert(0, fl)
195: (12)                       if self.options['linenos'] is None and m.group('shebang'):
196: (16)                           # Overridable and Shebang exists - use line numbers
197: (16)                           self.options['linenos'] = True
198: (12)                       self.options['hl_lines'] = parse_hl_lines(m.group('hl_lines'))
199: (8)                    else:
200: (12)                       # No match
201: (12)                       lines.insert(0, fl)
202: (8)                    self.src = "\n".join(lines).strip("\n")
203: (0)            # ------------------ The Markdown Extension -------------------------------
204: (0)            class HiliteTreeprocessor(Treeprocessor):
205: (4)                """ Highlight source code in code blocks. """
206: (4)                config: dict[str, Any]
207: (4)                def code_unescape(self, text: str) -> str:
208: (8)                    """Unescape code."""
209: (8)                    text = text.replace("&lt;", "<")
210: (8)                    text = text.replace("&gt;", ">")
211: (8)                    # Escaped '&' should be replaced at the end to avoid
212: (8)                    # conflicting with < and >.
213: (8)                    text = text.replace("&amp;", "&")
214: (8)                    return text
215: (4)                def run(self, root: etree.Element) -> None:
216: (8)                    """ Find code blocks and store in `htmlStash`. """
217: (8)                    blocks = root.iter('pre')
218: (8)                    for block in blocks:
219: (12)                       if len(block) == 1 and block[0].tag == 'code':
220: (16)                           local_config = self.config.copy()
221: (16)                           text = block[0].text
222: (16)                           if text is None:
223: (20)                               continue
224: (16)                           code = CodeHilite(
225: (20)                               self.code_unescape(text),
226: (20)                               tab_length=self.md.tab_length,
227: (20)                               style=local_config.pop('pygments_style', 'default'),
228: (20)                               **local_config
229: (16)                           )
230: (16)                           placeholder = self.md.htmlStash.store(code.hilite())
231: (16)                           # Clear code block in `etree` instance
232: (16)                           block.clear()
233: (16)                           # Change to `p` element which will later
234: (16)                           # be removed when inserting raw html
235: (16)                           block.tag = 'p'
236: (16)                           block.text = placeholder
237: (0)            class CodeHiliteExtension(Extension):
238: (4)                """ Add source code highlighting to markdown code blocks. """
239: (4)                def __init__(self, **kwargs):
240: (8)                    # define default configs
241: (8)                    self.config = {
242: (12)                       'linenums': [
243: (16)                           None, "Use lines numbers. True|table|inline=yes, False=no, None=auto. Default: `None`."
244: (12)                       ],
245: (12)                       'guess_lang': [
246: (16)                           True, "Automatic language detection - Default: `True`."
247: (12)                       ],
248: (12)                       'css_class': [
249: (16)                           "codehilite", "Set class name for wrapper <div> - Default: `codehilite`."
250: (12)                       ],
251: (12)                       'pygments_style': [
252: (16)                           'default', 'Pygments HTML Formatter Style (Colorscheme). Default: `default`.'
253: (12)                       ],
254: (12)                       'noclasses': [
255: (16)                           False, 'Use inline styles instead of CSS classes - Default `False`.'
256: (12)                       ],
257: (12)                       'use_pygments': [
258: (16)                           True, 'Highlight code blocks with pygments. Disable if using a JavaScript library. Default: `True`.'
259: (12)                       ],
260: (12)                       'lang_prefix': [
261: (16)                           'language-', 'Prefix prepended to the language when `use_pygments` is false. Default: `language-`.'
262: (12)                       ],
263: (12)                       'pygments_formatter': [
264: (16)                           'html', 'Use a specific formatter for Pygments highlighting. Default: `html`.'
265: (12)                       ],
266: (8)                    }
267: (8)                    """ Default configuration options. """
268: (8)                    for key, value in kwargs.items():
269: (12)                       if key in self.config:
270: (16)                           self.setConfig(key, value)
271: (12)                       else:
272: (16)                           # manually set unknown keywords.
273: (16)                           if isinstance(value, str):
274: (20)                               try:
275: (24)                                   # Attempt to parse `str` as a boolean value
276: (24)                                   value = parseBoolValue(value, preserve_none=True)
277: (20)                               except ValueError:
278: (24)                                   pass  # Assume it's not a boolean value. Use as-is.
279: (16)                           self.config[key] = [value, '']
280: (4)                def extendMarkdown(self, md):
281: (8)                    """ Add `HilitePostprocessor` to Markdown instance. """
282: (8)                    hiliter = HiliteTreeprocessor(md)
283: (8)                    hiliter.config = self.getConfigs()
284: (8)                    md.treeprocessors.register(hiliter, 'hilite', 30)
285: (8)                    md.registerExtension(self)
286: (0)            def makeExtension(**kwargs):  # pragma: no cover
287: (4)                return CodeHiliteExtension(**kwargs)

----------------------------------------

File 20 - .\extensions \def_list.py:

1: (0)              # Definition List Extension for Python-Markdown
2: (0)              # =============================================
3: (0)              # Adds parsing of Definition Lists to Python-Markdown.
4: (0)              # See https://Python-Markdown.github.io/extensions/definition_lists
5: (0)              # for documentation.
6: (0)              # Original code Copyright 2008 [Waylan Limberg](http://achinghead.com)
7: (0)              # All changes Copyright 2008-2014 The Python Markdown Project
8: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
9: (0)              """
10: (0)             Adds parsing of Definition Lists to Python-Markdown.
11: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/definition_lists)
12: (0)             for details.
13: (0)             """
14: (0)             from __future__ import annotations
15: (0)             from . import Extension
16: (0)             from ..blockprocessors import BlockProcessor, ListIndentProcessor
17: (0)             import xml.etree.ElementTree as etree
18: (0)             import re
19: (0)             class DefListProcessor(BlockProcessor):
20: (4)                 """ Process Definition Lists. """
21: (4)                 RE = re.compile(r'(^|\n)[ ]{0,3}:[ ]{1,3}(.*?)(\n|$)')
22: (4)                 NO_INDENT_RE = re.compile(r'^[ ]{0,3}[^ :]')
23: (4)                 def test(self, parent: etree.Element, block: str) -> bool:
24: (8)                     return bool(self.RE.search(block))
25: (4)                 def run(self, parent: etree.Element, blocks: list[str]) -> bool | None:
26: (8)                     raw_block = blocks.pop(0)
27: (8)                     m = self.RE.search(raw_block)
28: (8)                     terms = [term.strip() for term in
29: (17)                             raw_block[:m.start()].split('\n') if term.strip()]
30: (8)                     block = raw_block[m.end():]
31: (8)                     no_indent = self.NO_INDENT_RE.match(block)
32: (8)                     if no_indent:
33: (12)                        d, theRest = (block, None)
34: (8)                     else:
35: (12)                        d, theRest = self.detab(block)
36: (8)                     if d:
37: (12)                        d = '{}\n{}'.format(m.group(2), d)
38: (8)                     else:
39: (12)                        d = m.group(2)
40: (8)                     sibling = self.lastChild(parent)
41: (8)                     if not terms and sibling is None:
42: (12)                        # This is not a definition item. Most likely a paragraph that
43: (12)                        # starts with a colon at the beginning of a document or list.
44: (12)                        blocks.insert(0, raw_block)
45: (12)                        return False
46: (8)                     if not terms and sibling.tag == 'p':
47: (12)                        # The previous paragraph contains the terms
48: (12)                        state = 'looselist'
49: (12)                        terms = sibling.text.split('\n')
50: (12)                        parent.remove(sibling)
51: (12)                        # Acquire new sibling
52: (12)                        sibling = self.lastChild(parent)
53: (8)                     else:
54: (12)                        state = 'list'
55: (8)                     if sibling is not None and sibling.tag == 'dl':
56: (12)                        # This is another item on an existing list
57: (12)                        dl = sibling
58: (12)                        if not terms and len(dl) and dl[-1].tag == 'dd' and len(dl[-1]):
59: (16)                            state = 'looselist'
60: (8)                     else:
61: (12)                        # This is a new list
62: (12)                        dl = etree.SubElement(parent, 'dl')
63: (8)                     # Add terms
64: (8)                     for term in terms:
65: (12)                        dt = etree.SubElement(dl, 'dt')
66: (12)                        dt.text = term
67: (8)                     # Add definition
68: (8)                     self.parser.state.set(state)
69: (8)                     dd = etree.SubElement(dl, 'dd')
70: (8)                     self.parser.parseBlocks(dd, [d])
71: (8)                     self.parser.state.reset()
72: (8)                     if theRest:
73: (12)                        blocks.insert(0, theRest)
74: (0)             class DefListIndentProcessor(ListIndentProcessor):
75: (4)                 """ Process indented children of definition list items. """
76: (4)                 # Definition lists need to be aware of all list types
77: (4)                 ITEM_TYPES = ['dd', 'li']
78: (4)                 """ Include `dd` in list item types. """
79: (4)                 LIST_TYPES = ['dl', 'ol', 'ul']
80: (4)                 """ Include `dl` is list types. """
81: (4)                 def create_item(self, parent: etree.Element, block: str) -> None:
82: (8)                     """ Create a new `dd` or `li` (depending on parent) and parse the block with it as the parent. """
83: (8)                     dd = etree.SubElement(parent, 'dd')
84: (8)                     self.parser.parseBlocks(dd, [block])
85: (0)             class DefListExtension(Extension):
86: (4)                 """ Add definition lists to Markdown. """
87: (4)                 def extendMarkdown(self, md):
88: (8)                     """ Add an instance of `DefListProcessor` to `BlockParser`. """
89: (8)                     md.parser.blockprocessors.register(DefListIndentProcessor(md.parser), 'defindent', 85)
90: (8)                     md.parser.blockprocessors.register(DefListProcessor(md.parser), 'deflist', 25)
91: (0)             def makeExtension(**kwargs):  # pragma: no cover
92: (4)                 return DefListExtension(**kwargs)

----------------------------------------

File 21 - .\extensions \extra.py:

1: (0)              # Python-Markdown Extra Extension
2: (0)              # ===============================
3: (0)              # A compilation of various Python-Markdown extensions that imitates
4: (0)              # [PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/).
5: (0)              # See https://Python-Markdown.github.io/extensions/extra
6: (0)              # for documentation.
7: (0)              # Copyright The Python Markdown Project
8: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
9: (0)              """
10: (0)             A compilation of various Python-Markdown extensions that imitates
11: (0)             [PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/).
12: (0)             Note that each of the individual extensions still need to be available
13: (0)             on your `PYTHONPATH`. This extension simply wraps them all up as a
14: (0)             convenience so that only one extension needs to be listed when
15: (0)             initiating Markdown. See the documentation for each individual
16: (0)             extension for specifics about that extension.
17: (0)             There may be additional extensions that are distributed with
18: (0)             Python-Markdown that are not included here in Extra. Those extensions
19: (0)             are not part of PHP Markdown Extra, and therefore, not part of
20: (0)             Python-Markdown Extra. If you really would like Extra to include
21: (0)             additional extensions, we suggest creating your own clone of Extra
22: (0)             under a different name. You could also edit the `extensions` global
23: (0)             variable defined below, but be aware that such changes may be lost
24: (0)             when you upgrade to any future version of Python-Markdown.
25: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/extra)
26: (0)             for details.
27: (0)             """
28: (0)             from __future__ import annotations
29: (0)             from . import Extension
30: (0)             extensions = [
31: (4)                 'fenced_code',
32: (4)                 'footnotes',
33: (4)                 'attr_list',
34: (4)                 'def_list',
35: (4)                 'tables',
36: (4)                 'abbr',
37: (4)                 'md_in_html'
38: (0)             ]
39: (0)             """ The list of included extensions. """
40: (0)             class ExtraExtension(Extension):
41: (4)                 """ Add various extensions to Markdown class."""
42: (4)                 def __init__(self, **kwargs):
43: (8)                     """ `config` is a dumb holder which gets passed to the actual extension later. """
44: (8)                     self.config = kwargs
45: (4)                 def extendMarkdown(self, md):
46: (8)                     """ Register extension instances. """
47: (8)                     md.registerExtensions(extensions, self.config)
48: (0)             def makeExtension(**kwargs):  # pragma: no cover
49: (4)                 return ExtraExtension(**kwargs)

----------------------------------------

File 22 - .\extensions \fenced_code.py:

1: (0)              # Fenced Code Extension for Python Markdown
2: (0)              # =========================================
3: (0)              # This extension adds Fenced Code Blocks to Python-Markdown.
4: (0)              # See https://Python-Markdown.github.io/extensions/fenced_code_blocks
5: (0)              # for documentation.
6: (0)              # Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).
7: (0)              # All changes Copyright 2008-2014 The Python Markdown Project
8: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
9: (0)              """
10: (0)             This extension adds Fenced Code Blocks to Python-Markdown.
11: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/fenced_code_blocks)
12: (0)             for details.
13: (0)             """
14: (0)             from __future__ import annotations
15: (0)             from textwrap import dedent
16: (0)             from . import Extension
17: (0)             from ..preprocessors import Preprocessor
18: (0)             from .codehilite import CodeHilite, CodeHiliteExtension, parse_hl_lines
19: (0)             from .attr_list import get_attrs_and_remainder, AttrListExtension
20: (0)             from ..util import parseBoolValue
21: (0)             from ..serializers import _escape_attrib_html
22: (0)             import re
23: (0)             from typing import TYPE_CHECKING, Any, Iterable
24: (0)             if TYPE_CHECKING:  # pragma: no cover
25: (4)                 from markdown import Markdown
26: (0)             class FencedCodeExtension(Extension):
27: (4)                 def __init__(self, **kwargs):
28: (8)                     self.config = {
29: (12)                        'lang_prefix': ['language-', 'Prefix prepended to the language. Default: "language-"']
30: (8)                     }
31: (8)                     """ Default configuration options. """
32: (8)                     super().__init__(**kwargs)
33: (4)                 def extendMarkdown(self, md):
34: (8)                     """ Add `FencedBlockPreprocessor` to the Markdown instance. """
35: (8)                     md.registerExtension(self)
36: (8)                     md.preprocessors.register(FencedBlockPreprocessor(md, self.getConfigs()), 'fenced_code_block', 25)
37: (0)             class FencedBlockPreprocessor(Preprocessor):
38: (4)                 """ Find and extract fenced code blocks. """
39: (4)                 FENCED_BLOCK_RE = re.compile(
40: (8)                     dedent(r'''
41: (12)                        (?P<fence>^(?:~{3,}|`{3,}))[ ]*                          # opening fence
42: (12)                        ((\{(?P<attrs>[^\n]*)\})|                                # (optional {attrs} or
43: (12)                        (\.?(?P<lang>[\w#.+-]*)[ ]*)?                            # optional (.)lang
44: (12)                        (hl_lines=(?P<quot>"|')(?P<hl_lines>.*?)(?P=quot)[ ]*)?) # optional hl_lines)
45: (12)                        \n                                                       # newline (end of opening fence)
46: (12)                        (?P<code>.*?)(?<=\n)                                     # the code block
47: (12)                        (?P=fence)[ ]*$                                          # closing fence
48: (8)                     '''),
49: (8)                     re.MULTILINE | re.DOTALL | re.VERBOSE
50: (4)                 )
51: (4)                 def __init__(self, md: Markdown, config: dict[str, Any]):
52: (8)                     super().__init__(md)
53: (8)                     self.config = config
54: (8)                     self.checked_for_deps = False
55: (8)                     self.codehilite_conf: dict[str, Any] = {}
56: (8)                     self.use_attr_list = False
57: (8)                     # List of options to convert to boolean values
58: (8)                     self.bool_options = [
59: (12)                        'linenums',
60: (12)                        'guess_lang',
61: (12)                        'noclasses',
62: (12)                        'use_pygments'
63: (8)                     ]
64: (4)                 def run(self, lines: list[str]) -> list[str]:
65: (8)                     """ Match and store Fenced Code Blocks in the `HtmlStash`. """
66: (8)                     # Check for dependent extensions
67: (8)                     if not self.checked_for_deps:
68: (12)                        for ext in self.md.registeredExtensions:
69: (16)                            if isinstance(ext, CodeHiliteExtension):
70: (20)                                self.codehilite_conf = ext.getConfigs()
71: (16)                            if isinstance(ext, AttrListExtension):
72: (20)                                self.use_attr_list = True
73: (12)                        self.checked_for_deps = True
74: (8)                     text = "\n".join(lines)
75: (8)                     index = 0
76: (8)                     while 1:
77: (12)                        m = self.FENCED_BLOCK_RE.search(text, index)
78: (12)                        if m:
79: (16)                            lang, id, classes, config = None, '', [], {}
80: (16)                            if m.group('attrs'):
81: (20)                                attrs, remainder = get_attrs_and_remainder(m.group('attrs'))
82: (20)                                if remainder:  # Does not have correctly matching curly braces, so the syntax is invalid.
83: (24)                                    index = m.end('attrs')  # Explicitly skip over this, to prevent an infinite loop.
84: (24)                                    continue
85: (20)                                id, classes, config = self.handle_attrs(attrs)
86: (20)                                if len(classes):
87: (24)                                    lang = classes.pop(0)
88: (16)                            else:
89: (20)                                if m.group('lang'):
90: (24)                                    lang = m.group('lang')
91: (20)                                if m.group('hl_lines'):
92: (24)                                    # Support `hl_lines` outside of `attrs` for backward-compatibility
93: (24)                                    config['hl_lines'] = parse_hl_lines(m.group('hl_lines'))
94: (16)                            # If `config` is not empty, then the `codehighlite` extension
95: (16)                            # is enabled, so we call it to highlight the code
96: (16)                            if self.codehilite_conf and self.codehilite_conf['use_pygments'] and config.get('use_pygments', True):
97: (20)                                local_config = self.codehilite_conf.copy()
98: (20)                                local_config.update(config)
99: (20)                                # Combine classes with `cssclass`. Ensure `cssclass` is at end
100: (20)                               # as Pygments appends a suffix under certain circumstances.
101: (20)                               # Ignore ID as Pygments does not offer an option to set it.
102: (20)                               if classes:
103: (24)                                   local_config['css_class'] = '{} {}'.format(
104: (28)                                       ' '.join(classes),
105: (28)                                       local_config['css_class']
106: (24)                                   )
107: (20)                               highliter = CodeHilite(
108: (24)                                   m.group('code'),
109: (24)                                   lang=lang,
110: (24)                                   style=local_config.pop('pygments_style', 'default'),
111: (24)                                   **local_config
112: (20)                               )
113: (20)                               code = highliter.hilite(shebang=False)
114: (16)                           else:
115: (20)                               id_attr = lang_attr = class_attr = kv_pairs = ''
116: (20)                               if lang:
117: (24)                                   prefix = self.config.get('lang_prefix', 'language-')
118: (24)                                   lang_attr = f' class="{prefix}{_escape_attrib_html(lang)}"'
119: (20)                               if classes:
120: (24)                                   class_attr = f' class="{_escape_attrib_html(" ".join(classes))}"'
121: (20)                               if id:
122: (24)                                   id_attr = f' id="{_escape_attrib_html(id)}"'
123: (20)                               if self.use_attr_list and config and not config.get('use_pygments', False):
124: (24)                                   # Only assign key/value pairs to code element if `attr_list` extension is enabled, key/value
125: (24)                                   # pairs were defined on the code block, and the `use_pygments` key was not set to `True`. The
126: (24)                                   # `use_pygments` key could be either set to `False` or not defined. It is omitted from output.
127: (24)                                   kv_pairs = ''.join(
128: (28)                                       f' {k}="{_escape_attrib_html(v)}"' for k, v in config.items() if k != 'use_pygments'
129: (24)                                   )
130: (20)                               code = self._escape(m.group('code'))
131: (20)                               code = f'<pre{id_attr}{class_attr}><code{lang_attr}{kv_pairs}>{code}</code></pre>'
132: (16)                           placeholder = self.md.htmlStash.store(code)
133: (16)                           text = f'{text[:m.start()]}\n{placeholder}\n{text[m.end():]}'
134: (16)                           # Continue from after the replaced text in the next iteration.
135: (16)                           index = m.start() + 1 + len(placeholder)
136: (12)                       else:
137: (16)                           break
138: (8)                    return text.split("\n")
139: (4)                def handle_attrs(self, attrs: Iterable[tuple[str, str]]) -> tuple[str, list[str], dict[str, Any]]:
140: (8)                    """ Return tuple: `(id, [list, of, classes], {configs})` """
141: (8)                    id = ''
142: (8)                    classes = []
143: (8)                    configs = {}
144: (8)                    for k, v in attrs:
145: (12)                       if k == 'id':
146: (16)                           id = v
147: (12)                       elif k == '.':
148: (16)                           classes.append(v)
149: (12)                       elif k == 'hl_lines':
150: (16)                           configs[k] = parse_hl_lines(v)
151: (12)                       elif k in self.bool_options:
152: (16)                           configs[k] = parseBoolValue(v, fail_on_errors=False, preserve_none=True)
153: (12)                       else:
154: (16)                           configs[k] = v
155: (8)                    return id, classes, configs
156: (4)                def _escape(self, txt: str) -> str:
157: (8)                    """ basic html escaping """
158: (8)                    txt = txt.replace('&', '&amp;')
159: (8)                    txt = txt.replace('<', '&lt;')
160: (8)                    txt = txt.replace('>', '&gt;')
161: (8)                    txt = txt.replace('"', '&quot;')
162: (8)                    return txt
163: (0)            def makeExtension(**kwargs):  # pragma: no cover
164: (4)                return FencedCodeExtension(**kwargs)

----------------------------------------

File 23 - .\extensions \footnotes.py:

1: (0)              # Footnotes Extension for Python-Markdown
2: (0)              # =======================================
3: (0)              # Adds footnote handling to Python-Markdown.
4: (0)              # See https://Python-Markdown.github.io/extensions/footnotes
5: (0)              # for documentation.
6: (0)              # Copyright The Python Markdown Project
7: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
8: (0)              """
9: (0)              Adds footnote handling to Python-Markdown.
10: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/footnotes)
11: (0)             for details.
12: (0)             """
13: (0)             from __future__ import annotations
14: (0)             from . import Extension
15: (0)             from ..blockprocessors import BlockProcessor
16: (0)             from ..inlinepatterns import InlineProcessor
17: (0)             from ..treeprocessors import Treeprocessor
18: (0)             from ..postprocessors import Postprocessor
19: (0)             from .. import util
20: (0)             from collections import OrderedDict
21: (0)             import re
22: (0)             import copy
23: (0)             import xml.etree.ElementTree as etree
24: (0)             FN_BACKLINK_TEXT = util.STX + "zz1337820767766393qq" + util.ETX
25: (0)             NBSP_PLACEHOLDER = util.STX + "qq3936677670287331zz" + util.ETX
26: (0)             RE_REF_ID = re.compile(r'(fnref)(\d+)')
27: (0)             class FootnoteExtension(Extension):
28: (4)                 """ Footnote Extension. """
29: (4)                 def __init__(self, **kwargs):
30: (8)                     """ Setup configs. """
31: (8)                     self.config = {
32: (12)                        'PLACE_MARKER': [
33: (16)                            '///Footnotes Go Here///', 'The text string that marks where the footnotes go'
34: (12)                        ],
35: (12)                        'UNIQUE_IDS': [
36: (16)                            False, 'Avoid name collisions across multiple calls to `reset()`.'
37: (12)                        ],
38: (12)                        'BACKLINK_TEXT': [
39: (16)                            '&#8617;', "The text string that links from the footnote to the reader's place."
40: (12)                        ],
41: (12)                        'SUPERSCRIPT_TEXT': [
42: (16)                            '{}', "The text string that links from the reader's place to the footnote."
43: (12)                        ],
44: (12)                        'BACKLINK_TITLE': [
45: (16)                            'Jump back to footnote %d in the text',
46: (16)                            'The text string used for the title HTML attribute of the backlink. '
47: (16)                            '%d will be replaced by the footnote number.'
48: (12)                        ],
49: (12)                        'SEPARATOR': [
50: (16)                            ':', 'Footnote separator.'
51: (12)                        ]
52: (8)                     }
53: (8)                     """ Default configuration options. """
54: (8)                     super().__init__(**kwargs)
55: (8)                     # In multiple invocations, emit links that don't get tangled.
56: (8)                     self.unique_prefix = 0
57: (8)                     self.found_refs: dict[str, int] = {}
58: (8)                     self.used_refs: set[str] = set()
59: (8)                     self.reset()
60: (4)                 def extendMarkdown(self, md):
61: (8)                     """ Add pieces to Markdown. """
62: (8)                     md.registerExtension(self)
63: (8)                     self.parser = md.parser
64: (8)                     self.md = md
65: (8)                     # Insert a `blockprocessor` before `ReferencePreprocessor`
66: (8)                     md.parser.blockprocessors.register(FootnoteBlockProcessor(self), 'footnote', 17)
67: (8)                     # Insert an inline pattern before `ImageReferencePattern`
68: (8)                     FOOTNOTE_RE = r'\[\^([^\]]*)\]'  # blah blah [^1] blah
69: (8)                     md.inlinePatterns.register(FootnoteInlineProcessor(FOOTNOTE_RE, self), 'footnote', 175)
70: (8)                     # Insert a tree-processor that would actually add the footnote div
71: (8)                     # This must be before all other tree-processors (i.e., `inline` and
72: (8)                     # `codehilite`) so they can run on the the contents of the div.
73: (8)                     md.treeprocessors.register(FootnoteTreeprocessor(self), 'footnote', 50)
74: (8)                     # Insert a tree-processor that will run after inline is done.
75: (8)                     # In this tree-processor we want to check our duplicate footnote tracker
76: (8)                     # And add additional `backrefs` to the footnote pointing back to the
77: (8)                     # duplicated references.
78: (8)                     md.treeprocessors.register(FootnotePostTreeprocessor(self), 'footnote-duplicate', 15)
79: (8)                     # Insert a postprocessor after amp_substitute processor
80: (8)                     md.postprocessors.register(FootnotePostprocessor(self), 'footnote', 25)
81: (4)                 def reset(self) -> None:
82: (8)                     """ Clear footnotes on reset, and prepare for distinct document. """
83: (8)                     self.footnotes: OrderedDict[str, str] = OrderedDict()
84: (8)                     self.unique_prefix += 1
85: (8)                     self.found_refs = {}
86: (8)                     self.used_refs = set()
87: (4)                 def unique_ref(self, reference: str, found: bool = False) -> str:
88: (8)                     """ Get a unique reference if there are duplicates. """
89: (8)                     if not found:
90: (12)                        return reference
91: (8)                     original_ref = reference
92: (8)                     while reference in self.used_refs:
93: (12)                        ref, rest = reference.split(self.get_separator(), 1)
94: (12)                        m = RE_REF_ID.match(ref)
95: (12)                        if m:
96: (16)                            reference = '%s%d%s%s' % (m.group(1), int(m.group(2))+1, self.get_separator(), rest)
97: (12)                        else:
98: (16)                            reference = '%s%d%s%s' % (ref, 2, self.get_separator(), rest)
99: (8)                     self.used_refs.add(reference)
100: (8)                    if original_ref in self.found_refs:
101: (12)                       self.found_refs[original_ref] += 1
102: (8)                    else:
103: (12)                       self.found_refs[original_ref] = 1
104: (8)                    return reference
105: (4)                def findFootnotesPlaceholder(
106: (8)                    self, root: etree.Element
107: (4)                ) -> tuple[etree.Element, etree.Element, bool] | None:
108: (8)                    """ Return ElementTree Element that contains Footnote placeholder. """
109: (8)                    def finder(element):
110: (12)                       for child in element:
111: (16)                           if child.text:
112: (20)                               if child.text.find(self.getConfig("PLACE_MARKER")) > -1:
113: (24)                                   return child, element, True
114: (16)                           if child.tail:
115: (20)                               if child.tail.find(self.getConfig("PLACE_MARKER")) > -1:
116: (24)                                   return child, element, False
117: (16)                           child_res = finder(child)
118: (16)                           if child_res is not None:
119: (20)                               return child_res
120: (12)                       return None
121: (8)                    res = finder(root)
122: (8)                    return res
123: (4)                def setFootnote(self, id: str, text: str) -> None:
124: (8)                    """ Store a footnote for later retrieval. """
125: (8)                    self.footnotes[id] = text
126: (4)                def get_separator(self) -> str:
127: (8)                    """ Get the footnote separator. """
128: (8)                    return self.getConfig("SEPARATOR")
129: (4)                def makeFootnoteId(self, id: str) -> str:
130: (8)                    """ Return footnote link id. """
131: (8)                    if self.getConfig("UNIQUE_IDS"):
132: (12)                       return 'fn%s%d-%s' % (self.get_separator(), self.unique_prefix, id)
133: (8)                    else:
134: (12)                       return 'fn{}{}'.format(self.get_separator(), id)
135: (4)                def makeFootnoteRefId(self, id: str, found: bool = False) -> str:
136: (8)                    """ Return footnote back-link id. """
137: (8)                    if self.getConfig("UNIQUE_IDS"):
138: (12)                       return self.unique_ref('fnref%s%d-%s' % (self.get_separator(), self.unique_prefix, id), found)
139: (8)                    else:
140: (12)                       return self.unique_ref('fnref{}{}'.format(self.get_separator(), id), found)
141: (4)                def makeFootnotesDiv(self, root: etree.Element) -> etree.Element | None:
142: (8)                    """ Return `div` of footnotes as `etree` Element. """
143: (8)                    if not list(self.footnotes.keys()):
144: (12)                       return None
145: (8)                    div = etree.Element("div")
146: (8)                    div.set('class', 'footnote')
147: (8)                    etree.SubElement(div, "hr")
148: (8)                    ol = etree.SubElement(div, "ol")
149: (8)                    surrogate_parent = etree.Element("div")
150: (8)                    # Backward compatibility with old '%d' placeholder
151: (8)                    backlink_title = self.getConfig("BACKLINK_TITLE").replace("%d", "{}")
152: (8)                    for index, id in enumerate(self.footnotes.keys(), start=1):
153: (12)                       li = etree.SubElement(ol, "li")
154: (12)                       li.set("id", self.makeFootnoteId(id))
155: (12)                       # Parse footnote with surrogate parent as `li` cannot be used.
156: (12)                       # List block handlers have special logic to deal with `li`.
157: (12)                       # When we are done parsing, we will copy everything over to `li`.
158: (12)                       self.parser.parseChunk(surrogate_parent, self.footnotes[id])
159: (12)                       for el in list(surrogate_parent):
160: (16)                           li.append(el)
161: (16)                           surrogate_parent.remove(el)
162: (12)                       backlink = etree.Element("a")
163: (12)                       backlink.set("href", "#" + self.makeFootnoteRefId(id))
164: (12)                       backlink.set("class", "footnote-backref")
165: (12)                       backlink.set(
166: (16)                           "title",
167: (16)                           backlink_title.format(index)
168: (12)                       )
169: (12)                       backlink.text = FN_BACKLINK_TEXT
170: (12)                       if len(li):
171: (16)                           node = li[-1]
172: (16)                           if node.tag == "p":
173: (20)                               node.text = node.text + NBSP_PLACEHOLDER
174: (20)                               node.append(backlink)
175: (16)                           else:
176: (20)                               p = etree.SubElement(li, "p")
177: (20)                               p.append(backlink)
178: (8)                    return div
179: (0)            class FootnoteBlockProcessor(BlockProcessor):
180: (4)                """ Find all footnote references and store for later use. """
181: (4)                RE = re.compile(r'^[ ]{0,3}\[\^([^\]]*)\]:[ ]*(.*)$', re.MULTILINE)
182: (4)                def __init__(self, footnotes: FootnoteExtension):
183: (8)                    super().__init__(footnotes.parser)
184: (8)                    self.footnotes = footnotes
185: (4)                def test(self, parent: etree.Element, block: str) -> bool:
186: (8)                    return True
187: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> bool:
188: (8)                    """ Find, set, and remove footnote definitions. """
189: (8)                    block = blocks.pop(0)
190: (8)                    m = self.RE.search(block)
191: (8)                    if m:
192: (12)                       id = m.group(1)
193: (12)                       fn_blocks = [m.group(2)]
194: (12)                       # Handle rest of block
195: (12)                       therest = block[m.end():].lstrip('\n')
196: (12)                       m2 = self.RE.search(therest)
197: (12)                       if m2:
198: (16)                           # Another footnote exists in the rest of this block.
199: (16)                           # Any content before match is continuation of this footnote, which may be lazily indented.
200: (16)                           before = therest[:m2.start()].rstrip('\n')
201: (16)                           fn_blocks[0] = '\n'.join([fn_blocks[0], self.detab(before)]).lstrip('\n')
202: (16)                           # Add back to blocks everything from beginning of match forward for next iteration.
203: (16)                           blocks.insert(0, therest[m2.start():])
204: (12)                       else:
205: (16)                           # All remaining lines of block are continuation of this footnote, which may be lazily indented.
206: (16)                           fn_blocks[0] = '\n'.join([fn_blocks[0], self.detab(therest)]).strip('\n')
207: (16)                           # Check for child elements in remaining blocks.
208: (16)                           fn_blocks.extend(self.detectTabbed(blocks))
209: (12)                       footnote = "\n\n".join(fn_blocks)
210: (12)                       self.footnotes.setFootnote(id, footnote.rstrip())
211: (12)                       if block[:m.start()].strip():
212: (16)                           # Add any content before match back to blocks as separate block
213: (16)                           blocks.insert(0, block[:m.start()].rstrip('\n'))
214: (12)                       return True
215: (8)                    # No match. Restore block.
216: (8)                    blocks.insert(0, block)
217: (8)                    return False
218: (4)                def detectTabbed(self, blocks: list[str]) -> list[str]:
219: (8)                    """ Find indented text and remove indent before further processing.
220: (8)                    Returns:
221: (12)                       A list of blocks with indentation removed.
222: (8)                    """
223: (8)                    fn_blocks = []
224: (8)                    while blocks:
225: (12)                       if blocks[0].startswith(' '*4):
226: (16)                           block = blocks.pop(0)
227: (16)                           # Check for new footnotes within this block and split at new footnote.
228: (16)                           m = self.RE.search(block)
229: (16)                           if m:
230: (20)                               # Another footnote exists in this block.
231: (20)                               # Any content before match is continuation of this footnote, which may be lazily indented.
232: (20)                               before = block[:m.start()].rstrip('\n')
233: (20)                               fn_blocks.append(self.detab(before))
234: (20)                               # Add back to blocks everything from beginning of match forward for next iteration.
235: (20)                               blocks.insert(0, block[m.start():])
236: (20)                               # End of this footnote.
237: (20)                               break
238: (16)                           else:
239: (20)                               # Entire block is part of this footnote.
240: (20)                               fn_blocks.append(self.detab(block))
241: (12)                       else:
242: (16)                           # End of this footnote.
243: (16)                           break
244: (8)                    return fn_blocks
245: (4)                def detab(self, block: str) -> str:
246: (8)                    """ Remove one level of indent from a block.
247: (8)                    Preserve lazily indented blocks by only removing indent from indented lines.
248: (8)                    """
249: (8)                    lines = block.split('\n')
250: (8)                    for i, line in enumerate(lines):
251: (12)                       if line.startswith(' '*4):
252: (16)                           lines[i] = line[4:]
253: (8)                    return '\n'.join(lines)
254: (0)            class FootnoteInlineProcessor(InlineProcessor):
255: (4)                """ `InlineProcessor` for footnote markers in a document's body text. """
256: (4)                def __init__(self, pattern: str, footnotes: FootnoteExtension):
257: (8)                    super().__init__(pattern)
258: (8)                    self.footnotes = footnotes
259: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:
260: (8)                    id = m.group(1)
261: (8)                    if id in self.footnotes.footnotes.keys():
262: (12)                       sup = etree.Element("sup")
263: (12)                       a = etree.SubElement(sup, "a")
264: (12)                       sup.set('id', self.footnotes.makeFootnoteRefId(id, found=True))
265: (12)                       a.set('href', '#' + self.footnotes.makeFootnoteId(id))
266: (12)                       a.set('class', 'footnote-ref')
267: (12)                       a.text = self.footnotes.getConfig("SUPERSCRIPT_TEXT").format(
268: (16)                           list(self.footnotes.footnotes.keys()).index(id) + 1
269: (12)                       )
270: (12)                       return sup, m.start(0), m.end(0)
271: (8)                    else:
272: (12)                       return None, None, None
273: (0)            class FootnotePostTreeprocessor(Treeprocessor):
274: (4)                """ Amend footnote div with duplicates. """
275: (4)                def __init__(self, footnotes: FootnoteExtension):
276: (8)                    self.footnotes = footnotes
277: (4)                def add_duplicates(self, li: etree.Element, duplicates: int) -> None:
278: (8)                    """ Adjust current `li` and add the duplicates: `fnref2`, `fnref3`, etc. """
279: (8)                    for link in li.iter('a'):
280: (12)                       # Find the link that needs to be duplicated.
281: (12)                       if link.attrib.get('class', '') == 'footnote-backref':
282: (16)                           ref, rest = link.attrib['href'].split(self.footnotes.get_separator(), 1)
283: (16)                           # Duplicate link the number of times we need to
284: (16)                           # and point the to the appropriate references.
285: (16)                           links = []
286: (16)                           for index in range(2, duplicates + 1):
287: (20)                               sib_link = copy.deepcopy(link)
288: (20)                               sib_link.attrib['href'] = '%s%d%s%s' % (ref, index, self.footnotes.get_separator(), rest)
289: (20)                               links.append(sib_link)
290: (20)                               self.offset += 1
291: (16)                           # Add all the new duplicate links.
292: (16)                           el = list(li)[-1]
293: (16)                           for link in links:
294: (20)                               el.append(link)
295: (16)                           break
296: (4)                def get_num_duplicates(self, li: etree.Element) -> int:
297: (8)                    """ Get the number of duplicate refs of the footnote. """
298: (8)                    fn, rest = li.attrib.get('id', '').split(self.footnotes.get_separator(), 1)
299: (8)                    link_id = '{}ref{}{}'.format(fn, self.footnotes.get_separator(), rest)
300: (8)                    return self.footnotes.found_refs.get(link_id, 0)
301: (4)                def handle_duplicates(self, parent: etree.Element) -> None:
302: (8)                    """ Find duplicate footnotes and format and add the duplicates. """
303: (8)                    for li in list(parent):
304: (12)                       # Check number of duplicates footnotes and insert
305: (12)                       # additional links if needed.
306: (12)                       count = self.get_num_duplicates(li)
307: (12)                       if count > 1:
308: (16)                           self.add_duplicates(li, count)
309: (4)                def run(self, root: etree.Element) -> None:
310: (8)                    """ Crawl the footnote div and add missing duplicate footnotes. """
311: (8)                    self.offset = 0
312: (8)                    for div in root.iter('div'):
313: (12)                       if div.attrib.get('class', '') == 'footnote':
314: (16)                           # Footnotes should be under the first ordered list under
315: (16)                           # the footnote div.  So once we find it, quit.
316: (16)                           for ol in div.iter('ol'):
317: (20)                               self.handle_duplicates(ol)
318: (20)                               break
319: (0)            class FootnoteTreeprocessor(Treeprocessor):
320: (4)                """ Build and append footnote div to end of document. """
321: (4)                def __init__(self, footnotes: FootnoteExtension):
322: (8)                    self.footnotes = footnotes
323: (4)                def run(self, root: etree.Element) -> None:
324: (8)                    footnotesDiv = self.footnotes.makeFootnotesDiv(root)
325: (8)                    if footnotesDiv is not None:
326: (12)                       result = self.footnotes.findFootnotesPlaceholder(root)
327: (12)                       if result:
328: (16)                           child, parent, isText = result
329: (16)                           ind = list(parent).index(child)
330: (16)                           if isText:
331: (20)                               parent.remove(child)
332: (20)                               parent.insert(ind, footnotesDiv)
333: (16)                           else:
334: (20)                               parent.insert(ind + 1, footnotesDiv)
335: (20)                               child.tail = None
336: (12)                       else:
337: (16)                           root.append(footnotesDiv)
338: (0)            class FootnotePostprocessor(Postprocessor):
339: (4)                """ Replace placeholders with html entities. """
340: (4)                def __init__(self, footnotes: FootnoteExtension):
341: (8)                    self.footnotes = footnotes
342: (4)                def run(self, text: str) -> str:
343: (8)                    text = text.replace(
344: (12)                       FN_BACKLINK_TEXT, self.footnotes.getConfig("BACKLINK_TEXT")
345: (8)                    )
346: (8)                    return text.replace(NBSP_PLACEHOLDER, "&#160;")
347: (0)            def makeExtension(**kwargs):  # pragma: no cover
348: (4)                """ Return an instance of the `FootnoteExtension` """
349: (4)                return FootnoteExtension(**kwargs)

----------------------------------------

File 24 - .\extensions \legacy_attrs.py:

1: (0)              # Python Markdown
2: (0)              # A Python implementation of John Gruber's Markdown.
3: (0)              # Documentation: https://python-markdown.github.io/
4: (0)              # GitHub: https://github.com/Python-Markdown/markdown/
5: (0)              # PyPI: https://pypi.org/project/Markdown/
6: (0)              # Started by Manfred Stienstra (http://www.dwerg.net/).
7: (0)              # Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).
8: (0)              # Currently maintained by Waylan Limberg (https://github.com/waylan),
9: (0)              # Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).
10: (0)             # Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)
11: (0)             # Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)
12: (0)             # Copyright 2004 Manfred Stienstra (the original version)
13: (0)             # License: BSD (see LICENSE.md for details).
14: (0)             """
15: (0)             An extension to Python Markdown which implements legacy attributes.
16: (0)             Prior to Python-Markdown version 3.0, the Markdown class had an `enable_attributes`
17: (0)             keyword which was on by default and provided for attributes to be defined for elements
18: (0)             using the format `{@key=value}`. This extension is provided as a replacement for
19: (0)             backward compatibility. New documents should be authored using `attr_lists`. However,
20: (0)             numerous documents exist which have been using the old attribute format for many
21: (0)             years. This extension can be used to continue to render those documents correctly.
22: (0)             """
23: (0)             from __future__ import annotations
24: (0)             import re
25: (0)             from markdown.treeprocessors import Treeprocessor, isString
26: (0)             from markdown.extensions import Extension
27: (0)             from typing import TYPE_CHECKING
28: (0)             if TYPE_CHECKING:  # pragma: no cover
29: (4)                 import xml.etree.ElementTree as etree
30: (0)             ATTR_RE = re.compile(r'\{@([^\}]*)=([^\}]*)}')  # {@id=123}
31: (0)             class LegacyAttrs(Treeprocessor):
32: (4)                 def run(self, doc: etree.Element) -> None:
33: (8)                     """Find and set values of attributes ({@key=value}). """
34: (8)                     for el in doc.iter():
35: (12)                        alt = el.get('alt', None)
36: (12)                        if alt is not None:
37: (16)                            el.set('alt', self.handleAttributes(el, alt))
38: (12)                        if el.text and isString(el.text):
39: (16)                            el.text = self.handleAttributes(el, el.text)
40: (12)                        if el.tail and isString(el.tail):
41: (16)                            el.tail = self.handleAttributes(el, el.tail)
42: (4)                 def handleAttributes(self, el: etree.Element, txt: str) -> str:
43: (8)                     """ Set attributes and return text without definitions. """
44: (8)                     def attributeCallback(match: re.Match[str]):
45: (12)                        el.set(match.group(1), match.group(2).replace('\n', ' '))
46: (8)                     return ATTR_RE.sub(attributeCallback, txt)
47: (0)             class LegacyAttrExtension(Extension):
48: (4)                 def extendMarkdown(self, md):
49: (8)                     """ Add `LegacyAttrs` to Markdown instance. """
50: (8)                     md.treeprocessors.register(LegacyAttrs(md), 'legacyattrs', 15)
51: (0)             def makeExtension(**kwargs):  # pragma: no cover
52: (4)                 return LegacyAttrExtension(**kwargs)

----------------------------------------

File 25 - .\extensions \legacy_em.py:

1: (0)              # Legacy Em Extension for Python-Markdown
2: (0)              # =======================================
3: (0)              # This extension provides legacy behavior for _connected_words_.
4: (0)              # Copyright 2015-2018 The Python Markdown Project
5: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
6: (0)              """
7: (0)              This extension provides legacy behavior for _connected_words_.
8: (0)              """
9: (0)              from __future__ import annotations
10: (0)             from . import Extension
11: (0)             from ..inlinepatterns import UnderscoreProcessor, EmStrongItem, EM_STRONG2_RE, STRONG_EM2_RE
12: (0)             import re
13: (0)             # _emphasis_
14: (0)             EMPHASIS_RE = r'(_)([^_]+)\1'
15: (0)             # __strong__
16: (0)             STRONG_RE = r'(_{2})(.+?)\1'
17: (0)             # __strong_em___
18: (0)             STRONG_EM_RE = r'(_)\1(?!\1)([^_]+?)\1(?!\1)(.+?)\1{3}'
19: (0)             class LegacyUnderscoreProcessor(UnderscoreProcessor):
20: (4)                 """Emphasis processor for handling strong and em matches inside underscores."""
21: (4)                 PATTERNS = [
22: (8)                     EmStrongItem(re.compile(EM_STRONG2_RE, re.DOTALL | re.UNICODE), 'double', 'strong,em'),
23: (8)                     EmStrongItem(re.compile(STRONG_EM2_RE, re.DOTALL | re.UNICODE), 'double', 'em,strong'),
24: (8)                     EmStrongItem(re.compile(STRONG_EM_RE, re.DOTALL | re.UNICODE), 'double2', 'strong,em'),
25: (8)                     EmStrongItem(re.compile(STRONG_RE, re.DOTALL | re.UNICODE), 'single', 'strong'),
26: (8)                     EmStrongItem(re.compile(EMPHASIS_RE, re.DOTALL | re.UNICODE), 'single', 'em')
27: (4)                 ]
28: (0)             class LegacyEmExtension(Extension):
29: (4)                 """ Add legacy_em extension to Markdown class."""
30: (4)                 def extendMarkdown(self, md):
31: (8)                     """ Modify inline patterns. """
32: (8)                     md.inlinePatterns.register(LegacyUnderscoreProcessor(r'_'), 'em_strong2', 50)
33: (0)             def makeExtension(**kwargs):  # pragma: no cover
34: (4)                 """ Return an instance of the `LegacyEmExtension` """
35: (4)                 return LegacyEmExtension(**kwargs)

----------------------------------------

File 26 - .\extensions \md_in_html.py:

1: (0)              # Python-Markdown Markdown in HTML Extension
2: (0)              # ===============================
3: (0)              # An implementation of [PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/)'s
4: (0)              # parsing of Markdown syntax in raw HTML.
5: (0)              # See https://Python-Markdown.github.io/extensions/raw_html
6: (0)              # for documentation.
7: (0)              # Copyright The Python Markdown Project
8: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
9: (0)              """
10: (0)             An implementation of [PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/)'s
11: (0)             parsing of Markdown syntax in raw HTML.
12: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/raw_html)
13: (0)             for details.
14: (0)             """
15: (0)             from __future__ import annotations
16: (0)             from . import Extension
17: (0)             from ..blockprocessors import BlockProcessor
18: (0)             from ..preprocessors import Preprocessor
19: (0)             from ..postprocessors import RawHtmlPostprocessor
20: (0)             from .. import util
21: (0)             from ..htmlparser import HTMLExtractor, blank_line_re
22: (0)             import xml.etree.ElementTree as etree
23: (0)             from typing import TYPE_CHECKING, Literal, Mapping
24: (0)             if TYPE_CHECKING:  # pragma: no cover
25: (4)                 from markdown import Markdown
26: (0)             class HTMLExtractorExtra(HTMLExtractor):
27: (4)                 """
28: (4)                 Override `HTMLExtractor` and create `etree` `Elements` for any elements which should have content parsed as
29: (4)                 Markdown.
30: (4)                 """
31: (4)                 def __init__(self, md: Markdown, *args, **kwargs):
32: (8)                     # All block-level tags.
33: (8)                     self.block_level_tags = set(md.block_level_elements.copy())
34: (8)                     # Block-level tags in which the content only gets span level parsing
35: (8)                     self.span_tags = set(
36: (12)                        ['address', 'dd', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'legend', 'li', 'p', 'summary', 'td', 'th']
37: (8)                     )
38: (8)                     # Block-level tags which never get their content parsed.
39: (8)                     self.raw_tags = set(['canvas', 'math', 'option', 'pre', 'script', 'style', 'textarea'])
40: (8)                     super().__init__(md, *args, **kwargs)
41: (8)                     # Block-level tags in which the content gets parsed as blocks
42: (8)                     self.block_tags = set(self.block_level_tags) - (self.span_tags | self.raw_tags | self.empty_tags)
43: (8)                     self.span_and_blocks_tags = self.block_tags | self.span_tags
44: (4)                 def reset(self):
45: (8)                     """Reset this instance.  Loses all unprocessed data."""
46: (8)                     self.mdstack: list[str] = []  # When markdown=1, stack contains a list of tags
47: (8)                     self.treebuilder = etree.TreeBuilder()
48: (8)                     self.mdstate: list[Literal['block', 'span', 'off', None]] = []
49: (8)                     super().reset()
50: (4)                 def close(self):
51: (8)                     """Handle any buffered data."""
52: (8)                     super().close()
53: (8)                     # Handle any unclosed tags.
54: (8)                     if self.mdstack:
55: (12)                        # Close the outermost parent. `handle_endtag` will close all unclosed children.
56: (12)                        self.handle_endtag(self.mdstack[0])
57: (4)                 def get_element(self) -> etree.Element:
58: (8)                     """ Return element from `treebuilder` and reset `treebuilder` for later use. """
59: (8)                     element = self.treebuilder.close()
60: (8)                     self.treebuilder = etree.TreeBuilder()
61: (8)                     return element
62: (4)                 def get_state(self, tag, attrs: Mapping[str, str]) -> Literal['block', 'span', 'off', None]:
63: (8)                     """ Return state from tag and `markdown` attribute. One of 'block', 'span', or 'off'. """
64: (8)                     md_attr = attrs.get('markdown', '0')
65: (8)                     if md_attr == 'markdown':
66: (12)                        # `<tag markdown>` is the same as `<tag markdown='1'>`.
67: (12)                        md_attr = '1'
68: (8)                     parent_state = self.mdstate[-1] if self.mdstate else None
69: (8)                     if parent_state == 'off' or (parent_state == 'span' and md_attr != '0'):
70: (12)                        # Only use the parent state if it is more restrictive than the markdown attribute.
71: (12)                        md_attr = parent_state
72: (8)                     if ((md_attr == '1' and tag in self.block_tags) or
73: (16)                            (md_attr == 'block' and tag in self.span_and_blocks_tags)):
74: (12)                        return 'block'
75: (8)                     elif ((md_attr == '1' and tag in self.span_tags) or
76: (14)                          (md_attr == 'span' and tag in self.span_and_blocks_tags)):
77: (12)                        return 'span'
78: (8)                     elif tag in self.block_level_tags:
79: (12)                        return 'off'
80: (8)                     else:  # pragma: no cover
81: (12)                        return None
82: (4)                 def handle_starttag(self, tag, attrs):
83: (8)                     # Handle tags that should always be empty and do not specify a closing tag
84: (8)                     if tag in self.empty_tags and (self.at_line_start() or self.intail):
85: (12)                        attrs = {key: value if value is not None else key for key, value in attrs}
86: (12)                        if "markdown" in attrs:
87: (16)                            attrs.pop('markdown')
88: (16)                            element = etree.Element(tag, attrs)
89: (16)                            data = etree.tostring(element, encoding='unicode', method='html')
90: (12)                        else:
91: (16)                            data = self.get_starttag_text()
92: (12)                        self.handle_empty_tag(data, True)
93: (12)                        return
94: (8)                     if tag in self.block_level_tags and (self.at_line_start() or self.intail):
95: (12)                        # Valueless attribute (ex: `<tag checked>`) results in `[('checked', None)]`.
96: (12)                        # Convert to `{'checked': 'checked'}`.
97: (12)                        attrs = {key: value if value is not None else key for key, value in attrs}
98: (12)                        state = self.get_state(tag, attrs)
99: (12)                        if self.inraw or (state in [None, 'off'] and not self.mdstack):
100: (16)                           # fall back to default behavior
101: (16)                           attrs.pop('markdown', None)
102: (16)                           super().handle_starttag(tag, attrs)
103: (12)                       else:
104: (16)                           if 'p' in self.mdstack and tag in self.block_level_tags:
105: (20)                               # Close unclosed 'p' tag
106: (20)                               self.handle_endtag('p')
107: (16)                           self.mdstate.append(state)
108: (16)                           self.mdstack.append(tag)
109: (16)                           attrs['markdown'] = state
110: (16)                           self.treebuilder.start(tag, attrs)
111: (8)                    else:
112: (12)                       # Span level tag
113: (12)                       if self.inraw:
114: (16)                           super().handle_starttag(tag, attrs)
115: (12)                       else:
116: (16)                           text = self.get_starttag_text()
117: (16)                           if self.mdstate and self.mdstate[-1] == "off":
118: (20)                               self.handle_data(self.md.htmlStash.store(text))
119: (16)                           else:
120: (20)                               self.handle_data(text)
121: (16)                           if tag in self.CDATA_CONTENT_ELEMENTS:
122: (20)                               # This is presumably a standalone tag in a code span (see #1036).
123: (20)                               self.clear_cdata_mode()
124: (4)                def handle_endtag(self, tag):
125: (8)                    if tag in self.block_level_tags:
126: (12)                       if self.inraw:
127: (16)                           super().handle_endtag(tag)
128: (12)                       elif tag in self.mdstack:
129: (16)                           # Close element and any unclosed children
130: (16)                           while self.mdstack:
131: (20)                               item = self.mdstack.pop()
132: (20)                               self.mdstate.pop()
133: (20)                               self.treebuilder.end(item)
134: (20)                               if item == tag:
135: (24)                                   break
136: (16)                           if not self.mdstack:
137: (20)                               # Last item in stack is closed. Stash it
138: (20)                               element = self.get_element()
139: (20)                               # Get last entry to see if it ends in newlines
140: (20)                               # If it is an element, assume there is no newlines
141: (20)                               item = self.cleandoc[-1] if self.cleandoc else ''
142: (20)                               # If we only have one newline before block element, add another
143: (20)                               if not item.endswith('\n\n') and item.endswith('\n'):
144: (24)                                   self.cleandoc.append('\n')
145: (20)                               self.cleandoc.append(self.md.htmlStash.store(element))
146: (20)                               self.cleandoc.append('\n\n')
147: (20)                               self.state = []
148: (20)                               # Check if element has a tail
149: (20)                               if not blank_line_re.match(
150: (28)                                       self.rawdata[self.line_offset + self.offset + len(self.get_endtag_text(tag)):]):
151: (24)                                   # More content exists after `endtag`.
152: (24)                                   self.intail = True
153: (12)                       else:
154: (16)                           # Treat orphan closing tag as a span level tag.
155: (16)                           text = self.get_endtag_text(tag)
156: (16)                           if self.mdstate and self.mdstate[-1] == "off":
157: (20)                               self.handle_data(self.md.htmlStash.store(text))
158: (16)                           else:
159: (20)                               self.handle_data(text)
160: (8)                    else:
161: (12)                       # Span level tag
162: (12)                       if self.inraw:
163: (16)                           super().handle_endtag(tag)
164: (12)                       else:
165: (16)                           text = self.get_endtag_text(tag)
166: (16)                           if self.mdstate and self.mdstate[-1] == "off":
167: (20)                               self.handle_data(self.md.htmlStash.store(text))
168: (16)                           else:
169: (20)                               self.handle_data(text)
170: (4)                def handle_startendtag(self, tag, attrs):
171: (8)                    if tag in self.empty_tags:
172: (12)                       attrs = {key: value if value is not None else key for key, value in attrs}
173: (12)                       if "markdown" in attrs:
174: (16)                           attrs.pop('markdown')
175: (16)                           element = etree.Element(tag, attrs)
176: (16)                           data = etree.tostring(element, encoding='unicode', method='html')
177: (12)                       else:
178: (16)                           data = self.get_starttag_text()
179: (8)                    else:
180: (12)                       data = self.get_starttag_text()
181: (8)                    self.handle_empty_tag(data, is_block=self.md.is_block_level(tag))
182: (4)                def handle_data(self, data):
183: (8)                    if self.intail and '\n' in data:
184: (12)                       self.intail = False
185: (8)                    if self.inraw or not self.mdstack:
186: (12)                       super().handle_data(data)
187: (8)                    else:
188: (12)                       self.treebuilder.data(data)
189: (4)                def handle_empty_tag(self, data, is_block):
190: (8)                    if self.inraw or not self.mdstack:
191: (12)                       super().handle_empty_tag(data, is_block)
192: (8)                    else:
193: (12)                       if self.at_line_start() and is_block:
194: (16)                           self.handle_data('\n' + self.md.htmlStash.store(data) + '\n\n')
195: (12)                       else:
196: (16)                           self.handle_data(self.md.htmlStash.store(data))
197: (4)                def parse_pi(self, i: int) -> int:
198: (8)                    if self.at_line_start() or self.intail or self.mdstack:
199: (12)                       # The same override exists in `HTMLExtractor` without the check
200: (12)                       # for `mdstack`. Therefore, use parent of `HTMLExtractor` instead.
201: (12)                       return super(HTMLExtractor, self).parse_pi(i)
202: (8)                    # This is not the beginning of a raw block so treat as plain data
203: (8)                    # and avoid consuming any tags which may follow (see #1066).
204: (8)                    self.handle_data('<?')
205: (8)                    return i + 2
206: (4)                def parse_html_declaration(self, i: int) -> int:
207: (8)                    if self.at_line_start() or self.intail or self.mdstack:
208: (12)                       # The same override exists in `HTMLExtractor` without the check
209: (12)                       # for `mdstack`. Therefore, use parent of `HTMLExtractor` instead.
210: (12)                       return super(HTMLExtractor, self).parse_html_declaration(i)
211: (8)                    # This is not the beginning of a raw block so treat as plain data
212: (8)                    # and avoid consuming any tags which may follow (see #1066).
213: (8)                    self.handle_data('<!')
214: (8)                    return i + 2
215: (0)            class HtmlBlockPreprocessor(Preprocessor):
216: (4)                """Remove html blocks from the text and store them for later retrieval."""
217: (4)                def run(self, lines: list[str]) -> list[str]:
218: (8)                    source = '\n'.join(lines)
219: (8)                    parser = HTMLExtractorExtra(self.md)
220: (8)                    parser.feed(source)
221: (8)                    parser.close()
222: (8)                    return ''.join(parser.cleandoc).split('\n')
223: (0)            class MarkdownInHtmlProcessor(BlockProcessor):
224: (4)                """Process Markdown Inside HTML Blocks which have been stored in the `HtmlStash`."""
225: (4)                def test(self, parent: etree.Element, block: str) -> bool:
226: (8)                    # Always return True. `run` will return `False` it not a valid match.
227: (8)                    return True
228: (4)                def parse_element_content(self, element: etree.Element) -> None:
229: (8)                    """
230: (8)                    Recursively parse the text content of an `etree` Element as Markdown.
231: (8)                    Any block level elements generated from the Markdown will be inserted as children of the element in place
232: (8)                    of the text content. All `markdown` attributes are removed. For any elements in which Markdown parsing has
233: (8)                    been disabled, the text content of it and its children are wrapped in an `AtomicString`.
234: (8)                    """
235: (8)                    md_attr = element.attrib.pop('markdown', 'off')
236: (8)                    if md_attr == 'block':
237: (12)                       # Parse content as block level
238: (12)                       # The order in which the different parts are parsed (text, children, tails) is important here as the
239: (12)                       # order of elements needs to be preserved. We can't be inserting items at a later point in the current
240: (12)                       # iteration as we don't want to do raw processing on elements created from parsing Markdown text (for
241: (12)                       # example). Therefore, the order of operations is children, tails, text.
242: (12)                       # Recursively parse existing children from raw HTML
243: (12)                       for child in list(element):
244: (16)                           self.parse_element_content(child)
245: (12)                       # Parse Markdown text in tail of children. Do this separate to avoid raw HTML parsing.
246: (12)                       # Save the position of each item to be inserted later in reverse.
247: (12)                       tails = []
248: (12)                       for pos, child in enumerate(element):
249: (16)                           if child.tail:
250: (20)                               block = child.tail.rstrip('\n')
251: (20)                               child.tail = ''
252: (20)                               # Use a dummy placeholder element.
253: (20)                               dummy = etree.Element('div')
254: (20)                               self.parser.parseBlocks(dummy, block.split('\n\n'))
255: (20)                               children = list(dummy)
256: (20)                               children.reverse()
257: (20)                               tails.append((pos + 1, children))
258: (12)                       # Insert the elements created from the tails in reverse.
259: (12)                       tails.reverse()
260: (12)                       for pos, tail in tails:
261: (16)                           for item in tail:
262: (20)                               element.insert(pos, item)
263: (12)                       # Parse Markdown text content. Do this last to avoid raw HTML parsing.
264: (12)                       if element.text:
265: (16)                           block = element.text.rstrip('\n')
266: (16)                           element.text = ''
267: (16)                           # Use a dummy placeholder element as the content needs to get inserted before existing children.
268: (16)                           dummy = etree.Element('div')
269: (16)                           self.parser.parseBlocks(dummy, block.split('\n\n'))
270: (16)                           children = list(dummy)
271: (16)                           children.reverse()
272: (16)                           for child in children:
273: (20)                               element.insert(0, child)
274: (8)                    elif md_attr == 'span':
275: (12)                       # Span level parsing will be handled by inline processors.
276: (12)                       # Walk children here to remove any `markdown` attributes.
277: (12)                       for child in list(element):
278: (16)                           self.parse_element_content(child)
279: (8)                    else:
280: (12)                       # Disable inline parsing for everything else
281: (12)                       if element.text is None:
282: (16)                           element.text = ''
283: (12)                       element.text = util.AtomicString(element.text)
284: (12)                       for child in list(element):
285: (16)                           self.parse_element_content(child)
286: (16)                           if child.tail:
287: (20)                               child.tail = util.AtomicString(child.tail)
288: (4)                def run(self, parent: etree.Element, blocks: list[str]) -> bool:
289: (8)                    m = util.HTML_PLACEHOLDER_RE.match(blocks[0])
290: (8)                    if m:
291: (12)                       index = int(m.group(1))
292: (12)                       element = self.parser.md.htmlStash.rawHtmlBlocks[index]
293: (12)                       if isinstance(element, etree.Element):
294: (16)                           # We have a matched element. Process it.
295: (16)                           blocks.pop(0)
296: (16)                           self.parse_element_content(element)
297: (16)                           parent.append(element)
298: (16)                           # Cleanup stash. Replace element with empty string to avoid confusing postprocessor.
299: (16)                           self.parser.md.htmlStash.rawHtmlBlocks.pop(index)
300: (16)                           self.parser.md.htmlStash.rawHtmlBlocks.insert(index, '')
301: (16)                           # Confirm the match to the `blockparser`.
302: (16)                           return True
303: (8)                    # No match found.
304: (8)                    return False
305: (0)            class MarkdownInHTMLPostprocessor(RawHtmlPostprocessor):
306: (4)                def stash_to_string(self, text: str | etree.Element) -> str:
307: (8)                    """ Override default to handle any `etree` elements still in the stash. """
308: (8)                    if isinstance(text, etree.Element):
309: (12)                       return self.md.serializer(text)
310: (8)                    else:
311: (12)                       return str(text)
312: (0)            class MarkdownInHtmlExtension(Extension):
313: (4)                """Add Markdown parsing in HTML to Markdown class."""
314: (4)                def extendMarkdown(self, md):
315: (8)                    """ Register extension instances. """
316: (8)                    # Replace raw HTML preprocessor
317: (8)                    md.preprocessors.register(HtmlBlockPreprocessor(md), 'html_block', 20)
318: (8)                    # Add `blockprocessor` which handles the placeholders for `etree` elements
319: (8)                    md.parser.blockprocessors.register(
320: (12)                       MarkdownInHtmlProcessor(md.parser), 'markdown_block', 105
321: (8)                    )
322: (8)                    # Replace raw HTML postprocessor
323: (8)                    md.postprocessors.register(MarkdownInHTMLPostprocessor(md), 'raw_html', 30)
324: (0)            def makeExtension(**kwargs):  # pragma: no cover
325: (4)                return MarkdownInHtmlExtension(**kwargs)

----------------------------------------

File 27 - .\extensions \meta.py:

1: (0)              # Meta Data Extension for Python-Markdown
2: (0)              # =======================================
3: (0)              # This extension adds Meta Data handling to markdown.
4: (0)              # See https://Python-Markdown.github.io/extensions/meta_data
5: (0)              # for documentation.
6: (0)              # Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com).
7: (0)              # All changes Copyright 2008-2014 The Python Markdown Project
8: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
9: (0)              """
10: (0)             This extension adds Meta Data handling to markdown.
11: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/meta_data)
12: (0)             for details.
13: (0)             """
14: (0)             from __future__ import annotations
15: (0)             from . import Extension
16: (0)             from ..preprocessors import Preprocessor
17: (0)             import re
18: (0)             import logging
19: (0)             from typing import Any
20: (0)             log = logging.getLogger('MARKDOWN')
21: (0)             # Global Vars
22: (0)             META_RE = re.compile(r'^[ ]{0,3}(?P<key>[A-Za-z0-9_-]+):\s*(?P<value>.*)')
23: (0)             META_MORE_RE = re.compile(r'^[ ]{4,}(?P<value>.*)')
24: (0)             BEGIN_RE = re.compile(r'^-{3}(\s.*)?')
25: (0)             END_RE = re.compile(r'^(-{3}|\.{3})(\s.*)?')
26: (0)             class MetaExtension (Extension):
27: (4)                 """ Meta-Data extension for Python-Markdown. """
28: (4)                 def extendMarkdown(self, md):
29: (8)                     """ Add `MetaPreprocessor` to Markdown instance. """
30: (8)                     md.registerExtension(self)
31: (8)                     self.md = md
32: (8)                     md.preprocessors.register(MetaPreprocessor(md), 'meta', 27)
33: (4)                 def reset(self) -> None:
34: (8)                     self.md.Meta = {}
35: (0)             class MetaPreprocessor(Preprocessor):
36: (4)                 """ Get Meta-Data. """
37: (4)                 def run(self, lines: list[str]) -> list[str]:
38: (8)                     """ Parse Meta-Data and store in Markdown.Meta. """
39: (8)                     meta: dict[str, Any] = {}
40: (8)                     key = None
41: (8)                     if lines and BEGIN_RE.match(lines[0]):
42: (12)                        lines.pop(0)
43: (8)                     while lines:
44: (12)                        line = lines.pop(0)
45: (12)                        m1 = META_RE.match(line)
46: (12)                        if line.strip() == '' or END_RE.match(line):
47: (16)                            break  # blank line or end of YAML header - done
48: (12)                        if m1:
49: (16)                            key = m1.group('key').lower().strip()
50: (16)                            value = m1.group('value').strip()
51: (16)                            try:
52: (20)                                meta[key].append(value)
53: (16)                            except KeyError:
54: (20)                                meta[key] = [value]
55: (12)                        else:
56: (16)                            m2 = META_MORE_RE.match(line)
57: (16)                            if m2 and key:
58: (20)                                # Add another line to existing key
59: (20)                                meta[key].append(m2.group('value').strip())
60: (16)                            else:
61: (20)                                lines.insert(0, line)
62: (20)                                break  # no meta data - done
63: (8)                     self.md.Meta = meta
64: (8)                     return lines
65: (0)             def makeExtension(**kwargs):  # pragma: no cover
66: (4)                 return MetaExtension(**kwargs)

----------------------------------------

File 28 - .\extensions \nl2br.py:

1: (0)              # `NL2BR` Extension
2: (0)              # ===============
3: (0)              # A Python-Markdown extension to treat newlines as hard breaks; like
4: (0)              # GitHub-flavored Markdown does.
5: (0)              # See https://Python-Markdown.github.io/extensions/nl2br
6: (0)              # for documentation.
7: (0)              # Original code Copyright 2011 [Brian Neal](https://deathofagremmie.com/)
8: (0)              # All changes Copyright 2011-2014 The Python Markdown Project
9: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
10: (0)             """
11: (0)             A Python-Markdown extension to treat newlines as hard breaks; like
12: (0)             GitHub-flavored Markdown does.
13: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/nl2br)
14: (0)             for details.
15: (0)             """
16: (0)             from __future__ import annotations
17: (0)             from . import Extension
18: (0)             from ..inlinepatterns import SubstituteTagInlineProcessor
19: (0)             BR_RE = r'\n'
20: (0)             class Nl2BrExtension(Extension):
21: (4)                 def extendMarkdown(self, md):
22: (8)                     """ Add a `SubstituteTagInlineProcessor` to Markdown. """
23: (8)                     br_tag = SubstituteTagInlineProcessor(BR_RE, 'br')
24: (8)                     md.inlinePatterns.register(br_tag, 'nl', 5)
25: (0)             def makeExtension(**kwargs):  # pragma: no cover
26: (4)                 return Nl2BrExtension(**kwargs)

----------------------------------------

File 29 - .\extensions \sane_lists.py:

1: (0)              # Sane List Extension for Python-Markdown
2: (0)              # =======================================
3: (0)              # Modify the behavior of Lists in Python-Markdown to act in a sane manor.
4: (0)              # See https://Python-Markdown.github.io/extensions/sane_lists
5: (0)              # for documentation.
6: (0)              # Original code Copyright 2011 [Waylan Limberg](http://achinghead.com)
7: (0)              # All changes Copyright 2011-2014 The Python Markdown Project
8: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
9: (0)              """
10: (0)             Modify the behavior of Lists in Python-Markdown to act in a sane manor.
11: (0)             See [documentation](https://Python-Markdown.github.io/extensions/sane_lists)
12: (0)             for details.
13: (0)             """
14: (0)             from __future__ import annotations
15: (0)             from . import Extension
16: (0)             from ..blockprocessors import OListProcessor, UListProcessor
17: (0)             import re
18: (0)             from typing import TYPE_CHECKING
19: (0)             if TYPE_CHECKING:  # pragma: no cover
20: (4)                 from .. import blockparser
21: (0)             class SaneOListProcessor(OListProcessor):
22: (4)                 """ Override `SIBLING_TAGS` to not include `ul` and set `LAZY_OL` to `False`. """
23: (4)                 SIBLING_TAGS = ['ol']
24: (4)                 """ Exclude `ul` from list of siblings. """
25: (4)                 LAZY_OL = False
26: (4)                 """ Disable lazy list behavior. """
27: (4)                 def __init__(self, parser: blockparser.BlockParser):
28: (8)                     super().__init__(parser)
29: (8)                     self.CHILD_RE = re.compile(r'^[ ]{0,%d}((\d+\.))[ ]+(.*)' %
30: (35)                                               (self.tab_length - 1))
31: (0)             class SaneUListProcessor(UListProcessor):
32: (4)                 """ Override `SIBLING_TAGS` to not include `ol`. """
33: (4)                 SIBLING_TAGS = ['ul']
34: (4)                 """ Exclude `ol` from list of siblings. """
35: (4)                 def __init__(self, parser: blockparser.BlockParser):
36: (8)                     super().__init__(parser)
37: (8)                     self.CHILD_RE = re.compile(r'^[ ]{0,%d}(([*+-]))[ ]+(.*)' %
38: (35)                                               (self.tab_length - 1))
39: (0)             class SaneListExtension(Extension):
40: (4)                 """ Add sane lists to Markdown. """
41: (4)                 def extendMarkdown(self, md):
42: (8)                     """ Override existing Processors. """
43: (8)                     md.parser.blockprocessors.register(SaneOListProcessor(md.parser), 'olist', 40)
44: (8)                     md.parser.blockprocessors.register(SaneUListProcessor(md.parser), 'ulist', 30)
45: (0)             def makeExtension(**kwargs):  # pragma: no cover
46: (4)                 return SaneListExtension(**kwargs)

----------------------------------------

File 30 - .\extensions \smarty.py:

1: (0)              # Smarty extension for Python-Markdown
2: (0)              # ====================================
3: (0)              # Adds conversion of ASCII dashes, quotes and ellipses to their HTML
4: (0)              # entity equivalents.
5: (0)              # See https://Python-Markdown.github.io/extensions/smarty
6: (0)              # for documentation.
7: (0)              # Author: 2013, Dmitry Shachnev <mitya57@gmail.com>
8: (0)              # All changes Copyright 2013-2014 The Python Markdown Project
9: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
10: (0)             # SmartyPants license:
11: (0)             #    Copyright (c) 2003 John Gruber <https://daringfireball.net/>
12: (0)             #    All rights reserved.
13: (0)             #    Redistribution and use in source and binary forms, with or without
14: (0)             #    modification, are permitted provided that the following conditions are
15: (0)             #    met:
16: (0)             #    *  Redistributions of source code must retain the above copyright
17: (0)             #       notice, this list of conditions and the following disclaimer.
18: (0)             #    *  Redistributions in binary form must reproduce the above copyright
19: (0)             #       notice, this list of conditions and the following disclaimer in
20: (0)             #       the documentation and/or other materials provided with the
21: (0)             #       distribution.
22: (0)             #    *  Neither the name "SmartyPants" nor the names of its contributors
23: (0)             #       may be used to endorse or promote products derived from this
24: (0)             #       software without specific prior written permission.
25: (0)             #    This software is provided by the copyright holders and contributors "as
26: (0)             #    is" and any express or implied warranties, including, but not limited
27: (0)             #    to, the implied warranties of merchantability and fitness for a
28: (0)             #    particular purpose are disclaimed. In no event shall the copyright
29: (0)             #    owner or contributors be liable for any direct, indirect, incidental,
30: (0)             #    special, exemplary, or consequential damages (including, but not
31: (0)             #    limited to, procurement of substitute goods or services; loss of use,
32: (0)             #    data, or profits; or business interruption) however caused and on any
33: (0)             #    theory of liability, whether in contract, strict liability, or tort
34: (0)             #    (including negligence or otherwise) arising in any way out of the use
35: (0)             #    of this software, even if advised of the possibility of such damage.
36: (0)             # `smartypants.py` license:
37: (0)             #    `smartypants.py` is a derivative work of SmartyPants.
38: (0)             #    Copyright (c) 2004, 2007 Chad Miller <http://web.chad.org/>
39: (0)             #    Redistribution and use in source and binary forms, with or without
40: (0)             #    modification, are permitted provided that the following conditions are
41: (0)             #    met:
42: (0)             #    *  Redistributions of source code must retain the above copyright
43: (0)             #       notice, this list of conditions and the following disclaimer.
44: (0)             #    *  Redistributions in binary form must reproduce the above copyright
45: (0)             #       notice, this list of conditions and the following disclaimer in
46: (0)             #       the documentation and/or other materials provided with the
47: (0)             #       distribution.
48: (0)             #    This software is provided by the copyright holders and contributors "as
49: (0)             #    is" and any express or implied warranties, including, but not limited
50: (0)             #    to, the implied warranties of merchantability and fitness for a
51: (0)             #    particular purpose are disclaimed. In no event shall the copyright
52: (0)             #    owner or contributors be liable for any direct, indirect, incidental,
53: (0)             #    special, exemplary, or consequential damages (including, but not
54: (0)             #    limited to, procurement of substitute goods or services; loss of use,
55: (0)             #    data, or profits; or business interruption) however caused and on any
56: (0)             #    theory of liability, whether in contract, strict liability, or tort
57: (0)             #    (including negligence or otherwise) arising in any way out of the use
58: (0)             #    of this software, even if advised of the possibility of such damage.
59: (0)             """
60: (0)             Adds conversion of ASCII dashes, quotes and ellipses to their HTML
61: (0)             entity equivalents.
62: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/smarty)
63: (0)             for details.
64: (0)             """
65: (0)             from __future__ import annotations
66: (0)             from . import Extension
67: (0)             from ..inlinepatterns import HtmlInlineProcessor, HTML_RE
68: (0)             from ..treeprocessors import InlineProcessor
69: (0)             from ..util import Registry
70: (0)             from typing import TYPE_CHECKING, Sequence
71: (0)             if TYPE_CHECKING:  # pragma: no cover
72: (4)                 from markdown import Markdown
73: (4)                 from .. import inlinepatterns
74: (4)                 import re
75: (4)                 import xml.etree.ElementTree as etree
76: (0)             # Constants for quote education.
77: (0)             punctClass = r"""[!"#\$\%'()*+,-.\/:;<=>?\@\[\\\]\^_`{|}~]"""
78: (0)             endOfWordClass = r"[\s.,;:!?)]"
79: (0)             closeClass = r"[^\ \t\r\n\[\{\(\-\u0002\u0003]"
80: (0)             openingQuotesBase = (
81: (4)                 r'(\s'               # a  whitespace char
82: (4)                 r'|&nbsp;'           # or a non-breaking space entity
83: (4)                 r'|--'               # or dashes
84: (4)                 r'|–|—'              # or Unicode
85: (4)                 r'|&[mn]dash;'       # or named dash entities
86: (4)                 r'|&#8211;|&#8212;'  # or decimal entities
87: (4)                 r')'
88: (0)             )
89: (0)             substitutions = {
90: (4)                 'mdash': '&mdash;',
91: (4)                 'ndash': '&ndash;',
92: (4)                 'ellipsis': '&hellip;',
93: (4)                 'left-angle-quote': '&laquo;',
94: (4)                 'right-angle-quote': '&raquo;',
95: (4)                 'left-single-quote': '&lsquo;',
96: (4)                 'right-single-quote': '&rsquo;',
97: (4)                 'left-double-quote': '&ldquo;',
98: (4)                 'right-double-quote': '&rdquo;',
99: (0)             }
100: (0)            # Special case if the very first character is a quote
101: (0)            # followed by punctuation at a non-word-break. Close the quotes by brute force:
102: (0)            singleQuoteStartRe = r"^'(?=%s\B)" % punctClass
103: (0)            doubleQuoteStartRe = r'^"(?=%s\B)' % punctClass
104: (0)            # Special case for double sets of quotes, e.g.:
105: (0)            #   <p>He said, "'Quoted' words in a larger quote."</p>
106: (0)            doubleQuoteSetsRe = r""""'(?=\w)"""
107: (0)            singleQuoteSetsRe = r"""'"(?=\w)"""
108: (0)            # Special case for decade abbreviations (the '80s):
109: (0)            decadeAbbrRe = r"(?<!\w)'(?=\d{2}s)"
110: (0)            # Get most opening double quotes:
111: (0)            openingDoubleQuotesRegex = r'%s"(?=\w)' % openingQuotesBase
112: (0)            # Double closing quotes:
113: (0)            closingDoubleQuotesRegex = r'"(?=\s)'
114: (0)            closingDoubleQuotesRegex2 = '(?<=%s)"' % closeClass
115: (0)            # Get most opening single quotes:
116: (0)            openingSingleQuotesRegex = r"%s'(?=\w)" % openingQuotesBase
117: (0)            # Single closing quotes:
118: (0)            closingSingleQuotesRegex = r"(?<=%s)'(?!\s|s\b|\d)" % closeClass
119: (0)            closingSingleQuotesRegex2 = r"'(\s|s\b)"
120: (0)            # All remaining quotes should be opening ones
121: (0)            remainingSingleQuotesRegex = r"'"
122: (0)            remainingDoubleQuotesRegex = r'"'
123: (0)            HTML_STRICT_RE = HTML_RE + r'(?!\>)'
124: (0)            class SubstituteTextPattern(HtmlInlineProcessor):
125: (4)                def __init__(self, pattern: str, replace: Sequence[int | str | etree.Element], md: Markdown):
126: (8)                    """ Replaces matches with some text. """
127: (8)                    HtmlInlineProcessor.__init__(self, pattern)
128: (8)                    self.replace = replace
129: (8)                    self.md = md
130: (4)                def handleMatch(self, m: re.Match[str], data: str) -> tuple[str, int, int]:
131: (8)                    result = ''
132: (8)                    for part in self.replace:
133: (12)                       if isinstance(part, int):
134: (16)                           result += m.group(part)
135: (12)                       else:
136: (16)                           result += self.md.htmlStash.store(part)
137: (8)                    return result, m.start(0), m.end(0)
138: (0)            class SmartyExtension(Extension):
139: (4)                """ Add Smarty to Markdown. """
140: (4)                def __init__(self, **kwargs):
141: (8)                    self.config = {
142: (12)                       'smart_quotes': [True, 'Educate quotes'],
143: (12)                       'smart_angled_quotes': [False, 'Educate angled quotes'],
144: (12)                       'smart_dashes': [True, 'Educate dashes'],
145: (12)                       'smart_ellipses': [True, 'Educate ellipses'],
146: (12)                       'substitutions': [{}, 'Overwrite default substitutions'],
147: (8)                    }
148: (8)                    """ Default configuration options. """
149: (8)                    super().__init__(**kwargs)
150: (8)                    self.substitutions: dict[str, str] = dict(substitutions)
151: (8)                    self.substitutions.update(self.getConfig('substitutions', default={}))
152: (4)                def _addPatterns(
153: (8)                    self,
154: (8)                    md: Markdown,
155: (8)                    patterns: Sequence[tuple[str, Sequence[int | str | etree.Element]]],
156: (8)                    serie: str,
157: (8)                    priority: int,
158: (4)                ):
159: (8)                    for ind, pattern in enumerate(patterns):
160: (12)                       pattern += (md,)
161: (12)                       pattern = SubstituteTextPattern(*pattern)
162: (12)                       name = 'smarty-%s-%d' % (serie, ind)
163: (12)                       self.inlinePatterns.register(pattern, name, priority-ind)
164: (4)                def educateDashes(self, md: Markdown) -> None:
165: (8)                    emDashesPattern = SubstituteTextPattern(
166: (12)                       r'(?<!-)---(?!-)', (self.substitutions['mdash'],), md
167: (8)                    )
168: (8)                    enDashesPattern = SubstituteTextPattern(
169: (12)                       r'(?<!-)--(?!-)', (self.substitutions['ndash'],), md
170: (8)                    )
171: (8)                    self.inlinePatterns.register(emDashesPattern, 'smarty-em-dashes', 50)
172: (8)                    self.inlinePatterns.register(enDashesPattern, 'smarty-en-dashes', 45)
173: (4)                def educateEllipses(self, md: Markdown) -> None:
174: (8)                    ellipsesPattern = SubstituteTextPattern(
175: (12)                       r'(?<!\.)\.{3}(?!\.)', (self.substitutions['ellipsis'],), md
176: (8)                    )
177: (8)                    self.inlinePatterns.register(ellipsesPattern, 'smarty-ellipses', 10)
178: (4)                def educateAngledQuotes(self, md: Markdown) -> None:
179: (8)                    leftAngledQuotePattern = SubstituteTextPattern(
180: (12)                       r'\<\<', (self.substitutions['left-angle-quote'],), md
181: (8)                    )
182: (8)                    rightAngledQuotePattern = SubstituteTextPattern(
183: (12)                       r'\>\>', (self.substitutions['right-angle-quote'],), md
184: (8)                    )
185: (8)                    self.inlinePatterns.register(leftAngledQuotePattern, 'smarty-left-angle-quotes', 40)
186: (8)                    self.inlinePatterns.register(rightAngledQuotePattern, 'smarty-right-angle-quotes', 35)
187: (4)                def educateQuotes(self, md: Markdown) -> None:
188: (8)                    lsquo = self.substitutions['left-single-quote']
189: (8)                    rsquo = self.substitutions['right-single-quote']
190: (8)                    ldquo = self.substitutions['left-double-quote']
191: (8)                    rdquo = self.substitutions['right-double-quote']
192: (8)                    patterns = (
193: (12)                       (singleQuoteStartRe, (rsquo,)),
194: (12)                       (doubleQuoteStartRe, (rdquo,)),
195: (12)                       (doubleQuoteSetsRe, (ldquo + lsquo,)),
196: (12)                       (singleQuoteSetsRe, (lsquo + ldquo,)),
197: (12)                       (decadeAbbrRe, (rsquo,)),
198: (12)                       (openingSingleQuotesRegex, (1, lsquo)),
199: (12)                       (closingSingleQuotesRegex, (rsquo,)),
200: (12)                       (closingSingleQuotesRegex2, (rsquo, 1)),
201: (12)                       (remainingSingleQuotesRegex, (lsquo,)),
202: (12)                       (openingDoubleQuotesRegex, (1, ldquo)),
203: (12)                       (closingDoubleQuotesRegex, (rdquo,)),
204: (12)                       (closingDoubleQuotesRegex2, (rdquo,)),
205: (12)                       (remainingDoubleQuotesRegex, (ldquo,))
206: (8)                    )
207: (8)                    self._addPatterns(md, patterns, 'quotes', 30)
208: (4)                def extendMarkdown(self, md):
209: (8)                    configs = self.getConfigs()
210: (8)                    self.inlinePatterns: Registry[inlinepatterns.InlineProcessor] = Registry()
211: (8)                    if configs['smart_ellipses']:
212: (12)                       self.educateEllipses(md)
213: (8)                    if configs['smart_quotes']:
214: (12)                       self.educateQuotes(md)
215: (8)                    if configs['smart_angled_quotes']:
216: (12)                       self.educateAngledQuotes(md)
217: (12)                       # Override `HTML_RE` from `inlinepatterns.py` so that it does not
218: (12)                       # process tags with duplicate closing quotes.
219: (12)                       md.inlinePatterns.register(HtmlInlineProcessor(HTML_STRICT_RE, md), 'html', 90)
220: (8)                    if configs['smart_dashes']:
221: (12)                       self.educateDashes(md)
222: (8)                    inlineProcessor = InlineProcessor(md)
223: (8)                    inlineProcessor.inlinePatterns = self.inlinePatterns
224: (8)                    md.treeprocessors.register(inlineProcessor, 'smarty', 6)
225: (8)                    md.ESCAPED_CHARS.extend(['"', "'"])
226: (0)            def makeExtension(**kwargs):  # pragma: no cover
227: (4)                return SmartyExtension(**kwargs)

----------------------------------------

File 31 - .\extensions \tables.py:

1: (0)              # Tables Extension for Python-Markdown
2: (0)              # ====================================
3: (0)              # Added parsing of tables to Python-Markdown.
4: (0)              # See https://Python-Markdown.github.io/extensions/tables
5: (0)              # for documentation.
6: (0)              # Original code Copyright 2009 [Waylan Limberg](http://achinghead.com)
7: (0)              # All changes Copyright 2008-2014 The Python Markdown Project
8: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
9: (0)              """
10: (0)             Added parsing of tables to Python-Markdown.
11: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/tables)
12: (0)             for details.
13: (0)             """
14: (0)             from __future__ import annotations
15: (0)             from . import Extension
16: (0)             from ..blockprocessors import BlockProcessor
17: (0)             import xml.etree.ElementTree as etree
18: (0)             import re
19: (0)             from typing import TYPE_CHECKING, Any, Sequence
20: (0)             if TYPE_CHECKING:  # pragma: no cover
21: (4)                 from .. import blockparser
22: (0)             PIPE_NONE = 0
23: (0)             PIPE_LEFT = 1
24: (0)             PIPE_RIGHT = 2
25: (0)             class TableProcessor(BlockProcessor):
26: (4)                 """ Process Tables. """
27: (4)                 RE_CODE_PIPES = re.compile(r'(?:(\\\\)|(\\`+)|(`+)|(\\\|)|(\|))')
28: (4)                 RE_END_BORDER = re.compile(r'(?<!\\)(?:\\\\)*\|$')
29: (4)                 def __init__(self, parser: blockparser.BlockParser, config: dict[str, Any]):
30: (8)                     self.border: bool | int = False
31: (8)                     self.separator: Sequence[str] = ''
32: (8)                     self.config = config
33: (8)                     super().__init__(parser)
34: (4)                 def test(self, parent: etree.Element, block: str) -> bool:
35: (8)                     """
36: (8)                     Ensure first two rows (column header and separator row) are valid table rows.
37: (8)                     Keep border check and separator row do avoid repeating the work.
38: (8)                     """
39: (8)                     is_table = False
40: (8)                     rows = [row.strip(' ') for row in block.split('\n')]
41: (8)                     if len(rows) > 1:
42: (12)                        header0 = rows[0]
43: (12)                        self.border = PIPE_NONE
44: (12)                        if header0.startswith('|'):
45: (16)                            self.border |= PIPE_LEFT
46: (12)                        if self.RE_END_BORDER.search(header0) is not None:
47: (16)                            self.border |= PIPE_RIGHT
48: (12)                        row = self._split_row(header0)
49: (12)                        row0_len = len(row)
50: (12)                        is_table = row0_len > 1
51: (12)                        # Each row in a single column table needs at least one pipe.
52: (12)                        if not is_table and row0_len == 1 and self.border:
53: (16)                            for index in range(1, len(rows)):
54: (20)                                is_table = rows[index].startswith('|')
55: (20)                                if not is_table:
56: (24)                                    is_table = self.RE_END_BORDER.search(rows[index]) is not None
57: (20)                                if not is_table:
58: (24)                                    break
59: (12)                        if is_table:
60: (16)                            row = self._split_row(rows[1])
61: (16)                            is_table = (len(row) == row0_len) and set(''.join(row)) <= set('|:- ')
62: (16)                            if is_table:
63: (20)                                self.separator = row
64: (8)                     return is_table
65: (4)                 def run(self, parent: etree.Element, blocks: list[str]) -> None:
66: (8)                     """ Parse a table block and build table. """
67: (8)                     block = blocks.pop(0).split('\n')
68: (8)                     header = block[0].strip(' ')
69: (8)                     rows = [] if len(block) < 3 else block[2:]
70: (8)                     # Get alignment of columns
71: (8)                     align: list[str | None] = []
72: (8)                     for c in self.separator:
73: (12)                        c = c.strip(' ')
74: (12)                        if c.startswith(':') and c.endswith(':'):
75: (16)                            align.append('center')
76: (12)                        elif c.startswith(':'):
77: (16)                            align.append('left')
78: (12)                        elif c.endswith(':'):
79: (16)                            align.append('right')
80: (12)                        else:
81: (16)                            align.append(None)
82: (8)                     # Build table
83: (8)                     table = etree.SubElement(parent, 'table')
84: (8)                     thead = etree.SubElement(table, 'thead')
85: (8)                     self._build_row(header, thead, align)
86: (8)                     tbody = etree.SubElement(table, 'tbody')
87: (8)                     if len(rows) == 0:
88: (12)                        # Handle empty table
89: (12)                        self._build_empty_row(tbody, align)
90: (8)                     else:
91: (12)                        for row in rows:
92: (16)                            self._build_row(row.strip(' '), tbody, align)
93: (4)                 def _build_empty_row(self, parent: etree.Element, align: Sequence[str | None]) -> None:
94: (8)                     """Build an empty row."""
95: (8)                     tr = etree.SubElement(parent, 'tr')
96: (8)                     count = len(align)
97: (8)                     while count:
98: (12)                        etree.SubElement(tr, 'td')
99: (12)                        count -= 1
100: (4)                def _build_row(self, row: str, parent: etree.Element, align: Sequence[str | None]) -> None:
101: (8)                    """ Given a row of text, build table cells. """
102: (8)                    tr = etree.SubElement(parent, 'tr')
103: (8)                    tag = 'td'
104: (8)                    if parent.tag == 'thead':
105: (12)                       tag = 'th'
106: (8)                    cells = self._split_row(row)
107: (8)                    # We use align here rather than cells to ensure every row
108: (8)                    # contains the same number of columns.
109: (8)                    for i, a in enumerate(align):
110: (12)                       c = etree.SubElement(tr, tag)
111: (12)                       try:
112: (16)                           c.text = cells[i].strip(' ')
113: (12)                       except IndexError:  # pragma: no cover
114: (16)                           c.text = ""
115: (12)                       if a:
116: (16)                           if self.config['use_align_attribute']:
117: (20)                               c.set('align', a)
118: (16)                           else:
119: (20)                               c.set('style', f'text-align: {a};')
120: (4)                def _split_row(self, row: str) -> list[str]:
121: (8)                    """ split a row of text into list of cells. """
122: (8)                    if self.border:
123: (12)                       if row.startswith('|'):
124: (16)                           row = row[1:]
125: (12)                       row = self.RE_END_BORDER.sub('', row)
126: (8)                    return self._split(row)
127: (4)                def _split(self, row: str) -> list[str]:
128: (8)                    """ split a row of text with some code into a list of cells. """
129: (8)                    elements = []
130: (8)                    pipes = []
131: (8)                    tics = []
132: (8)                    tic_points = []
133: (8)                    tic_region = []
134: (8)                    good_pipes = []
135: (8)                    # Parse row
136: (8)                    # Throw out \\, and \|
137: (8)                    for m in self.RE_CODE_PIPES.finditer(row):
138: (12)                       # Store ` data (len, start_pos, end_pos)
139: (12)                       if m.group(2):
140: (16)                           # \`+
141: (16)                           # Store length of each tic group: subtract \
142: (16)                           tics.append(len(m.group(2)) - 1)
143: (16)                           # Store start of group, end of group, and escape length
144: (16)                           tic_points.append((m.start(2), m.end(2) - 1, 1))
145: (12)                       elif m.group(3):
146: (16)                           # `+
147: (16)                           # Store length of each tic group
148: (16)                           tics.append(len(m.group(3)))
149: (16)                           # Store start of group, end of group, and escape length
150: (16)                           tic_points.append((m.start(3), m.end(3) - 1, 0))
151: (12)                       # Store pipe location
152: (12)                       elif m.group(5):
153: (16)                           pipes.append(m.start(5))
154: (8)                    # Pair up tics according to size if possible
155: (8)                    # Subtract the escape length *only* from the opening.
156: (8)                    # Walk through tic list and see if tic has a close.
157: (8)                    # Store the tic region (start of region, end of region).
158: (8)                    pos = 0
159: (8)                    tic_len = len(tics)
160: (8)                    while pos < tic_len:
161: (12)                       try:
162: (16)                           tic_size = tics[pos] - tic_points[pos][2]
163: (16)                           if tic_size == 0:
164: (20)                               raise ValueError
165: (16)                           index = tics[pos + 1:].index(tic_size) + 1
166: (16)                           tic_region.append((tic_points[pos][0], tic_points[pos + index][1]))
167: (16)                           pos += index + 1
168: (12)                       except ValueError:
169: (16)                           pos += 1
170: (8)                    # Resolve pipes.  Check if they are within a tic pair region.
171: (8)                    # Walk through pipes comparing them to each region.
172: (8)                    #     - If pipe position is less that a region, it isn't in a region
173: (8)                    #     - If it is within a region, we don't want it, so throw it out
174: (8)                    #     - If we didn't throw it out, it must be a table pipe
175: (8)                    for pipe in pipes:
176: (12)                       throw_out = False
177: (12)                       for region in tic_region:
178: (16)                           if pipe < region[0]:
179: (20)                               # Pipe is not in a region
180: (20)                               break
181: (16)                           elif region[0] <= pipe <= region[1]:
182: (20)                               # Pipe is within a code region.  Throw it out.
183: (20)                               throw_out = True
184: (20)                               break
185: (12)                       if not throw_out:
186: (16)                           good_pipes.append(pipe)
187: (8)                    # Split row according to table delimiters.
188: (8)                    pos = 0
189: (8)                    for pipe in good_pipes:
190: (12)                       elements.append(row[pos:pipe])
191: (12)                       pos = pipe + 1
192: (8)                    elements.append(row[pos:])
193: (8)                    return elements
194: (0)            class TableExtension(Extension):
195: (4)                """ Add tables to Markdown. """
196: (4)                def __init__(self, **kwargs):
197: (8)                    self.config = {
198: (12)                       'use_align_attribute': [False, 'True to use align attribute instead of style.'],
199: (8)                    }
200: (8)                    """ Default configuration options. """
201: (8)                    super().__init__(**kwargs)
202: (4)                def extendMarkdown(self, md):
203: (8)                    """ Add an instance of `TableProcessor` to `BlockParser`. """
204: (8)                    if '|' not in md.ESCAPED_CHARS:
205: (12)                       md.ESCAPED_CHARS.append('|')
206: (8)                    processor = TableProcessor(md.parser, self.getConfigs())
207: (8)                    md.parser.blockprocessors.register(processor, 'table', 75)
208: (0)            def makeExtension(**kwargs):  # pragma: no cover
209: (4)                return TableExtension(**kwargs)

----------------------------------------

File 32 - .\extensions \toc.py:

1: (0)              # Table of Contents Extension for Python-Markdown
2: (0)              # ===============================================
3: (0)              # See https://Python-Markdown.github.io/extensions/toc
4: (0)              # for documentation.
5: (0)              # Original code Copyright 2008 [Jack Miller](https://codezen.org/)
6: (0)              # All changes Copyright 2008-2024 The Python Markdown Project
7: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
8: (0)              """
9: (0)              Add table of contents support to Python-Markdown.
10: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/toc)
11: (0)             for details.
12: (0)             """
13: (0)             from __future__ import annotations
14: (0)             from . import Extension
15: (0)             from ..treeprocessors import Treeprocessor
16: (0)             from ..util import parseBoolValue, AMP_SUBSTITUTE, deprecated, HTML_PLACEHOLDER_RE, AtomicString
17: (0)             from ..treeprocessors import UnescapeTreeprocessor
18: (0)             from ..serializers import RE_AMP
19: (0)             import re
20: (0)             import html
21: (0)             import unicodedata
22: (0)             from copy import deepcopy
23: (0)             import xml.etree.ElementTree as etree
24: (0)             from typing import TYPE_CHECKING, Any, Iterator, MutableSet
25: (0)             if TYPE_CHECKING:  # pragma: no cover
26: (4)                 from markdown import Markdown
27: (0)             def slugify(value: str, separator: str, unicode: bool = False) -> str:
28: (4)                 """ Slugify a string, to make it URL friendly. """
29: (4)                 if not unicode:
30: (8)                     # Replace Extended Latin characters with ASCII, i.e. `žlutý` => `zluty`
31: (8)                     value = unicodedata.normalize('NFKD', value)
32: (8)                     value = value.encode('ascii', 'ignore').decode('ascii')
33: (4)                 value = re.sub(r'[^\w\s-]', '', value).strip().lower()
34: (4)                 return re.sub(r'[{}\s]+'.format(separator), separator, value)
35: (0)             def slugify_unicode(value: str, separator: str) -> str:
36: (4)                 """ Slugify a string, to make it URL friendly while preserving Unicode characters. """
37: (4)                 return slugify(value, separator, unicode=True)
38: (0)             IDCOUNT_RE = re.compile(r'^(.*)_([0-9]+)$')
39: (0)             def unique(id: str, ids: MutableSet[str]) -> str:
40: (4)                 """ Ensure id is unique in set of ids. Append '_1', '_2'... if not """
41: (4)                 while id in ids or not id:
42: (8)                     m = IDCOUNT_RE.match(id)
43: (8)                     if m:
44: (12)                        id = '%s_%d' % (m.group(1), int(m.group(2))+1)
45: (8)                     else:
46: (12)                        id = '%s_%d' % (id, 1)
47: (4)                 ids.add(id)
48: (4)                 return id
49: (0)             @deprecated('Use `render_inner_html` and `striptags` instead.')
50: (0)             def get_name(el: etree.Element) -> str:
51: (4)                 """Get title name."""
52: (4)                 text = []
53: (4)                 for c in el.itertext():
54: (8)                     if isinstance(c, AtomicString):
55: (12)                        text.append(html.unescape(c))
56: (8)                     else:
57: (12)                        text.append(c)
58: (4)                 return ''.join(text).strip()
59: (0)             @deprecated('Use `run_postprocessors`, `render_inner_html` and/or `striptags` instead.')
60: (0)             def stashedHTML2text(text: str, md: Markdown, strip_entities: bool = True) -> str:
61: (4)                 """ Extract raw HTML from stash, reduce to plain text and swap with placeholder. """
62: (4)                 def _html_sub(m: re.Match[str]) -> str:
63: (8)                     """ Substitute raw html with plain text. """
64: (8)                     try:
65: (12)                        raw = md.htmlStash.rawHtmlBlocks[int(m.group(1))]
66: (8)                     except (IndexError, TypeError):  # pragma: no cover
67: (12)                        return m.group(0)
68: (8)                     # Strip out tags and/or entities - leaving text
69: (8)                     res = re.sub(r'(<[^>]+>)', '', raw)
70: (8)                     if strip_entities:
71: (12)                        res = re.sub(r'(&[\#a-zA-Z0-9]+;)', '', res)
72: (8)                     return res
73: (4)                 return HTML_PLACEHOLDER_RE.sub(_html_sub, text)
74: (0)             def unescape(text: str) -> str:
75: (4)                 """ Unescape Markdown backslash escaped text. """
76: (4)                 c = UnescapeTreeprocessor()
77: (4)                 return c.unescape(text)
78: (0)             def strip_tags(text: str) -> str:
79: (4)                 """ Strip HTML tags and return plain text. Note: HTML entities are unaffected. """
80: (4)                 # A comment could contain a tag, so strip comments first
81: (4)                 while (start := text.find('<!--')) != -1 and (end := text.find('-->', start)) != -1:
82: (8)                     text = f'{text[:start]}{text[end + 3:]}'
83: (4)                 while (start := text.find('<')) != -1 and (end := text.find('>', start)) != -1:
84: (8)                     text = f'{text[:start]}{text[end + 1:]}'
85: (4)                 # Collapse whitespace
86: (4)                 text = ' '.join(text.split())
87: (4)                 return text
88: (0)             def escape_cdata(text: str) -> str:
89: (4)                 """ Escape character data. """
90: (4)                 if "&" in text:
91: (8)                     # Only replace & when not part of an entity
92: (8)                     text = RE_AMP.sub('&amp;', text)
93: (4)                 if "<" in text:
94: (8)                     text = text.replace("<", "&lt;")
95: (4)                 if ">" in text:
96: (8)                     text = text.replace(">", "&gt;")
97: (4)                 return text
98: (0)             def run_postprocessors(text: str, md: Markdown) -> str:
99: (4)                 """ Run postprocessors from Markdown instance on text. """
100: (4)                for pp in md.postprocessors:
101: (8)                    text = pp.run(text)
102: (4)                return text.strip()
103: (0)            def render_inner_html(el: etree.Element, md: Markdown) -> str:
104: (4)                """ Fully render inner html of an `etree` element as a string. """
105: (4)                # The `UnescapeTreeprocessor` runs after `toc` extension so run here.
106: (4)                text = unescape(md.serializer(el))
107: (4)                # strip parent tag
108: (4)                start = text.index('>') + 1
109: (4)                end = text.rindex('<')
110: (4)                text = text[start:end].strip()
111: (4)                return run_postprocessors(text, md)
112: (0)            def remove_fnrefs(root: etree.Element) -> etree.Element:
113: (4)                """ Remove footnote references from a copy of the element, if any are present. """
114: (4)                # Remove footnote references, which look like this: `<sup id="fnref:1">...</sup>`.
115: (4)                # If there are no `sup` elements, then nothing to do.
116: (4)                if next(root.iter('sup'), None) is None:
117: (8)                    return root
118: (4)                root = deepcopy(root)
119: (4)                # Find parent elements that contain `sup` elements.
120: (4)                for parent in root.findall('.//sup/..'):
121: (8)                    carry_text = ""
122: (8)                    for child in reversed(parent):  # Reversed for the ability to mutate during iteration.
123: (12)                       # Remove matching footnote references but carry any `tail` text to preceding elements.
124: (12)                       if child.tag == 'sup' and child.get('id', '').startswith('fnref'):
125: (16)                           carry_text = f'{child.tail or ""}{carry_text}'
126: (16)                           parent.remove(child)
127: (12)                       elif carry_text:
128: (16)                           child.tail = f'{child.tail or ""}{carry_text}'
129: (16)                           carry_text = ""
130: (8)                    if carry_text:
131: (12)                       parent.text = f'{parent.text or ""}{carry_text}'
132: (4)                return root
133: (0)            def nest_toc_tokens(toc_list):
134: (4)                """Given an unsorted list with errors and skips, return a nested one.
135: (8)                    [{'level': 1}, {'level': 2}]
136: (8)                    =>
137: (8)                    [{'level': 1, 'children': [{'level': 2, 'children': []}]}]
138: (4)                A wrong list is also converted:
139: (8)                    [{'level': 2}, {'level': 1}]
140: (8)                    =>
141: (8)                    [{'level': 2, 'children': []}, {'level': 1, 'children': []}]
142: (4)                """
143: (4)                ordered_list = []
144: (4)                if len(toc_list):
145: (8)                    # Initialize everything by processing the first entry
146: (8)                    last = toc_list.pop(0)
147: (8)                    last['children'] = []
148: (8)                    levels = [last['level']]
149: (8)                    ordered_list.append(last)
150: (8)                    parents = []
151: (8)                    # Walk the rest nesting the entries properly
152: (8)                    while toc_list:
153: (12)                       t = toc_list.pop(0)
154: (12)                       current_level = t['level']
155: (12)                       t['children'] = []
156: (12)                       # Reduce depth if current level < last item's level
157: (12)                       if current_level < levels[-1]:
158: (16)                           # Pop last level since we know we are less than it
159: (16)                           levels.pop()
160: (16)                           # Pop parents and levels we are less than or equal to
161: (16)                           to_pop = 0
162: (16)                           for p in reversed(parents):
163: (20)                               if current_level <= p['level']:
164: (24)                                   to_pop += 1
165: (20)                               else:  # pragma: no cover
166: (24)                                   break
167: (16)                           if to_pop:
168: (20)                               levels = levels[:-to_pop]
169: (20)                               parents = parents[:-to_pop]
170: (16)                           # Note current level as last
171: (16)                           levels.append(current_level)
172: (12)                       # Level is the same, so append to
173: (12)                       # the current parent (if available)
174: (12)                       if current_level == levels[-1]:
175: (16)                           (parents[-1]['children'] if parents
176: (17)                            else ordered_list).append(t)
177: (12)                       # Current level is > last item's level,
178: (12)                       # So make last item a parent and append current as child
179: (12)                       else:
180: (16)                           last['children'].append(t)
181: (16)                           parents.append(last)
182: (16)                           levels.append(current_level)
183: (12)                       last = t
184: (4)                return ordered_list
185: (0)            class TocTreeprocessor(Treeprocessor):
186: (4)                """ Step through document and build TOC. """
187: (4)                def __init__(self, md: Markdown, config: dict[str, Any]):
188: (8)                    super().__init__(md)
189: (8)                    self.marker: str = config["marker"]
190: (8)                    self.title: str = config["title"]
191: (8)                    self.base_level = int(config["baselevel"]) - 1
192: (8)                    self.slugify = config["slugify"]
193: (8)                    self.sep = config["separator"]
194: (8)                    self.toc_class = config["toc_class"]
195: (8)                    self.title_class: str = config["title_class"]
196: (8)                    self.use_anchors: bool = parseBoolValue(config["anchorlink"])
197: (8)                    self.anchorlink_class: str = config["anchorlink_class"]
198: (8)                    self.use_permalinks = parseBoolValue(config["permalink"], False)
199: (8)                    if self.use_permalinks is None:
200: (12)                       self.use_permalinks = config["permalink"]
201: (8)                    self.permalink_class: str = config["permalink_class"]
202: (8)                    self.permalink_title: str = config["permalink_title"]
203: (8)                    self.permalink_leading: bool | None = parseBoolValue(config["permalink_leading"], False)
204: (8)                    self.header_rgx = re.compile("[Hh][123456]")
205: (8)                    if isinstance(config["toc_depth"], str) and '-' in config["toc_depth"]:
206: (12)                       self.toc_top, self.toc_bottom = [int(x) for x in config["toc_depth"].split('-')]
207: (8)                    else:
208: (12)                       self.toc_top = 1
209: (12)                       self.toc_bottom = int(config["toc_depth"])
210: (4)                def iterparent(self, node: etree.Element) -> Iterator[tuple[etree.Element, etree.Element]]:
211: (8)                    """ Iterator wrapper to get allowed parent and child all at once. """
212: (8)                    # We do not allow the marker inside a header as that
213: (8)                    # would causes an endless loop of placing a new TOC
214: (8)                    # inside previously generated TOC.
215: (8)                    for child in node:
216: (12)                       if not self.header_rgx.match(child.tag) and child.tag not in ['pre', 'code']:
217: (16)                           yield node, child
218: (16)                           yield from self.iterparent(child)
219: (4)                def replace_marker(self, root: etree.Element, elem: etree.Element) -> None:
220: (8)                    """ Replace marker with elem. """
221: (8)                    for (p, c) in self.iterparent(root):
222: (12)                       text = ''.join(c.itertext()).strip()
223: (12)                       if not text:
224: (16)                           continue
225: (12)                       # To keep the output from screwing up the
226: (12)                       # validation by putting a `<div>` inside of a `<p>`
227: (12)                       # we actually replace the `<p>` in its entirety.
228: (12)                       # The `<p>` element may contain more than a single text content
229: (12)                       # (`nl2br` can introduce a `<br>`). In this situation, `c.text` returns
230: (12)                       # the very first content, ignore children contents or tail content.
231: (12)                       # `len(c) == 0` is here to ensure there is only text in the `<p>`.
232: (12)                       if c.text and c.text.strip() == self.marker and len(c) == 0:
233: (16)                           for i in range(len(p)):
234: (20)                               if p[i] == c:
235: (24)                                   p[i] = elem
236: (24)                                   break
237: (4)                def set_level(self, elem: etree.Element) -> None:
238: (8)                    """ Adjust header level according to base level. """
239: (8)                    level = int(elem.tag[-1]) + self.base_level
240: (8)                    if level > 6:
241: (12)                       level = 6
242: (8)                    elem.tag = 'h%d' % level
243: (4)                def add_anchor(self, c: etree.Element, elem_id: str) -> None:
244: (8)                    anchor = etree.Element("a")
245: (8)                    anchor.text = c.text
246: (8)                    anchor.attrib["href"] = "#" + elem_id
247: (8)                    anchor.attrib["class"] = self.anchorlink_class
248: (8)                    c.text = ""
249: (8)                    for elem in c:
250: (12)                       anchor.append(elem)
251: (8)                    while len(c):
252: (12)                       c.remove(c[0])
253: (8)                    c.append(anchor)
254: (4)                def add_permalink(self, c: etree.Element, elem_id: str) -> None:
255: (8)                    permalink = etree.Element("a")
256: (8)                    permalink.text = ("%spara;" % AMP_SUBSTITUTE
257: (26)                                     if self.use_permalinks is True
258: (26)                                     else self.use_permalinks)
259: (8)                    permalink.attrib["href"] = "#" + elem_id
260: (8)                    permalink.attrib["class"] = self.permalink_class
261: (8)                    if self.permalink_title:
262: (12)                       permalink.attrib["title"] = self.permalink_title
263: (8)                    if self.permalink_leading:
264: (12)                       permalink.tail = c.text
265: (12)                       c.text = ""
266: (12)                       c.insert(0, permalink)
267: (8)                    else:
268: (12)                       c.append(permalink)
269: (4)                def build_toc_div(self, toc_list: list) -> etree.Element:
270: (8)                    """ Return a string div given a toc list. """
271: (8)                    div = etree.Element("div")
272: (8)                    div.attrib["class"] = self.toc_class
273: (8)                    # Add title to the div
274: (8)                    if self.title:
275: (12)                       header = etree.SubElement(div, "span")
276: (12)                       if self.title_class:
277: (16)                           header.attrib["class"] = self.title_class
278: (12)                       header.text = self.title
279: (8)                    def build_etree_ul(toc_list: list, parent: etree.Element) -> etree.Element:
280: (12)                       ul = etree.SubElement(parent, "ul")
281: (12)                       for item in toc_list:
282: (16)                           # List item link, to be inserted into the toc div
283: (16)                           li = etree.SubElement(ul, "li")
284: (16)                           link = etree.SubElement(li, "a")
285: (16)                           link.text = item.get('name', '')
286: (16)                           link.attrib["href"] = '#' + item.get('id', '')
287: (16)                           if item['children']:
288: (20)                               build_etree_ul(item['children'], li)
289: (12)                       return ul
290: (8)                    build_etree_ul(toc_list, div)
291: (8)                    if 'prettify' in self.md.treeprocessors:
292: (12)                       self.md.treeprocessors['prettify'].run(div)
293: (8)                    return div
294: (4)                def run(self, doc: etree.Element) -> None:
295: (8)                    # Get a list of id attributes
296: (8)                    used_ids = set()
297: (8)                    for el in doc.iter():
298: (12)                       if "id" in el.attrib:
299: (16)                           used_ids.add(el.attrib["id"])
300: (8)                    toc_tokens = []
301: (8)                    for el in doc.iter():
302: (12)                       if isinstance(el.tag, str) and self.header_rgx.match(el.tag):
303: (16)                           self.set_level(el)
304: (16)                           innerhtml = render_inner_html(remove_fnrefs(el), self.md)
305: (16)                           name = strip_tags(innerhtml)
306: (16)                           # Do not override pre-existing ids
307: (16)                           if "id" not in el.attrib:
308: (20)                               el.attrib["id"] = unique(self.slugify(html.unescape(name), self.sep), used_ids)
309: (16)                           data_toc_label = ''
310: (16)                           if 'data-toc-label' in el.attrib:
311: (20)                               data_toc_label = run_postprocessors(unescape(el.attrib['data-toc-label']), self.md)
312: (20)                               # Overwrite name with sanitized value of `data-toc-label`.
313: (20)                               name = escape_cdata(strip_tags(data_toc_label))
314: (20)                               # Remove the data-toc-label attribute as it is no longer needed
315: (20)                               del el.attrib['data-toc-label']
316: (16)                           if int(el.tag[-1]) >= self.toc_top and int(el.tag[-1]) <= self.toc_bottom:
317: (20)                               toc_tokens.append({
318: (24)                                   'level': int(el.tag[-1]),
319: (24)                                   'id': el.attrib["id"],
320: (24)                                   'name': name,
321: (24)                                   'html': innerhtml,
322: (24)                                   'data-toc-label': data_toc_label
323: (20)                               })
324: (16)                           if self.use_anchors:
325: (20)                               self.add_anchor(el, el.attrib["id"])
326: (16)                           if self.use_permalinks not in [False, None]:
327: (20)                               self.add_permalink(el, el.attrib["id"])
328: (8)                    toc_tokens = nest_toc_tokens(toc_tokens)
329: (8)                    div = self.build_toc_div(toc_tokens)
330: (8)                    if self.marker:
331: (12)                       self.replace_marker(doc, div)
332: (8)                    # serialize and attach to markdown instance.
333: (8)                    toc = self.md.serializer(div)
334: (8)                    for pp in self.md.postprocessors:
335: (12)                       toc = pp.run(toc)
336: (8)                    self.md.toc_tokens = toc_tokens
337: (8)                    self.md.toc = toc
338: (0)            class TocExtension(Extension):
339: (4)                TreeProcessorClass = TocTreeprocessor
340: (4)                def __init__(self, **kwargs):
341: (8)                    self.config = {
342: (12)                       'marker': [
343: (16)                           '[TOC]',
344: (16)                           'Text to find and replace with Table of Contents. Set to an empty string to disable. '
345: (16)                           'Default: `[TOC]`.'
346: (12)                       ],
347: (12)                       'title': [
348: (16)                           '', 'Title to insert into TOC `<div>`. Default: an empty string.'
349: (12)                       ],
350: (12)                       'title_class': [
351: (16)                           'toctitle', 'CSS class used for the title. Default: `toctitle`.'
352: (12)                       ],
353: (12)                       'toc_class': [
354: (16)                           'toc', 'CSS class(es) used for the link. Default: `toclink`.'
355: (12)                       ],
356: (12)                       'anchorlink': [
357: (16)                           False, 'True if header should be a self link. Default: `False`.'
358: (12)                       ],
359: (12)                       'anchorlink_class': [
360: (16)                           'toclink', 'CSS class(es) used for the link. Defaults: `toclink`.'
361: (12)                       ],
362: (12)                       'permalink': [
363: (16)                           0, 'True or link text if a Sphinx-style permalink should be added. Default: `False`.'
364: (12)                       ],
365: (12)                       'permalink_class': [
366: (16)                           'headerlink', 'CSS class(es) used for the link. Default: `headerlink`.'
367: (12)                       ],
368: (12)                       'permalink_title': [
369: (16)                           'Permanent link', 'Title attribute of the permalink. Default: `Permanent link`.'
370: (12)                       ],
371: (12)                       'permalink_leading': [
372: (16)                           False,
373: (16)                           'True if permalinks should be placed at start of the header, rather than end. Default: False.'
374: (12)                       ],
375: (12)                       'baselevel': ['1', 'Base level for headers. Default: `1`.'],
376: (12)                       'slugify': [
377: (16)                           slugify, 'Function to generate anchors based on header text. Default: `slugify`.'
378: (12)                       ],
379: (12)                       'separator': ['-', 'Word separator. Default: `-`.'],
380: (12)                       'toc_depth': [
381: (16)                           6,
382: (16)                           'Define the range of section levels to include in the Table of Contents. A single integer '
383: (16)                           '(b) defines the bottom section level (<h1>..<hb>) only. A string consisting of two digits '
384: (16)                           'separated by a hyphen in between (`2-5`) defines the top (t) and the bottom (b) (<ht>..<hb>). '
385: (16)                           'Default: `6` (bottom).'
386: (12)                       ],
387: (8)                    }
388: (8)                    """ Default configuration options. """
389: (8)                    super().__init__(**kwargs)
390: (4)                def extendMarkdown(self, md):
391: (8)                    """ Add TOC tree processor to Markdown. """
392: (8)                    md.registerExtension(self)
393: (8)                    self.md = md
394: (8)                    self.reset()
395: (8)                    tocext = self.TreeProcessorClass(md, self.getConfigs())
396: (8)                    md.treeprocessors.register(tocext, 'toc', 5)
397: (4)                def reset(self) -> None:
398: (8)                    self.md.toc = ''
399: (8)                    self.md.toc_tokens = []
400: (0)            def makeExtension(**kwargs):  # pragma: no cover
401: (4)                return TocExtension(**kwargs)

----------------------------------------

File 33 - .\extensions \wikilinks.py:

1: (0)              # WikiLinks Extension for Python-Markdown
2: (0)              # ======================================
3: (0)              # Converts [[WikiLinks]] to relative links.
4: (0)              # See https://Python-Markdown.github.io/extensions/wikilinks
5: (0)              # for documentation.
6: (0)              # Original code Copyright [Waylan Limberg](http://achinghead.com/).
7: (0)              # All changes Copyright The Python Markdown Project
8: (0)              # License: [BSD](https://opensource.org/licenses/bsd-license.php)
9: (0)              """
10: (0)             Converts `[[WikiLinks]]` to relative links.
11: (0)             See the [documentation](https://Python-Markdown.github.io/extensions/wikilinks)
12: (0)             for details.
13: (0)             """
14: (0)             from __future__ import annotations
15: (0)             from . import Extension
16: (0)             from ..inlinepatterns import InlineProcessor
17: (0)             import xml.etree.ElementTree as etree
18: (0)             import re
19: (0)             from typing import Any
20: (0)             def build_url(label: str, base: str, end: str) -> str:
21: (4)                 """ Build a URL from the label, a base, and an end. """
22: (4)                 clean_label = re.sub(r'([ ]+_)|(_[ ]+)|([ ]+)', '_', label)
23: (4)                 return '{}{}{}'.format(base, clean_label, end)
24: (0)             class WikiLinkExtension(Extension):
25: (4)                 """ Add inline processor to Markdown. """
26: (4)                 def __init__(self, **kwargs):
27: (8)                     self.config = {
28: (12)                        'base_url': ['/', 'String to append to beginning or URL.'],
29: (12)                        'end_url': ['/', 'String to append to end of URL.'],
30: (12)                        'html_class': ['wikilink', 'CSS hook. Leave blank for none.'],
31: (12)                        'build_url': [build_url, 'Callable formats URL from label.'],
32: (8)                     }
33: (8)                     """ Default configuration options. """
34: (8)                     super().__init__(**kwargs)
35: (4)                 def extendMarkdown(self, md):
36: (8)                     self.md = md
37: (8)                     # append to end of inline patterns
38: (8)                     WIKILINK_RE = r'\[\[([\w0-9_ -]+)\]\]'
39: (8)                     wikilinkPattern = WikiLinksInlineProcessor(WIKILINK_RE, self.getConfigs())
40: (8)                     wikilinkPattern.md = md
41: (8)                     md.inlinePatterns.register(wikilinkPattern, 'wikilink', 75)
42: (0)             class WikiLinksInlineProcessor(InlineProcessor):
43: (4)                 """ Build link from `wikilink`. """
44: (4)                 def __init__(self, pattern: str, config: dict[str, Any]):
45: (8)                     super().__init__(pattern)
46: (8)                     self.config = config
47: (4)                 def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | str, int, int]:
48: (8)                     if m.group(1).strip():
49: (12)                        base_url, end_url, html_class = self._getMeta()
50: (12)                        label = m.group(1).strip()
51: (12)                        url = self.config['build_url'](label, base_url, end_url)
52: (12)                        a = etree.Element('a')
53: (12)                        a.text = label
54: (12)                        a.set('href', url)
55: (12)                        if html_class:
56: (16)                            a.set('class', html_class)
57: (8)                     else:
58: (12)                        a = ''
59: (8)                     return a, m.start(0), m.end(0)
60: (4)                 def _getMeta(self) -> tuple[str, str, str]:
61: (8)                     """ Return meta data or `config` data. """
62: (8)                     base_url = self.config['base_url']
63: (8)                     end_url = self.config['end_url']
64: (8)                     html_class = self.config['html_class']
65: (8)                     if hasattr(self.md, 'Meta'):
66: (12)                        if 'wiki_base_url' in self.md.Meta:
67: (16)                            base_url = self.md.Meta['wiki_base_url'][0]
68: (12)                        if 'wiki_end_url' in self.md.Meta:
69: (16)                            end_url = self.md.Meta['wiki_end_url'][0]
70: (12)                        if 'wiki_html_class' in self.md.Meta:
71: (16)                            html_class = self.md.Meta['wiki_html_class'][0]
72: (8)                     return base_url, end_url, html_class
73: (0)             def makeExtension(**kwargs):  # pragma: no cover
74: (4)                 return WikiLinkExtension(**kwargs)

----------------------------------------

File 34 - . \SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRYCOMBINER_aligner_20_characters_for_pythons_codes.py:

1: (0)              import os
2: (0)              from datetime import datetime
3: (0)              def get_file_info(root_folder):
4: (4)                  file_info_list = []
5: (4)                  for root, dirs, files in os.walk(root_folder):
6: (8)                      for file in files:
7: (12)                         try:
8: (16)                             # Check if the file is a Python file
9: (16)                             if file.endswith('.py'):
10: (20)                                file_path = os.path.join(root, file)
11: (20)                                # Get file times
12: (20)                                creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
13: (20)                                modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))
14: (20)                                # Get file extension
15: (20)                                file_extension = os.path.splitext(file)[1].lower()
16: (20)                                # Append file info to list
17: (20)                                file_info_list.append([file, file_path, creation_time, modified_time, file_extension, root])
18: (12)                        except Exception as e:
19: (16)                            print(f"Error processing file {file}: {e}")
20: (4)                 # Sort the files by multiple criteria
21: (4)                 file_info_list.sort(key=lambda x: (x[2], x[3], len(x[0]), x[4]))  # Sort by creation, modification time, name length, extension
22: (4)                 return file_info_list
23: (0)             def process_file(file_info_list):
24: (4)                 combined_output = []
25: (4)                 for idx, (file_name, file_path, creation_time, modified_time, file_extension, root) in enumerate(file_info_list):
26: (8)                     with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
27: (12)                        content = f.read()
28: (12)                        # Remove Python comments and blank lines
29: (10)                      ###  content = "\n".join([line for line in content.split('\n') if line.strip() and not line.strip().startswith("#")])
30: (12)                        content = "\n".join([line for line in content.split('\n') if line.strip() ])###and not line.strip().startswith("#")
31: (12)                        # Replace tabs with spaces
32: (12)                        content = content.replace('\t', '    ')
33: (12)                        # Process each line
34: (12)                        processed_lines = []
35: (12)                        for i, line in enumerate(content.split('\n')):
36: (16)                            # Count the number of starting blank spaces
37: (16)                            leading_spaces = len(line) - len(line.lstrip(' '))
38: (16)                            # Create the line with line number and leading spaces count
39: (16)                            line_number_str = f"{i+1}: ({leading_spaces})"
40: (16)                            # Calculate padding to align the original code at the 61st character
41: (16)                            padding = ' ' * (20 - len(line_number_str))
42: (16)                            processed_line = f"{line_number_str}{padding}{line}"
43: (16)                            processed_lines.append(processed_line)
44: (12)                        content_with_line_numbers = "\n".join(processed_lines)
45: (12)                        # Add file listing order and line number
46: (12)                        combined_output.append(f"File {idx + 1} - {root} \\{file_name}:\n")
47: (12)                        combined_output.append(content_with_line_numbers)
48: (12)                        combined_output.append("\n" + "-"*40 + "\n")
49: (4)                 return combined_output
50: (0)             # Set the root folder path
51: (0)             root_folder_path = '.'  # Set this to the desired folder
52: (0)             # Get file information and process files
53: (0)             file_info_list = get_file_info(root_folder_path)
54: (0)             combined_output = process_file(file_info_list)
55: (0)             # Save the processed data to an output file
56: (0)             output_file = 'WITHRELPATH_COMMENTSKEPT_SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRY_combined_python_files_20_chars.txt'
57: (0)             with open(output_file, 'w', encoding='utf-8') as logfile:
58: (4)                 logfile.write("\n".join(combined_output))
59: (0)             print(f"Processed file info logged to {output_file}")

----------------------------------------
