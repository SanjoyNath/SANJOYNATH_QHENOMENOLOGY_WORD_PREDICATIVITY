File 1 - . \scene.py:

1: (0)              """Basic canvas for animations."""
2: (0)              from __future__ import annotations
3: (0)              from manim.utils.parameter_parsing import flatten_iterable_parameters
4: (0)              __all__ = ["Scene"]
5: (0)              import copy
6: (0)              import datetime
7: (0)              import inspect
8: (0)              import platform
9: (0)              import random
10: (0)             import threading
11: (0)             import time
12: (0)             import types
13: (0)             from queue import Queue
14: (0)             import srt
15: (0)             from manim.scene.section import DefaultSectionType
16: (0)             try:
17: (4)                 import dearpygui.dearpygui as dpg
18: (4)                 dearpygui_imported = True
19: (0)             except ImportError:
20: (4)                 dearpygui_imported = False
21: (0)             from typing import TYPE_CHECKING
22: (0)             import numpy as np
23: (0)             from tqdm import tqdm
24: (0)             from watchdog.events import FileSystemEventHandler
25: (0)             from watchdog.observers import Observer
26: (0)             from manim.mobject.mobject import Mobject
27: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLPoint
28: (0)             from .. import config, logger
29: (0)             from ..animation.animation import Animation, Wait, prepare_animation
30: (0)             from ..camera.camera import Camera
31: (0)             from ..constants import *
32: (0)             from ..gui.gui import configure_pygui
33: (0)             from ..renderer.cairo_renderer import CairoRenderer
34: (0)             from ..renderer.opengl_renderer import OpenGLRenderer
35: (0)             from ..renderer.shader import Object3D
36: (0)             from ..utils import opengl, space_ops
37: (0)             from ..utils.exceptions import EndSceneEarlyException, RerunSceneException
38: (0)             from ..utils.family import extract_mobject_family_members
39: (0)             from ..utils.family_ops import restructure_list_to_exclude_certain_family_members
40: (0)             from ..utils.file_ops import open_media_file
41: (0)             from ..utils.iterables import list_difference_update, list_update
42: (0)             if TYPE_CHECKING:
43: (4)                 from typing import Callable, Iterable
44: (0)             class RerunSceneHandler(FileSystemEventHandler):
45: (4)                 """A class to handle rerunning a Scene after the input file is modified."""
46: (4)                 def __init__(self, queue):
47: (8)                     super().__init__()
48: (8)                     self.queue = queue
49: (4)                 def on_modified(self, event):
50: (8)                     self.queue.put(("rerun_file", [], {}))
51: (0)             class Scene:
52: (4)                 """A Scene is the canvas of your animation.
53: (4)                 The primary role of :class:`Scene` is to provide the user with tools to manage
54: (4)                 mobjects and animations.  Generally speaking, a manim script consists of a class
55: (4)                 that derives from :class:`Scene` whose :meth:`Scene.construct` method is overridden
56: (4)                 by the user's code.
57: (4)                 Mobjects are displayed on screen by calling :meth:`Scene.add` and removed from
58: (4)                 screen by calling :meth:`Scene.remove`.  All mobjects currently on screen are kept
59: (4)                 in :attr:`Scene.mobjects`.  Animations are played by calling :meth:`Scene.play`.
60: (4)                 A :class:`Scene` is rendered internally by calling :meth:`Scene.render`.  This in
61: (4)                 turn calls :meth:`Scene.setup`, :meth:`Scene.construct`, and
62: (4)                 :meth:`Scene.tear_down`, in that order.
63: (4)                 It is not recommended to override the ``__init__`` method in user Scenes.  For code
64: (4)                 that should be ran before a Scene is rendered, use :meth:`Scene.setup` instead.
65: (4)                 Examples
66: (4)                 --------
67: (4)                 Override the :meth:`Scene.construct` method with your code.
68: (4)                 .. code-block:: python
69: (8)                     class MyScene(Scene):
70: (12)                        def construct(self):
71: (16)                            self.play(Write(Text("Hello World!")))
72: (4)                 """
73: (4)                 def __init__(
74: (8)                     self,
75: (8)                     renderer=None,
76: (8)                     camera_class=Camera,
77: (8)                     always_update_mobjects=False,
78: (8)                     random_seed=None,
79: (8)                     skip_animations=False,
80: (4)                 ):
81: (8)                     self.camera_class = camera_class
82: (8)                     self.always_update_mobjects = always_update_mobjects
83: (8)                     self.random_seed = random_seed
84: (8)                     self.skip_animations = skip_animations
85: (8)                     self.animations = None
86: (8)                     self.stop_condition = None
87: (8)                     self.moving_mobjects = []
88: (8)                     self.static_mobjects = []
89: (8)                     self.time_progression = None
90: (8)                     self.duration = None
91: (8)                     self.last_t = None
92: (8)                     self.queue = Queue()
93: (8)                     self.skip_animation_preview = False
94: (8)                     self.meshes = []
95: (8)                     self.camera_target = ORIGIN
96: (8)                     self.widgets = []
97: (8)                     self.dearpygui_imported = dearpygui_imported
98: (8)                     self.updaters = []
99: (8)                     self.point_lights = []
100: (8)                    self.ambient_light = None
101: (8)                    self.key_to_function_map = {}
102: (8)                    self.mouse_press_callbacks = []
103: (8)                    self.interactive_mode = False
104: (8)                    if config.renderer == RendererType.OPENGL:
105: (12)                       # Items associated with interaction
106: (12)                       self.mouse_point = OpenGLPoint()
107: (12)                       self.mouse_drag_point = OpenGLPoint()
108: (12)                       if renderer is None:
109: (16)                           renderer = OpenGLRenderer()
110: (8)                    if renderer is None:
111: (12)                       self.renderer = CairoRenderer(
112: (16)                           camera_class=self.camera_class,
113: (16)                           skip_animations=self.skip_animations,
114: (12)                       )
115: (8)                    else:
116: (12)                       self.renderer = renderer
117: (8)                    self.renderer.init_scene(self)
118: (8)                    self.mobjects = []
119: (8)                    # TODO, remove need for foreground mobjects
120: (8)                    self.foreground_mobjects = []
121: (8)                    if self.random_seed is not None:
122: (12)                       random.seed(self.random_seed)
123: (12)                       np.random.seed(self.random_seed)
124: (4)                @property
125: (4)                def camera(self):
126: (8)                    return self.renderer.camera
127: (4)                def __deepcopy__(self, clone_from_id):
128: (8)                    cls = self.__class__
129: (8)                    result = cls.__new__(cls)
130: (8)                    clone_from_id[id(self)] = result
131: (8)                    for k, v in self.__dict__.items():
132: (12)                       if k in ["renderer", "time_progression"]:
133: (16)                           continue
134: (12)                       if k == "camera_class":
135: (16)                           setattr(result, k, v)
136: (12)                       setattr(result, k, copy.deepcopy(v, clone_from_id))
137: (8)                    result.mobject_updater_lists = []
138: (8)                    # Update updaters
139: (8)                    for mobject in self.mobjects:
140: (12)                       cloned_updaters = []
141: (12)                       for updater in mobject.updaters:
142: (16)                           # Make the cloned updater use the cloned Mobjects as free variables
143: (16)                           # rather than the original ones. Analyzing function bytecode with the
144: (16)                           # dis module will help in understanding this.
145: (16)                           # https://docs.python.org/3/library/dis.html
146: (16)                           # TODO: Do the same for function calls recursively.
147: (16)                           free_variable_map = inspect.getclosurevars(updater).nonlocals
148: (16)                           cloned_co_freevars = []
149: (16)                           cloned_closure = []
150: (16)                           for free_variable_name in updater.__code__.co_freevars:
151: (20)                               free_variable_value = free_variable_map[free_variable_name]
152: (20)                               # If the referenced variable has not been cloned, raise.
153: (20)                               if id(free_variable_value) not in clone_from_id:
154: (24)                                   raise Exception(
155: (28)                                       f"{free_variable_name} is referenced from an updater "
156: (28)                                       "but is not an attribute of the Scene, which isn't "
157: (28)                                       "allowed.",
158: (24)                                   )
159: (20)                               # Add the cloned object's name to the free variable list.
160: (20)                               cloned_co_freevars.append(free_variable_name)
161: (20)                               # Add a cell containing the cloned object's reference to the
162: (20)                               # closure list.
163: (20)                               cloned_closure.append(
164: (24)                                   types.CellType(clone_from_id[id(free_variable_value)]),
165: (20)                               )
166: (16)                           cloned_updater = types.FunctionType(
167: (20)                               updater.__code__.replace(co_freevars=tuple(cloned_co_freevars)),
168: (20)                               updater.__globals__,
169: (20)                               updater.__name__,
170: (20)                               updater.__defaults__,
171: (20)                               tuple(cloned_closure),
172: (16)                           )
173: (16)                           cloned_updaters.append(cloned_updater)
174: (12)                       mobject_clone = clone_from_id[id(mobject)]
175: (12)                       mobject_clone.updaters = cloned_updaters
176: (12)                       if len(cloned_updaters) > 0:
177: (16)                           result.mobject_updater_lists.append((mobject_clone, cloned_updaters))
178: (8)                    return result
179: (4)                def render(self, preview: bool = False):
180: (8)                    """
181: (8)                    Renders this Scene.
182: (8)                    Parameters
183: (8)                    ---------
184: (8)                    preview
185: (12)                       If true, opens scene in a file viewer.
186: (8)                    """
187: (8)                    self.setup()
188: (8)                    try:
189: (12)                       self.construct()
190: (8)                    except EndSceneEarlyException:
191: (12)                       pass
192: (8)                    except RerunSceneException as e:
193: (12)                       self.remove(*self.mobjects)
194: (12)                       self.renderer.clear_screen()
195: (12)                       self.renderer.num_plays = 0
196: (12)                       return True
197: (8)                    self.tear_down()
198: (8)                    # We have to reset these settings in case of multiple renders.
199: (8)                    self.renderer.scene_finished(self)
200: (8)                    # Show info only if animations are rendered or to get image
201: (8)                    if (
202: (12)                       self.renderer.num_plays
203: (12)                       or config["format"] == "png"
204: (12)                       or config["save_last_frame"]
205: (8)                    ):
206: (12)                       logger.info(
207: (16)                           f"Rendered {str(self)}\nPlayed {self.renderer.num_plays} animations",
208: (12)                       )
209: (8)                    # If preview open up the render after rendering.
210: (8)                    if preview:
211: (12)                       config["preview"] = True
212: (8)                    if config["preview"] or config["show_in_file_browser"]:
213: (12)                       open_media_file(self.renderer.file_writer)
214: (4)                def setup(self):
215: (8)                    """
216: (8)                    This is meant to be implemented by any scenes which
217: (8)                    are commonly subclassed, and have some common setup
218: (8)                    involved before the construct method is called.
219: (8)                    """
220: (8)                    pass
221: (4)                def tear_down(self):
222: (8)                    """
223: (8)                    This is meant to be implemented by any scenes which
224: (8)                    are commonly subclassed, and have some common method
225: (8)                    to be invoked before the scene ends.
226: (8)                    """
227: (8)                    pass
228: (4)                def construct(self):
229: (8)                    """Add content to the Scene.
230: (8)                    From within :meth:`Scene.construct`, display mobjects on screen by calling
231: (8)                    :meth:`Scene.add` and remove them from screen by calling :meth:`Scene.remove`.
232: (8)                    All mobjects currently on screen are kept in :attr:`Scene.mobjects`.  Play
233: (8)                    animations by calling :meth:`Scene.play`.
234: (8)                    Notes
235: (8)                    -----
236: (8)                    Initialization code should go in :meth:`Scene.setup`.  Termination code should
237: (8)                    go in :meth:`Scene.tear_down`.
238: (8)                    Examples
239: (8)                    --------
240: (8)                    A typical manim script includes a class derived from :class:`Scene` with an
241: (8)                    overridden :meth:`Scene.construct` method:
242: (8)                    .. code-block:: python
243: (12)                       class MyScene(Scene):
244: (16)                           def construct(self):
245: (20)                               self.play(Write(Text("Hello World!")))
246: (8)                    See Also
247: (8)                    --------
248: (8)                    :meth:`Scene.setup`
249: (8)                    :meth:`Scene.render`
250: (8)                    :meth:`Scene.tear_down`
251: (8)                    """
252: (8)                    pass  # To be implemented in subclasses
253: (4)                def next_section(
254: (8)                    self,
255: (8)                    name: str = "unnamed",
256: (8)                    type: str = DefaultSectionType.NORMAL,
257: (8)                    skip_animations: bool = False,
258: (4)                ) -> None:
259: (8)                    """Create separation here; the last section gets finished and a new one gets created.
260: (8)                    ``skip_animations`` skips the rendering of all animations in this section.
261: (8)                    Refer to :doc:`the documentation</tutorials/output_and_config>` on how to use sections.
262: (8)                    """
263: (8)                    self.renderer.file_writer.next_section(name, type, skip_animations)
264: (4)                def __str__(self):
265: (8)                    return self.__class__.__name__
266: (4)                def get_attrs(self, *keys: str):
267: (8)                    """
268: (8)                    Gets attributes of a scene given the attribute's identifier/name.
269: (8)                    Parameters
270: (8)                    ----------
271: (8)                    *keys
272: (12)                       Name(s) of the argument(s) to return the attribute of.
273: (8)                    Returns
274: (8)                    -------
275: (8)                    list
276: (12)                       List of attributes of the passed identifiers.
277: (8)                    """
278: (8)                    return [getattr(self, key) for key in keys]
279: (4)                def update_mobjects(self, dt: float):
280: (8)                    """
281: (8)                    Begins updating all mobjects in the Scene.
282: (8)                    Parameters
283: (8)                    ----------
284: (8)                    dt
285: (12)                       Change in time between updates. Defaults (mostly) to 1/frames_per_second
286: (8)                    """
287: (8)                    for mobject in self.mobjects:
288: (12)                       mobject.update(dt)
289: (4)                def update_meshes(self, dt):
290: (8)                    for obj in self.meshes:
291: (12)                       for mesh in obj.get_family():
292: (16)                           mesh.update(dt)
293: (4)                def update_self(self, dt: float):
294: (8)                    """Run all scene updater functions.
295: (8)                    Among all types of update functions (mobject updaters, mesh updaters,
296: (8)                    scene updaters), scene update functions are called last.
297: (8)                    Parameters
298: (8)                    ----------
299: (8)                    dt
300: (12)                       Scene time since last update.
301: (8)                    See Also
302: (8)                    --------
303: (8)                    :meth:`.Scene.add_updater`
304: (8)                    :meth:`.Scene.remove_updater`
305: (8)                    """
306: (8)                    for func in self.updaters:
307: (12)                       func(dt)
308: (4)                def should_update_mobjects(self) -> bool:
309: (8)                    """
310: (8)                    Returns True if the mobjects of this scene should be updated.
311: (8)                    In particular, this checks whether
312: (8)                    - the :attr:`always_update_mobjects` attribute of :class:`.Scene`
313: (10)                     is set to ``True``,
314: (8)                    - the :class:`.Scene` itself has time-based updaters attached,
315: (8)                    - any mobject in this :class:`.Scene` has time-based updaters attached.
316: (8)                    This is only called when a single Wait animation is played.
317: (8)                    """
318: (8)                    wait_animation = self.animations[0]
319: (8)                    if wait_animation.is_static_wait is None:
320: (12)                       should_update = (
321: (16)                           self.always_update_mobjects
322: (16)                           or self.updaters
323: (16)                           or wait_animation.stop_condition is not None
324: (16)                           or any(
325: (20)                               mob.has_time_based_updater()
326: (20)                               for mob in self.get_mobject_family_members()
327: (16)                           )
328: (12)                       )
329: (12)                       wait_animation.is_static_wait = not should_update
330: (8)                    return not wait_animation.is_static_wait
331: (4)                def get_top_level_mobjects(self):
332: (8)                    """
333: (8)                    Returns all mobjects which are not submobjects.
334: (8)                    Returns
335: (8)                    -------
336: (8)                    list
337: (12)                       List of top level mobjects.
338: (8)                    """
339: (8)                    # Return only those which are not in the family
340: (8)                    # of another mobject from the scene
341: (8)                    families = [m.get_family() for m in self.mobjects]
342: (8)                    def is_top_level(mobject):
343: (12)                       num_families = sum((mobject in family) for family in families)
344: (12)                       return num_families == 1
345: (8)                    return list(filter(is_top_level, self.mobjects))
346: (4)                def get_mobject_family_members(self):
347: (8)                    """
348: (8)                    Returns list of family-members of all mobjects in scene.
349: (8)                    If a Circle() and a VGroup(Rectangle(),Triangle()) were added,
350: (8)                    it returns not only the Circle(), Rectangle() and Triangle(), but
351: (8)                    also the VGroup() object.
352: (8)                    Returns
353: (8)                    -------
354: (8)                    list
355: (12)                       List of mobject family members.
356: (8)                    """
357: (8)                    if config.renderer == RendererType.OPENGL:
358: (12)                       family_members = []
359: (12)                       for mob in self.mobjects:
360: (16)                           family_members.extend(mob.get_family())
361: (12)                       return family_members
362: (8)                    elif config.renderer == RendererType.CAIRO:
363: (12)                       return extract_mobject_family_members(
364: (16)                           self.mobjects,
365: (16)                           use_z_index=self.renderer.camera.use_z_index,
366: (12)                       )
367: (4)                def add(self, *mobjects: Mobject):
368: (8)                    """
369: (8)                    Mobjects will be displayed, from background to
370: (8)                    foreground in the order with which they are added.
371: (8)                    Parameters
372: (8)                    ---------
373: (8)                    *mobjects
374: (12)                       Mobjects to add.
375: (8)                    Returns
376: (8)                    -------
377: (8)                    Scene
378: (12)                       The same scene after adding the Mobjects in.
379: (8)                    """
380: (8)                    if config.renderer == RendererType.OPENGL:
381: (12)                       new_mobjects = []
382: (12)                       new_meshes = []
383: (12)                       for mobject_or_mesh in mobjects:
384: (16)                           if isinstance(mobject_or_mesh, Object3D):
385: (20)                               new_meshes.append(mobject_or_mesh)
386: (16)                           else:
387: (20)                               new_mobjects.append(mobject_or_mesh)
388: (12)                       self.remove(*new_mobjects)
389: (12)                       self.mobjects += new_mobjects
390: (12)                       self.remove(*new_meshes)
391: (12)                       self.meshes += new_meshes
392: (8)                    elif config.renderer == RendererType.CAIRO:
393: (12)                       mobjects = [*mobjects, *self.foreground_mobjects]
394: (12)                       self.restructure_mobjects(to_remove=mobjects)
395: (12)                       self.mobjects += mobjects
396: (12)                       if self.moving_mobjects:
397: (16)                           self.restructure_mobjects(
398: (20)                               to_remove=mobjects,
399: (20)                               mobject_list_name="moving_mobjects",
400: (16)                           )
401: (16)                           self.moving_mobjects += mobjects
402: (8)                    return self
403: (4)                def add_mobjects_from_animations(self, animations):
404: (8)                    curr_mobjects = self.get_mobject_family_members()
405: (8)                    for animation in animations:
406: (12)                       if animation.is_introducer():
407: (16)                           continue
408: (12)                       # Anything animated that's not already in the
409: (12)                       # scene gets added to the scene
410: (12)                       mob = animation.mobject
411: (12)                       if mob is not None and mob not in curr_mobjects:
412: (16)                           self.add(mob)
413: (16)                           curr_mobjects += mob.get_family()
414: (4)                def remove(self, *mobjects: Mobject):
415: (8)                    """
416: (8)                    Removes mobjects in the passed list of mobjects
417: (8)                    from the scene and the foreground, by removing them
418: (8)                    from "mobjects" and "foreground_mobjects"
419: (8)                    Parameters
420: (8)                    ----------
421: (8)                    *mobjects
422: (12)                       The mobjects to remove.
423: (8)                    """
424: (8)                    if config.renderer == RendererType.OPENGL:
425: (12)                       mobjects_to_remove = []
426: (12)                       meshes_to_remove = set()
427: (12)                       for mobject_or_mesh in mobjects:
428: (16)                           if isinstance(mobject_or_mesh, Object3D):
429: (20)                               meshes_to_remove.add(mobject_or_mesh)
430: (16)                           else:
431: (20)                               mobjects_to_remove.append(mobject_or_mesh)
432: (12)                       self.mobjects = restructure_list_to_exclude_certain_family_members(
433: (16)                           self.mobjects,
434: (16)                           mobjects_to_remove,
435: (12)                       )
436: (12)                       self.meshes = list(
437: (16)                           filter(lambda mesh: mesh not in set(meshes_to_remove), self.meshes),
438: (12)                       )
439: (12)                       return self
440: (8)                    elif config.renderer == RendererType.CAIRO:
441: (12)                       for list_name in "mobjects", "foreground_mobjects":
442: (16)                           self.restructure_mobjects(mobjects, list_name, False)
443: (12)                       return self
444: (4)                def replace(self, old_mobject: Mobject, new_mobject: Mobject) -> None:
445: (8)                    """Replace one mobject in the scene with another, preserving draw order.
446: (8)                    If ``old_mobject`` is a submobject of some other Mobject (e.g. a
447: (8)                    :class:`.Group`), the new_mobject will replace it inside the group,
448: (8)                    without otherwise changing the parent mobject.
449: (8)                    Parameters
450: (8)                    ----------
451: (8)                    old_mobject
452: (12)                       The mobject to be replaced. Must be present in the scene.
453: (8)                    new_mobject
454: (12)                       A mobject which must not already be in the scene.
455: (8)                    """
456: (8)                    if old_mobject is None or new_mobject is None:
457: (12)                       raise ValueError("Specified mobjects cannot be None")
458: (8)                    def replace_in_list(
459: (12)                       mobj_list: list[Mobject], old_m: Mobject, new_m: Mobject
460: (8)                    ) -> bool:
461: (12)                       # We use breadth-first search because some Mobjects get very deep and
462: (12)                       # we expect top-level elements to be the most common targets for replace.
463: (12)                       for i in range(0, len(mobj_list)):
464: (16)                           # Is this the old mobject?
465: (16)                           if mobj_list[i] == old_m:
466: (20)                               # If so, write the new object to the same spot and stop looking.
467: (20)                               mobj_list[i] = new_m
468: (20)                               return True
469: (12)                       # Now check all the children of all these mobs.
470: (12)                       for mob in mobj_list:  # noqa: SIM110
471: (16)                           if replace_in_list(mob.submobjects, old_m, new_m):
472: (20)                               # If we found it in a submobject, stop looking.
473: (20)                               return True
474: (12)                       # If we did not find the mobject in the mobject list or any submobjects,
475: (12)                       # (or the list was empty), indicate we did not make the replacement.
476: (12)                       return False
477: (8)                    # Make use of short-circuiting conditionals to check mobjects and then
478: (8)                    # foreground_mobjects
479: (8)                    replaced = replace_in_list(
480: (12)                       self.mobjects, old_mobject, new_mobject
481: (8)                    ) or replace_in_list(self.foreground_mobjects, old_mobject, new_mobject)
482: (8)                    if not replaced:
483: (12)                       raise ValueError(f"Could not find {old_mobject} in scene")
484: (4)                def add_updater(self, func: Callable[[float], None]) -> None:
485: (8)                    """Add an update function to the scene.
486: (8)                    The scene updater functions are run every frame,
487: (8)                    and they are the last type of updaters to run.
488: (8)                    .. WARNING::
489: (12)                       When using the Cairo renderer, scene updaters that
490: (12)                       modify mobjects are not detected in the same way
491: (12)                       that mobject updaters are. To be more concrete,
492: (12)                       a mobject only modified via a scene updater will
493: (12)                       not necessarily be added to the list of *moving
494: (12)                       mobjects* and thus might not be updated every frame.
495: (12)                       TL;DR: Use mobject updaters to update mobjects.
496: (8)                    Parameters
497: (8)                    ----------
498: (8)                    func
499: (12)                       The updater function. It takes a float, which is the
500: (12)                       time difference since the last update (usually equal
501: (12)                       to the frame rate).
502: (8)                    See also
503: (8)                    --------
504: (8)                    :meth:`.Scene.remove_updater`
505: (8)                    :meth:`.Scene.update_self`
506: (8)                    """
507: (8)                    self.updaters.append(func)
508: (4)                def remove_updater(self, func: Callable[[float], None]) -> None:
509: (8)                    """Remove an update function from the scene.
510: (8)                    Parameters
511: (8)                    ----------
512: (8)                    func
513: (12)                       The updater function to be removed.
514: (8)                    See also
515: (8)                    --------
516: (8)                    :meth:`.Scene.add_updater`
517: (8)                    :meth:`.Scene.update_self`
518: (8)                    """
519: (8)                    self.updaters = [f for f in self.updaters if f is not func]
520: (4)                def restructure_mobjects(
521: (8)                    self,
522: (8)                    to_remove: Mobject,
523: (8)                    mobject_list_name: str = "mobjects",
524: (8)                    extract_families: bool = True,
525: (4)                ):
526: (8)                    """
527: (8)                    tl:wr
528: (12)                       If your scene has a Group(), and you removed a mobject from the Group,
529: (12)                       this dissolves the group and puts the rest of the mobjects directly
530: (12)                       in self.mobjects or self.foreground_mobjects.
531: (8)                    In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
532: (8)                    of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
533: (8)                    will be edited to contain other submobjects, but not m1, e.g. it will now
534: (8)                    insert m2 and m3 to where the group once was.
535: (8)                    Parameters
536: (8)                    ----------
537: (8)                    to_remove
538: (12)                       The Mobject to remove.
539: (8)                    mobject_list_name
540: (12)                       The list of mobjects ("mobjects", "foreground_mobjects" etc) to remove from.
541: (8)                    extract_families
542: (12)                       Whether the mobject's families should be recursively extracted.
543: (8)                    Returns
544: (8)                    -------
545: (8)                    Scene
546: (12)                       The Scene mobject with restructured Mobjects.
547: (8)                    """
548: (8)                    if extract_families:
549: (12)                       to_remove = extract_mobject_family_members(
550: (16)                           to_remove,
551: (16)                           use_z_index=self.renderer.camera.use_z_index,
552: (12)                       )
553: (8)                    _list = getattr(self, mobject_list_name)
554: (8)                    new_list = self.get_restructured_mobject_list(_list, to_remove)
555: (8)                    setattr(self, mobject_list_name, new_list)
556: (8)                    return self
557: (4)                def get_restructured_mobject_list(self, mobjects: list, to_remove: list):
558: (8)                    """
559: (8)                    Given a list of mobjects and a list of mobjects to be removed, this
560: (8)                    filters out the removable mobjects from the list of mobjects.
561: (8)                    Parameters
562: (8)                    ----------
563: (8)                    mobjects
564: (12)                       The Mobjects to check.
565: (8)                    to_remove
566: (12)                       The list of mobjects to remove.
567: (8)                    Returns
568: (8)                    -------
569: (8)                    list
570: (12)                       The list of mobjects with the mobjects to remove removed.
571: (8)                    """
572: (8)                    new_mobjects = []
573: (8)                    def add_safe_mobjects_from_list(list_to_examine, set_to_remove):
574: (12)                       for mob in list_to_examine:
575: (16)                           if mob in set_to_remove:
576: (20)                               continue
577: (16)                           intersect = set_to_remove.intersection(mob.get_family())
578: (16)                           if intersect:
579: (20)                               add_safe_mobjects_from_list(mob.submobjects, intersect)
580: (16)                           else:
581: (20)                               new_mobjects.append(mob)
582: (8)                    add_safe_mobjects_from_list(mobjects, set(to_remove))
583: (8)                    return new_mobjects
584: (4)                # TODO, remove this, and calls to this
585: (4)                def add_foreground_mobjects(self, *mobjects: Mobject):
586: (8)                    """
587: (8)                    Adds mobjects to the foreground, and internally to the list
588: (8)                    foreground_mobjects, and mobjects.
589: (8)                    Parameters
590: (8)                    ----------
591: (8)                    *mobjects
592: (12)                       The Mobjects to add to the foreground.
593: (8)                    Returns
594: (8)                    ------
595: (8)                    Scene
596: (12)                       The Scene, with the foreground mobjects added.
597: (8)                    """
598: (8)                    self.foreground_mobjects = list_update(self.foreground_mobjects, mobjects)
599: (8)                    self.add(*mobjects)
600: (8)                    return self
601: (4)                def add_foreground_mobject(self, mobject: Mobject):
602: (8)                    """
603: (8)                    Adds a single mobject to the foreground, and internally to the list
604: (8)                    foreground_mobjects, and mobjects.
605: (8)                    Parameters
606: (8)                    ----------
607: (8)                    mobject
608: (12)                       The Mobject to add to the foreground.
609: (8)                    Returns
610: (8)                    ------
611: (8)                    Scene
612: (12)                       The Scene, with the foreground mobject added.
613: (8)                    """
614: (8)                    return self.add_foreground_mobjects(mobject)
615: (4)                def remove_foreground_mobjects(self, *to_remove: Mobject):
616: (8)                    """
617: (8)                    Removes mobjects from the foreground, and internally from the list
618: (8)                    foreground_mobjects.
619: (8)                    Parameters
620: (8)                    ----------
621: (8)                    *to_remove
622: (12)                       The mobject(s) to remove from the foreground.
623: (8)                    Returns
624: (8)                    ------
625: (8)                    Scene
626: (12)                       The Scene, with the foreground mobjects removed.
627: (8)                    """
628: (8)                    self.restructure_mobjects(to_remove, "foreground_mobjects")
629: (8)                    return self
630: (4)                def remove_foreground_mobject(self, mobject: Mobject):
631: (8)                    """
632: (8)                    Removes a single mobject from the foreground, and internally from the list
633: (8)                    foreground_mobjects.
634: (8)                    Parameters
635: (8)                    ----------
636: (8)                    mobject
637: (12)                       The mobject to remove from the foreground.
638: (8)                    Returns
639: (8)                    ------
640: (8)                    Scene
641: (12)                       The Scene, with the foreground mobject removed.
642: (8)                    """
643: (8)                    return self.remove_foreground_mobjects(mobject)
644: (4)                def bring_to_front(self, *mobjects: Mobject):
645: (8)                    """
646: (8)                    Adds the passed mobjects to the scene again,
647: (8)                    pushing them to he front of the scene.
648: (8)                    Parameters
649: (8)                    ----------
650: (8)                    *mobjects
651: (12)                       The mobject(s) to bring to the front of the scene.
652: (8)                    Returns
653: (8)                    ------
654: (8)                    Scene
655: (12)                       The Scene, with the mobjects brought to the front
656: (12)                       of the scene.
657: (8)                    """
658: (8)                    self.add(*mobjects)
659: (8)                    return self
660: (4)                def bring_to_back(self, *mobjects: Mobject):
661: (8)                    """
662: (8)                    Removes the mobject from the scene and
663: (8)                    adds them to the back of the scene.
664: (8)                    Parameters
665: (8)                    ----------
666: (8)                    *mobjects
667: (12)                       The mobject(s) to push to the back of the scene.
668: (8)                    Returns
669: (8)                    ------
670: (8)                    Scene
671: (12)                       The Scene, with the mobjects pushed to the back
672: (12)                       of the scene.
673: (8)                    """
674: (8)                    self.remove(*mobjects)
675: (8)                    self.mobjects = list(mobjects) + self.mobjects
676: (8)                    return self
677: (4)                def clear(self):
678: (8)                    """
679: (8)                    Removes all mobjects present in self.mobjects
680: (8)                    and self.foreground_mobjects from the scene.
681: (8)                    Returns
682: (8)                    ------
683: (8)                    Scene
684: (12)                       The Scene, with all of its mobjects in
685: (12)                       self.mobjects and self.foreground_mobjects
686: (12)                       removed.
687: (8)                    """
688: (8)                    self.mobjects = []
689: (8)                    self.foreground_mobjects = []
690: (8)                    return self
691: (4)                def get_moving_mobjects(self, *animations: Animation):
692: (8)                    """
693: (8)                    Gets all moving mobjects in the passed animation(s).
694: (8)                    Parameters
695: (8)                    ----------
696: (8)                    *animations
697: (12)                       The animations to check for moving mobjects.
698: (8)                    Returns
699: (8)                    ------
700: (8)                    list
701: (12)                       The list of mobjects that could be moving in
702: (12)                       the Animation(s)
703: (8)                    """
704: (8)                    # Go through mobjects from start to end, and
705: (8)                    # as soon as there's one that needs updating of
706: (8)                    # some kind per frame, return the list from that
707: (8)                    # point forward.
708: (8)                    animation_mobjects = [anim.mobject for anim in animations]
709: (8)                    mobjects = self.get_mobject_family_members()
710: (8)                    for i, mob in enumerate(mobjects):
711: (12)                       update_possibilities = [
712: (16)                           mob in animation_mobjects,
713: (16)                           len(mob.get_family_updaters()) > 0,
714: (16)                           mob in self.foreground_mobjects,
715: (12)                       ]
716: (12)                       if any(update_possibilities):
717: (16)                           return mobjects[i:]
718: (8)                    return []
719: (4)                def get_moving_and_static_mobjects(self, animations):
720: (8)                    all_mobjects = list_update(self.mobjects, self.foreground_mobjects)
721: (8)                    all_mobject_families = extract_mobject_family_members(
722: (12)                       all_mobjects,
723: (12)                       use_z_index=self.renderer.camera.use_z_index,
724: (12)                       only_those_with_points=True,
725: (8)                    )
726: (8)                    moving_mobjects = self.get_moving_mobjects(*animations)
727: (8)                    all_moving_mobject_families = extract_mobject_family_members(
728: (12)                       moving_mobjects,
729: (12)                       use_z_index=self.renderer.camera.use_z_index,
730: (8)                    )
731: (8)                    static_mobjects = list_difference_update(
732: (12)                       all_mobject_families,
733: (12)                       all_moving_mobject_families,
734: (8)                    )
735: (8)                    return all_moving_mobject_families, static_mobjects
736: (4)                def compile_animations(
737: (8)                    self,
738: (8)                    *args: Animation | Iterable[Animation] | types.GeneratorType[Animation],
739: (8)                    **kwargs,
740: (4)                ):
741: (8)                    """
742: (8)                    Creates _MethodAnimations from any _AnimationBuilders and updates animation
743: (8)                    kwargs with kwargs passed to play().
744: (8)                    Parameters
745: (8)                    ----------
746: (8)                    *args
747: (12)                       Animations to be played.
748: (8)                    **kwargs
749: (12)                       Configuration for the call to play().
750: (8)                    Returns
751: (8)                    -------
752: (8)                    Tuple[:class:`Animation`]
753: (12)                       Animations to be played.
754: (8)                    """
755: (8)                    animations = []
756: (8)                    arg_anims = flatten_iterable_parameters(args)
757: (8)                    # Allow passing a generator to self.play instead of comma separated arguments
758: (8)                    for arg in arg_anims:
759: (12)                       try:
760: (16)                           animations.append(prepare_animation(arg))
761: (12)                       except TypeError:
762: (16)                           if inspect.ismethod(arg):
763: (20)                               raise TypeError(
764: (24)                                   "Passing Mobject methods to Scene.play is no longer"
765: (24)                                   " supported. Use Mobject.animate instead.",
766: (20)                               )
767: (16)                           else:
768: (20)                               raise TypeError(
769: (24)                                   f"Unexpected argument {arg} passed to Scene.play().",
770: (20)                               )
771: (8)                    for animation in animations:
772: (12)                       for k, v in kwargs.items():
773: (16)                           setattr(animation, k, v)
774: (8)                    return animations
775: (4)                def _get_animation_time_progression(
776: (8)                    self, animations: list[Animation], duration: float
777: (4)                ):
778: (8)                    """
779: (8)                    You will hardly use this when making your own animations.
780: (8)                    This method is for Manim's internal use.
781: (8)                    Uses :func:`~.get_time_progression` to obtain a
782: (8)                    CommandLine ProgressBar whose ``fill_time`` is
783: (8)                    dependent on the qualities of the passed Animation,
784: (8)                    Parameters
785: (8)                    ----------
786: (8)                    animations
787: (12)                       The list of animations to get
788: (12)                       the time progression for.
789: (8)                    duration
790: (12)                       duration of wait time
791: (8)                    Returns
792: (8)                    -------
793: (8)                    time_progression
794: (12)                       The CommandLine Progress Bar.
795: (8)                    """
796: (8)                    if len(animations) == 1 and isinstance(animations[0], Wait):
797: (12)                       stop_condition = animations[0].stop_condition
798: (12)                       if stop_condition is not None:
799: (16)                           time_progression = self.get_time_progression(
800: (20)                               duration,
801: (20)                               f"Waiting for {stop_condition.__name__}",
802: (20)                               n_iterations=-1,  # So it doesn't show % progress
803: (20)                               override_skip_animations=True,
804: (16)                           )
805: (12)                       else:
806: (16)                           time_progression = self.get_time_progression(
807: (20)                               duration,
808: (20)                               f"Waiting {self.renderer.num_plays}",
809: (16)                           )
810: (8)                    else:
811: (12)                       time_progression = self.get_time_progression(
812: (16)                           duration,
813: (16)                           "".join(
814: (20)                               [
815: (24)                                   f"Animation {self.renderer.num_plays}: ",
816: (24)                                   str(animations[0]),
817: (24)                                   (", etc." if len(animations) > 1 else ""),
818: (20)                               ],
819: (16)                           ),
820: (12)                       )
821: (8)                    return time_progression
822: (4)                def get_time_progression(
823: (8)                    self,
824: (8)                    run_time: float,
825: (8)                    description,
826: (8)                    n_iterations: int | None = None,
827: (8)                    override_skip_animations: bool = False,
828: (4)                ):
829: (8)                    """
830: (8)                    You will hardly use this when making your own animations.
831: (8)                    This method is for Manim's internal use.
832: (8)                    Returns a CommandLine ProgressBar whose ``fill_time``
833: (8)                    is dependent on the ``run_time`` of an animation,
834: (8)                    the iterations to perform in that animation
835: (8)                    and a bool saying whether or not to consider
836: (8)                    the skipped animations.
837: (8)                    Parameters
838: (8)                    ----------
839: (8)                    run_time
840: (12)                       The ``run_time`` of the animation.
841: (8)                    n_iterations
842: (12)                       The number of iterations in the animation.
843: (8)                    override_skip_animations
844: (12)                       Whether or not to show skipped animations in the progress bar.
845: (8)                    Returns
846: (8)                    -------
847: (8)                    time_progression
848: (12)                       The CommandLine Progress Bar.
849: (8)                    """
850: (8)                    if self.renderer.skip_animations and not override_skip_animations:
851: (12)                       times = [run_time]
852: (8)                    else:
853: (12)                       step = 1 / config["frame_rate"]
854: (12)                       times = np.arange(0, run_time, step)
855: (8)                    time_progression = tqdm(
856: (12)                       times,
857: (12)                       desc=description,
858: (12)                       total=n_iterations,
859: (12)                       leave=config["progress_bar"] == "leave",
860: (12)                       ascii=True if platform.system() == "Windows" else None,
861: (12)                       disable=config["progress_bar"] == "none",
862: (8)                    )
863: (8)                    return time_progression
864: (4)                def get_run_time(self, animations: list[Animation]):
865: (8)                    """
866: (8)                    Gets the total run time for a list of animations.
867: (8)                    Parameters
868: (8)                    ----------
869: (8)                    animations
870: (12)                       A list of the animations whose total
871: (12)                       ``run_time`` is to be calculated.
872: (8)                    Returns
873: (8)                    -------
874: (8)                    float
875: (12)                       The total ``run_time`` of all of the animations in the list.
876: (8)                    """
877: (8)                    if len(animations) == 1 and isinstance(animations[0], Wait):
878: (12)                       return animations[0].duration
879: (8)                    else:
880: (12)                       return np.max([animation.run_time for animation in animations])
881: (4)                def play(
882: (8)                    self,
883: (8)                    *args: Animation | Iterable[Animation] | types.GeneratorType[Animation],
884: (8)                    subcaption=None,
885: (8)                    subcaption_duration=None,
886: (8)                    subcaption_offset=0,
887: (8)                    **kwargs,
888: (4)                ):
889: (8)                    r"""Plays an animation in this scene.
890: (8)                    Parameters
891: (8)                    ----------
892: (8)                    args
893: (12)                       Animations to be played.
894: (8)                    subcaption
895: (12)                       The content of the external subcaption that should
896: (12)                       be added during the animation.
897: (8)                    subcaption_duration
898: (12)                       The duration for which the specified subcaption is
899: (12)                       added. If ``None`` (the default), the run time of the
900: (12)                       animation is taken.
901: (8)                    subcaption_offset
902: (12)                       An offset (in seconds) for the start time of the
903: (12)                       added subcaption.
904: (8)                    kwargs
905: (12)                       All other keywords are passed to the renderer.
906: (8)                    """
907: (8)                    # If we are in interactive embedded mode, make sure this is running on the main thread (required for OpenGL)
908: (8)                    if (
909: (12)                       self.interactive_mode
910: (12)                       and config.renderer == RendererType.OPENGL
911: (12)                       and threading.current_thread().name != "MainThread"
912: (8)                    ):
913: (12)                       kwargs.update(
914: (16)                           {
915: (20)                               "subcaption": subcaption,
916: (20)                               "subcaption_duration": subcaption_duration,
917: (20)                               "subcaption_offset": subcaption_offset,
918: (16)                           }
919: (12)                       )
920: (12)                       self.queue.put(
921: (16)                           (
922: (20)                               "play",
923: (20)                               args,
924: (20)                               kwargs,
925: (16)                           )
926: (12)                       )
927: (12)                       return
928: (8)                    start_time = self.renderer.time
929: (8)                    self.renderer.play(self, *args, **kwargs)
930: (8)                    run_time = self.renderer.time - start_time
931: (8)                    if subcaption:
932: (12)                       if subcaption_duration is None:
933: (16)                           subcaption_duration = run_time
934: (12)                       # The start of the subcaption needs to be offset by the
935: (12)                       # run_time of the animation because it is added after
936: (12)                       # the animation has already been played (and Scene.renderer.time
937: (12)                       # has already been updated).
938: (12)                       self.add_subcaption(
939: (16)                           content=subcaption,
940: (16)                           duration=subcaption_duration,
941: (16)                           offset=-run_time + subcaption_offset,
942: (12)                       )
943: (4)                def wait(
944: (8)                    self,
945: (8)                    duration: float = DEFAULT_WAIT_TIME,
946: (8)                    stop_condition: Callable[[], bool] | None = None,
947: (8)                    frozen_frame: bool | None = None,
948: (4)                ):
949: (8)                    """Plays a "no operation" animation.
950: (8)                    Parameters
951: (8)                    ----------
952: (8)                    duration
953: (12)                       The run time of the animation.
954: (8)                    stop_condition
955: (12)                       A function without positional arguments that is evaluated every time
956: (12)                       a frame is rendered. The animation only stops when the return value
957: (12)                       of the function is truthy, or when the time specified in ``duration``
958: (12)                       passes.
959: (8)                    frozen_frame
960: (12)                       If True, updater functions are not evaluated, and the animation outputs
961: (12)                       a frozen frame. If False, updater functions are called and frames
962: (12)                       are rendered as usual. If None (the default), the scene tries to
963: (12)                       determine whether or not the frame is frozen on its own.
964: (8)                    See also
965: (8)                    --------
966: (8)                    :class:`.Wait`, :meth:`.should_mobjects_update`
967: (8)                    """
968: (8)                    self.play(
969: (12)                       Wait(
970: (16)                           run_time=duration,
971: (16)                           stop_condition=stop_condition,
972: (16)                           frozen_frame=frozen_frame,
973: (12)                       )
974: (8)                    )
975: (4)                def pause(self, duration: float = DEFAULT_WAIT_TIME):
976: (8)                    """Pauses the scene (i.e., displays a frozen frame).
977: (8)                    This is an alias for :meth:`.wait` with ``frozen_frame``
978: (8)                    set to ``True``.
979: (8)                    Parameters
980: (8)                    ----------
981: (8)                    duration
982: (12)                       The duration of the pause.
983: (8)                    See also
984: (8)                    --------
985: (8)                    :meth:`.wait`, :class:`.Wait`
986: (8)                    """
987: (8)                    self.wait(duration=duration, frozen_frame=True)
988: (4)                def wait_until(self, stop_condition: Callable[[], bool], max_time: float = 60):
989: (8)                    """Wait until a condition is satisfied, up to a given maximum duration.
990: (8)                    Parameters
991: (8)                    ----------
992: (8)                    stop_condition
993: (12)                       A function with no arguments that determines whether or not the
994: (12)                       scene should keep waiting.
995: (8)                    max_time
996: (12)                       The maximum wait time in seconds.
997: (8)                    """
998: (8)                    self.wait(max_time, stop_condition=stop_condition)
999: (4)                def compile_animation_data(
1000: (8)                   self,
1001: (8)                   *animations: Animation | Iterable[Animation] | types.GeneratorType[Animation],
1002: (8)                   **play_kwargs,
1003: (4)               ):
1004: (8)                   """Given a list of animations, compile the corresponding
1005: (8)                   static and moving mobjects, and gather the animation durations.
1006: (8)                   This also begins the animations.
1007: (8)                   Parameters
1008: (8)                   ----------
1009: (8)                   animations
1010: (12)                      Animation or mobject with mobject method and params
1011: (8)                   play_kwargs
1012: (12)                      Named parameters affecting what was passed in ``animations``,
1013: (12)                      e.g. ``run_time``, ``lag_ratio`` and so on.
1014: (8)                   Returns
1015: (8)                   -------
1016: (8)                   self, None
1017: (12)                      None if there is nothing to play, or self otherwise.
1018: (8)                   """
1019: (8)                   # NOTE TODO : returns statement of this method are wrong. It should return nothing, as it makes a little sense to get any information from this method.
1020: (8)                   # The return are kept to keep webgl renderer from breaking.
1021: (8)                   if len(animations) == 0:
1022: (12)                      raise ValueError("Called Scene.play with no animations")
1023: (8)                   self.animations = self.compile_animations(*animations, **play_kwargs)
1024: (8)                   self.add_mobjects_from_animations(self.animations)
1025: (8)                   self.last_t = 0
1026: (8)                   self.stop_condition = None
1027: (8)                   self.moving_mobjects = []
1028: (8)                   self.static_mobjects = []
1029: (8)                   if len(self.animations) == 1 and isinstance(self.animations[0], Wait):
1030: (12)                      if self.should_update_mobjects():
1031: (16)                          self.update_mobjects(dt=0)  # Any problems with this?
1032: (16)                          self.stop_condition = self.animations[0].stop_condition
1033: (12)                      else:
1034: (16)                          self.duration = self.animations[0].duration
1035: (16)                          # Static image logic when the wait is static is done by the renderer, not here.
1036: (16)                          self.animations[0].is_static_wait = True
1037: (16)                          return None
1038: (8)                   self.duration = self.get_run_time(self.animations)
1039: (8)                   return self
1040: (4)               def begin_animations(self) -> None:
1041: (8)                   """Start the animations of the scene."""
1042: (8)                   for animation in self.animations:
1043: (12)                      animation._setup_scene(self)
1044: (12)                      animation.begin()
1045: (8)                   if config.renderer == RendererType.CAIRO:
1046: (12)                      # Paint all non-moving objects onto the screen, so they don't
1047: (12)                      # have to be rendered every frame
1048: (12)                      (
1049: (16)                          self.moving_mobjects,
1050: (16)                          self.static_mobjects,
1051: (12)                      ) = self.get_moving_and_static_mobjects(self.animations)
1052: (4)               def is_current_animation_frozen_frame(self) -> bool:
1053: (8)                   """Returns whether the current animation produces a static frame (generally a Wait)."""
1054: (8)                   return (
1055: (12)                      isinstance(self.animations[0], Wait)
1056: (12)                      and len(self.animations) == 1
1057: (12)                      and self.animations[0].is_static_wait
1058: (8)                   )
1059: (4)               def play_internal(self, skip_rendering: bool = False):
1060: (8)                   """
1061: (8)                   This method is used to prep the animations for rendering,
1062: (8)                   apply the arguments and parameters required to them,
1063: (8)                   render them, and write them to the video file.
1064: (8)                   Parameters
1065: (8)                   ----------
1066: (8)                   skip_rendering
1067: (12)                      Whether the rendering should be skipped, by default False
1068: (8)                   """
1069: (8)                   self.duration = self.get_run_time(self.animations)
1070: (8)                   self.time_progression = self._get_animation_time_progression(
1071: (12)                      self.animations,
1072: (12)                      self.duration,
1073: (8)                   )
1074: (8)                   for t in self.time_progression:
1075: (12)                      self.update_to_time(t)
1076: (12)                      if not skip_rendering and not self.skip_animation_preview:
1077: (16)                          self.renderer.render(self, t, self.moving_mobjects)
1078: (12)                      if self.stop_condition is not None and self.stop_condition():
1079: (16)                          self.time_progression.close()
1080: (16)                          break
1081: (8)                   for animation in self.animations:
1082: (12)                      animation.finish()
1083: (12)                      animation.clean_up_from_scene(self)
1084: (8)                   if not self.renderer.skip_animations:
1085: (12)                      self.update_mobjects(0)
1086: (8)                   self.renderer.static_image = None
1087: (8)                   # Closing the progress bar at the end of the play.
1088: (8)                   self.time_progression.close()
1089: (4)               def check_interactive_embed_is_valid(self):
1090: (8)                   if config["force_window"]:
1091: (12)                      return True
1092: (8)                   if self.skip_animation_preview:
1093: (12)                      logger.warning(
1094: (16)                          "Disabling interactive embed as 'skip_animation_preview' is enabled",
1095: (12)                      )
1096: (12)                      return False
1097: (8)                   elif config["write_to_movie"]:
1098: (12)                      logger.warning("Disabling interactive embed as 'write_to_movie' is enabled")
1099: (12)                      return False
1100: (8)                   elif config["format"]:
1101: (12)                      logger.warning(
1102: (16)                          "Disabling interactive embed as '--format' is set as "
1103: (16)                          + config["format"],
1104: (12)                      )
1105: (12)                      return False
1106: (8)                   elif not self.renderer.window:
1107: (12)                      logger.warning("Disabling interactive embed as no window was created")
1108: (12)                      return False
1109: (8)                   elif config.dry_run:
1110: (12)                      logger.warning("Disabling interactive embed as dry_run is enabled")
1111: (12)                      return False
1112: (8)                   return True
1113: (4)               def interactive_embed(self):
1114: (8)                   """
1115: (8)                   Like embed(), but allows for screen interaction.
1116: (8)                   """
1117: (8)                   if not self.check_interactive_embed_is_valid():
1118: (12)                      return
1119: (8)                   self.interactive_mode = True
1120: (8)                   def ipython(shell, namespace):
1121: (12)                      import manim.opengl
1122: (12)                      def load_module_into_namespace(module, namespace):
1123: (16)                          for name in dir(module):
1124: (20)                              namespace[name] = getattr(module, name)
1125: (12)                      load_module_into_namespace(manim, namespace)
1126: (12)                      load_module_into_namespace(manim.opengl, namespace)
1127: (12)                      def embedded_rerun(*args, **kwargs):
1128: (16)                          self.queue.put(("rerun_keyboard", args, kwargs))
1129: (16)                          shell.exiter()
1130: (12)                      namespace["rerun"] = embedded_rerun
1131: (12)                      shell(local_ns=namespace)
1132: (12)                      self.queue.put(("exit_keyboard", [], {}))
1133: (8)                   def get_embedded_method(method_name):
1134: (12)                      return lambda *args, **kwargs: self.queue.put((method_name, args, kwargs))
1135: (8)                   local_namespace = inspect.currentframe().f_back.f_locals
1136: (8)                   for method in ("play", "wait", "add", "remove"):
1137: (12)                      embedded_method = get_embedded_method(method)
1138: (12)                      # Allow for calling scene methods without prepending 'self.'.
1139: (12)                      local_namespace[method] = embedded_method
1140: (8)                   from sqlite3 import connect
1141: (8)                   from IPython.core.getipython import get_ipython
1142: (8)                   from IPython.terminal.embed import InteractiveShellEmbed
1143: (8)                   from traitlets.config import Config
1144: (8)                   cfg = Config()
1145: (8)                   cfg.TerminalInteractiveShell.confirm_exit = False
1146: (8)                   if get_ipython() is None:
1147: (12)                      shell = InteractiveShellEmbed.instance(config=cfg)
1148: (8)                   else:
1149: (12)                      shell = InteractiveShellEmbed(config=cfg)
1150: (8)                   hist = get_ipython().history_manager
1151: (8)                   hist.db = connect(hist.hist_file, check_same_thread=False)
1152: (8)                   keyboard_thread = threading.Thread(
1153: (12)                      target=ipython,
1154: (12)                      args=(shell, local_namespace),
1155: (8)                   )
1156: (8)                   # run as daemon to kill thread when main thread exits
1157: (8)                   if not shell.pt_app:
1158: (12)                      keyboard_thread.daemon = True
1159: (8)                   keyboard_thread.start()
1160: (8)                   if self.dearpygui_imported and config["enable_gui"]:
1161: (12)                      if not dpg.is_dearpygui_running():
1162: (16)                          gui_thread = threading.Thread(
1163: (20)                              target=configure_pygui,
1164: (20)                              args=(self.renderer, self.widgets),
1165: (20)                              kwargs={"update": False},
1166: (16)                          )
1167: (16)                          gui_thread.start()
1168: (12)                      else:
1169: (16)                          configure_pygui(self.renderer, self.widgets, update=True)
1170: (8)                   self.camera.model_matrix = self.camera.default_model_matrix
1171: (8)                   self.interact(shell, keyboard_thread)
1172: (4)               def interact(self, shell, keyboard_thread):
1173: (8)                   event_handler = RerunSceneHandler(self.queue)
1174: (8)                   file_observer = Observer()
1175: (8)                   file_observer.schedule(event_handler, config["input_file"], recursive=True)
1176: (8)                   file_observer.start()
1177: (8)                   self.quit_interaction = False
1178: (8)                   keyboard_thread_needs_join = shell.pt_app is not None
1179: (8)                   assert self.queue.qsize() == 0
1180: (8)                   last_time = time.time()
1181: (8)                   while not (self.renderer.window.is_closing or self.quit_interaction):
1182: (12)                      if not self.queue.empty():
1183: (16)                          tup = self.queue.get_nowait()
1184: (16)                          if tup[0].startswith("rerun"):
1185: (20)                              # Intentionally skip calling join() on the file thread to save time.
1186: (20)                              if not tup[0].endswith("keyboard"):
1187: (24)                                  if shell.pt_app:
1188: (28)                                      shell.pt_app.app.exit(exception=EOFError)
1189: (24)                                  file_observer.unschedule_all()
1190: (24)                                  raise RerunSceneException
1191: (20)                              keyboard_thread.join()
1192: (20)                              kwargs = tup[2]
1193: (20)                              if "from_animation_number" in kwargs:
1194: (24)                                  config["from_animation_number"] = kwargs[
1195: (28)                                      "from_animation_number"
1196: (24)                                  ]
1197: (20)                              # # TODO: This option only makes sense if interactive_embed() is run at the
1198: (20)                              # # end of a scene by default.
1199: (20)                              # if "upto_animation_number" in kwargs:
1200: (20)                              #     config["upto_animation_number"] = kwargs[
1201: (20)                              #         "upto_animation_number"
1202: (20)                              #     ]
1203: (20)                              keyboard_thread.join()
1204: (20)                              file_observer.unschedule_all()
1205: (20)                              raise RerunSceneException
1206: (16)                          elif tup[0].startswith("exit"):
1207: (20)                              # Intentionally skip calling join() on the file thread to save time.
1208: (20)                              if not tup[0].endswith("keyboard") and shell.pt_app:
1209: (24)                                  shell.pt_app.app.exit(exception=EOFError)
1210: (20)                              keyboard_thread.join()
1211: (20)                              # Remove exit_keyboard from the queue if necessary.
1212: (20)                              while self.queue.qsize() > 0:
1213: (24)                                  self.queue.get()
1214: (20)                              keyboard_thread_needs_join = False
1215: (20)                              break
1216: (16)                          else:
1217: (20)                              method, args, kwargs = tup
1218: (20)                              getattr(self, method)(*args, **kwargs)
1219: (12)                      else:
1220: (16)                          self.renderer.animation_start_time = 0
1221: (16)                          dt = time.time() - last_time
1222: (16)                          last_time = time.time()
1223: (16)                          self.renderer.render(self, dt, self.moving_mobjects)
1224: (16)                          self.update_mobjects(dt)
1225: (16)                          self.update_meshes(dt)
1226: (16)                          self.update_self(dt)
1227: (8)                   # Join the keyboard thread if necessary.
1228: (8)                   if shell is not None and keyboard_thread_needs_join:
1229: (12)                      shell.pt_app.app.exit(exception=EOFError)
1230: (12)                      keyboard_thread.join()
1231: (12)                      # Remove exit_keyboard from the queue if necessary.
1232: (12)                      while self.queue.qsize() > 0:
1233: (16)                          self.queue.get()
1234: (8)                   file_observer.stop()
1235: (8)                   file_observer.join()
1236: (8)                   if self.dearpygui_imported and config["enable_gui"]:
1237: (12)                      dpg.stop_dearpygui()
1238: (8)                   if self.renderer.window.is_closing:
1239: (12)                      self.renderer.window.destroy()
1240: (4)               def embed(self):
1241: (8)                   if not config["preview"]:
1242: (12)                      logger.warning("Called embed() while no preview window is available.")
1243: (12)                      return
1244: (8)                   if config["write_to_movie"]:
1245: (12)                      logger.warning("embed() is skipped while writing to a file.")
1246: (12)                      return
1247: (8)                   self.renderer.animation_start_time = 0
1248: (8)                   self.renderer.render(self, -1, self.moving_mobjects)
1249: (8)                   # Configure IPython shell.
1250: (8)                   from IPython.terminal.embed import InteractiveShellEmbed
1251: (8)                   shell = InteractiveShellEmbed()
1252: (8)                   # Have the frame update after each command
1253: (8)                   shell.events.register(
1254: (12)                      "post_run_cell",
1255: (12)                      lambda *a, **kw: self.renderer.render(self, -1, self.moving_mobjects),
1256: (8)                   )
1257: (8)                   # Use the locals of the caller as the local namespace
1258: (8)                   # once embedded, and add a few custom shortcuts.
1259: (8)                   local_ns = inspect.currentframe().f_back.f_locals
1260: (8)                   # local_ns["touch"] = self.interact
1261: (8)                   for method in (
1262: (12)                      "play",
1263: (12)                      "wait",
1264: (12)                      "add",
1265: (12)                      "remove",
1266: (12)                      "interact",
1267: (12)                      # "clear",
1268: (12)                      # "save_state",
1269: (12)                      # "restore",
1270: (8)                   ):
1271: (12)                      local_ns[method] = getattr(self, method)
1272: (8)                   shell(local_ns=local_ns, stack_depth=2)
1273: (8)                   # End scene when exiting an embed.
1274: (8)                   raise Exception("Exiting scene.")
1275: (4)               def update_to_time(self, t):
1276: (8)                   dt = t - self.last_t
1277: (8)                   self.last_t = t
1278: (8)                   for animation in self.animations:
1279: (12)                      animation.update_mobjects(dt)
1280: (12)                      alpha = t / animation.run_time
1281: (12)                      animation.interpolate(alpha)
1282: (8)                   self.update_mobjects(dt)
1283: (8)                   self.update_meshes(dt)
1284: (8)                   self.update_self(dt)
1285: (4)               def add_subcaption(
1286: (8)                   self, content: str, duration: float = 1, offset: float = 0
1287: (4)               ) -> None:
1288: (8)                   r"""Adds an entry in the corresponding subcaption file
1289: (8)                   at the current time stamp.
1290: (8)                   The current time stamp is obtained from ``Scene.renderer.time``.
1291: (8)                   Parameters
1292: (8)                   ----------
1293: (8)                   content
1294: (12)                      The subcaption content.
1295: (8)                   duration
1296: (12)                      The duration (in seconds) for which the subcaption is shown.
1297: (8)                   offset
1298: (12)                      This offset (in seconds) is added to the starting time stamp
1299: (12)                      of the subcaption.
1300: (8)                   Examples
1301: (8)                   --------
1302: (8)                   This example illustrates both possibilities for adding
1303: (8)                   subcaptions to Manimations::
1304: (12)                      class SubcaptionExample(Scene):
1305: (16)                          def construct(self):
1306: (20)                              square = Square()
1307: (20)                              circle = Circle()
1308: (20)                              # first option: via the add_subcaption method
1309: (20)                              self.add_subcaption("Hello square!", duration=1)
1310: (20)                              self.play(Create(square))
1311: (20)                              # second option: within the call to Scene.play
1312: (20)                              self.play(
1313: (24)                                  Transform(square, circle),
1314: (24)                                  subcaption="The square transforms."
1315: (20)                              )
1316: (8)                   """
1317: (8)                   subtitle = srt.Subtitle(
1318: (12)                      index=len(self.renderer.file_writer.subcaptions),
1319: (12)                      content=content,
1320: (12)                      start=datetime.timedelta(seconds=float(self.renderer.time + offset)),
1321: (12)                      end=datetime.timedelta(
1322: (16)                          seconds=float(self.renderer.time + offset + duration)
1323: (12)                      ),
1324: (8)                   )
1325: (8)                   self.renderer.file_writer.subcaptions.append(subtitle)
1326: (4)               def add_sound(
1327: (8)                   self,
1328: (8)                   sound_file: str,
1329: (8)                   time_offset: float = 0,
1330: (8)                   gain: float | None = None,
1331: (8)                   **kwargs,
1332: (4)               ):
1333: (8)                   """
1334: (8)                   This method is used to add a sound to the animation.
1335: (8)                   Parameters
1336: (8)                   ----------
1337: (8)                   sound_file
1338: (12)                      The path to the sound file.
1339: (8)                   time_offset
1340: (12)                      The offset in the sound file after which
1341: (12)                      the sound can be played.
1342: (8)                   gain
1343: (12)                      Amplification of the sound.
1344: (8)                   Examples
1345: (8)                   --------
1346: (8)                   .. manim:: SoundExample
1347: (12)                      :no_autoplay:
1348: (12)                      class SoundExample(Scene):
1349: (16)                          # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/
1350: (16)                          def construct(self):
1351: (20)                              dot = Dot().set_color(GREEN)
1352: (20)                              self.add_sound("click.wav")
1353: (20)                              self.add(dot)
1354: (20)                              self.wait()
1355: (20)                              self.add_sound("click.wav")
1356: (20)                              dot.set_color(BLUE)
1357: (20)                              self.wait()
1358: (20)                              self.add_sound("click.wav")
1359: (20)                              dot.set_color(RED)
1360: (20)                              self.wait()
1361: (8)                   Download the resource for the previous example `here <https://github.com/ManimCommunity/manim/blob/main/docs/source/_static/click.wav>`_ .
1362: (8)                   """
1363: (8)                   if self.renderer.skip_animations:
1364: (12)                      return
1365: (8)                   time = self.renderer.time + time_offset
1366: (8)                   self.renderer.file_writer.add_sound(sound_file, time, gain, **kwargs)
1367: (4)               def on_mouse_motion(self, point, d_point):
1368: (8)                   self.mouse_point.move_to(point)
1369: (8)                   if SHIFT_VALUE in self.renderer.pressed_keys:
1370: (12)                      shift = -d_point
1371: (12)                      shift[0] *= self.camera.get_width() / 2
1372: (12)                      shift[1] *= self.camera.get_height() / 2
1373: (12)                      transform = self.camera.inverse_rotation_matrix
1374: (12)                      shift = np.dot(np.transpose(transform), shift)
1375: (12)                      self.camera.shift(shift)
1376: (4)               def on_mouse_scroll(self, point, offset):
1377: (8)                   if not config.use_projection_stroke_shaders:
1378: (12)                      factor = 1 + np.arctan(-2.1 * offset[1])
1379: (12)                      self.camera.scale(factor, about_point=self.camera_target)
1380: (8)                   self.mouse_scroll_orbit_controls(point, offset)
1381: (4)               def on_key_press(self, symbol, modifiers):
1382: (8)                   try:
1383: (12)                      char = chr(symbol)
1384: (8)                   except OverflowError:
1385: (12)                      logger.warning("The value of the pressed key is too large.")
1386: (12)                      return
1387: (8)                   if char == "r":
1388: (12)                      self.camera.to_default_state()
1389: (12)                      self.camera_target = np.array([0, 0, 0], dtype=np.float32)
1390: (8)                   elif char == "q":
1391: (12)                      self.quit_interaction = True
1392: (8)                   else:
1393: (12)                      if char in self.key_to_function_map:
1394: (16)                          self.key_to_function_map[char]()
1395: (4)               def on_key_release(self, symbol, modifiers):
1396: (8)                   pass
1397: (4)               def on_mouse_drag(self, point, d_point, buttons, modifiers):
1398: (8)                   self.mouse_drag_point.move_to(point)
1399: (8)                   if buttons == 1:
1400: (12)                      self.camera.increment_theta(-d_point[0])
1401: (12)                      self.camera.increment_phi(d_point[1])
1402: (8)                   elif buttons == 4:
1403: (12)                      camera_x_axis = self.camera.model_matrix[:3, 0]
1404: (12)                      horizontal_shift_vector = -d_point[0] * camera_x_axis
1405: (12)                      vertical_shift_vector = -d_point[1] * np.cross(OUT, camera_x_axis)
1406: (12)                      total_shift_vector = horizontal_shift_vector + vertical_shift_vector
1407: (12)                      self.camera.shift(1.1 * total_shift_vector)
1408: (8)                   self.mouse_drag_orbit_controls(point, d_point, buttons, modifiers)
1409: (4)               def mouse_scroll_orbit_controls(self, point, offset):
1410: (8)                   camera_to_target = self.camera_target - self.camera.get_position()
1411: (8)                   camera_to_target *= np.sign(offset[1])
1412: (8)                   shift_vector = 0.01 * camera_to_target
1413: (8)                   self.camera.model_matrix = (
1414: (12)                      opengl.translation_matrix(*shift_vector) @ self.camera.model_matrix
1415: (8)                   )
1416: (4)               def mouse_drag_orbit_controls(self, point, d_point, buttons, modifiers):
1417: (8)                   # Left click drag.
1418: (8)                   if buttons == 1:
1419: (12)                      # Translate to target the origin and rotate around the z axis.
1420: (12)                      self.camera.model_matrix = (
1421: (16)                          opengl.rotation_matrix(z=-d_point[0])
1422: (16)                          @ opengl.translation_matrix(*-self.camera_target)
1423: (16)                          @ self.camera.model_matrix
1424: (12)                      )
1425: (12)                      # Rotation off of the z axis.
1426: (12)                      camera_position = self.camera.get_position()
1427: (12)                      camera_y_axis = self.camera.model_matrix[:3, 1]
1428: (12)                      axis_of_rotation = space_ops.normalize(
1429: (16)                          np.cross(camera_y_axis, camera_position),
1430: (12)                      )
1431: (12)                      rotation_matrix = space_ops.rotation_matrix(
1432: (16)                          d_point[1],
1433: (16)                          axis_of_rotation,
1434: (16)                          homogeneous=True,
1435: (12)                      )
1436: (12)                      maximum_polar_angle = self.camera.maximum_polar_angle
1437: (12)                      minimum_polar_angle = self.camera.minimum_polar_angle
1438: (12)                      potential_camera_model_matrix = rotation_matrix @ self.camera.model_matrix
1439: (12)                      potential_camera_location = potential_camera_model_matrix[:3, 3]
1440: (12)                      potential_camera_y_axis = potential_camera_model_matrix[:3, 1]
1441: (12)                      sign = (
1442: (16)                          np.sign(potential_camera_y_axis[2])
1443: (16)                          if potential_camera_y_axis[2] != 0
1444: (16)                          else 1
1445: (12)                      )
1446: (12)                      potential_polar_angle = sign * np.arccos(
1447: (16)                          potential_camera_location[2]
1448: (16)                          / np.linalg.norm(potential_camera_location),
1449: (12)                      )
1450: (12)                      if minimum_polar_angle <= potential_polar_angle <= maximum_polar_angle:
1451: (16)                          self.camera.model_matrix = potential_camera_model_matrix
1452: (12)                      else:
1453: (16)                          sign = np.sign(camera_y_axis[2]) if camera_y_axis[2] != 0 else 1
1454: (16)                          current_polar_angle = sign * np.arccos(
1455: (20)                              camera_position[2] / np.linalg.norm(camera_position),
1456: (16)                          )
1457: (16)                          if potential_polar_angle > maximum_polar_angle:
1458: (20)                              polar_angle_delta = maximum_polar_angle - current_polar_angle
1459: (16)                          else:
1460: (20)                              polar_angle_delta = minimum_polar_angle - current_polar_angle
1461: (16)                          rotation_matrix = space_ops.rotation_matrix(
1462: (20)                              polar_angle_delta,
1463: (20)                              axis_of_rotation,
1464: (20)                              homogeneous=True,
1465: (16)                          )
1466: (16)                          self.camera.model_matrix = rotation_matrix @ self.camera.model_matrix
1467: (12)                      # Translate to target the original target.
1468: (12)                      self.camera.model_matrix = (
1469: (16)                          opengl.translation_matrix(*self.camera_target)
1470: (16)                          @ self.camera.model_matrix
1471: (12)                      )
1472: (8)                   # Right click drag.
1473: (8)                   elif buttons == 4:
1474: (12)                      camera_x_axis = self.camera.model_matrix[:3, 0]
1475: (12)                      horizontal_shift_vector = -d_point[0] * camera_x_axis
1476: (12)                      vertical_shift_vector = -d_point[1] * np.cross(OUT, camera_x_axis)
1477: (12)                      total_shift_vector = horizontal_shift_vector + vertical_shift_vector
1478: (12)                      self.camera.model_matrix = (
1479: (16)                          opengl.translation_matrix(*total_shift_vector)
1480: (16)                          @ self.camera.model_matrix
1481: (12)                      )
1482: (12)                      self.camera_target += total_shift_vector
1483: (4)               def set_key_function(self, char, func):
1484: (8)                   self.key_to_function_map[char] = func
1485: (4)               def on_mouse_press(self, point, button, modifiers):
1486: (8)                   for func in self.mouse_press_callbacks:
1487: (12)                      func()

----------------------------------------

File 2 - . \__init__.py:

1: (0)              

----------------------------------------

File 3 - . \moving_camera_scene.py:

1: (0)              """A scene whose camera can be moved around.
2: (0)              .. SEEALSO::
3: (4)                  :mod:`.moving_camera`
4: (0)              Examples
5: (0)              --------
6: (0)              .. manim:: ChangingCameraWidthAndRestore
7: (4)                  class ChangingCameraWidthAndRestore(MovingCameraScene):
8: (8)                      def construct(self):
9: (12)                         text = Text("Hello World").set_color(BLUE)
10: (12)                        self.add(text)
11: (12)                        self.camera.frame.save_state()
12: (12)                        self.play(self.camera.frame.animate.set(width=text.width * 1.2))
13: (12)                        self.wait(0.3)
14: (12)                        self.play(Restore(self.camera.frame))
15: (0)             .. manim:: MovingCameraCenter
16: (4)                 class MovingCameraCenter(MovingCameraScene):
17: (8)                     def construct(self):
18: (12)                        s = Square(color=RED, fill_opacity=0.5).move_to(2 * LEFT)
19: (12)                        t = Triangle(color=GREEN, fill_opacity=0.5).move_to(2 * RIGHT)
20: (12)                        self.wait(0.3)
21: (12)                        self.add(s, t)
22: (12)                        self.play(self.camera.frame.animate.move_to(s))
23: (12)                        self.wait(0.3)
24: (12)                        self.play(self.camera.frame.animate.move_to(t))
25: (0)             .. manim:: MovingAndZoomingCamera
26: (4)                 class MovingAndZoomingCamera(MovingCameraScene):
27: (8)                     def construct(self):
28: (12)                        s = Square(color=BLUE, fill_opacity=0.5).move_to(2 * LEFT)
29: (12)                        t = Triangle(color=YELLOW, fill_opacity=0.5).move_to(2 * RIGHT)
30: (12)                        self.add(s, t)
31: (12)                        self.play(self.camera.frame.animate.move_to(s).set(width=s.width*2))
32: (12)                        self.wait(0.3)
33: (12)                        self.play(self.camera.frame.animate.move_to(t).set(width=t.width*2))
34: (12)                        self.play(self.camera.frame.animate.move_to(ORIGIN).set(width=14))
35: (0)             .. manim:: MovingCameraOnGraph
36: (4)                 class MovingCameraOnGraph(MovingCameraScene):
37: (8)                     def construct(self):
38: (12)                        self.camera.frame.save_state()
39: (12)                        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])
40: (12)                        graph = ax.plot(lambda x: np.sin(x), color=WHITE, x_range=[0, 3 * PI])
41: (12)                        dot_1 = Dot(ax.i2gp(graph.t_min, graph))
42: (12)                        dot_2 = Dot(ax.i2gp(graph.t_max, graph))
43: (12)                        self.add(ax, graph, dot_1, dot_2)
44: (12)                        self.play(self.camera.frame.animate.scale(0.5).move_to(dot_1))
45: (12)                        self.play(self.camera.frame.animate.move_to(dot_2))
46: (12)                        self.play(Restore(self.camera.frame))
47: (12)                        self.wait()
48: (0)             """
49: (0)             from __future__ import annotations
50: (0)             __all__ = ["MovingCameraScene"]
51: (0)             from manim.animation.animation import Animation
52: (0)             from ..camera.moving_camera import MovingCamera
53: (0)             from ..scene.scene import Scene
54: (0)             from ..utils.family import extract_mobject_family_members
55: (0)             from ..utils.iterables import list_update
56: (0)             class MovingCameraScene(Scene):
57: (4)                 """
58: (4)                 This is a Scene, with special configurations and properties that
59: (4)                 make it suitable for cases where the camera must be moved around.
60: (4)                 .. SEEALSO::
61: (8)                     :class:`.MovingCamera`
62: (4)                 """
63: (4)                 def __init__(self, camera_class=MovingCamera, **kwargs):
64: (8)                     super().__init__(camera_class=camera_class, **kwargs)
65: (4)                 def get_moving_mobjects(self, *animations: Animation):
66: (8)                     """
67: (8)                     This method returns a list of all of the Mobjects in the Scene that
68: (8)                     are moving, that are also in the animations passed.
69: (8)                     Parameters
70: (8)                     ----------
71: (8)                     *animations
72: (12)                        The Animations whose mobjects will be checked.
73: (8)                     """
74: (8)                     moving_mobjects = super().get_moving_mobjects(*animations)
75: (8)                     all_moving_mobjects = extract_mobject_family_members(moving_mobjects)
76: (8)                     movement_indicators = self.renderer.camera.get_mobjects_indicating_movement()
77: (8)                     for movement_indicator in movement_indicators:
78: (12)                        if movement_indicator in all_moving_mobjects:
79: (16)                            # When one of these is moving, the camera should
80: (16)                            # consider all mobjects to be moving
81: (16)                            return list_update(self.mobjects, moving_mobjects)
82: (8)                     return moving_mobjects

----------------------------------------

File 4 - . \section.py:

1: (0)              """building blocks of segmented video API"""
2: (0)              from __future__ import annotations
3: (0)              from enum import Enum
4: (0)              from pathlib import Path
5: (0)              from typing import Any
6: (0)              from manim import get_video_metadata
7: (0)              __all__ = ["Section", "DefaultSectionType"]
8: (0)              class DefaultSectionType(str, Enum):
9: (4)                  """The type of a section can be used for third party applications.
10: (4)                 A presentation system could for example use the types to created loops.
11: (4)                 Examples
12: (4)                 --------
13: (4)                 This class can be reimplemented for more types::
14: (8)                     class PresentationSectionType(str, Enum):
15: (12)                        # start, end, wait for continuation by user
16: (12)                        NORMAL = "presentation.normal"
17: (12)                        # start, end, immediately continue to next section
18: (12)                        SKIP = "presentation.skip"
19: (12)                        # start, end, restart, immediately continue to next section when continued by user
20: (12)                        LOOP = "presentation.loop"
21: (12)                        # start, end, restart, finish animation first when user continues
22: (12)                        COMPLETE_LOOP = "presentation.complete_loop"
23: (4)                 """
24: (4)                 NORMAL = "default.normal"
25: (0)             class Section:
26: (4)                 """A :class:`.Scene` can be segmented into multiple Sections.
27: (4)                 Refer to :doc:`the documentation</tutorials/output_and_config>` for more info.
28: (4)                 It consists of multiple animations.
29: (4)                 Attributes
30: (4)                 ----------
31: (4)                 type
32: (8)                     Can be used by a third party applications to classify different types of sections.
33: (4)                 video
34: (8)                     Path to video file with animations belonging to section relative to sections directory.
35: (8)                     If ``None``, then the section will not be saved.
36: (4)                 name
37: (8)                     Human readable, non-unique name for this section.
38: (4)                 skip_animations
39: (8)                     Skip rendering the animations in this section when ``True``.
40: (4)                 partial_movie_files
41: (8)                     Animations belonging to this section.
42: (4)                 See Also
43: (4)                 --------
44: (4)                 :class:`.DefaultSectionType`
45: (4)                 :meth:`.CairoRenderer.update_skipping_status`
46: (4)                 :meth:`.OpenGLRenderer.update_skipping_status`
47: (4)                 """
48: (4)                 def __init__(self, type: str, video: str | None, name: str, skip_animations: bool):
49: (8)                     self.type = type
50: (8)                     # None when not to be saved -> still keeps section alive
51: (8)                     self.video: str | None = video
52: (8)                     self.name = name
53: (8)                     self.skip_animations = skip_animations
54: (8)                     self.partial_movie_files: list[str | None] = []
55: (4)                 def is_empty(self) -> bool:
56: (8)                     """Check whether this section is empty.
57: (8)                     Note that animations represented by ``None`` are also counted.
58: (8)                     """
59: (8)                     return len(self.partial_movie_files) == 0
60: (4)                 def get_clean_partial_movie_files(self) -> list[str]:
61: (8)                     """Return all partial movie files that are not ``None``."""
62: (8)                     return [el for el in self.partial_movie_files if el is not None]
63: (4)                 def get_dict(self, sections_dir: Path) -> dict[str, Any]:
64: (8)                     """Get dictionary representation with metadata of output video.
65: (8)                     The output from this function is used from every section to build the sections index file.
66: (8)                     The output video must have been created in the ``sections_dir`` before executing this method.
67: (8)                     This is the main part of the Segmented Video API.
68: (8)                     """
69: (8)                     if self.video is None:
70: (12)                        raise ValueError(
71: (16)                            f"Section '{self.name}' cannot be exported as dict, it does not have a video path assigned to it"
72: (12)                        )
73: (8)                     video_metadata = get_video_metadata(sections_dir / self.video)
74: (8)                     return dict(
75: (12)                        {
76: (16)                            "name": self.name,
77: (16)                            "type": self.type,
78: (16)                            "video": self.video,
79: (12)                        },
80: (12)                        **video_metadata,
81: (8)                     )
82: (4)                 def __repr__(self):
83: (8)                     return f"<Section '{self.name}' stored in '{self.video}'>"

----------------------------------------

File 5 - . \zoomed_scene.py:

1: (0)              """A scene supporting zooming in on a specified section.
2: (0)              Examples
3: (0)              --------
4: (0)              .. manim:: UseZoomedScene
5: (4)                  class UseZoomedScene(ZoomedScene):
6: (8)                      def construct(self):
7: (12)                         dot = Dot().set_color(GREEN)
8: (12)                         self.add(dot)
9: (12)                         self.wait(1)
10: (12)                        self.activate_zooming(animate=False)
11: (12)                        self.wait(1)
12: (12)                        self.play(dot.animate.shift(LEFT))
13: (0)             .. manim:: ChangingZoomScale
14: (4)                 class ChangingZoomScale(ZoomedScene):
15: (8)                     def __init__(self, **kwargs):
16: (12)                        ZoomedScene.__init__(
17: (16)                            self,
18: (16)                            zoom_factor=0.3,
19: (16)                            zoomed_display_height=1,
20: (16)                            zoomed_display_width=3,
21: (16)                            image_frame_stroke_width=20,
22: (16)                            zoomed_camera_config={
23: (20)                                "default_frame_stroke_width": 3,
24: (16)                            },
25: (16)                            **kwargs
26: (12)                        )
27: (8)                     def construct(self):
28: (12)                        dot = Dot().set_color(GREEN)
29: (12)                        sq = Circle(fill_opacity=1, radius=0.2).next_to(dot, RIGHT)
30: (12)                        self.add(dot, sq)
31: (12)                        self.wait(1)
32: (12)                        self.activate_zooming(animate=False)
33: (12)                        self.wait(1)
34: (12)                        self.play(dot.animate.shift(LEFT * 0.3))
35: (12)                        self.play(self.zoomed_camera.frame.animate.scale(4))
36: (12)                        self.play(self.zoomed_camera.frame.animate.shift(0.5 * DOWN))
37: (0)             """
38: (0)             from __future__ import annotations
39: (0)             __all__ = ["ZoomedScene"]
40: (0)             from ..animation.transform import ApplyMethod
41: (0)             from ..camera.moving_camera import MovingCamera
42: (0)             from ..camera.multi_camera import MultiCamera
43: (0)             from ..constants import *
44: (0)             from ..mobject.types.image_mobject import ImageMobjectFromCamera
45: (0)             from ..scene.moving_camera_scene import MovingCameraScene
46: (0)             # Note, any scenes from old videos using ZoomedScene will almost certainly
47: (0)             # break, as it was restructured.
48: (0)             class ZoomedScene(MovingCameraScene):
49: (4)                 """
50: (4)                 This is a Scene with special configurations made for when
51: (4)                 a particular part of the scene must be zoomed in on and displayed
52: (4)                 separately.
53: (4)                 """
54: (4)                 def __init__(
55: (8)                     self,
56: (8)                     camera_class=MultiCamera,
57: (8)                     zoomed_display_height=3,
58: (8)                     zoomed_display_width=3,
59: (8)                     zoomed_display_center=None,
60: (8)                     zoomed_display_corner=UP + RIGHT,
61: (8)                     zoomed_display_corner_buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER,
62: (8)                     zoomed_camera_config={
63: (12)                        "default_frame_stroke_width": 2,
64: (12)                        "background_opacity": 1,
65: (8)                     },
66: (8)                     zoomed_camera_image_mobject_config={},
67: (8)                     zoomed_camera_frame_starting_position=ORIGIN,
68: (8)                     zoom_factor=0.15,
69: (8)                     image_frame_stroke_width=3,
70: (8)                     zoom_activated=False,
71: (8)                     **kwargs,
72: (4)                 ):
73: (8)                     self.zoomed_display_height = zoomed_display_height
74: (8)                     self.zoomed_display_width = zoomed_display_width
75: (8)                     self.zoomed_display_center = zoomed_display_center
76: (8)                     self.zoomed_display_corner = zoomed_display_corner
77: (8)                     self.zoomed_display_corner_buff = zoomed_display_corner_buff
78: (8)                     self.zoomed_camera_config = zoomed_camera_config
79: (8)                     self.zoomed_camera_image_mobject_config = zoomed_camera_image_mobject_config
80: (8)                     self.zoomed_camera_frame_starting_position = (
81: (12)                        zoomed_camera_frame_starting_position
82: (8)                     )
83: (8)                     self.zoom_factor = zoom_factor
84: (8)                     self.image_frame_stroke_width = image_frame_stroke_width
85: (8)                     self.zoom_activated = zoom_activated
86: (8)                     super().__init__(camera_class=camera_class, **kwargs)
87: (4)                 def setup(self):
88: (8)                     """
89: (8)                     This method is used internally by Manim to
90: (8)                     setup the scene for proper use.
91: (8)                     """
92: (8)                     super().setup()
93: (8)                     # Initialize camera and display
94: (8)                     zoomed_camera = MovingCamera(**self.zoomed_camera_config)
95: (8)                     zoomed_display = ImageMobjectFromCamera(
96: (12)                        zoomed_camera, **self.zoomed_camera_image_mobject_config
97: (8)                     )
98: (8)                     zoomed_display.add_display_frame()
99: (8)                     for mob in zoomed_camera.frame, zoomed_display:
100: (12)                       mob.stretch_to_fit_height(self.zoomed_display_height)
101: (12)                       mob.stretch_to_fit_width(self.zoomed_display_width)
102: (8)                    zoomed_camera.frame.scale(self.zoom_factor)
103: (8)                    # Position camera and display
104: (8)                    zoomed_camera.frame.move_to(self.zoomed_camera_frame_starting_position)
105: (8)                    if self.zoomed_display_center is not None:
106: (12)                       zoomed_display.move_to(self.zoomed_display_center)
107: (8)                    else:
108: (12)                       zoomed_display.to_corner(
109: (16)                           self.zoomed_display_corner,
110: (16)                           buff=self.zoomed_display_corner_buff,
111: (12)                       )
112: (8)                    self.zoomed_camera = zoomed_camera
113: (8)                    self.zoomed_display = zoomed_display
114: (4)                def activate_zooming(self, animate: bool = False):
115: (8)                    """
116: (8)                    This method is used to activate the zooming for
117: (8)                    the zoomed_camera.
118: (8)                    Parameters
119: (8)                    ----------
120: (8)                    animate
121: (12)                       Whether or not to animate the activation
122: (12)                       of the zoomed camera.
123: (8)                    """
124: (8)                    self.zoom_activated = True
125: (8)                    self.renderer.camera.add_image_mobject_from_camera(self.zoomed_display)
126: (8)                    if animate:
127: (12)                       self.play(self.get_zoom_in_animation())
128: (12)                       self.play(self.get_zoomed_display_pop_out_animation())
129: (8)                    self.add_foreground_mobjects(
130: (12)                       self.zoomed_camera.frame,
131: (12)                       self.zoomed_display,
132: (8)                    )
133: (4)                def get_zoom_in_animation(self, run_time: float = 2, **kwargs):
134: (8)                    """
135: (8)                    Returns the animation of camera zooming in.
136: (8)                    Parameters
137: (8)                    ----------
138: (8)                    run_time
139: (12)                       The run_time of the animation of the camera zooming in.
140: (8)                    **kwargs
141: (12)                       Any valid keyword arguments of ApplyMethod()
142: (8)                    Returns
143: (8)                    -------
144: (8)                    ApplyMethod
145: (12)                       The animation of the camera zooming in.
146: (8)                    """
147: (8)                    frame = self.zoomed_camera.frame
148: (8)                    full_frame_height = self.camera.frame_height
149: (8)                    full_frame_width = self.camera.frame_width
150: (8)                    frame.save_state()
151: (8)                    frame.stretch_to_fit_width(full_frame_width)
152: (8)                    frame.stretch_to_fit_height(full_frame_height)
153: (8)                    frame.center()
154: (8)                    frame.set_stroke(width=0)
155: (8)                    return ApplyMethod(frame.restore, run_time=run_time, **kwargs)
156: (4)                def get_zoomed_display_pop_out_animation(self, **kwargs):
157: (8)                    """
158: (8)                    This is the animation of the popping out of the
159: (8)                    mini-display that shows the content of the zoomed
160: (8)                    camera.
161: (8)                    Returns
162: (8)                    -------
163: (8)                    ApplyMethod
164: (12)                       The Animation of the Zoomed Display popping out.
165: (8)                    """
166: (8)                    display = self.zoomed_display
167: (8)                    display.save_state()
168: (8)                    display.replace(self.zoomed_camera.frame, stretch=True)
169: (8)                    return ApplyMethod(display.restore)
170: (4)                def get_zoom_factor(self):
171: (8)                    """
172: (8)                    Returns the Zoom factor of the Zoomed camera.
173: (8)                    Defined as the ratio between the height of the
174: (8)                    zoomed camera and the height of the zoomed mini
175: (8)                    display.
176: (8)                    Returns
177: (8)                    -------
178: (8)                    float
179: (12)                       The zoom factor.
180: (8)                    """
181: (8)                    return self.zoomed_camera.frame.height / self.zoomed_display.height

----------------------------------------

File 6 - . \three_d_scene.py:

1: (0)              """A scene suitable for rendering three-dimensional objects and animations."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["ThreeDScene", "SpecialThreeDScene"]
4: (0)              import warnings
5: (0)              from typing import Iterable, Sequence
6: (0)              import numpy as np
7: (0)              from manim.mobject.geometry.line import Line
8: (0)              from manim.mobject.graphing.coordinate_systems import ThreeDAxes
9: (0)              from manim.mobject.opengl.opengl_mobject import OpenGLMobject
10: (0)             from manim.mobject.three_d.three_dimensions import Sphere
11: (0)             from manim.mobject.value_tracker import ValueTracker
12: (0)             from .. import config
13: (0)             from ..animation.animation import Animation
14: (0)             from ..animation.transform import Transform
15: (0)             from ..camera.three_d_camera import ThreeDCamera
16: (0)             from ..constants import DEGREES, RendererType
17: (0)             from ..mobject.mobject import Mobject
18: (0)             from ..mobject.types.vectorized_mobject import VectorizedPoint, VGroup
19: (0)             from ..renderer.opengl_renderer import OpenGLCamera
20: (0)             from ..scene.scene import Scene
21: (0)             from ..utils.config_ops import merge_dicts_recursively
22: (0)             class ThreeDScene(Scene):
23: (4)                 """
24: (4)                 This is a Scene, with special configurations and properties that
25: (4)                 make it suitable for Three Dimensional Scenes.
26: (4)                 """
27: (4)                 def __init__(
28: (8)                     self,
29: (8)                     camera_class=ThreeDCamera,
30: (8)                     ambient_camera_rotation=None,
31: (8)                     default_angled_camera_orientation_kwargs=None,
32: (8)                     **kwargs,
33: (4)                 ):
34: (8)                     self.ambient_camera_rotation = ambient_camera_rotation
35: (8)                     if default_angled_camera_orientation_kwargs is None:
36: (12)                        default_angled_camera_orientation_kwargs = {
37: (16)                            "phi": 70 * DEGREES,
38: (16)                            "theta": -135 * DEGREES,
39: (12)                        }
40: (8)                     self.default_angled_camera_orientation_kwargs = (
41: (12)                        default_angled_camera_orientation_kwargs
42: (8)                     )
43: (8)                     super().__init__(camera_class=camera_class, **kwargs)
44: (4)                 def set_camera_orientation(
45: (8)                     self,
46: (8)                     phi: float | None = None,
47: (8)                     theta: float | None = None,
48: (8)                     gamma: float | None = None,
49: (8)                     zoom: float | None = None,
50: (8)                     focal_distance: float | None = None,
51: (8)                     frame_center: Mobject | Sequence[float] | None = None,
52: (8)                     **kwargs,
53: (4)                 ):
54: (8)                     """
55: (8)                     This method sets the orientation of the camera in the scene.
56: (8)                     Parameters
57: (8)                     ----------
58: (8)                     phi
59: (12)                        The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.
60: (8)                     theta
61: (12)                        The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.
62: (8)                     focal_distance
63: (12)                        The focal_distance of the Camera.
64: (8)                     gamma
65: (12)                        The rotation of the camera about the vector from the ORIGIN to the Camera.
66: (8)                     zoom
67: (12)                        The zoom factor of the scene.
68: (8)                     frame_center
69: (12)                        The new center of the camera frame in cartesian coordinates.
70: (8)                     """
71: (8)                     if phi is not None:
72: (12)                        self.renderer.camera.set_phi(phi)
73: (8)                     if theta is not None:
74: (12)                        self.renderer.camera.set_theta(theta)
75: (8)                     if focal_distance is not None:
76: (12)                        self.renderer.camera.set_focal_distance(focal_distance)
77: (8)                     if gamma is not None:
78: (12)                        self.renderer.camera.set_gamma(gamma)
79: (8)                     if zoom is not None:
80: (12)                        self.renderer.camera.set_zoom(zoom)
81: (8)                     if frame_center is not None:
82: (12)                        self.renderer.camera._frame_center.move_to(frame_center)
83: (4)                 def begin_ambient_camera_rotation(self, rate: float = 0.02, about: str = "theta"):
84: (8)                     """
85: (8)                     This method begins an ambient rotation of the camera about the Z_AXIS,
86: (8)                     in the anticlockwise direction
87: (8)                     Parameters
88: (8)                     ----------
89: (8)                     rate
90: (12)                        The rate at which the camera should rotate about the Z_AXIS.
91: (12)                        Negative rate means clockwise rotation.
92: (8)                     about
93: (12)                        one of 3 options: ["theta", "phi", "gamma"]. defaults to theta.
94: (8)                     """
95: (8)                     # TODO, use a ValueTracker for rate, so that it
96: (8)                     # can begin and end smoothly
97: (8)                     about: str = about.lower()
98: (8)                     try:
99: (12)                        if config.renderer == RendererType.CAIRO:
100: (16)                           trackers = {
101: (20)                               "theta": self.camera.theta_tracker,
102: (20)                               "phi": self.camera.phi_tracker,
103: (20)                               "gamma": self.camera.gamma_tracker,
104: (16)                           }
105: (16)                           x: ValueTracker = trackers[about]
106: (16)                           x.add_updater(lambda m, dt: x.increment_value(rate * dt))
107: (16)                           self.add(x)
108: (12)                       elif config.renderer == RendererType.OPENGL:
109: (16)                           cam: OpenGLCamera = self.camera
110: (16)                           methods = {
111: (20)                               "theta": cam.increment_theta,
112: (20)                               "phi": cam.increment_phi,
113: (20)                               "gamma": cam.increment_gamma,
114: (16)                           }
115: (16)                           cam.add_updater(lambda m, dt: methods[about](rate * dt))
116: (16)                           self.add(self.camera)
117: (8)                    except Exception:
118: (12)                       raise ValueError("Invalid ambient rotation angle.")
119: (4)                def stop_ambient_camera_rotation(self, about="theta"):
120: (8)                    """
121: (8)                    This method stops all ambient camera rotation.
122: (8)                    """
123: (8)                    about: str = about.lower()
124: (8)                    try:
125: (12)                       if config.renderer == RendererType.CAIRO:
126: (16)                           trackers = {
127: (20)                               "theta": self.camera.theta_tracker,
128: (20)                               "phi": self.camera.phi_tracker,
129: (20)                               "gamma": self.camera.gamma_tracker,
130: (16)                           }
131: (16)                           x: ValueTracker = trackers[about]
132: (16)                           x.clear_updaters()
133: (16)                           self.remove(x)
134: (12)                       elif config.renderer == RendererType.OPENGL:
135: (16)                           self.camera.clear_updaters()
136: (8)                    except Exception:
137: (12)                       raise ValueError("Invalid ambient rotation angle.")
138: (4)                def begin_3dillusion_camera_rotation(
139: (8)                    self,
140: (8)                    rate: float = 1,
141: (8)                    origin_phi: float | None = None,
142: (8)                    origin_theta: float | None = None,
143: (4)                ):
144: (8)                    """
145: (8)                    This method creates a 3D camera rotation illusion around
146: (8)                    the current camera orientation.
147: (8)                    Parameters
148: (8)                    ----------
149: (8)                    rate
150: (12)                       The rate at which the camera rotation illusion should operate.
151: (8)                    origin_phi
152: (12)                       The polar angle the camera should move around. Defaults
153: (12)                       to the current phi angle.
154: (8)                    origin_theta
155: (12)                       The azimutal angle the camera should move around. Defaults
156: (12)                       to the current theta angle.
157: (8)                    """
158: (8)                    if origin_theta is None:
159: (12)                       origin_theta = self.renderer.camera.theta_tracker.get_value()
160: (8)                    if origin_phi is None:
161: (12)                       origin_phi = self.renderer.camera.phi_tracker.get_value()
162: (8)                    val_tracker_theta = ValueTracker(0)
163: (8)                    def update_theta(m, dt):
164: (12)                       val_tracker_theta.increment_value(dt * rate)
165: (12)                       val_for_left_right = 0.2 * np.sin(val_tracker_theta.get_value())
166: (12)                       return m.set_value(origin_theta + val_for_left_right)
167: (8)                    self.renderer.camera.theta_tracker.add_updater(update_theta)
168: (8)                    self.add(self.renderer.camera.theta_tracker)
169: (8)                    val_tracker_phi = ValueTracker(0)
170: (8)                    def update_phi(m, dt):
171: (12)                       val_tracker_phi.increment_value(dt * rate)
172: (12)                       val_for_up_down = 0.1 * np.cos(val_tracker_phi.get_value()) - 0.1
173: (12)                       return m.set_value(origin_phi + val_for_up_down)
174: (8)                    self.renderer.camera.phi_tracker.add_updater(update_phi)
175: (8)                    self.add(self.renderer.camera.phi_tracker)
176: (4)                def stop_3dillusion_camera_rotation(self):
177: (8)                    """
178: (8)                    This method stops all illusion camera rotations.
179: (8)                    """
180: (8)                    self.renderer.camera.theta_tracker.clear_updaters()
181: (8)                    self.remove(self.renderer.camera.theta_tracker)
182: (8)                    self.renderer.camera.phi_tracker.clear_updaters()
183: (8)                    self.remove(self.renderer.camera.phi_tracker)
184: (4)                def move_camera(
185: (8)                    self,
186: (8)                    phi: float | None = None,
187: (8)                    theta: float | None = None,
188: (8)                    gamma: float | None = None,
189: (8)                    zoom: float | None = None,
190: (8)                    focal_distance: float | None = None,
191: (8)                    frame_center: Mobject | Sequence[float] | None = None,
192: (8)                    added_anims: Iterable[Animation] = [],
193: (8)                    **kwargs,
194: (4)                ):
195: (8)                    """
196: (8)                    This method animates the movement of the camera
197: (8)                    to the given spherical coordinates.
198: (8)                    Parameters
199: (8)                    ----------
200: (8)                    phi
201: (12)                       The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.
202: (8)                    theta
203: (12)                       The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.
204: (8)                    focal_distance
205: (12)                       The radial focal_distance between ORIGIN and Camera.
206: (8)                    gamma
207: (12)                       The rotation of the camera about the vector from the ORIGIN to the Camera.
208: (8)                    zoom
209: (12)                       The zoom factor of the camera.
210: (8)                    frame_center
211: (12)                       The new center of the camera frame in cartesian coordinates.
212: (8)                    added_anims
213: (12)                       Any other animations to be played at the same time.
214: (8)                    """
215: (8)                    anims = []
216: (8)                    if config.renderer == RendererType.CAIRO:
217: (12)                       self.camera: ThreeDCamera
218: (12)                       value_tracker_pairs = [
219: (16)                           (phi, self.camera.phi_tracker),
220: (16)                           (theta, self.camera.theta_tracker),
221: (16)                           (focal_distance, self.camera.focal_distance_tracker),
222: (16)                           (gamma, self.camera.gamma_tracker),
223: (16)                           (zoom, self.camera.zoom_tracker),
224: (12)                       ]
225: (12)                       for value, tracker in value_tracker_pairs:
226: (16)                           if value is not None:
227: (20)                               anims.append(tracker.animate.set_value(value))
228: (12)                       if frame_center is not None:
229: (16)                           anims.append(self.camera._frame_center.animate.move_to(frame_center))
230: (8)                    elif config.renderer == RendererType.OPENGL:
231: (12)                       cam: OpenGLCamera = self.camera
232: (12)                       cam2 = cam.copy()
233: (12)                       methods = {
234: (16)                           "theta": cam2.set_theta,
235: (16)                           "phi": cam2.set_phi,
236: (16)                           "gamma": cam2.set_gamma,
237: (16)                           "zoom": cam2.scale,
238: (16)                           "frame_center": cam2.move_to,
239: (12)                       }
240: (12)                       if frame_center is not None:
241: (16)                           if isinstance(frame_center, OpenGLMobject):
242: (20)                               frame_center = frame_center.get_center()
243: (16)                           frame_center = list(frame_center)
244: (12)                       zoom_value = None
245: (12)                       if zoom is not None:
246: (16)                           zoom_value = config.frame_height / (zoom * cam.height)
247: (12)                       for value, method in [
248: (16)                           [theta, "theta"],
249: (16)                           [phi, "phi"],
250: (16)                           [gamma, "gamma"],
251: (16)                           [zoom_value, "zoom"],
252: (16)                           [frame_center, "frame_center"],
253: (12)                       ]:
254: (16)                           if value is not None:
255: (20)                               methods[method](value)
256: (12)                       if focal_distance is not None:
257: (16)                           warnings.warn(
258: (20)                               "focal distance of OpenGLCamera can not be adjusted.",
259: (20)                               stacklevel=2,
260: (16)                           )
261: (12)                       anims += [Transform(cam, cam2)]
262: (8)                    self.play(*anims + added_anims, **kwargs)
263: (8)                    # These lines are added to improve performance. If manim thinks that frame_center is moving,
264: (8)                    # it is required to redraw every object. These lines remove frame_center from the Scene once
265: (8)                    # its animation is done, ensuring that manim does not think that it is moving. Since the
266: (8)                    # frame_center is never actually drawn, this shouldn't break anything.
267: (8)                    if frame_center is not None and config.renderer == RendererType.CAIRO:
268: (12)                       self.remove(self.camera._frame_center)
269: (4)                def get_moving_mobjects(self, *animations: Animation):
270: (8)                    """
271: (8)                    This method returns a list of all of the Mobjects in the Scene that
272: (8)                    are moving, that are also in the animations passed.
273: (8)                    Parameters
274: (8)                    ----------
275: (8)                    *animations
276: (12)                       The animations whose mobjects will be checked.
277: (8)                    """
278: (8)                    moving_mobjects = super().get_moving_mobjects(*animations)
279: (8)                    camera_mobjects = self.renderer.camera.get_value_trackers() + [
280: (12)                       self.renderer.camera._frame_center,
281: (8)                    ]
282: (8)                    if any(cm in moving_mobjects for cm in camera_mobjects):
283: (12)                       return self.mobjects
284: (8)                    return moving_mobjects
285: (4)                def add_fixed_orientation_mobjects(self, *mobjects: Mobject, **kwargs):
286: (8)                    """
287: (8)                    This method is used to prevent the rotation and tilting
288: (8)                    of mobjects as the camera moves around. The mobject can
289: (8)                    still move in the x,y,z directions, but will always be
290: (8)                    at the angle (relative to the camera) that it was at
291: (8)                    when it was passed through this method.)
292: (8)                    Parameters
293: (8)                    ----------
294: (8)                    *mobjects
295: (12)                       The Mobject(s) whose orientation must be fixed.
296: (8)                    **kwargs
297: (12)                       Some valid kwargs are
298: (16)                           use_static_center_func : bool
299: (16)                           center_func : function
300: (8)                    """
301: (8)                    if config.renderer == RendererType.CAIRO:
302: (12)                       self.add(*mobjects)
303: (12)                       self.renderer.camera.add_fixed_orientation_mobjects(*mobjects, **kwargs)
304: (8)                    elif config.renderer == RendererType.OPENGL:
305: (12)                       for mob in mobjects:
306: (16)                           mob: OpenGLMobject
307: (16)                           mob.fix_orientation()
308: (16)                           self.add(mob)
309: (4)                def add_fixed_in_frame_mobjects(self, *mobjects: Mobject):
310: (8)                    """
311: (8)                    This method is used to prevent the rotation and movement
312: (8)                    of mobjects as the camera moves around. The mobject is
313: (8)                    essentially overlaid, and is not impacted by the camera's
314: (8)                    movement in any way.
315: (8)                    Parameters
316: (8)                    ----------
317: (8)                    *mobjects
318: (12)                       The Mobjects whose orientation must be fixed.
319: (8)                    """
320: (8)                    if config.renderer == RendererType.CAIRO:
321: (12)                       self.add(*mobjects)
322: (12)                       self.camera: ThreeDCamera
323: (12)                       self.camera.add_fixed_in_frame_mobjects(*mobjects)
324: (8)                    elif config.renderer == RendererType.OPENGL:
325: (12)                       for mob in mobjects:
326: (16)                           mob: OpenGLMobject
327: (16)                           mob.fix_in_frame()
328: (16)                           self.add(mob)
329: (4)                def remove_fixed_orientation_mobjects(self, *mobjects: Mobject):
330: (8)                    """
331: (8)                    This method "unfixes" the orientation of the mobjects
332: (8)                    passed, meaning they will no longer be at the same angle
333: (8)                    relative to the camera. This only makes sense if the
334: (8)                    mobject was passed through add_fixed_orientation_mobjects first.
335: (8)                    Parameters
336: (8)                    ----------
337: (8)                    *mobjects
338: (12)                       The Mobjects whose orientation must be unfixed.
339: (8)                    """
340: (8)                    if config.renderer == RendererType.CAIRO:
341: (12)                       self.renderer.camera.remove_fixed_orientation_mobjects(*mobjects)
342: (8)                    elif config.renderer == RendererType.OPENGL:
343: (12)                       for mob in mobjects:
344: (16)                           mob: OpenGLMobject
345: (16)                           mob.unfix_orientation()
346: (16)                           self.remove(mob)
347: (4)                def remove_fixed_in_frame_mobjects(self, *mobjects: Mobject):
348: (8)                    """
349: (9)                     This method undoes what add_fixed_in_frame_mobjects does.
350: (9)                     It allows the mobject to be affected by the movement of
351: (9)                     the camera.
352: (8)                    Parameters
353: (8)                    ----------
354: (8)                    *mobjects
355: (12)                       The Mobjects whose position and orientation must be unfixed.
356: (8)                    """
357: (8)                    if config.renderer == RendererType.CAIRO:
358: (12)                       self.renderer.camera.remove_fixed_in_frame_mobjects(*mobjects)
359: (8)                    elif config.renderer == RendererType.OPENGL:
360: (12)                       for mob in mobjects:
361: (16)                           mob: OpenGLMobject
362: (16)                           mob.unfix_from_frame()
363: (16)                           self.remove(mob)
364: (4)                ##
365: (4)                def set_to_default_angled_camera_orientation(self, **kwargs):
366: (8)                    """
367: (8)                    This method sets the default_angled_camera_orientation to the
368: (8)                    keyword arguments passed, and sets the camera to that orientation.
369: (8)                    Parameters
370: (8)                    ----------
371: (8)                    **kwargs
372: (12)                       Some recognised kwargs are phi, theta, focal_distance, gamma,
373: (12)                       which have the same meaning as the parameters in set_camera_orientation.
374: (8)                    """
375: (8)                    config = dict(
376: (12)                       self.default_camera_orientation_kwargs,
377: (8)                    )  # Where doe this come from?
378: (8)                    config.update(kwargs)
379: (8)                    self.set_camera_orientation(**config)
380: (0)            class SpecialThreeDScene(ThreeDScene):
381: (4)                """An extension of :class:`ThreeDScene` with more settings.
382: (4)                It has some extra configuration for axes, spheres,
383: (4)                and an override for low quality rendering. Further key differences
384: (4)                are:
385: (4)                * The camera shades applicable 3DMobjects by default,
386: (6)                  except if rendering in low quality.
387: (4)                * Some default params for Spheres and Axes have been added.
388: (4)                """
389: (4)                def __init__(
390: (8)                    self,
391: (8)                    cut_axes_at_radius=True,
392: (8)                    camera_config={"should_apply_shading": True, "exponential_projection": True},
393: (8)                    three_d_axes_config={
394: (12)                       "num_axis_pieces": 1,
395: (12)                       "axis_config": {
396: (16)                           "unit_size": 2,
397: (16)                           "tick_frequency": 1,
398: (16)                           "numbers_with_elongated_ticks": [0, 1, 2],
399: (16)                           "stroke_width": 2,
400: (12)                       },
401: (8)                    },
402: (8)                    sphere_config={"radius": 2, "resolution": (24, 48)},
403: (8)                    default_angled_camera_position={
404: (12)                       "phi": 70 * DEGREES,
405: (12)                       "theta": -110 * DEGREES,
406: (8)                    },
407: (8)                    # When scene is extracted with -l flag, this
408: (8)                    # configuration will override the above configuration.
409: (8)                    low_quality_config={
410: (12)                       "camera_config": {"should_apply_shading": False},
411: (12)                       "three_d_axes_config": {"num_axis_pieces": 1},
412: (12)                       "sphere_config": {"resolution": (12, 24)},
413: (8)                    },
414: (8)                    **kwargs,
415: (4)                ):
416: (8)                    self.cut_axes_at_radius = cut_axes_at_radius
417: (8)                    self.camera_config = camera_config
418: (8)                    self.three_d_axes_config = three_d_axes_config
419: (8)                    self.sphere_config = sphere_config
420: (8)                    self.default_angled_camera_position = default_angled_camera_position
421: (8)                    self.low_quality_config = low_quality_config
422: (8)                    if self.renderer.camera_config["pixel_width"] == config["pixel_width"]:
423: (12)                       _config = {}
424: (8)                    else:
425: (12)                       _config = self.low_quality_config
426: (8)                    _config = merge_dicts_recursively(_config, kwargs)
427: (8)                    super().__init__(**_config)
428: (4)                def get_axes(self):
429: (8)                    """Return a set of 3D axes.
430: (8)                    Returns
431: (8)                    -------
432: (8)                    :class:`.ThreeDAxes`
433: (12)                       A set of 3D axes.
434: (8)                    """
435: (8)                    axes = ThreeDAxes(**self.three_d_axes_config)
436: (8)                    for axis in axes:
437: (12)                       if self.cut_axes_at_radius:
438: (16)                           p0 = axis.get_start()
439: (16)                           p1 = axis.number_to_point(-1)
440: (16)                           p2 = axis.number_to_point(1)
441: (16)                           p3 = axis.get_end()
442: (16)                           new_pieces = VGroup(Line(p0, p1), Line(p1, p2), Line(p2, p3))
443: (16)                           for piece in new_pieces:
444: (20)                               piece.shade_in_3d = True
445: (16)                           new_pieces.match_style(axis.pieces)
446: (16)                           axis.pieces.submobjects = new_pieces.submobjects
447: (12)                       for tick in axis.tick_marks:
448: (16)                           tick.add(VectorizedPoint(1.5 * tick.get_center()))
449: (8)                    return axes
450: (4)                def get_sphere(self, **kwargs):
451: (8)                    """
452: (8)                    Returns a sphere with the passed keyword arguments as properties.
453: (8)                    Parameters
454: (8)                    ----------
455: (8)                    **kwargs
456: (12)                       Any valid parameter of :class:`~.Sphere` or :class:`~.Surface`.
457: (8)                    Returns
458: (8)                    -------
459: (8)                    :class:`~.Sphere`
460: (12)                       The sphere object.
461: (8)                    """
462: (8)                    config = merge_dicts_recursively(self.sphere_config, kwargs)
463: (8)                    return Sphere(**config)
464: (4)                def get_default_camera_position(self):
465: (8)                    """
466: (8)                    Returns the default_angled_camera position.
467: (8)                    Returns
468: (8)                    -------
469: (8)                    dict
470: (12)                       Dictionary of phi, theta, focal_distance, and gamma.
471: (8)                    """
472: (8)                    return self.default_angled_camera_position
473: (4)                def set_camera_to_default_position(self):
474: (8)                    """
475: (8)                    Sets the camera to its default position.
476: (8)                    """
477: (8)                    self.set_camera_orientation(**self.default_angled_camera_position)

----------------------------------------

File 7 - . \scene_file_writer.py:

1: (0)              """The interface between scenes and ffmpeg."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["SceneFileWriter"]
4: (0)              import json
5: (0)              import os
6: (0)              import shutil
7: (0)              import subprocess
8: (0)              from pathlib import Path
9: (0)              from typing import TYPE_CHECKING, Any
10: (0)             import numpy as np
11: (0)             import srt
12: (0)             from PIL import Image
13: (0)             from pydub import AudioSegment
14: (0)             from manim import __version__
15: (0)             from .. import config, logger
16: (0)             from .._config.logger_utils import set_file_logger
17: (0)             from ..constants import RendererType
18: (0)             from ..utils.file_ops import (
19: (4)                 add_extension_if_not_present,
20: (4)                 add_version_before_extension,
21: (4)                 ensure_executable,
22: (4)                 guarantee_existence,
23: (4)                 is_gif_format,
24: (4)                 is_png_format,
25: (4)                 is_webm_format,
26: (4)                 modify_atime,
27: (4)                 write_to_movie,
28: (0)             )
29: (0)             from ..utils.sounds import get_full_sound_file_path
30: (0)             from .section import DefaultSectionType, Section
31: (0)             if TYPE_CHECKING:
32: (4)                 from manim.renderer.opengl_renderer import OpenGLRenderer
33: (0)             class SceneFileWriter:
34: (4)                 """
35: (4)                 SceneFileWriter is the object that actually writes the animations
36: (4)                 played, into video files, using FFMPEG.
37: (4)                 This is mostly for Manim's internal use. You will rarely, if ever,
38: (4)                 have to use the methods for this class, unless tinkering with the very
39: (4)                 fabric of Manim's reality.
40: (4)                 Attributes
41: (4)                 ----------
42: (8)                     sections : list of :class:`.Section`
43: (12)                        used to segment scene
44: (8)                     sections_output_dir : :class:`pathlib.Path`
45: (12)                        where are section videos stored
46: (8)                     output_name : str
47: (12)                        name of movie without extension and basis for section video names
48: (4)                 Some useful attributes are:
49: (8)                     "write_to_movie" (bool=False)
50: (12)                        Whether or not to write the animations into a video file.
51: (8)                     "movie_file_extension" (str=".mp4")
52: (12)                        The file-type extension of the outputted video.
53: (8)                     "partial_movie_files"
54: (12)                        List of all the partial-movie files.
55: (4)                 """
56: (4)                 force_output_as_scene_name = False
57: (4)                 def __init__(self, renderer, scene_name, **kwargs):
58: (8)                     self.renderer = renderer
59: (8)                     self.init_output_directories(scene_name)
60: (8)                     self.init_audio()
61: (8)                     self.frame_count = 0
62: (8)                     self.partial_movie_files: list[str] = []
63: (8)                     self.subcaptions: list[srt.Subtitle] = []
64: (8)                     self.sections: list[Section] = []
65: (8)                     # first section gets automatically created for convenience
66: (8)                     # if you need the first section to be skipped, add a first section by hand, it will replace this one
67: (8)                     self.next_section(
68: (12)                        name="autocreated", type=DefaultSectionType.NORMAL, skip_animations=False
69: (8)                     )
70: (8)                     # fail fast if ffmpeg is not found
71: (8)                     if not ensure_executable(Path(config.ffmpeg_executable)):
72: (12)                        raise RuntimeError(
73: (16)                            "Manim could not find ffmpeg, which is required for generating video output.\n"
74: (16)                            "For installing ffmpeg please consult https://docs.manim.community/en/stable/installation.html\n"
75: (16)                            "Make sure to either add ffmpeg to the PATH environment variable\n"
76: (16)                            "or set path to the ffmpeg executable under the ffmpeg header in Manim's configuration."
77: (12)                        )
78: (4)                 def init_output_directories(self, scene_name):
79: (8)                     """Initialise output directories.
80: (8)                     Notes
81: (8)                     -----
82: (8)                     The directories are read from ``config``, for example
83: (8)                     ``config['media_dir']``.  If the target directories don't already
84: (8)                     exist, they will be created.
85: (8)                     """
86: (8)                     if config["dry_run"]:  # in dry-run mode there is no output
87: (12)                        return
88: (8)                     if config["input_file"]:
89: (12)                        module_name = config.get_dir("input_file").stem
90: (8)                     else:
91: (12)                        module_name = ""
92: (8)                     if SceneFileWriter.force_output_as_scene_name:
93: (12)                        self.output_name = Path(scene_name)
94: (8)                     elif config["output_file"] and not config["write_all"]:
95: (12)                        self.output_name = config.get_dir("output_file")
96: (8)                     else:
97: (12)                        self.output_name = Path(scene_name)
98: (8)                     if config["media_dir"]:
99: (12)                        image_dir = guarantee_existence(
100: (16)                           config.get_dir(
101: (20)                               "images_dir", module_name=module_name, scene_name=scene_name
102: (16)                           ),
103: (12)                       )
104: (12)                       self.image_file_path = image_dir / add_extension_if_not_present(
105: (16)                           self.output_name, ".png"
106: (12)                       )
107: (8)                    if write_to_movie():
108: (12)                       movie_dir = guarantee_existence(
109: (16)                           config.get_dir(
110: (20)                               "video_dir", module_name=module_name, scene_name=scene_name
111: (16)                           ),
112: (12)                       )
113: (12)                       self.movie_file_path = movie_dir / add_extension_if_not_present(
114: (16)                           self.output_name, config["movie_file_extension"]
115: (12)                       )
116: (12)                       # TODO: /dev/null would be good in case sections_output_dir is used without bein set (doesn't work on Windows), everyone likes defensive programming, right?
117: (12)                       self.sections_output_dir = Path("")
118: (12)                       if config.save_sections:
119: (16)                           self.sections_output_dir = guarantee_existence(
120: (20)                               config.get_dir(
121: (24)                                   "sections_dir", module_name=module_name, scene_name=scene_name
122: (20)                               )
123: (16)                           )
124: (12)                       if is_gif_format():
125: (16)                           self.gif_file_path = add_extension_if_not_present(
126: (20)                               self.output_name, ".gif"
127: (16)                           )
128: (16)                           if not config["output_file"]:
129: (20)                               self.gif_file_path = add_version_before_extension(
130: (24)                                   self.gif_file_path
131: (20)                               )
132: (16)                           self.gif_file_path = movie_dir / self.gif_file_path
133: (12)                       self.partial_movie_directory = guarantee_existence(
134: (16)                           config.get_dir(
135: (20)                               "partial_movie_dir",
136: (20)                               scene_name=scene_name,
137: (20)                               module_name=module_name,
138: (16)                           ),
139: (12)                       )
140: (12)                       if config["log_to_file"]:
141: (16)                           log_dir = guarantee_existence(config.get_dir("log_dir"))
142: (16)                           set_file_logger(
143: (20)                               scene_name=scene_name, module_name=module_name, log_dir=log_dir
144: (16)                           )
145: (4)                def finish_last_section(self) -> None:
146: (8)                    """Delete current section if it is empty."""
147: (8)                    if len(self.sections) and self.sections[-1].is_empty():
148: (12)                       self.sections.pop()
149: (4)                def next_section(self, name: str, type: str, skip_animations: bool) -> None:
150: (8)                    """Create segmentation cut here."""
151: (8)                    self.finish_last_section()
152: (8)                    # images don't support sections
153: (8)                    section_video: str | None = None
154: (8)                    # don't save when None
155: (8)                    if (
156: (12)                       not config.dry_run
157: (12)                       and write_to_movie()
158: (12)                       and config.save_sections
159: (12)                       and not skip_animations
160: (8)                    ):
161: (12)                       # relative to index file
162: (12)                       section_video = f"{self.output_name}_{len(self.sections):04}_{name}{config.movie_file_extension}"
163: (8)                    self.sections.append(
164: (12)                       Section(
165: (16)                           type,
166: (16)                           section_video,
167: (16)                           name,
168: (16)                           skip_animations,
169: (12)                       ),
170: (8)                    )
171: (4)                def add_partial_movie_file(self, hash_animation: str):
172: (8)                    """Adds a new partial movie file path to `scene.partial_movie_files` and current section from a hash.
173: (8)                    This method will compute the path from the hash. In addition to that it adds the new animation to the current section.
174: (8)                    Parameters
175: (8)                    ----------
176: (8)                    hash_animation
177: (12)                       Hash of the animation.
178: (8)                    """
179: (8)                    if not hasattr(self, "partial_movie_directory") or not write_to_movie():
180: (12)                       return
181: (8)                    # None has to be added to partial_movie_files to keep the right index with scene.num_plays.
182: (8)                    # i.e if an animation is skipped, scene.num_plays is still incremented and we add an element to partial_movie_file be even with num_plays.
183: (8)                    if hash_animation is None:
184: (12)                       self.partial_movie_files.append(None)
185: (12)                       self.sections[-1].partial_movie_files.append(None)
186: (8)                    else:
187: (12)                       new_partial_movie_file = str(
188: (16)                           self.partial_movie_directory
189: (16)                           / f"{hash_animation}{config['movie_file_extension']}"
190: (12)                       )
191: (12)                       self.partial_movie_files.append(new_partial_movie_file)
192: (12)                       self.sections[-1].partial_movie_files.append(new_partial_movie_file)
193: (4)                def get_resolution_directory(self):
194: (8)                    """Get the name of the resolution directory directly containing
195: (8)                    the video file.
196: (8)                    This method gets the name of the directory that immediately contains the
197: (8)                    video file. This name is ``<height_in_pixels_of_video>p<frame_rate>``.
198: (8)                    For example, if you are rendering an 854x480 px animation at 15fps,
199: (8)                    the name of the directory that immediately contains the video,  file
200: (8)                    will be ``480p15``.
201: (8)                    The file structure should look something like::
202: (12)                       MEDIA_DIR
203: (16)                           |--Tex
204: (16)                           |--texts
205: (16)                           |--videos
206: (16)                           |--<name_of_file_containing_scene>
207: (20)                               |--<height_in_pixels_of_video>p<frame_rate>
208: (24)                                   |--<scene_name>.mp4
209: (8)                    Returns
210: (8)                    -------
211: (8)                    :class:`str`
212: (12)                       The name of the directory.
213: (8)                    """
214: (8)                    pixel_height = config["pixel_height"]
215: (8)                    frame_rate = config["frame_rate"]
216: (8)                    return f"{pixel_height}p{frame_rate}"
217: (4)                # Sound
218: (4)                def init_audio(self):
219: (8)                    """
220: (8)                    Preps the writer for adding audio to the movie.
221: (8)                    """
222: (8)                    self.includes_sound = False
223: (4)                def create_audio_segment(self):
224: (8)                    """
225: (8)                    Creates an empty, silent, Audio Segment.
226: (8)                    """
227: (8)                    self.audio_segment = AudioSegment.silent()
228: (4)                def add_audio_segment(
229: (8)                    self,
230: (8)                    new_segment: AudioSegment,
231: (8)                    time: float | None = None,
232: (8)                    gain_to_background: float | None = None,
233: (4)                ):
234: (8)                    """
235: (8)                    This method adds an audio segment from an
236: (8)                    AudioSegment type object and suitable parameters.
237: (8)                    Parameters
238: (8)                    ----------
239: (8)                    new_segment
240: (12)                       The audio segment to add
241: (8)                    time
242: (12)                       the timestamp at which the
243: (12)                       sound should be added.
244: (8)                    gain_to_background
245: (12)                       The gain of the segment from the background.
246: (8)                    """
247: (8)                    if not self.includes_sound:
248: (12)                       self.includes_sound = True
249: (12)                       self.create_audio_segment()
250: (8)                    segment = self.audio_segment
251: (8)                    curr_end = segment.duration_seconds
252: (8)                    if time is None:
253: (12)                       time = curr_end
254: (8)                    if time < 0:
255: (12)                       raise ValueError("Adding sound at timestamp < 0")
256: (8)                    new_end = time + new_segment.duration_seconds
257: (8)                    diff = new_end - curr_end
258: (8)                    if diff > 0:
259: (12)                       segment = segment.append(
260: (16)                           AudioSegment.silent(int(np.ceil(diff * 1000))),
261: (16)                           crossfade=0,
262: (12)                       )
263: (8)                    self.audio_segment = segment.overlay(
264: (12)                       new_segment,
265: (12)                       position=int(1000 * time),
266: (12)                       gain_during_overlay=gain_to_background,
267: (8)                    )
268: (4)                def add_sound(
269: (8)                    self,
270: (8)                    sound_file: str,
271: (8)                    time: float | None = None,
272: (8)                    gain: float | None = None,
273: (8)                    **kwargs,
274: (4)                ):
275: (8)                    """
276: (8)                    This method adds an audio segment from a sound file.
277: (8)                    Parameters
278: (8)                    ----------
279: (8)                    sound_file
280: (12)                       The path to the sound file.
281: (8)                    time
282: (12)                       The timestamp at which the audio should be added.
283: (8)                    gain
284: (12)                       The gain of the given audio segment.
285: (8)                    **kwargs
286: (12)                       This method uses add_audio_segment, so any keyword arguments
287: (12)                       used there can be referenced here.
288: (8)                    """
289: (8)                    file_path = get_full_sound_file_path(sound_file)
290: (8)                    new_segment = AudioSegment.from_file(file_path)
291: (8)                    if gain:
292: (12)                       new_segment = new_segment.apply_gain(gain)
293: (8)                    self.add_audio_segment(new_segment, time, **kwargs)
294: (4)                # Writers
295: (4)                def begin_animation(self, allow_write: bool = False, file_path=None):
296: (8)                    """
297: (8)                    Used internally by manim to stream the animation to FFMPEG for
298: (8)                    displaying or writing to a file.
299: (8)                    Parameters
300: (8)                    ----------
301: (8)                    allow_write
302: (12)                       Whether or not to write to a video file.
303: (8)                    """
304: (8)                    if write_to_movie() and allow_write:
305: (12)                       self.open_movie_pipe(file_path=file_path)
306: (4)                def end_animation(self, allow_write: bool = False):
307: (8)                    """
308: (8)                    Internally used by Manim to stop streaming to
309: (8)                    FFMPEG gracefully.
310: (8)                    Parameters
311: (8)                    ----------
312: (8)                    allow_write
313: (12)                       Whether or not to write to a video file.
314: (8)                    """
315: (8)                    if write_to_movie() and allow_write:
316: (12)                       self.close_movie_pipe()
317: (4)                def write_frame(self, frame_or_renderer: np.ndarray | OpenGLRenderer):
318: (8)                    """
319: (8)                    Used internally by Manim to write a frame to
320: (8)                    the FFMPEG input buffer.
321: (8)                    Parameters
322: (8)                    ----------
323: (8)                    frame_or_renderer
324: (12)                       Pixel array of the frame.
325: (8)                    """
326: (8)                    if config.renderer == RendererType.OPENGL:
327: (12)                       self.write_opengl_frame(frame_or_renderer)
328: (8)                    elif config.renderer == RendererType.CAIRO:
329: (12)                       frame = frame_or_renderer
330: (12)                       if write_to_movie():
331: (16)                           self.writing_process.stdin.write(frame.tobytes())
332: (12)                       if is_png_format() and not config["dry_run"]:
333: (16)                           self.output_image_from_array(frame)
334: (4)                def write_opengl_frame(self, renderer: OpenGLRenderer):
335: (8)                    if write_to_movie():
336: (12)                       self.writing_process.stdin.write(
337: (16)                           renderer.get_raw_frame_buffer_object_data(),
338: (12)                       )
339: (8)                    elif is_png_format() and not config["dry_run"]:
340: (12)                       target_dir = self.image_file_path.parent / self.image_file_path.stem
341: (12)                       extension = self.image_file_path.suffix
342: (12)                       self.output_image(
343: (16)                           renderer.get_image(),
344: (16)                           target_dir,
345: (16)                           extension,
346: (16)                           config["zero_pad"],
347: (12)                       )
348: (4)                def output_image_from_array(self, frame_data):
349: (8)                    target_dir = self.image_file_path.parent / self.image_file_path.stem
350: (8)                    extension = self.image_file_path.suffix
351: (8)                    self.output_image(
352: (12)                       Image.fromarray(frame_data),
353: (12)                       target_dir,
354: (12)                       extension,
355: (12)                       config["zero_pad"],
356: (8)                    )
357: (4)                def output_image(self, image: Image.Image, target_dir, ext, zero_pad: bool):
358: (8)                    if zero_pad:
359: (12)                       image.save(f"{target_dir}{str(self.frame_count).zfill(zero_pad)}{ext}")
360: (8)                    else:
361: (12)                       image.save(f"{target_dir}{self.frame_count}{ext}")
362: (8)                    self.frame_count += 1
363: (4)                def save_final_image(self, image: np.ndarray):
364: (8)                    """
365: (8)                    The name is a misnomer. This method saves the image
366: (8)                    passed to it as an in the default image directory.
367: (8)                    Parameters
368: (8)                    ----------
369: (8)                    image
370: (12)                       The pixel array of the image to save.
371: (8)                    """
372: (8)                    if config["dry_run"]:
373: (12)                       return
374: (8)                    if not config["output_file"]:
375: (12)                       self.image_file_path = add_version_before_extension(self.image_file_path)
376: (8)                    image.save(self.image_file_path)
377: (8)                    self.print_file_ready_message(self.image_file_path)
378: (4)                def finish(self):
379: (8)                    """
380: (8)                    Finishes writing to the FFMPEG buffer or writing images
381: (8)                    to output directory.
382: (8)                    Combines the partial movie files into the
383: (8)                    whole scene.
384: (8)                    If save_last_frame is True, saves the last
385: (8)                    frame in the default image directory.
386: (8)                    """
387: (8)                    if write_to_movie():
388: (12)                       if hasattr(self, "writing_process"):
389: (16)                           self.writing_process.terminate()
390: (12)                       self.combine_to_movie()
391: (12)                       if config.save_sections:
392: (16)                           self.combine_to_section_videos()
393: (12)                       if config["flush_cache"]:
394: (16)                           self.flush_cache_directory()
395: (12)                       else:
396: (16)                           self.clean_cache()
397: (8)                    elif is_png_format() and not config["dry_run"]:
398: (12)                       target_dir = self.image_file_path.parent / self.image_file_path.stem
399: (12)                       logger.info("\n%i images ready at %s\n", self.frame_count, str(target_dir))
400: (8)                    if self.subcaptions:
401: (12)                       self.write_subcaption_file()
402: (4)                def open_movie_pipe(self, file_path=None):
403: (8)                    """
404: (8)                    Used internally by Manim to initialise
405: (8)                    FFMPEG and begin writing to FFMPEG's input
406: (8)                    buffer.
407: (8)                    """
408: (8)                    if file_path is None:
409: (12)                       file_path = self.partial_movie_files[self.renderer.num_plays]
410: (8)                    self.partial_movie_file_path = file_path
411: (8)                    fps = config["frame_rate"]
412: (8)                    if fps == int(fps):  # fps is integer
413: (12)                       fps = int(fps)
414: (8)                    if config.renderer == RendererType.OPENGL:
415: (12)                       width, height = self.renderer.get_pixel_shape()
416: (8)                    else:
417: (12)                       height = config["pixel_height"]
418: (12)                       width = config["pixel_width"]
419: (8)                    command = [
420: (12)                       config.ffmpeg_executable,
421: (12)                       "-y",  # overwrite output file if it exists
422: (12)                       "-f",
423: (12)                       "rawvideo",
424: (12)                       "-s",
425: (12)                       "%dx%d" % (width, height),  # size of one frame
426: (12)                       "-pix_fmt",
427: (12)                       "rgba",
428: (12)                       "-r",
429: (12)                       str(fps),  # frames per second
430: (12)                       "-i",
431: (12)                       "-",  # The input comes from a pipe
432: (12)                       "-an",  # Tells FFMPEG not to expect any audio
433: (12)                       "-loglevel",
434: (12)                       config["ffmpeg_loglevel"].lower(),
435: (12)                       "-metadata",
436: (12)                       f"comment=Rendered with Manim Community v{__version__}",
437: (8)                    ]
438: (8)                    if config.renderer == RendererType.OPENGL:
439: (12)                       command += ["-vf", "vflip"]
440: (8)                    if is_webm_format():
441: (12)                       command += ["-vcodec", "libvpx-vp9", "-auto-alt-ref", "0"]
442: (8)                    # .mov format
443: (8)                    elif config["transparent"]:
444: (12)                       command += ["-vcodec", "qtrle"]
445: (8)                    else:
446: (12)                       command += ["-vcodec", "libx264", "-pix_fmt", "yuv420p"]
447: (8)                    command += [file_path]
448: (8)                    self.writing_process = subprocess.Popen(command, stdin=subprocess.PIPE)
449: (4)                def close_movie_pipe(self):
450: (8)                    """
451: (8)                    Used internally by Manim to gracefully stop writing to FFMPEG's input buffer
452: (8)                    """
453: (8)                    self.writing_process.stdin.close()
454: (8)                    self.writing_process.wait()
455: (8)                    logger.info(
456: (12)                       f"Animation {self.renderer.num_plays} : Partial movie file written in %(path)s",
457: (12)                       {"path": f"'{self.partial_movie_file_path}'"},
458: (8)                    )
459: (4)                def is_already_cached(self, hash_invocation: str):
460: (8)                    """Will check if a file named with `hash_invocation` exists.
461: (8)                    Parameters
462: (8)                    ----------
463: (8)                    hash_invocation
464: (12)                       The hash corresponding to an invocation to either `scene.play` or `scene.wait`.
465: (8)                    Returns
466: (8)                    -------
467: (8)                    :class:`bool`
468: (12)                       Whether the file exists.
469: (8)                    """
470: (8)                    if not hasattr(self, "partial_movie_directory") or not write_to_movie():
471: (12)                       return False
472: (8)                    path = (
473: (12)                       self.partial_movie_directory
474: (12)                       / f"{hash_invocation}{config['movie_file_extension']}"
475: (8)                    )
476: (8)                    return path.exists()
477: (4)                def combine_files(
478: (8)                    self,
479: (8)                    input_files: list[str],
480: (8)                    output_file: Path,
481: (8)                    create_gif=False,
482: (8)                    includes_sound=False,
483: (4)                ):
484: (8)                    file_list = self.partial_movie_directory / "partial_movie_file_list.txt"
485: (8)                    logger.debug(
486: (12)                       f"Partial movie files to combine ({len(input_files)} files): %(p)s",
487: (12)                       {"p": input_files[:5]},
488: (8)                    )
489: (8)                    with file_list.open("w", encoding="utf-8") as fp:
490: (12)                       fp.write("# This file is used internally by FFMPEG.\n")
491: (12)                       for pf_path in input_files:
492: (16)                           pf_path = Path(pf_path).as_posix()
493: (16)                           fp.write(f"file 'file:{pf_path}'\n")
494: (8)                    commands = [
495: (12)                       config.ffmpeg_executable,
496: (12)                       "-y",  # overwrite output file if it exists
497: (12)                       "-f",
498: (12)                       "concat",
499: (12)                       "-safe",
500: (12)                       "0",
501: (12)                       "-i",
502: (12)                       str(file_list),
503: (12)                       "-loglevel",
504: (12)                       config.ffmpeg_loglevel.lower(),
505: (12)                       "-metadata",
506: (12)                       f"comment=Rendered with Manim Community v{__version__}",
507: (12)                       "-nostdin",
508: (8)                    ]
509: (8)                    if create_gif:
510: (12)                       commands += [
511: (16)                           "-vf",
512: (16)                           f"fps={np.clip(config['frame_rate'], 1, 50)},split[s0][s1];[s0]palettegen=stats_mode=diff[p];[s1][p]paletteuse=dither=bayer:bayer_scale=5:diff_mode=rectangle",
513: (12)                       ]
514: (8)                    else:
515: (12)                       commands += ["-c", "copy"]
516: (8)                    if not includes_sound:
517: (12)                       commands += ["-an"]
518: (8)                    commands += [str(output_file)]
519: (8)                    combine_process = subprocess.Popen(commands)
520: (8)                    combine_process.wait()
521: (4)                def combine_to_movie(self):
522: (8)                    """Used internally by Manim to combine the separate
523: (8)                    partial movie files that make up a Scene into a single
524: (8)                    video file for that Scene.
525: (8)                    """
526: (8)                    partial_movie_files = [el for el in self.partial_movie_files if el is not None]
527: (8)                    # NOTE: Here we should do a check and raise an exception if partial
528: (8)                    # movie file is empty.  We can't, as a lot of stuff (in particular, in
529: (8)                    # tests) use scene initialization, and this error would be raised as
530: (8)                    # it's just an empty scene initialized.
531: (8)                    # determine output path
532: (8)                    movie_file_path = self.movie_file_path
533: (8)                    if is_gif_format():
534: (12)                       movie_file_path = self.gif_file_path
535: (8)                    logger.info("Combining to Movie file.")
536: (8)                    self.combine_files(
537: (12)                       partial_movie_files,
538: (12)                       movie_file_path,
539: (12)                       is_gif_format(),
540: (12)                       self.includes_sound,
541: (8)                    )
542: (8)                    # handle sound
543: (8)                    if self.includes_sound:
544: (12)                       sound_file_path = movie_file_path.with_suffix(".wav")
545: (12)                       # Makes sure sound file length will match video file
546: (12)                       self.add_audio_segment(AudioSegment.silent(0))
547: (12)                       self.audio_segment.export(
548: (16)                           sound_file_path,
549: (16)                           bitrate="312k",
550: (12)                       )
551: (12)                       temp_file_path = movie_file_path.with_name(
552: (16)                           f"{movie_file_path.stem}_temp{movie_file_path.suffix}"
553: (12)                       )
554: (12)                       commands = [
555: (16)                           config.ffmpeg_executable,
556: (16)                           "-i",
557: (16)                           str(movie_file_path),
558: (16)                           "-i",
559: (16)                           str(sound_file_path),
560: (16)                           "-y",  # overwrite output file if it exists
561: (16)                           "-c:v",
562: (16)                           "copy",
563: (16)                           "-c:a",
564: (16)                           "aac",
565: (16)                           "-b:a",
566: (16)                           "320k",
567: (16)                           # select video stream from first file
568: (16)                           "-map",
569: (16)                           "0:v:0",
570: (16)                           # select audio stream from second file
571: (16)                           "-map",
572: (16)                           "1:a:0",
573: (16)                           "-loglevel",
574: (16)                           config.ffmpeg_loglevel.lower(),
575: (16)                           "-metadata",
576: (16)                           f"comment=Rendered with Manim Community v{__version__}",
577: (16)                           # "-shortest",
578: (16)                           str(temp_file_path),
579: (12)                       ]
580: (12)                       subprocess.call(commands)
581: (12)                       shutil.move(str(temp_file_path), str(movie_file_path))
582: (12)                       sound_file_path.unlink()
583: (8)                    self.print_file_ready_message(str(movie_file_path))
584: (8)                    if write_to_movie():
585: (12)                       for file_path in partial_movie_files:
586: (16)                           # We have to modify the accessed time so if we have to clean the cache we remove the one used the longest.
587: (16)                           modify_atime(file_path)
588: (4)                def combine_to_section_videos(self) -> None:
589: (8)                    """Concatenate partial movie files for each section."""
590: (8)                    self.finish_last_section()
591: (8)                    sections_index: list[dict[str, Any]] = []
592: (8)                    for section in self.sections:
593: (12)                       # only if section does want to be saved
594: (12)                       if section.video is not None:
595: (16)                           logger.info(f"Combining partial files for section '{section.name}'")
596: (16)                           self.combine_files(
597: (20)                               section.get_clean_partial_movie_files(),
598: (20)                               self.sections_output_dir / section.video,
599: (16)                           )
600: (16)                           sections_index.append(section.get_dict(self.sections_output_dir))
601: (8)                    with (self.sections_output_dir / f"{self.output_name}.json").open("w") as file:
602: (12)                       json.dump(sections_index, file, indent=4)
603: (4)                def clean_cache(self):
604: (8)                    """Will clean the cache by removing the oldest partial_movie_files."""
605: (8)                    cached_partial_movies = [
606: (12)                       (self.partial_movie_directory / file_name)
607: (12)                       for file_name in self.partial_movie_directory.iterdir()
608: (12)                       if file_name != "partial_movie_file_list.txt"
609: (8)                    ]
610: (8)                    if len(cached_partial_movies) > config["max_files_cached"]:
611: (12)                       number_files_to_delete = (
612: (16)                           len(cached_partial_movies) - config["max_files_cached"]
613: (12)                       )
614: (12)                       oldest_files_to_delete = sorted(
615: (16)                           cached_partial_movies,
616: (16)                           key=lambda path: path.stat().st_atime,
617: (12)                       )[:number_files_to_delete]
618: (12)                       for file_to_delete in oldest_files_to_delete:
619: (16)                           file_to_delete.unlink()
620: (12)                       logger.info(
621: (16)                           f"The partial movie directory is full (> {config['max_files_cached']} files). Therefore, manim has removed the {number_files_to_delete} oldest file(s)."
622: (16)                           " You can change this behaviour by changing max_files_cached in config.",
623: (12)                       )
624: (4)                def flush_cache_directory(self):
625: (8)                    """Delete all the cached partial movie files"""
626: (8)                    cached_partial_movies = [
627: (12)                       self.partial_movie_directory / file_name
628: (12)                       for file_name in self.partial_movie_directory.iterdir()
629: (12)                       if file_name != "partial_movie_file_list.txt"
630: (8)                    ]
631: (8)                    for f in cached_partial_movies:
632: (12)                       f.unlink()
633: (8)                    logger.info(
634: (12)                       f"Cache flushed. {len(cached_partial_movies)} file(s) deleted in %(par_dir)s.",
635: (12)                       {"par_dir": self.partial_movie_directory},
636: (8)                    )
637: (4)                def write_subcaption_file(self):
638: (8)                    """Writes the subcaption file."""
639: (8)                    if config.output_file is None:
640: (12)                       return
641: (8)                    subcaption_file = Path(config.output_file).with_suffix(".srt")
642: (8)                    subcaption_file.write_text(srt.compose(self.subcaptions), encoding="utf-8")
643: (8)                    logger.info(f"Subcaption file has been written as {subcaption_file}")
644: (4)                def print_file_ready_message(self, file_path):
645: (8)                    """Prints the "File Ready" message to STDOUT."""
646: (8)                    config["output_file"] = file_path
647: (8)                    logger.info("\nFile ready at %(file_path)s\n", {"file_path": f"'{file_path}'"})

----------------------------------------

File 8 - . \vector_space_scene.py:

1: (0)              """A scene suitable for vector spaces."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["VectorScene", "LinearTransformationScene"]
4: (0)              from typing import Callable
5: (0)              import numpy as np
6: (0)              from manim.mobject.geometry.arc import Dot
7: (0)              from manim.mobject.geometry.line import Arrow, Line, Vector
8: (0)              from manim.mobject.geometry.polygram import Rectangle
9: (0)              from manim.mobject.graphing.coordinate_systems import Axes, NumberPlane
10: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLMobject
11: (0)             from manim.mobject.text.tex_mobject import MathTex, Tex
12: (0)             from manim.utils.config_ops import update_dict_recursively
13: (0)             from .. import config
14: (0)             from ..animation.animation import Animation
15: (0)             from ..animation.creation import Create, Write
16: (0)             from ..animation.fading import FadeOut
17: (0)             from ..animation.growing import GrowArrow
18: (0)             from ..animation.transform import ApplyFunction, ApplyPointwiseFunction, Transform
19: (0)             from ..constants import *
20: (0)             from ..mobject.matrix import Matrix
21: (0)             from ..mobject.mobject import Mobject
22: (0)             from ..mobject.types.vectorized_mobject import VGroup, VMobject
23: (0)             from ..scene.scene import Scene
24: (0)             from ..utils.color import (
25: (4)                 BLACK,
26: (4)                 BLUE_D,
27: (4)                 GREEN_C,
28: (4)                 GREY,
29: (4)                 RED_C,
30: (4)                 WHITE,
31: (4)                 YELLOW,
32: (4)                 ManimColor,
33: (4)                 ParsableManimColor,
34: (0)             )
35: (0)             from ..utils.rate_functions import rush_from, rush_into
36: (0)             from ..utils.space_ops import angle_of_vector
37: (0)             X_COLOR = GREEN_C
38: (0)             Y_COLOR = RED_C
39: (0)             Z_COLOR = BLUE_D
40: (0)             # TODO: Much of this scene type seems dependent on the coordinate system chosen.
41: (0)             # That is, being centered at the origin with grid units corresponding to the
42: (0)             # arbitrary space units.  Change it!
43: (0)             #
44: (0)             # Also, methods I would have thought of as getters, like coords_to_vector, are
45: (0)             # actually doing a lot of animating.
46: (0)             class VectorScene(Scene):
47: (4)                 def __init__(self, basis_vector_stroke_width=6, **kwargs):
48: (8)                     super().__init__(**kwargs)
49: (8)                     self.basis_vector_stroke_width = basis_vector_stroke_width
50: (4)                 def add_plane(self, animate: bool = False, **kwargs):
51: (8)                     """
52: (8)                     Adds a NumberPlane object to the background.
53: (8)                     Parameters
54: (8)                     ----------
55: (8)                     animate
56: (12)                        Whether or not to animate the addition of the plane via Create.
57: (8)                     **kwargs
58: (12)                        Any valid keyword arguments accepted by NumberPlane.
59: (8)                     Returns
60: (8)                     -------
61: (8)                     NumberPlane
62: (12)                        The NumberPlane object.
63: (8)                     """
64: (8)                     plane = NumberPlane(**kwargs)
65: (8)                     if animate:
66: (12)                        self.play(Create(plane, lag_ratio=0.5))
67: (8)                     self.add(plane)
68: (8)                     return plane
69: (4)                 def add_axes(self, animate: bool = False, color: bool = WHITE, **kwargs):
70: (8)                     """
71: (8)                     Adds a pair of Axes to the Scene.
72: (8)                     Parameters
73: (8)                     ----------
74: (8)                     animate
75: (12)                        Whether or not to animate the addition of the axes through Create.
76: (8)                     color
77: (12)                        The color of the axes. Defaults to WHITE.
78: (8)                     """
79: (8)                     axes = Axes(color=color, axis_config={"unit_size": 1})
80: (8)                     if animate:
81: (12)                        self.play(Create(axes))
82: (8)                     self.add(axes)
83: (8)                     return axes
84: (4)                 def lock_in_faded_grid(self, dimness: float = 0.7, axes_dimness: float = 0.5):
85: (8)                     """
86: (8)                     This method freezes the NumberPlane and Axes that were already
87: (8)                     in the background, and adds new, manipulatable ones to the foreground.
88: (8)                     Parameters
89: (8)                     ----------
90: (8)                     dimness
91: (12)                        The required dimness of the NumberPlane
92: (8)                     axes_dimness
93: (12)                        The required dimness of the Axes.
94: (8)                     """
95: (8)                     plane = self.add_plane()
96: (8)                     axes = plane.get_axes()
97: (8)                     plane.fade(dimness)
98: (8)                     axes.set_color(WHITE)
99: (8)                     axes.fade(axes_dimness)
100: (8)                    self.add(axes)
101: (8)                    self.renderer.update_frame()
102: (8)                    self.renderer.camera = Camera(self.renderer.get_frame())
103: (8)                    self.clear()
104: (4)                def get_vector(self, numerical_vector: np.ndarray | list | tuple, **kwargs):
105: (8)                    """
106: (8)                    Returns an arrow on the Plane given an input numerical vector.
107: (8)                    Parameters
108: (8)                    ----------
109: (8)                    numerical_vector
110: (12)                       The Vector to plot.
111: (8)                    **kwargs
112: (12)                       Any valid keyword argument of Arrow.
113: (8)                    Returns
114: (8)                    -------
115: (8)                    Arrow
116: (12)                       The Arrow representing the Vector.
117: (8)                    """
118: (8)                    return Arrow(
119: (12)                       self.plane.coords_to_point(0, 0),
120: (12)                       self.plane.coords_to_point(*numerical_vector[:2]),
121: (12)                       buff=0,
122: (12)                       **kwargs,
123: (8)                    )
124: (4)                def add_vector(
125: (8)                    self,
126: (8)                    vector: Arrow | list | tuple | np.ndarray,
127: (8)                    color: str = YELLOW,
128: (8)                    animate: bool = True,
129: (8)                    **kwargs,
130: (4)                ):
131: (8)                    """
132: (8)                    Returns the Vector after adding it to the Plane.
133: (8)                    Parameters
134: (8)                    ----------
135: (8)                    vector
136: (12)                       It can be a pre-made graphical vector, or the
137: (12)                       coordinates of one.
138: (8)                    color
139: (12)                       The string of the hex color of the vector.
140: (12)                       This is only taken into consideration if
141: (12)                       'vector' is not an Arrow. Defaults to YELLOW.
142: (8)                    animate
143: (12)                       Whether or not to animate the addition of the vector
144: (12)                       by using GrowArrow
145: (8)                    **kwargs
146: (12)                       Any valid keyword argument of Arrow.
147: (12)                       These are only considered if vector is not
148: (12)                       an Arrow.
149: (8)                    Returns
150: (8)                    -------
151: (8)                    Arrow
152: (12)                       The arrow representing the vector.
153: (8)                    """
154: (8)                    if not isinstance(vector, Arrow):
155: (12)                       vector = Vector(vector, color=color, **kwargs)
156: (8)                    if animate:
157: (12)                       self.play(GrowArrow(vector))
158: (8)                    self.add(vector)
159: (8)                    return vector
160: (4)                def write_vector_coordinates(self, vector: Arrow, **kwargs):
161: (8)                    """
162: (8)                    Returns a column matrix indicating the vector coordinates,
163: (8)                    after writing them to the screen.
164: (8)                    Parameters
165: (8)                    ----------
166: (8)                    vector
167: (12)                       The arrow representing the vector.
168: (8)                    **kwargs
169: (12)                       Any valid keyword arguments of :meth:`~.Vector.coordinate_label`:
170: (8)                    Returns
171: (8)                    -------
172: (8)                    :class:`.Matrix`
173: (12)                       The column matrix representing the vector.
174: (8)                    """
175: (8)                    coords = vector.coordinate_label(**kwargs)
176: (8)                    self.play(Write(coords))
177: (8)                    return coords
178: (4)                def get_basis_vectors(self, i_hat_color: str = X_COLOR, j_hat_color: str = Y_COLOR):
179: (8)                    """
180: (8)                    Returns a VGroup of the Basis Vectors (1,0) and (0,1)
181: (8)                    Parameters
182: (8)                    ----------
183: (8)                    i_hat_color
184: (12)                       The hex colour to use for the basis vector in the x direction
185: (8)                    j_hat_color
186: (12)                       The hex colour to use for the basis vector in the y direction
187: (8)                    Returns
188: (8)                    -------
189: (8)                    VGroup
190: (12)                       VGroup of the Vector Mobjects representing the basis vectors.
191: (8)                    """
192: (8)                    return VGroup(
193: (12)                       *(
194: (16)                           Vector(vect, color=color, stroke_width=self.basis_vector_stroke_width)
195: (16)                           for vect, color in [([1, 0], i_hat_color), ([0, 1], j_hat_color)]
196: (12)                       )
197: (8)                    )
198: (4)                def get_basis_vector_labels(self, **kwargs):
199: (8)                    """
200: (8)                    Returns naming labels for the basis vectors.
201: (8)                    Parameters
202: (8)                    ----------
203: (8)                    **kwargs
204: (12)                       Any valid keyword arguments of get_vector_label:
205: (16)                           vector,
206: (16)                           label (str,MathTex)
207: (16)                           at_tip (bool=False),
208: (16)                           direction (str="left"),
209: (16)                           rotate (bool),
210: (16)                           color (str),
211: (16)                           label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),
212: (8)                    """
213: (8)                    i_hat, j_hat = self.get_basis_vectors()
214: (8)                    return VGroup(
215: (12)                       *(
216: (16)                           self.get_vector_label(
217: (20)                               vect, label, color=color, label_scale_factor=1, **kwargs
218: (16)                           )
219: (16)                           for vect, label, color in [
220: (20)                               (i_hat, "\\hat{\\imath}", X_COLOR),
221: (20)                               (j_hat, "\\hat{\\jmath}", Y_COLOR),
222: (16)                           ]
223: (12)                       )
224: (8)                    )
225: (4)                def get_vector_label(
226: (8)                    self,
227: (8)                    vector: Vector,
228: (8)                    label,
229: (8)                    at_tip: bool = False,
230: (8)                    direction: str = "left",
231: (8)                    rotate: bool = False,
232: (8)                    color: str | None = None,
233: (8)                    label_scale_factor: float = LARGE_BUFF - 0.2,
234: (4)                ):
235: (8)                    """
236: (8)                    Returns naming labels for the passed vector.
237: (8)                    Parameters
238: (8)                    ----------
239: (8)                    vector
240: (12)                       Vector Object for which to get the label.
241: (8)                    at_tip
242: (12)                       Whether or not to place the label at the tip of the vector.
243: (8)                    direction
244: (12)                       If the label should be on the "left" or right of the vector.
245: (8)                    rotate
246: (12)                       Whether or not to rotate it to align it with the vector.
247: (8)                    color
248: (12)                       The color to give the label.
249: (8)                    label_scale_factor
250: (12)                       How much to scale the label by.
251: (8)                    Returns
252: (8)                    -------
253: (8)                    MathTex
254: (12)                       The MathTex of the label.
255: (8)                    """
256: (8)                    if not isinstance(label, MathTex):
257: (12)                       if len(label) == 1:
258: (16)                           label = "\\vec{\\textbf{%s}}" % label
259: (12)                       label = MathTex(label)
260: (12)                       if color is None:
261: (16)                           color = vector.get_color()
262: (12)                       label.set_color(color)
263: (8)                    label.scale(label_scale_factor)
264: (8)                    label.add_background_rectangle()
265: (8)                    if at_tip:
266: (12)                       vect = vector.get_vector()
267: (12)                       vect /= np.linalg.norm(vect)
268: (12)                       label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)
269: (8)                    else:
270: (12)                       angle = vector.get_angle()
271: (12)                       if not rotate:
272: (16)                           label.rotate(-angle, about_point=ORIGIN)
273: (12)                       if direction == "left":
274: (16)                           label.shift(-label.get_bottom() + 0.1 * UP)
275: (12)                       else:
276: (16)                           label.shift(-label.get_top() + 0.1 * DOWN)
277: (12)                       label.rotate(angle, about_point=ORIGIN)
278: (12)                       label.shift((vector.get_end() - vector.get_start()) / 2)
279: (8)                    return label
280: (4)                def label_vector(
281: (8)                    self, vector: Vector, label: MathTex | str, animate: bool = True, **kwargs
282: (4)                ):
283: (8)                    """
284: (8)                    Shortcut method for creating, and animating the addition of
285: (8)                    a label for the vector.
286: (8)                    Parameters
287: (8)                    ----------
288: (8)                    vector
289: (12)                       The vector for which the label must be added.
290: (8)                    label
291: (12)                       The MathTex/string of the label.
292: (8)                    animate
293: (12)                       Whether or not to animate the labelling w/ Write
294: (8)                    **kwargs
295: (12)                       Any valid keyword argument of get_vector_label
296: (8)                    Returns
297: (8)                    -------
298: (8)                    :class:`~.MathTex`
299: (12)                       The MathTex of the label.
300: (8)                    """
301: (8)                    label = self.get_vector_label(vector, label, **kwargs)
302: (8)                    if animate:
303: (12)                       self.play(Write(label, run_time=1))
304: (8)                    self.add(label)
305: (8)                    return label
306: (4)                def position_x_coordinate(
307: (8)                    self,
308: (8)                    x_coord,
309: (8)                    x_line,
310: (8)                    vector,
311: (4)                ):  # TODO Write DocStrings for this.
312: (8)                    x_coord.next_to(x_line, -np.sign(vector[1]) * UP)
313: (8)                    x_coord.set_color(X_COLOR)
314: (8)                    return x_coord
315: (4)                def position_y_coordinate(
316: (8)                    self,
317: (8)                    y_coord,
318: (8)                    y_line,
319: (8)                    vector,
320: (4)                ):  # TODO Write DocStrings for this.
321: (8)                    y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)
322: (8)                    y_coord.set_color(Y_COLOR)
323: (8)                    return y_coord
324: (4)                def coords_to_vector(
325: (8)                    self,
326: (8)                    vector: np.ndarray | list | tuple,
327: (8)                    coords_start: np.ndarray | list | tuple = 2 * RIGHT + 2 * UP,
328: (8)                    clean_up: bool = True,
329: (4)                ):
330: (8)                    """
331: (8)                    This method writes the vector as a column matrix (henceforth called the label),
332: (8)                    takes the values in it one by one, and form the corresponding
333: (8)                    lines that make up the x and y components of the vector. Then, an
334: (8)                    Vector() based vector is created between the lines on the Screen.
335: (8)                    Parameters
336: (8)                    ----------
337: (8)                    vector
338: (12)                       The vector to show.
339: (8)                    coords_start
340: (12)                       The starting point of the location of
341: (12)                       the label of the vector that shows it
342: (12)                       numerically.
343: (12)                       Defaults to 2 * RIGHT + 2 * UP or (2,2)
344: (8)                    clean_up
345: (12)                       Whether or not to remove whatever
346: (12)                       this method did after it's done.
347: (8)                    """
348: (8)                    starting_mobjects = list(self.mobjects)
349: (8)                    array = Matrix(vector)
350: (8)                    array.shift(coords_start)
351: (8)                    arrow = Vector(vector)
352: (8)                    x_line = Line(ORIGIN, vector[0] * RIGHT)
353: (8)                    y_line = Line(x_line.get_end(), arrow.get_end())
354: (8)                    x_line.set_color(X_COLOR)
355: (8)                    y_line.set_color(Y_COLOR)
356: (8)                    x_coord, y_coord = array.get_mob_matrix().flatten()
357: (8)                    self.play(Write(array, run_time=1))
358: (8)                    self.wait()
359: (8)                    self.play(
360: (12)                       ApplyFunction(
361: (16)                           lambda x: self.position_x_coordinate(x, x_line, vector),
362: (16)                           x_coord,
363: (12)                       ),
364: (8)                    )
365: (8)                    self.play(Create(x_line))
366: (8)                    animations = [
367: (12)                       ApplyFunction(
368: (16)                           lambda y: self.position_y_coordinate(y, y_line, vector),
369: (16)                           y_coord,
370: (12)                       ),
371: (12)                       FadeOut(array.get_brackets()),
372: (8)                    ]
373: (8)                    self.play(*animations)
374: (8)                    y_coord, _ = (anim.mobject for anim in animations)
375: (8)                    self.play(Create(y_line))
376: (8)                    self.play(Create(arrow))
377: (8)                    self.wait()
378: (8)                    if clean_up:
379: (12)                       self.clear()
380: (12)                       self.add(*starting_mobjects)
381: (4)                def vector_to_coords(
382: (8)                    self,
383: (8)                    vector: np.ndarray | list | tuple,
384: (8)                    integer_labels: bool = True,
385: (8)                    clean_up: bool = True,
386: (4)                ):
387: (8)                    """
388: (8)                    This method displays vector as a Vector() based vector, and then shows
389: (8)                    the corresponding lines that make up the x and y components of the vector.
390: (8)                    Then, a column matrix (henceforth called the label) is created near the
391: (8)                    head of the Vector.
392: (8)                    Parameters
393: (8)                    ----------
394: (8)                    vector
395: (12)                       The vector to show.
396: (8)                    integer_labels
397: (12)                       Whether or not to round the value displayed.
398: (12)                       in the vector's label to the nearest integer
399: (8)                    clean_up
400: (12)                       Whether or not to remove whatever
401: (12)                       this method did after it's done.
402: (8)                    """
403: (8)                    starting_mobjects = list(self.mobjects)
404: (8)                    show_creation = False
405: (8)                    if isinstance(vector, Arrow):
406: (12)                       arrow = vector
407: (12)                       vector = arrow.get_end()[:2]
408: (8)                    else:
409: (12)                       arrow = Vector(vector)
410: (12)                       show_creation = True
411: (8)                    array = arrow.coordinate_label(integer_labels=integer_labels)
412: (8)                    x_line = Line(ORIGIN, vector[0] * RIGHT)
413: (8)                    y_line = Line(x_line.get_end(), arrow.get_end())
414: (8)                    x_line.set_color(X_COLOR)
415: (8)                    y_line.set_color(Y_COLOR)
416: (8)                    x_coord, y_coord = array.get_entries()
417: (8)                    x_coord_start = self.position_x_coordinate(x_coord.copy(), x_line, vector)
418: (8)                    y_coord_start = self.position_y_coordinate(y_coord.copy(), y_line, vector)
419: (8)                    brackets = array.get_brackets()
420: (8)                    if show_creation:
421: (12)                       self.play(Create(arrow))
422: (8)                    self.play(Create(x_line), Write(x_coord_start), run_time=1)
423: (8)                    self.play(Create(y_line), Write(y_coord_start), run_time=1)
424: (8)                    self.wait()
425: (8)                    self.play(
426: (12)                       Transform(x_coord_start, x_coord, lag_ratio=0),
427: (12)                       Transform(y_coord_start, y_coord, lag_ratio=0),
428: (12)                       Write(brackets, run_time=1),
429: (8)                    )
430: (8)                    self.wait()
431: (8)                    self.remove(x_coord_start, y_coord_start, brackets)
432: (8)                    self.add(array)
433: (8)                    if clean_up:
434: (12)                       self.clear()
435: (12)                       self.add(*starting_mobjects)
436: (8)                    return array, x_line, y_line
437: (4)                def show_ghost_movement(self, vector: Arrow | list | tuple | np.ndarray):
438: (8)                    """
439: (8)                    This method plays an animation that partially shows the entire plane moving
440: (8)                    in the direction of a particular vector. This is useful when you wish to
441: (8)                    convey the idea of mentally moving the entire plane in a direction, without
442: (8)                    actually moving the plane.
443: (8)                    Parameters
444: (8)                    ----------
445: (8)                    vector
446: (12)                       The vector which indicates the direction of movement.
447: (8)                    """
448: (8)                    if isinstance(vector, Arrow):
449: (12)                       vector = vector.get_end() - vector.get_start()
450: (8)                    elif len(vector) == 2:
451: (12)                       vector = np.append(np.array(vector), 0.0)
452: (8)                    x_max = int(config["frame_x_radius"] + abs(vector[0]))
453: (8)                    y_max = int(config["frame_y_radius"] + abs(vector[1]))
454: (8)                    dots = VMobject(
455: (12)                       *(
456: (16)                           Dot(x * RIGHT + y * UP)
457: (16)                           for x in range(-x_max, x_max)
458: (16)                           for y in range(-y_max, y_max)
459: (12)                       )
460: (8)                    )
461: (8)                    dots.set_fill(BLACK, opacity=0)
462: (8)                    dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)
463: (8)                    dots_end = dots.copy().shift(vector)
464: (8)                    self.play(Transform(dots, dots_halfway, rate_func=rush_into))
465: (8)                    self.play(Transform(dots, dots_end, rate_func=rush_from))
466: (8)                    self.remove(dots)
467: (0)            class LinearTransformationScene(VectorScene):
468: (4)                """
469: (4)                This scene contains special methods that make it
470: (4)                especially suitable for showing linear transformations.
471: (4)                Parameters
472: (4)                ----------
473: (4)                include_background_plane
474: (8)                    Whether or not to include the background plane in the scene.
475: (4)                include_foreground_plane
476: (8)                    Whether or not to include the foreground plane in the scene.
477: (4)                background_plane_kwargs
478: (8)                    Parameters to be passed to :class:`NumberPlane` to adjust the background plane.
479: (4)                foreground_plane_kwargs
480: (8)                    Parameters to be passed to :class:`NumberPlane` to adjust the foreground plane.
481: (4)                show_coordinates
482: (8)                    Whether or not to include the coordinates for the background plane.
483: (4)                show_basis_vectors
484: (8)                    Whether to show the basis x_axis -> ``i_hat`` and y_axis -> ``j_hat`` vectors.
485: (4)                basis_vector_stroke_width
486: (8)                    The ``stroke_width`` of the basis vectors.
487: (4)                i_hat_color
488: (8)                    The color of the ``i_hat`` vector.
489: (4)                j_hat_color
490: (8)                    The color of the ``j_hat`` vector.
491: (4)                leave_ghost_vectors
492: (8)                    Indicates the previous position of the basis vectors following a transformation.
493: (4)                Examples
494: (4)                -------
495: (4)                .. manim:: LinearTransformationSceneExample
496: (8)                    class LinearTransformationSceneExample(LinearTransformationScene):
497: (12)                       def __init__(self, **kwargs):
498: (16)                           LinearTransformationScene.__init__(
499: (20)                               self,
500: (20)                               show_coordinates=True,
501: (20)                               leave_ghost_vectors=True,
502: (20)                               **kwargs
503: (16)                           )
504: (12)                       def construct(self):
505: (16)                           matrix = [[1, 1], [0, 1]]
506: (16)                           self.apply_matrix(matrix)
507: (16)                           self.wait()
508: (4)                """
509: (4)                def __init__(
510: (8)                    self,
511: (8)                    include_background_plane: bool = True,
512: (8)                    include_foreground_plane: bool = True,
513: (8)                    background_plane_kwargs: dict | None = None,
514: (8)                    foreground_plane_kwargs: dict | None = None,
515: (8)                    show_coordinates: bool = False,
516: (8)                    show_basis_vectors: bool = True,
517: (8)                    basis_vector_stroke_width: float = 6,
518: (8)                    i_hat_color: ParsableManimColor = X_COLOR,
519: (8)                    j_hat_color: ParsableManimColor = Y_COLOR,
520: (8)                    leave_ghost_vectors: bool = False,
521: (8)                    **kwargs,
522: (4)                ):
523: (8)                    super().__init__(**kwargs)
524: (8)                    self.include_background_plane = include_background_plane
525: (8)                    self.include_foreground_plane = include_foreground_plane
526: (8)                    self.show_coordinates = show_coordinates
527: (8)                    self.show_basis_vectors = show_basis_vectors
528: (8)                    self.basis_vector_stroke_width = basis_vector_stroke_width
529: (8)                    self.i_hat_color = ManimColor(i_hat_color)
530: (8)                    self.j_hat_color = ManimColor(j_hat_color)
531: (8)                    self.leave_ghost_vectors = leave_ghost_vectors
532: (8)                    self.background_plane_kwargs = {
533: (12)                       "color": GREY,
534: (12)                       "axis_config": {
535: (16)                           "color": GREY,
536: (12)                       },
537: (12)                       "background_line_style": {
538: (16)                           "stroke_color": GREY,
539: (16)                           "stroke_width": 1,
540: (12)                       },
541: (8)                    }
542: (8)                    self.ghost_vectors = VGroup()
543: (8)                    self.foreground_plane_kwargs = {
544: (12)                       "x_range": np.array([-config["frame_width"], config["frame_width"], 1.0]),
545: (12)                       "y_range": np.array([-config["frame_width"], config["frame_width"], 1.0]),
546: (12)                       "faded_line_ratio": 1,
547: (8)                    }
548: (8)                    self.update_default_configs(
549: (12)                       (self.foreground_plane_kwargs, self.background_plane_kwargs),
550: (12)                       (foreground_plane_kwargs, background_plane_kwargs),
551: (8)                    )
552: (4)                @staticmethod
553: (4)                def update_default_configs(default_configs, passed_configs):
554: (8)                    for default_config, passed_config in zip(default_configs, passed_configs):
555: (12)                       if passed_config is not None:
556: (16)                           update_dict_recursively(default_config, passed_config)
557: (4)                def setup(self):
558: (8)                    # The has_already_setup attr is to not break all the old Scenes
559: (8)                    if hasattr(self, "has_already_setup"):
560: (12)                       return
561: (8)                    self.has_already_setup = True
562: (8)                    self.background_mobjects = []
563: (8)                    self.foreground_mobjects = []
564: (8)                    self.transformable_mobjects = []
565: (8)                    self.moving_vectors = []
566: (8)                    self.transformable_labels = []
567: (8)                    self.moving_mobjects = []
568: (8)                    self.background_plane = NumberPlane(**self.background_plane_kwargs)
569: (8)                    if self.show_coordinates:
570: (12)                       self.background_plane.add_coordinates()
571: (8)                    if self.include_background_plane:
572: (12)                       self.add_background_mobject(self.background_plane)
573: (8)                    if self.include_foreground_plane:
574: (12)                       self.plane = NumberPlane(**self.foreground_plane_kwargs)
575: (12)                       self.add_transformable_mobject(self.plane)
576: (8)                    if self.show_basis_vectors:
577: (12)                       self.basis_vectors = self.get_basis_vectors(
578: (16)                           i_hat_color=self.i_hat_color,
579: (16)                           j_hat_color=self.j_hat_color,
580: (12)                       )
581: (12)                       self.moving_vectors += list(self.basis_vectors)
582: (12)                       self.i_hat, self.j_hat = self.basis_vectors
583: (12)                       self.add(self.basis_vectors)
584: (4)                def add_special_mobjects(self, mob_list: list, *mobs_to_add: Mobject):
585: (8)                    """
586: (8)                    Adds mobjects to a separate list that can be tracked,
587: (8)                    if these mobjects have some extra importance.
588: (8)                    Parameters
589: (8)                    ----------
590: (8)                    mob_list
591: (12)                       The special list to which you want to add
592: (12)                       these mobjects.
593: (8)                    *mobs_to_add
594: (12)                       The mobjects to add.
595: (8)                    """
596: (8)                    for mobject in mobs_to_add:
597: (12)                       if mobject not in mob_list:
598: (16)                           mob_list.append(mobject)
599: (16)                           self.add(mobject)
600: (4)                def add_background_mobject(self, *mobjects: Mobject):
601: (8)                    """
602: (8)                    Adds the mobjects to the special list
603: (8)                    self.background_mobjects.
604: (8)                    Parameters
605: (8)                    ----------
606: (8)                    *mobjects
607: (12)                       The mobjects to add to the list.
608: (8)                    """
609: (8)                    self.add_special_mobjects(self.background_mobjects, *mobjects)
610: (4)                # TODO, this conflicts with Scene.add_fore
611: (4)                def add_foreground_mobject(self, *mobjects: Mobject):
612: (8)                    """
613: (8)                    Adds the mobjects to the special list
614: (8)                    self.foreground_mobjects.
615: (8)                    Parameters
616: (8)                    ----------
617: (8)                    *mobjects
618: (12)                       The mobjects to add to the list
619: (8)                    """
620: (8)                    self.add_special_mobjects(self.foreground_mobjects, *mobjects)
621: (4)                def add_transformable_mobject(self, *mobjects: Mobject):
622: (8)                    """
623: (8)                    Adds the mobjects to the special list
624: (8)                    self.transformable_mobjects.
625: (8)                    Parameters
626: (8)                    ----------
627: (8)                    *mobjects
628: (12)                       The mobjects to add to the list.
629: (8)                    """
630: (8)                    self.add_special_mobjects(self.transformable_mobjects, *mobjects)
631: (4)                def add_moving_mobject(
632: (8)                    self, mobject: Mobject, target_mobject: Mobject | None = None
633: (4)                ):
634: (8)                    """
635: (8)                    Adds the mobject to the special list
636: (8)                    self.moving_mobject, and adds a property
637: (8)                    to the mobject called mobject.target, which
638: (8)                    keeps track of what the mobject will move to
639: (8)                    or become etc.
640: (8)                    Parameters
641: (8)                    ----------
642: (8)                    mobject
643: (12)                       The mobjects to add to the list
644: (8)                    target_mobject
645: (12)                       What the moving_mobject goes to, etc.
646: (8)                    """
647: (8)                    mobject.target = target_mobject
648: (8)                    self.add_special_mobjects(self.moving_mobjects, mobject)
649: (4)                def get_ghost_vectors(self) -> VGroup:
650: (8)                    """
651: (8)                    Returns all ghost vectors ever added to ``self``. Each element is a ``VGroup`` of
652: (8)                    two ghost vectors.
653: (8)                    """
654: (8)                    return self.ghost_vectors
655: (4)                def get_unit_square(
656: (8)                    self, color: str = YELLOW, opacity: float = 0.3, stroke_width: float = 3
657: (4)                ):
658: (8)                    """
659: (8)                    Returns a unit square for the current NumberPlane.
660: (8)                    Parameters
661: (8)                    ----------
662: (8)                    color
663: (12)                       The string of the hex color code of the color wanted.
664: (8)                    opacity
665: (12)                       The opacity of the square
666: (8)                    stroke_width
667: (12)                       The stroke_width in pixels of the border of the square
668: (8)                    Returns
669: (8)                    -------
670: (8)                    Square
671: (8)                    """
672: (8)                    square = self.square = Rectangle(
673: (12)                       color=color,
674: (12)                       width=self.plane.get_x_unit_size(),
675: (12)                       height=self.plane.get_y_unit_size(),
676: (12)                       stroke_color=color,
677: (12)                       stroke_width=stroke_width,
678: (12)                       fill_color=color,
679: (12)                       fill_opacity=opacity,
680: (8)                    )
681: (8)                    square.move_to(self.plane.coords_to_point(0, 0), DL)
682: (8)                    return square
683: (4)                def add_unit_square(self, animate: bool = False, **kwargs):
684: (8)                    """
685: (8)                    Adds a unit square to the scene via
686: (8)                    self.get_unit_square.
687: (8)                    Parameters
688: (8)                    ----------
689: (8)                    animate
690: (12)                       Whether or not to animate the addition
691: (12)                       with DrawBorderThenFill.
692: (8)                    **kwargs
693: (12)                       Any valid keyword arguments of
694: (12)                       self.get_unit_square()
695: (8)                    Returns
696: (8)                    -------
697: (8)                    Square
698: (12)                       The unit square.
699: (8)                    """
700: (8)                    square = self.get_unit_square(**kwargs)
701: (8)                    if animate:
702: (12)                       self.play(
703: (16)                           DrawBorderThenFill(square),
704: (16)                           Animation(Group(*self.moving_vectors)),
705: (12)                       )
706: (8)                    self.add_transformable_mobject(square)
707: (8)                    self.bring_to_front(*self.moving_vectors)
708: (8)                    self.square = square
709: (8)                    return self
710: (4)                def add_vector(
711: (8)                    self, vector: Arrow | list | tuple | np.ndarray, color: str = YELLOW, **kwargs
712: (4)                ):
713: (8)                    """
714: (8)                    Adds a vector to the scene, and puts it in the special
715: (8)                    list self.moving_vectors.
716: (8)                    Parameters
717: (8)                    ----------
718: (8)                    vector
719: (12)                       It can be a pre-made graphical vector, or the
720: (12)                       coordinates of one.
721: (8)                    color
722: (12)                       The string of the hex color of the vector.
723: (12)                       This is only taken into consideration if
724: (12)                       'vector' is not an Arrow. Defaults to YELLOW.
725: (8)                    **kwargs
726: (12)                       Any valid keyword argument of VectorScene.add_vector.
727: (8)                    Returns
728: (8)                    -------
729: (8)                    Arrow
730: (12)                       The arrow representing the vector.
731: (8)                    """
732: (8)                    vector = super().add_vector(vector, color=color, **kwargs)
733: (8)                    self.moving_vectors.append(vector)
734: (8)                    return vector
735: (4)                def write_vector_coordinates(self, vector: Arrow, **kwargs):
736: (8)                    """
737: (8)                    Returns a column matrix indicating the vector coordinates,
738: (8)                    after writing them to the screen, and adding them to the
739: (8)                    special list self.foreground_mobjects
740: (8)                    Parameters
741: (8)                    ----------
742: (8)                    vector
743: (12)                       The arrow representing the vector.
744: (8)                    **kwargs
745: (12)                       Any valid keyword arguments of VectorScene.write_vector_coordinates
746: (8)                    Returns
747: (8)                    -------
748: (8)                    Matrix
749: (12)                       The column matrix representing the vector.
750: (8)                    """
751: (8)                    coords = super().write_vector_coordinates(vector, **kwargs)
752: (8)                    self.add_foreground_mobject(coords)
753: (8)                    return coords
754: (4)                def add_transformable_label(
755: (8)                    self,
756: (8)                    vector: Vector,
757: (8)                    label: MathTex | str,
758: (8)                    transformation_name: str | MathTex = "L",
759: (8)                    new_label: str | MathTex | None = None,
760: (8)                    **kwargs,
761: (4)                ):
762: (8)                    """
763: (8)                    Method for creating, and animating the addition of
764: (8)                    a transformable label for the vector.
765: (8)                    Parameters
766: (8)                    ----------
767: (8)                    vector
768: (12)                       The vector for which the label must be added.
769: (8)                    label
770: (12)                       The MathTex/string of the label.
771: (8)                    transformation_name
772: (12)                       The name to give the transformation as a label.
773: (8)                    new_label
774: (12)                       What the label should display after a Linear Transformation
775: (8)                    **kwargs
776: (12)                       Any valid keyword argument of get_vector_label
777: (8)                    Returns
778: (8)                    -------
779: (8)                    :class:`~.MathTex`
780: (12)                       The MathTex of the label.
781: (8)                    """
782: (8)                    label_mob = self.label_vector(vector, label, **kwargs)
783: (8)                    if new_label:
784: (12)                       label_mob.target_text = new_label
785: (8)                    else:
786: (12)                       label_mob.target_text = "{}({})".format(
787: (16)                           transformation_name,
788: (16)                           label_mob.get_tex_string(),
789: (12)                       )
790: (8)                    label_mob.vector = vector
791: (8)                    label_mob.kwargs = kwargs
792: (8)                    if "animate" in label_mob.kwargs:
793: (12)                       label_mob.kwargs.pop("animate")
794: (8)                    self.transformable_labels.append(label_mob)
795: (8)                    return label_mob
796: (4)                def add_title(
797: (8)                    self,
798: (8)                    title: str | MathTex | Tex,
799: (8)                    scale_factor: float = 1.5,
800: (8)                    animate: bool = False,
801: (4)                ):
802: (8)                    """
803: (8)                    Adds a title, after scaling it, adding a background rectangle,
804: (8)                    moving it to the top and adding it to foreground_mobjects adding
805: (8)                    it as a local variable of self. Returns the Scene.
806: (8)                    Parameters
807: (8)                    ----------
808: (8)                    title
809: (12)                       What the title should be.
810: (8)                    scale_factor
811: (12)                       How much the title should be scaled by.
812: (8)                    animate
813: (12)                       Whether or not to animate the addition.
814: (8)                    Returns
815: (8)                    -------
816: (8)                    LinearTransformationScene
817: (12)                       The scene with the title added to it.
818: (8)                    """
819: (8)                    if not isinstance(title, (Mobject, OpenGLMobject)):
820: (12)                       title = Tex(title).scale(scale_factor)
821: (8)                    title.to_edge(UP)
822: (8)                    title.add_background_rectangle()
823: (8)                    if animate:
824: (12)                       self.play(Write(title))
825: (8)                    self.add_foreground_mobject(title)
826: (8)                    self.title = title
827: (8)                    return self
828: (4)                def get_matrix_transformation(self, matrix: np.ndarray | list | tuple):
829: (8)                    """
830: (8)                    Returns a function corresponding to the linear
831: (8)                    transformation represented by the matrix passed.
832: (8)                    Parameters
833: (8)                    ----------
834: (8)                    matrix
835: (12)                       The matrix.
836: (8)                    """
837: (8)                    return self.get_transposed_matrix_transformation(np.array(matrix).T)
838: (4)                def get_transposed_matrix_transformation(
839: (8)                    self, transposed_matrix: np.ndarray | list | tuple
840: (4)                ):
841: (8)                    """
842: (8)                    Returns a function corresponding to the linear
843: (8)                    transformation represented by the transposed
844: (8)                    matrix passed.
845: (8)                    Parameters
846: (8)                    ----------
847: (8)                    transposed_matrix
848: (12)                       The matrix.
849: (8)                    """
850: (8)                    transposed_matrix = np.array(transposed_matrix)
851: (8)                    if transposed_matrix.shape == (2, 2):
852: (12)                       new_matrix = np.identity(3)
853: (12)                       new_matrix[:2, :2] = transposed_matrix
854: (12)                       transposed_matrix = new_matrix
855: (8)                    elif transposed_matrix.shape != (3, 3):
856: (12)                       raise ValueError("Matrix has bad dimensions")
857: (8)                    return lambda point: np.dot(point, transposed_matrix)
858: (4)                def get_piece_movement(self, pieces: list | tuple | np.ndarray):
859: (8)                    """
860: (8)                    This method returns an animation that moves an arbitrary
861: (8)                    mobject in "pieces" to its corresponding .target value.
862: (8)                    If self.leave_ghost_vectors is True, ghosts of the original
863: (8)                    positions/mobjects are left on screen
864: (8)                    Parameters
865: (8)                    ----------
866: (8)                    pieces
867: (12)                       The pieces for which the movement must be shown.
868: (8)                    Returns
869: (8)                    -------
870: (8)                    Animation
871: (12)                       The animation of the movement.
872: (8)                    """
873: (8)                    v_pieces = [piece for piece in pieces if isinstance(piece, VMobject)]
874: (8)                    start = VGroup(*v_pieces)
875: (8)                    target = VGroup(*(mob.target for mob in v_pieces))
876: (8)                    # don't add empty VGroups
877: (8)                    if self.leave_ghost_vectors and start.submobjects:
878: (12)                       # start.copy() gives a VGroup of Vectors
879: (12)                       self.ghost_vectors.add(start.copy().fade(0.7))
880: (12)                       self.add(self.ghost_vectors[-1])
881: (8)                    return Transform(start, target, lag_ratio=0)
882: (4)                def get_moving_mobject_movement(self, func: Callable[[np.ndarray], np.ndarray]):
883: (8)                    """
884: (8)                    This method returns an animation that moves a mobject
885: (8)                    in "self.moving_mobjects"  to its corresponding .target value.
886: (8)                    func is a function that determines where the .target goes.
887: (8)                    Parameters
888: (8)                    ----------
889: (8)                    func
890: (12)                       The function that determines where the .target of
891: (12)                       the moving mobject goes.
892: (8)                    Returns
893: (8)                    -------
894: (8)                    Animation
895: (12)                       The animation of the movement.
896: (8)                    """
897: (8)                    for m in self.moving_mobjects:
898: (12)                       if m.target is None:
899: (16)                           m.target = m.copy()
900: (12)                       target_point = func(m.get_center())
901: (12)                       m.target.move_to(target_point)
902: (8)                    return self.get_piece_movement(self.moving_mobjects)
903: (4)                def get_vector_movement(self, func: Callable[[np.ndarray], np.ndarray]):
904: (8)                    """
905: (8)                    This method returns an animation that moves a mobject
906: (8)                    in "self.moving_vectors"  to its corresponding .target value.
907: (8)                    func is a function that determines where the .target goes.
908: (8)                    Parameters
909: (8)                    ----------
910: (8)                    func
911: (12)                       The function that determines where the .target of
912: (12)                       the moving mobject goes.
913: (8)                    Returns
914: (8)                    -------
915: (8)                    Animation
916: (12)                       The animation of the movement.
917: (8)                    """
918: (8)                    for v in self.moving_vectors:
919: (12)                       v.target = Vector(func(v.get_end()), color=v.get_color())
920: (12)                       norm = np.linalg.norm(v.target.get_end())
921: (12)                       if norm < 0.1:
922: (16)                           v.target.get_tip().scale(norm)
923: (8)                    return self.get_piece_movement(self.moving_vectors)
924: (4)                def get_transformable_label_movement(self):
925: (8)                    """
926: (8)                    This method returns an animation that moves all labels
927: (8)                    in "self.transformable_labels" to its corresponding .target .
928: (8)                    Returns
929: (8)                    -------
930: (8)                    Animation
931: (12)                       The animation of the movement.
932: (8)                    """
933: (8)                    for label in self.transformable_labels:
934: (12)                       label.target = self.get_vector_label(
935: (16)                           label.vector.target, label.target_text, **label.kwargs
936: (12)                       )
937: (8)                    return self.get_piece_movement(self.transformable_labels)
938: (4)                def apply_matrix(self, matrix: np.ndarray | list | tuple, **kwargs):
939: (8)                    """
940: (8)                    Applies the transformation represented by the
941: (8)                    given matrix to the number plane, and each vector/similar
942: (8)                    mobject on it.
943: (8)                    Parameters
944: (8)                    ----------
945: (8)                    matrix
946: (12)                       The matrix.
947: (8)                    **kwargs
948: (12)                       Any valid keyword argument of self.apply_transposed_matrix()
949: (8)                    """
950: (8)                    self.apply_transposed_matrix(np.array(matrix).T, **kwargs)
951: (4)                def apply_inverse(self, matrix: np.ndarray | list | tuple, **kwargs):
952: (8)                    """
953: (8)                    This method applies the linear transformation
954: (8)                    represented by the inverse of the passed matrix
955: (8)                    to the number plane, and each vector/similar mobject on it.
956: (8)                    Parameters
957: (8)                    ----------
958: (8)                    matrix
959: (12)                       The matrix whose inverse is to be applied.
960: (8)                    **kwargs
961: (12)                       Any valid keyword argument of self.apply_matrix()
962: (8)                    """
963: (8)                    self.apply_matrix(np.linalg.inv(matrix), **kwargs)
964: (4)                def apply_transposed_matrix(
965: (8)                    self, transposed_matrix: np.ndarray | list | tuple, **kwargs
966: (4)                ):
967: (8)                    """
968: (8)                    Applies the transformation represented by the
969: (8)                    given transposed matrix to the number plane,
970: (8)                    and each vector/similar mobject on it.
971: (8)                    Parameters
972: (8)                    ----------
973: (8)                    transposed_matrix
974: (12)                       The matrix.
975: (8)                    **kwargs
976: (12)                       Any valid keyword argument of self.apply_function()
977: (8)                    """
978: (8)                    func = self.get_transposed_matrix_transformation(transposed_matrix)
979: (8)                    if "path_arc" not in kwargs:
980: (12)                       net_rotation = np.mean(
981: (16)                           [angle_of_vector(func(RIGHT)), angle_of_vector(func(UP)) - np.pi / 2],
982: (12)                       )
983: (12)                       kwargs["path_arc"] = net_rotation
984: (8)                    self.apply_function(func, **kwargs)
985: (4)                def apply_inverse_transpose(self, t_matrix: np.ndarray | list | tuple, **kwargs):
986: (8)                    """
987: (8)                    Applies the inverse of the transformation represented
988: (8)                    by the given transposed matrix to the number plane and each
989: (8)                    vector/similar mobject on it.
990: (8)                    Parameters
991: (8)                    ----------
992: (8)                    t_matrix
993: (12)                       The matrix.
994: (8)                    **kwargs
995: (12)                       Any valid keyword argument of self.apply_transposed_matrix()
996: (8)                    """
997: (8)                    t_inv = np.linalg.inv(np.array(t_matrix).T).T
998: (8)                    self.apply_transposed_matrix(t_inv, **kwargs)
999: (4)                def apply_nonlinear_transformation(
1000: (8)                   self, function: Callable[[np.ndarray], np.ndarray], **kwargs
1001: (4)               ):
1002: (8)                   """
1003: (8)                   Applies the non-linear transformation represented
1004: (8)                   by the given function to the number plane and each
1005: (8)                   vector/similar mobject on it.
1006: (8)                   Parameters
1007: (8)                   ----------
1008: (8)                   function
1009: (12)                      The function.
1010: (8)                   **kwargs
1011: (12)                      Any valid keyword argument of self.apply_function()
1012: (8)                   """
1013: (8)                   self.plane.prepare_for_nonlinear_transform()
1014: (8)                   self.apply_function(function, **kwargs)
1015: (4)               def apply_function(
1016: (8)                   self,
1017: (8)                   function: Callable[[np.ndarray], np.ndarray],
1018: (8)                   added_anims: list = [],
1019: (8)                   **kwargs,
1020: (4)               ):
1021: (8)                   """
1022: (8)                   Applies the given function to each of the mobjects in
1023: (8)                   self.transformable_mobjects, and plays the animation showing
1024: (8)                   this.
1025: (8)                   Parameters
1026: (8)                   ----------
1027: (8)                   function
1028: (12)                      The function that affects each point
1029: (12)                      of each mobject in self.transformable_mobjects.
1030: (8)                   added_anims
1031: (12)                      Any other animations that need to be played
1032: (12)                      simultaneously with this.
1033: (8)                   **kwargs
1034: (12)                      Any valid keyword argument of a self.play() call.
1035: (8)                   """
1036: (8)                   if "run_time" not in kwargs:
1037: (12)                      kwargs["run_time"] = 3
1038: (8)                   anims = (
1039: (12)                      [
1040: (16)                          ApplyPointwiseFunction(function, t_mob)
1041: (16)                          for t_mob in self.transformable_mobjects
1042: (12)                      ]
1043: (12)                      + [
1044: (16)                          self.get_vector_movement(function),
1045: (16)                          self.get_transformable_label_movement(),
1046: (16)                          self.get_moving_mobject_movement(function),
1047: (12)                      ]
1048: (12)                      + [Animation(f_mob) for f_mob in self.foreground_mobjects]
1049: (12)                      + added_anims
1050: (8)                   )
1051: (8)                   self.play(*anims, **kwargs)

----------------------------------------

File 9 - . \SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRYCOMBINER_aligner_20_characters_for_pythons_codes.py:

1: (0)              import os
2: (0)              from datetime import datetime
3: (0)              def get_file_info(root_folder):
4: (4)                  file_info_list = []
5: (4)                  for root, dirs, files in os.walk(root_folder):
6: (8)                      for file in files:
7: (12)                         try:
8: (16)                             # Check if the file is a Python file
9: (16)                             if file.endswith('.py'):
10: (20)                                file_path = os.path.join(root, file)
11: (20)                                # Get file times
12: (20)                                creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
13: (20)                                modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))
14: (20)                                # Get file extension
15: (20)                                file_extension = os.path.splitext(file)[1].lower()
16: (20)                                # Append file info to list
17: (20)                                file_info_list.append([file, file_path, creation_time, modified_time, file_extension, root])
18: (12)                        except Exception as e:
19: (16)                            print(f"Error processing file {file}: {e}")
20: (4)                 # Sort the files by multiple criteria
21: (4)                 file_info_list.sort(key=lambda x: (x[2], x[3], len(x[0]), x[4]))  # Sort by creation, modification time, name length, extension
22: (4)                 return file_info_list
23: (0)             def process_file(file_info_list):
24: (4)                 combined_output = []
25: (4)                 for idx, (file_name, file_path, creation_time, modified_time, file_extension, root) in enumerate(file_info_list):
26: (8)                     with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
27: (12)                        content = f.read()
28: (12)                        # Remove Python comments and blank lines
29: (10)                      ###  content = "\n".join([line for line in content.split('\n') if line.strip() and not line.strip().startswith("#")])
30: (12)                        content = "\n".join([line for line in content.split('\n') if line.strip() ])###and not line.strip().startswith("#")
31: (12)                        # Replace tabs with spaces
32: (12)                        content = content.replace('\t', '    ')
33: (12)                        # Process each line
34: (12)                        processed_lines = []
35: (12)                        for i, line in enumerate(content.split('\n')):
36: (16)                            # Count the number of starting blank spaces
37: (16)                            leading_spaces = len(line) - len(line.lstrip(' '))
38: (16)                            # Create the line with line number and leading spaces count
39: (16)                            line_number_str = f"{i+1}: ({leading_spaces})"
40: (16)                            # Calculate padding to align the original code at the 61st character
41: (16)                            padding = ' ' * (20 - len(line_number_str))
42: (16)                            processed_line = f"{line_number_str}{padding}{line}"
43: (16)                            processed_lines.append(processed_line)
44: (12)                        content_with_line_numbers = "\n".join(processed_lines)
45: (12)                        # Add file listing order and line number
46: (12)                        combined_output.append(f"File {idx + 1} - {root} \\{file_name}:\n")
47: (12)                        combined_output.append(content_with_line_numbers)
48: (12)                        combined_output.append("\n" + "-"*40 + "\n")
49: (4)                 return combined_output
50: (0)             # Set the root folder path
51: (0)             root_folder_path = '.'  # Set this to the desired folder
52: (0)             # Get file information and process files
53: (0)             file_info_list = get_file_info(root_folder_path)
54: (0)             combined_output = process_file(file_info_list)
55: (0)             # Save the processed data to an output file
56: (0)             output_file = 'WITHRELPATH_COMMENTSKEPT_SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRY_combined_python_files_20_chars.txt'
57: (0)             with open(output_file, 'w', encoding='utf-8') as logfile:
58: (4)                 logfile.write("\n".join(combined_output))
59: (0)             print(f"Processed file info logged to {output_file}")

----------------------------------------
