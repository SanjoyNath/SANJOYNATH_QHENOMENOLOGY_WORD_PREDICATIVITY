File 1 - . \fading.py:

1: (0)              """Fading in and out of view.
2: (0)              .. manim:: Fading
3: (4)                  class Fading(Scene):
4: (8)                      def construct(self):
5: (12)                         tex_in = Tex("Fade", "In").scale(3)
6: (12)                         tex_out = Tex("Fade", "Out").scale(3)
7: (12)                         self.play(FadeIn(tex_in, shift=DOWN, scale=0.66))
8: (12)                         self.play(ReplacementTransform(tex_in, tex_out))
9: (12)                         self.play(FadeOut(tex_out, shift=DOWN * 2, scale=1.5))
10: (0)             """
11: (0)             from __future__ import annotations
12: (0)             __all__ = [
13: (4)                 "FadeOut",
14: (4)                 "FadeIn",
15: (0)             ]
16: (0)             import numpy as np
17: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLMobject
18: (0)             from ..animation.transform import Transform
19: (0)             from ..constants import ORIGIN
20: (0)             from ..mobject.mobject import Group, Mobject
21: (0)             from ..scene.scene import Scene
22: (0)             class _Fade(Transform):
23: (4)                 """Fade :class:`~.Mobject` s in or out.
24: (4)                 Parameters
25: (4)                 ----------
26: (4)                 mobjects
27: (8)                     The mobjects to be faded.
28: (4)                 shift
29: (8)                     The vector by which the mobject shifts while being faded.
30: (4)                 target_position
31: (8)                     The position to/from which the mobject moves while being faded in. In case
32: (8)                     another mobject is given as target position, its center is used.
33: (4)                 scale
34: (8)                     The factor by which the mobject is scaled initially before being rescaling to
35: (8)                     its original size while being faded in.
36: (4)                 """
37: (4)                 def __init__(
38: (8)                     self,
39: (8)                     *mobjects: Mobject,
40: (8)                     shift: np.ndarray | None = None,
41: (8)                     target_position: np.ndarray | Mobject | None = None,
42: (8)                     scale: float = 1,
43: (8)                     **kwargs,
44: (4)                 ) -> None:
45: (8)                     if not mobjects:
46: (12)                        raise ValueError("At least one mobject must be passed.")
47: (8)                     if len(mobjects) == 1:
48: (12)                        mobject = mobjects[0]
49: (8)                     else:
50: (12)                        mobject = Group(*mobjects)
51: (8)                     self.point_target = False
52: (8)                     if shift is None:
53: (12)                        if target_position is not None:
54: (16)                            if isinstance(target_position, (Mobject, OpenGLMobject)):
55: (20)                                target_position = target_position.get_center()
56: (16)                            shift = target_position - mobject.get_center()
57: (16)                            self.point_target = True
58: (12)                        else:
59: (16)                            shift = ORIGIN
60: (8)                     self.shift_vector = shift
61: (8)                     self.scale_factor = scale
62: (8)                     super().__init__(mobject, **kwargs)
63: (4)                 def _create_faded_mobject(self, fadeIn: bool) -> Mobject:
64: (8)                     """Create a faded, shifted and scaled copy of the mobject.
65: (8)                     Parameters
66: (8)                     ----------
67: (8)                     fadeIn
68: (12)                        Whether the faded mobject is used to fade in.
69: (8)                     Returns
70: (8)                     -------
71: (8)                     Mobject
72: (12)                        The faded, shifted and scaled copy of the mobject.
73: (8)                     """
74: (8)                     faded_mobject = self.mobject.copy()
75: (8)                     faded_mobject.fade(1)
76: (8)                     direction_modifier = -1 if fadeIn and not self.point_target else 1
77: (8)                     faded_mobject.shift(self.shift_vector * direction_modifier)
78: (8)                     faded_mobject.scale(self.scale_factor)
79: (8)                     return faded_mobject
80: (0)             class FadeIn(_Fade):
81: (4)                 """Fade in :class:`~.Mobject` s.
82: (4)                 Parameters
83: (4)                 ----------
84: (4)                 mobjects
85: (8)                     The mobjects to be faded in.
86: (4)                 shift
87: (8)                     The vector by which the mobject shifts while being faded in.
88: (4)                 target_position
89: (8)                     The position from which the mobject starts while being faded in. In case
90: (8)                     another mobject is given as target position, its center is used.
91: (4)                 scale
92: (8)                     The factor by which the mobject is scaled initially before being rescaling to
93: (8)                     its original size while being faded in.
94: (4)                 Examples
95: (4)                 --------
96: (4)                 .. manim :: FadeInExample
97: (8)                     class FadeInExample(Scene):
98: (12)                        def construct(self):
99: (16)                            dot = Dot(UP * 2 + LEFT)
100: (16)                           self.add(dot)
101: (16)                           tex = Tex(
102: (20)                               "FadeIn with ", "shift ", " or target\\_position", " and scale"
103: (16)                           ).scale(1)
104: (16)                           animations = [
105: (20)                               FadeIn(tex[0]),
106: (20)                               FadeIn(tex[1], shift=DOWN),
107: (20)                               FadeIn(tex[2], target_position=dot),
108: (20)                               FadeIn(tex[3], scale=1.5),
109: (16)                           ]
110: (16)                           self.play(AnimationGroup(*animations, lag_ratio=0.5))
111: (4)                """
112: (4)                def __init__(self, *mobjects: Mobject, **kwargs) -> None:
113: (8)                    super().__init__(*mobjects, introducer=True, **kwargs)
114: (4)                def create_target(self):
115: (8)                    return self.mobject
116: (4)                def create_starting_mobject(self):
117: (8)                    return self._create_faded_mobject(fadeIn=True)
118: (0)            class FadeOut(_Fade):
119: (4)                """Fade out :class:`~.Mobject` s.
120: (4)                Parameters
121: (4)                ----------
122: (4)                mobjects
123: (8)                    The mobjects to be faded out.
124: (4)                shift
125: (8)                    The vector by which the mobject shifts while being faded out.
126: (4)                target_position
127: (8)                    The position to which the mobject moves while being faded out. In case another
128: (8)                    mobject is given as target position, its center is used.
129: (4)                scale
130: (8)                    The factor by which the mobject is scaled while being faded out.
131: (4)                Examples
132: (4)                --------
133: (4)                .. manim :: FadeInExample
134: (8)                    class FadeInExample(Scene):
135: (12)                       def construct(self):
136: (16)                           dot = Dot(UP * 2 + LEFT)
137: (16)                           self.add(dot)
138: (16)                           tex = Tex(
139: (20)                               "FadeOut with ", "shift ", " or target\\_position", " and scale"
140: (16)                           ).scale(1)
141: (16)                           animations = [
142: (20)                               FadeOut(tex[0]),
143: (20)                               FadeOut(tex[1], shift=DOWN),
144: (20)                               FadeOut(tex[2], target_position=dot),
145: (20)                               FadeOut(tex[3], scale=0.5),
146: (16)                           ]
147: (16)                           self.play(AnimationGroup(*animations, lag_ratio=0.5))
148: (4)                """
149: (4)                def __init__(self, *mobjects: Mobject, **kwargs) -> None:
150: (8)                    super().__init__(*mobjects, remover=True, **kwargs)
151: (4)                def create_target(self):
152: (8)                    return self._create_faded_mobject(fadeIn=False)
153: (4)                def clean_up_from_scene(self, scene: Scene = None) -> None:
154: (8)                    super().clean_up_from_scene(scene)
155: (8)                    self.interpolate(0)

----------------------------------------

File 2 - . \growing.py:

1: (0)              """Animations that introduce mobjects to scene by growing them from points.
2: (0)              .. manim:: Growing
3: (4)                  class Growing(Scene):
4: (8)                      def construct(self):
5: (12)                         square = Square()
6: (12)                         circle = Circle()
7: (12)                         triangle = Triangle()
8: (12)                         arrow = Arrow(LEFT, RIGHT)
9: (12)                         star = Star()
10: (12)                        VGroup(square, circle, triangle).set_x(0).arrange(buff=1.5).set_y(2)
11: (12)                        VGroup(arrow, star).move_to(DOWN).set_x(0).arrange(buff=1.5).set_y(-2)
12: (12)                        self.play(GrowFromPoint(square, ORIGIN))
13: (12)                        self.play(GrowFromCenter(circle))
14: (12)                        self.play(GrowFromEdge(triangle, DOWN))
15: (12)                        self.play(GrowArrow(arrow))
16: (12)                        self.play(SpinInFromNothing(star))
17: (0)             """
18: (0)             from __future__ import annotations
19: (0)             __all__ = [
20: (4)                 "GrowFromPoint",
21: (4)                 "GrowFromCenter",
22: (4)                 "GrowFromEdge",
23: (4)                 "GrowArrow",
24: (4)                 "SpinInFromNothing",
25: (0)             ]
26: (0)             import typing
27: (0)             import numpy as np
28: (0)             from ..animation.transform import Transform
29: (0)             from ..constants import PI
30: (0)             from ..utils.paths import spiral_path
31: (0)             if typing.TYPE_CHECKING:
32: (4)                 from manim.mobject.geometry.line import Arrow
33: (4)                 from ..mobject.mobject import Mobject
34: (0)             class GrowFromPoint(Transform):
35: (4)                 """Introduce an :class:`~.Mobject` by growing it from a point.
36: (4)                 Parameters
37: (4)                 ----------
38: (4)                 mobject
39: (8)                     The mobjects to be introduced.
40: (4)                 point
41: (8)                     The point from which the mobject grows.
42: (4)                 point_color
43: (8)                     Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.
44: (4)                 Examples
45: (4)                 --------
46: (4)                 .. manim :: GrowFromPointExample
47: (8)                     class GrowFromPointExample(Scene):
48: (12)                        def construct(self):
49: (16)                            dot = Dot(3 * UR, color=GREEN)
50: (16)                            squares = [Square() for _ in range(4)]
51: (16)                            VGroup(*squares).set_x(0).arrange(buff=1)
52: (16)                            self.add(dot)
53: (16)                            self.play(GrowFromPoint(squares[0], ORIGIN))
54: (16)                            self.play(GrowFromPoint(squares[1], [-2, 2, 0]))
55: (16)                            self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))
56: (16)                            self.play(GrowFromPoint(squares[3], dot, dot.get_color()))
57: (4)                 """
58: (4)                 def __init__(
59: (8)                     self, mobject: Mobject, point: np.ndarray, point_color: str = None, **kwargs
60: (4)                 ) -> None:
61: (8)                     self.point = point
62: (8)                     self.point_color = point_color
63: (8)                     super().__init__(mobject, introducer=True, **kwargs)
64: (4)                 def create_target(self) -> Mobject:
65: (8)                     return self.mobject
66: (4)                 def create_starting_mobject(self) -> Mobject:
67: (8)                     start = super().create_starting_mobject()
68: (8)                     start.scale(0)
69: (8)                     start.move_to(self.point)
70: (8)                     if self.point_color:
71: (12)                        start.set_color(self.point_color)
72: (8)                     return start
73: (0)             class GrowFromCenter(GrowFromPoint):
74: (4)                 """Introduce an :class:`~.Mobject` by growing it from its center.
75: (4)                 Parameters
76: (4)                 ----------
77: (4)                 mobject
78: (8)                     The mobjects to be introduced.
79: (4)                 point_color
80: (8)                     Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.
81: (4)                 Examples
82: (4)                 --------
83: (4)                 .. manim :: GrowFromCenterExample
84: (8)                     class GrowFromCenterExample(Scene):
85: (12)                        def construct(self):
86: (16)                            squares = [Square() for _ in range(2)]
87: (16)                            VGroup(*squares).set_x(0).arrange(buff=2)
88: (16)                            self.play(GrowFromCenter(squares[0]))
89: (16)                            self.play(GrowFromCenter(squares[1], point_color=RED))
90: (4)                 """
91: (4)                 def __init__(self, mobject: Mobject, point_color: str = None, **kwargs) -> None:
92: (8)                     point = mobject.get_center()
93: (8)                     super().__init__(mobject, point, point_color=point_color, **kwargs)
94: (0)             class GrowFromEdge(GrowFromPoint):
95: (4)                 """Introduce an :class:`~.Mobject` by growing it from one of its bounding box edges.
96: (4)                 Parameters
97: (4)                 ----------
98: (4)                 mobject
99: (8)                     The mobjects to be introduced.
100: (4)                edge
101: (8)                    The direction to seek bounding box edge of mobject.
102: (4)                point_color
103: (8)                    Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.
104: (4)                Examples
105: (4)                --------
106: (4)                .. manim :: GrowFromEdgeExample
107: (8)                    class GrowFromEdgeExample(Scene):
108: (12)                       def construct(self):
109: (16)                           squares = [Square() for _ in range(4)]
110: (16)                           VGroup(*squares).set_x(0).arrange(buff=1)
111: (16)                           self.play(GrowFromEdge(squares[0], DOWN))
112: (16)                           self.play(GrowFromEdge(squares[1], RIGHT))
113: (16)                           self.play(GrowFromEdge(squares[2], UR))
114: (16)                           self.play(GrowFromEdge(squares[3], UP, point_color=RED))
115: (4)                """
116: (4)                def __init__(
117: (8)                    self, mobject: Mobject, edge: np.ndarray, point_color: str = None, **kwargs
118: (4)                ) -> None:
119: (8)                    point = mobject.get_critical_point(edge)
120: (8)                    super().__init__(mobject, point, point_color=point_color, **kwargs)
121: (0)            class GrowArrow(GrowFromPoint):
122: (4)                """Introduce an :class:`~.Arrow` by growing it from its start toward its tip.
123: (4)                Parameters
124: (4)                ----------
125: (4)                arrow
126: (8)                    The arrow to be introduced.
127: (4)                point_color
128: (8)                    Initial color of the arrow before growing to its full size. Leave empty to match arrow's color.
129: (4)                Examples
130: (4)                --------
131: (4)                .. manim :: GrowArrowExample
132: (8)                    class GrowArrowExample(Scene):
133: (12)                       def construct(self):
134: (16)                           arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]
135: (16)                           VGroup(*arrows).set_x(0).arrange(buff=2)
136: (16)                           self.play(GrowArrow(arrows[0]))
137: (16)                           self.play(GrowArrow(arrows[1], point_color=RED))
138: (4)                """
139: (4)                def __init__(self, arrow: Arrow, point_color: str = None, **kwargs) -> None:
140: (8)                    point = arrow.get_start()
141: (8)                    super().__init__(arrow, point, point_color=point_color, **kwargs)
142: (4)                def create_starting_mobject(self) -> Mobject:
143: (8)                    start_arrow = self.mobject.copy()
144: (8)                    start_arrow.scale(0, scale_tips=True, about_point=self.point)
145: (8)                    if self.point_color:
146: (12)                       start_arrow.set_color(self.point_color)
147: (8)                    return start_arrow
148: (0)            class SpinInFromNothing(GrowFromCenter):
149: (4)                """Introduce an :class:`~.Mobject` spinning and growing it from its center.
150: (4)                Parameters
151: (4)                ----------
152: (4)                mobject
153: (8)                    The mobjects to be introduced.
154: (4)                angle
155: (8)                    The amount of spinning before mobject reaches its full size. E.g. 2*PI means
156: (8)                    that the object will do one full spin before being fully introduced.
157: (4)                point_color
158: (8)                    Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.
159: (4)                Examples
160: (4)                --------
161: (4)                .. manim :: SpinInFromNothingExample
162: (8)                    class SpinInFromNothingExample(Scene):
163: (12)                       def construct(self):
164: (16)                           squares = [Square() for _ in range(3)]
165: (16)                           VGroup(*squares).set_x(0).arrange(buff=2)
166: (16)                           self.play(SpinInFromNothing(squares[0]))
167: (16)                           self.play(SpinInFromNothing(squares[1], angle=2 * PI))
168: (16)                           self.play(SpinInFromNothing(squares[2], point_color=RED))
169: (4)                """
170: (4)                def __init__(
171: (8)                    self, mobject: Mobject, angle: float = PI / 2, point_color: str = None, **kwargs
172: (4)                ) -> None:
173: (8)                    self.angle = angle
174: (8)                    super().__init__(
175: (12)                       mobject, path_func=spiral_path(angle), point_color=point_color, **kwargs
176: (8)                    )

----------------------------------------

File 3 - . \changing.py:

1: (0)              """Animation of a mobject boundary and tracing of points."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["AnimatedBoundary", "TracedPath"]
4: (0)              from typing import Callable
5: (0)              from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
6: (0)              from manim.mobject.types.vectorized_mobject import VGroup, VMobject
7: (0)              from manim.utils.color import (
8: (4)                  BLUE_B,
9: (4)                  BLUE_D,
10: (4)                 BLUE_E,
11: (4)                 GREY_BROWN,
12: (4)                 WHITE,
13: (4)                 ParsableManimColor,
14: (0)             )
15: (0)             from manim.utils.rate_functions import smooth
16: (0)             class AnimatedBoundary(VGroup):
17: (4)                 """Boundary of a :class:`.VMobject` with animated color change.
18: (4)                 Examples
19: (4)                 --------
20: (4)                 .. manim:: AnimatedBoundaryExample
21: (8)                     class AnimatedBoundaryExample(Scene):
22: (12)                        def construct(self):
23: (16)                            text = Text("So shiny!")
24: (16)                            boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],
25: (44)                                                        cycle_rate=3)
26: (16)                            self.add(text, boundary)
27: (16)                            self.wait(2)
28: (4)                 """
29: (4)                 def __init__(
30: (8)                     self,
31: (8)                     vmobject,
32: (8)                     colors=[BLUE_D, BLUE_B, BLUE_E, GREY_BROWN],
33: (8)                     max_stroke_width=3,
34: (8)                     cycle_rate=0.5,
35: (8)                     back_and_forth=True,
36: (8)                     draw_rate_func=smooth,
37: (8)                     fade_rate_func=smooth,
38: (8)                     **kwargs,
39: (4)                 ):
40: (8)                     super().__init__(**kwargs)
41: (8)                     self.colors = colors
42: (8)                     self.max_stroke_width = max_stroke_width
43: (8)                     self.cycle_rate = cycle_rate
44: (8)                     self.back_and_forth = back_and_forth
45: (8)                     self.draw_rate_func = draw_rate_func
46: (8)                     self.fade_rate_func = fade_rate_func
47: (8)                     self.vmobject = vmobject
48: (8)                     self.boundary_copies = [
49: (12)                        vmobject.copy().set_style(stroke_width=0, fill_opacity=0) for x in range(2)
50: (8)                     ]
51: (8)                     self.add(*self.boundary_copies)
52: (8)                     self.total_time = 0
53: (8)                     self.add_updater(lambda m, dt: self.update_boundary_copies(dt))
54: (4)                 def update_boundary_copies(self, dt):
55: (8)                     # Not actual time, but something which passes at
56: (8)                     # an altered rate to make the implementation below
57: (8)                     # cleaner
58: (8)                     time = self.total_time * self.cycle_rate
59: (8)                     growing, fading = self.boundary_copies
60: (8)                     colors = self.colors
61: (8)                     msw = self.max_stroke_width
62: (8)                     vmobject = self.vmobject
63: (8)                     index = int(time % len(colors))
64: (8)                     alpha = time % 1
65: (8)                     draw_alpha = self.draw_rate_func(alpha)
66: (8)                     fade_alpha = self.fade_rate_func(alpha)
67: (8)                     if self.back_and_forth and int(time) % 2 == 1:
68: (12)                        bounds = (1 - draw_alpha, 1)
69: (8)                     else:
70: (12)                        bounds = (0, draw_alpha)
71: (8)                     self.full_family_become_partial(growing, vmobject, *bounds)
72: (8)                     growing.set_stroke(colors[index], width=msw)
73: (8)                     if time >= 1:
74: (12)                        self.full_family_become_partial(fading, vmobject, 0, 1)
75: (12)                        fading.set_stroke(color=colors[index - 1], width=(1 - fade_alpha) * msw)
76: (8)                     self.total_time += dt
77: (4)                 def full_family_become_partial(self, mob1, mob2, a, b):
78: (8)                     family1 = mob1.family_members_with_points()
79: (8)                     family2 = mob2.family_members_with_points()
80: (8)                     for sm1, sm2 in zip(family1, family2):
81: (12)                        sm1.pointwise_become_partial(sm2, a, b)
82: (8)                     return self
83: (0)             class TracedPath(VMobject, metaclass=ConvertToOpenGL):
84: (4)                 """Traces the path of a point returned by a function call.
85: (4)                 Parameters
86: (4)                 ----------
87: (4)                 traced_point_func
88: (8)                     The function to be traced.
89: (4)                 stroke_width
90: (8)                     The width of the trace.
91: (4)                 stroke_color
92: (8)                     The color of the trace.
93: (4)                 dissipating_time
94: (8)                     The time taken for the path to dissipate. Default set to ``None``
95: (8)                     which disables dissipation.
96: (4)                 Examples
97: (4)                 --------
98: (4)                 .. manim:: TracedPathExample
99: (8)                     class TracedPathExample(Scene):
100: (12)                       def construct(self):
101: (16)                           circ = Circle(color=RED).shift(4*LEFT)
102: (16)                           dot = Dot(color=RED).move_to(circ.get_start())
103: (16)                           rolling_circle = VGroup(circ, dot)
104: (16)                           trace = TracedPath(circ.get_start)
105: (16)                           rolling_circle.add_updater(lambda m: m.rotate(-0.3))
106: (16)                           self.add(trace, rolling_circle)
107: (16)                           self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)
108: (4)                .. manim:: DissipatingPathExample
109: (8)                    class DissipatingPathExample(Scene):
110: (12)                       def construct(self):
111: (16)                           a = Dot(RIGHT * 2)
112: (16)                           b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])
113: (16)                           self.add(a, b)
114: (16)                           self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))
115: (16)                           self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))
116: (16)                           self.wait()
117: (4)                """
118: (4)                def __init__(
119: (8)                    self,
120: (8)                    traced_point_func: Callable,
121: (8)                    stroke_width: float = 2,
122: (8)                    stroke_color: ParsableManimColor | None = WHITE,
123: (8)                    dissipating_time: float | None = None,
124: (8)                    **kwargs,
125: (4)                ):
126: (8)                    super().__init__(stroke_color=stroke_color, stroke_width=stroke_width, **kwargs)
127: (8)                    self.traced_point_func = traced_point_func
128: (8)                    self.dissipating_time = dissipating_time
129: (8)                    self.time = 1 if self.dissipating_time else None
130: (8)                    self.add_updater(self.update_path)
131: (4)                def update_path(self, mob, dt):
132: (8)                    new_point = self.traced_point_func()
133: (8)                    if not self.has_points():
134: (12)                       self.start_new_path(new_point)
135: (8)                    self.add_line_to(new_point)
136: (8)                    if self.dissipating_time:
137: (12)                       self.time += dt
138: (12)                       if self.time - 1 > self.dissipating_time:
139: (16)                           nppcc = self.n_points_per_curve
140: (16)                           self.set_points(self.points[nppcc:])

----------------------------------------

File 4 - . \creation.py:

1: (0)              r"""Animate the display or removal of a mobject from a scene.
2: (0)              .. manim:: CreationModule
3: (4)                  :hide_source:
4: (4)                  from manim import ManimBanner
5: (4)                  class CreationModule(Scene):
6: (8)                      def construct(self):
7: (12)                         s1 = Square()
8: (12)                         s2 = Square()
9: (12)                         s3 = Square()
10: (12)                        s4 = Square()
11: (12)                        VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.9).shift(UP)
12: (12)                        s5 = Square()
13: (12)                        s6 = Square()
14: (12)                        s7 = Square()
15: (12)                        VGroup(s5, s6, s7).set_x(0).arrange(buff=2.6).shift(2 * DOWN)
16: (12)                        t1 = Text("Write", font_size=24).next_to(s1, UP)
17: (12)                        t2 = Text("AddTextLetterByLetter", font_size=24).next_to(s2, UP)
18: (12)                        t3 = Text("Create", font_size=24).next_to(s3, UP)
19: (12)                        t4 = Text("Uncreate", font_size=24).next_to(s4, UP)
20: (12)                        t5 = Text("DrawBorderThenFill", font_size=24).next_to(s5, UP)
21: (12)                        t6 = Text("ShowIncreasingSubsets", font_size=22).next_to(s6, UP)
22: (12)                        t7 = Text("ShowSubmobjectsOneByOne", font_size=22).next_to(s7, UP)
23: (12)                        self.add(s1, s2, s3, s4, s5, s6, s7, t1, t2, t3, t4, t5, t6, t7)
24: (12)                        texts = [Text("manim", font_size=29), Text("manim", font_size=29)]
25: (12)                        texts[0].move_to(s1.get_center())
26: (12)                        texts[1].move_to(s2.get_center())
27: (12)                        self.add(*texts)
28: (12)                        objs = [ManimBanner().scale(0.25) for _ in range(5)]
29: (12)                        objs[0].move_to(s3.get_center())
30: (12)                        objs[1].move_to(s4.get_center())
31: (12)                        objs[2].move_to(s5.get_center())
32: (12)                        objs[3].move_to(s6.get_center())
33: (12)                        objs[4].move_to(s7.get_center())
34: (12)                        self.add(*objs)
35: (12)                        self.play(
36: (16)                            # text creation
37: (16)                            Write(texts[0]),
38: (16)                            AddTextLetterByLetter(texts[1]),
39: (16)                            # mobject creation
40: (16)                            Create(objs[0]),
41: (16)                            Uncreate(objs[1]),
42: (16)                            DrawBorderThenFill(objs[2]),
43: (16)                            ShowIncreasingSubsets(objs[3]),
44: (16)                            ShowSubmobjectsOneByOne(objs[4]),
45: (16)                            run_time=3,
46: (12)                        )
47: (12)                        self.wait()
48: (0)             """
49: (0)             from __future__ import annotations
50: (0)             __all__ = [
51: (4)                 "Create",
52: (4)                 "Uncreate",
53: (4)                 "DrawBorderThenFill",
54: (4)                 "Write",
55: (4)                 "Unwrite",
56: (4)                 "ShowPartial",
57: (4)                 "ShowIncreasingSubsets",
58: (4)                 "SpiralIn",
59: (4)                 "AddTextLetterByLetter",
60: (4)                 "RemoveTextLetterByLetter",
61: (4)                 "ShowSubmobjectsOneByOne",
62: (4)                 "AddTextWordByWord",
63: (0)             ]
64: (0)             import itertools as it
65: (0)             from typing import TYPE_CHECKING, Callable, Iterable, Sequence
66: (0)             import numpy as np
67: (0)             if TYPE_CHECKING:
68: (4)                 from manim.mobject.text.text_mobject import Text
69: (0)             from manim.mobject.opengl.opengl_surface import OpenGLSurface
70: (0)             from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject
71: (0)             from manim.utils.color import ManimColor
72: (0)             from .. import config
73: (0)             from ..animation.animation import Animation
74: (0)             from ..animation.composition import Succession
75: (0)             from ..constants import TAU
76: (0)             from ..mobject.mobject import Group, Mobject
77: (0)             from ..mobject.types.vectorized_mobject import VMobject
78: (0)             from ..utils.bezier import integer_interpolate
79: (0)             from ..utils.rate_functions import double_smooth, linear
80: (0)             class ShowPartial(Animation):
81: (4)                 """Abstract class for Animations that show the VMobject partially.
82: (4)                 Raises
83: (4)                 ------
84: (4)                 :class:`TypeError`
85: (8)                     If ``mobject`` is not an instance of :class:`~.VMobject`.
86: (4)                 See Also
87: (4)                 --------
88: (4)                 :class:`Create`, :class:`~.ShowPassingFlash`
89: (4)                 """
90: (4)                 def __init__(
91: (8)                     self,
92: (8)                     mobject: VMobject | OpenGLVMobject | OpenGLSurface | None,
93: (8)                     **kwargs,
94: (4)                 ):
95: (8)                     pointwise = getattr(mobject, "pointwise_become_partial", None)
96: (8)                     if not callable(pointwise):
97: (12)                        raise NotImplementedError("This animation is not defined for this Mobject.")
98: (8)                     super().__init__(mobject, **kwargs)
99: (4)                 def interpolate_submobject(
100: (8)                    self,
101: (8)                    submobject: Mobject,
102: (8)                    starting_submobject: Mobject,
103: (8)                    alpha: float,
104: (4)                ) -> None:
105: (8)                    submobject.pointwise_become_partial(
106: (12)                       starting_submobject, *self._get_bounds(alpha)
107: (8)                    )
108: (4)                def _get_bounds(self, alpha: float) -> None:
109: (8)                    raise NotImplementedError("Please use Create or ShowPassingFlash")
110: (0)            class Create(ShowPartial):
111: (4)                """Incrementally show a VMobject.
112: (4)                Parameters
113: (4)                ----------
114: (4)                mobject
115: (8)                    The VMobject to animate.
116: (4)                Raises
117: (4)                ------
118: (4)                :class:`TypeError`
119: (8)                    If ``mobject`` is not an instance of :class:`~.VMobject`.
120: (4)                Examples
121: (4)                --------
122: (4)                .. manim:: CreateScene
123: (8)                    class CreateScene(Scene):
124: (12)                       def construct(self):
125: (16)                           self.play(Create(Square()))
126: (4)                See Also
127: (4)                --------
128: (4)                :class:`~.ShowPassingFlash`
129: (4)                """
130: (4)                def __init__(
131: (8)                    self,
132: (8)                    mobject: VMobject | OpenGLVMobject | OpenGLSurface,
133: (8)                    lag_ratio: float = 1.0,
134: (8)                    introducer: bool = True,
135: (8)                    **kwargs,
136: (4)                ) -> None:
137: (8)                    super().__init__(mobject, lag_ratio=lag_ratio, introducer=introducer, **kwargs)
138: (4)                def _get_bounds(self, alpha: float) -> tuple[int, float]:
139: (8)                    return (0, alpha)
140: (0)            class Uncreate(Create):
141: (4)                """Like :class:`Create` but in reverse.
142: (4)                Examples
143: (4)                --------
144: (4)                .. manim:: ShowUncreate
145: (8)                    class ShowUncreate(Scene):
146: (12)                       def construct(self):
147: (16)                           self.play(Uncreate(Square()))
148: (4)                See Also
149: (4)                --------
150: (4)                :class:`Create`
151: (4)                """
152: (4)                def __init__(
153: (8)                    self,
154: (8)                    mobject: VMobject | OpenGLVMobject,
155: (8)                    reverse_rate_function: bool = True,
156: (8)                    remover: bool = True,
157: (8)                    **kwargs,
158: (4)                ) -> None:
159: (8)                    super().__init__(
160: (12)                       mobject,
161: (12)                       reverse_rate_function=reverse_rate_function,
162: (12)                       introducer=False,
163: (12)                       remover=remover,
164: (12)                       **kwargs,
165: (8)                    )
166: (0)            class DrawBorderThenFill(Animation):
167: (4)                """Draw the border first and then show the fill.
168: (4)                Examples
169: (4)                --------
170: (4)                .. manim:: ShowDrawBorderThenFill
171: (8)                    class ShowDrawBorderThenFill(Scene):
172: (12)                       def construct(self):
173: (16)                           self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))
174: (4)                """
175: (4)                def __init__(
176: (8)                    self,
177: (8)                    vmobject: VMobject | OpenGLVMobject,
178: (8)                    run_time: float = 2,
179: (8)                    rate_func: Callable[[float], float] = double_smooth,
180: (8)                    stroke_width: float = 2,
181: (8)                    stroke_color: str = None,
182: (8)                    draw_border_animation_config: dict = {},  # what does this dict accept?
183: (8)                    fill_animation_config: dict = {},
184: (8)                    introducer: bool = True,
185: (8)                    **kwargs,
186: (4)                ) -> None:
187: (8)                    self._typecheck_input(vmobject)
188: (8)                    super().__init__(
189: (12)                       vmobject,
190: (12)                       run_time=run_time,
191: (12)                       introducer=introducer,
192: (12)                       rate_func=rate_func,
193: (12)                       **kwargs,
194: (8)                    )
195: (8)                    self.stroke_width = stroke_width
196: (8)                    self.stroke_color = stroke_color
197: (8)                    self.draw_border_animation_config = draw_border_animation_config
198: (8)                    self.fill_animation_config = fill_animation_config
199: (8)                    self.outline = self.get_outline()
200: (4)                def _typecheck_input(self, vmobject: VMobject | OpenGLVMobject) -> None:
201: (8)                    if not isinstance(vmobject, (VMobject, OpenGLVMobject)):
202: (12)                       raise TypeError("DrawBorderThenFill only works for vectorized Mobjects")
203: (4)                def begin(self) -> None:
204: (8)                    self.outline = self.get_outline()
205: (8)                    super().begin()
206: (4)                def get_outline(self) -> Mobject:
207: (8)                    outline = self.mobject.copy()
208: (8)                    outline.set_fill(opacity=0)
209: (8)                    for sm in outline.family_members_with_points():
210: (12)                       sm.set_stroke(color=self.get_stroke_color(sm), width=self.stroke_width)
211: (8)                    return outline
212: (4)                def get_stroke_color(self, vmobject: VMobject | OpenGLVMobject) -> ManimColor:
213: (8)                    if self.stroke_color:
214: (12)                       return self.stroke_color
215: (8)                    elif vmobject.get_stroke_width() > 0:
216: (12)                       return vmobject.get_stroke_color()
217: (8)                    return vmobject.get_color()
218: (4)                def get_all_mobjects(self) -> Sequence[Mobject]:
219: (8)                    return [*super().get_all_mobjects(), self.outline]
220: (4)                def interpolate_submobject(
221: (8)                    self,
222: (8)                    submobject: Mobject,
223: (8)                    starting_submobject: Mobject,
224: (8)                    outline,
225: (8)                    alpha: float,
226: (4)                ) -> None:  # Fixme: not matching the parent class? What is outline doing here?
227: (8)                    index: int
228: (8)                    subalpha: int
229: (8)                    index, subalpha = integer_interpolate(0, 2, alpha)
230: (8)                    if index == 0:
231: (12)                       submobject.pointwise_become_partial(outline, 0, subalpha)
232: (12)                       submobject.match_style(outline)
233: (8)                    else:
234: (12)                       submobject.interpolate(outline, starting_submobject, subalpha)
235: (0)            class Write(DrawBorderThenFill):
236: (4)                """Simulate hand-writing a :class:`~.Text` or hand-drawing a :class:`~.VMobject`.
237: (4)                Examples
238: (4)                --------
239: (4)                .. manim:: ShowWrite
240: (8)                    class ShowWrite(Scene):
241: (12)                       def construct(self):
242: (16)                           self.play(Write(Text("Hello", font_size=144)))
243: (4)                .. manim:: ShowWriteReversed
244: (8)                    class ShowWriteReversed(Scene):
245: (12)                       def construct(self):
246: (16)                           self.play(Write(Text("Hello", font_size=144), reverse=True, remover=False))
247: (4)                Tests
248: (4)                -----
249: (4)                Check that creating empty :class:`.Write` animations works::
250: (8)                    >>> from manim import Write, Text
251: (8)                    >>> Write(Text(''))
252: (8)                    Write(Text(''))
253: (4)                """
254: (4)                def __init__(
255: (8)                    self,
256: (8)                    vmobject: VMobject | OpenGLVMobject,
257: (8)                    rate_func: Callable[[float], float] = linear,
258: (8)                    reverse: bool = False,
259: (8)                    **kwargs,
260: (4)                ) -> None:
261: (8)                    run_time: float | None = kwargs.pop("run_time", None)
262: (8)                    lag_ratio: float | None = kwargs.pop("lag_ratio", None)
263: (8)                    run_time, lag_ratio = self._set_default_config_from_length(
264: (12)                       vmobject,
265: (12)                       run_time,
266: (12)                       lag_ratio,
267: (8)                    )
268: (8)                    self.reverse = reverse
269: (8)                    if "remover" not in kwargs:
270: (12)                       kwargs["remover"] = reverse
271: (8)                    super().__init__(
272: (12)                       vmobject,
273: (12)                       rate_func=rate_func,
274: (12)                       run_time=run_time,
275: (12)                       lag_ratio=lag_ratio,
276: (12)                       introducer=not reverse,
277: (12)                       **kwargs,
278: (8)                    )
279: (4)                def _set_default_config_from_length(
280: (8)                    self,
281: (8)                    vmobject: VMobject | OpenGLVMobject,
282: (8)                    run_time: float | None,
283: (8)                    lag_ratio: float | None,
284: (4)                ) -> tuple[float, float]:
285: (8)                    length = len(vmobject.family_members_with_points())
286: (8)                    if run_time is None:
287: (12)                       if length < 15:
288: (16)                           run_time = 1
289: (12)                       else:
290: (16)                           run_time = 2
291: (8)                    if lag_ratio is None:
292: (12)                       lag_ratio = min(4.0 / max(1.0, length), 0.2)
293: (8)                    return run_time, lag_ratio
294: (4)                def reverse_submobjects(self) -> None:
295: (8)                    self.mobject.invert(recursive=True)
296: (4)                def begin(self) -> None:
297: (8)                    if self.reverse:
298: (12)                       self.reverse_submobjects()
299: (8)                    super().begin()
300: (4)                def finish(self) -> None:
301: (8)                    super().finish()
302: (8)                    if self.reverse:
303: (12)                       self.reverse_submobjects()
304: (0)            class Unwrite(Write):
305: (4)                """Simulate erasing by hand a :class:`~.Text` or a :class:`~.VMobject`.
306: (4)                Parameters
307: (4)                ----------
308: (4)                reverse
309: (8)                    Set True to have the animation start erasing from the last submobject first.
310: (4)                Examples
311: (4)                --------
312: (4)                .. manim :: UnwriteReverseTrue
313: (8)                    class UnwriteReverseTrue(Scene):
314: (12)                       def construct(self):
315: (16)                           text = Tex("Alice and Bob").scale(3)
316: (16)                           self.add(text)
317: (16)                           self.play(Unwrite(text))
318: (4)                .. manim:: UnwriteReverseFalse
319: (8)                    class UnwriteReverseFalse(Scene):
320: (12)                       def construct(self):
321: (16)                           text = Tex("Alice and Bob").scale(3)
322: (16)                           self.add(text)
323: (16)                           self.play(Unwrite(text, reverse=False))
324: (4)                """
325: (4)                def __init__(
326: (8)                    self,
327: (8)                    vmobject: VMobject,
328: (8)                    rate_func: Callable[[float], float] = linear,
329: (8)                    reverse: bool = True,
330: (8)                    **kwargs,
331: (4)                ) -> None:
332: (8)                    run_time: float | None = kwargs.pop("run_time", None)
333: (8)                    lag_ratio: float | None = kwargs.pop("lag_ratio", None)
334: (8)                    run_time, lag_ratio = self._set_default_config_from_length(
335: (12)                       vmobject,
336: (12)                       run_time,
337: (12)                       lag_ratio,
338: (8)                    )
339: (8)                    super().__init__(
340: (12)                       vmobject,
341: (12)                       run_time=run_time,
342: (12)                       lag_ratio=lag_ratio,
343: (12)                       reverse_rate_function=True,
344: (12)                       reverse=reverse,
345: (12)                       **kwargs,
346: (8)                    )
347: (0)            class SpiralIn(Animation):
348: (4)                r"""Create the Mobject with sub-Mobjects flying in on spiral trajectories.
349: (4)                Parameters
350: (4)                ----------
351: (4)                shapes
352: (8)                    The Mobject on which to be operated.
353: (4)                scale_factor
354: (8)                    The factor used for scaling the effect.
355: (4)                fade_in_fraction
356: (8)                    Fractional duration of initial fade-in of sub-Mobjects as they fly inward.
357: (4)                Examples
358: (4)                --------
359: (4)                .. manim :: SpiralInExample
360: (8)                    class SpiralInExample(Scene):
361: (12)                       def construct(self):
362: (16)                           pi = MathTex(r"\pi").scale(7)
363: (16)                           pi.shift(2.25 * LEFT + 1.5 * UP)
364: (16)                           circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)
365: (16)                           square = Square(color=BLUE_D, fill_opacity=1).shift(UP)
366: (16)                           shapes = VGroup(pi, circle, square)
367: (16)                           self.play(SpiralIn(shapes))
368: (4)                """
369: (4)                def __init__(
370: (8)                    self,
371: (8)                    shapes: Mobject,
372: (8)                    scale_factor: float = 8,
373: (8)                    fade_in_fraction=0.3,
374: (8)                    **kwargs,
375: (4)                ) -> None:
376: (8)                    self.shapes = shapes.copy()
377: (8)                    self.scale_factor = scale_factor
378: (8)                    self.shape_center = shapes.get_center()
379: (8)                    self.fade_in_fraction = fade_in_fraction
380: (8)                    for shape in shapes:
381: (12)                       shape.final_position = shape.get_center()
382: (12)                       shape.initial_position = (
383: (16)                           shape.final_position
384: (16)                           + (shape.final_position - self.shape_center) * self.scale_factor
385: (12)                       )
386: (12)                       shape.move_to(shape.initial_position)
387: (12)                       shape.save_state()
388: (8)                    super().__init__(shapes, introducer=True, **kwargs)
389: (4)                def interpolate_mobject(self, alpha: float) -> None:
390: (8)                    alpha = self.rate_func(alpha)
391: (8)                    for original_shape, shape in zip(self.shapes, self.mobject):
392: (12)                       shape.restore()
393: (12)                       fill_opacity = original_shape.get_fill_opacity()
394: (12)                       stroke_opacity = original_shape.get_stroke_opacity()
395: (12)                       new_fill_opacity = min(
396: (16)                           fill_opacity, alpha * fill_opacity / self.fade_in_fraction
397: (12)                       )
398: (12)                       new_stroke_opacity = min(
399: (16)                           stroke_opacity, alpha * stroke_opacity / self.fade_in_fraction
400: (12)                       )
401: (12)                       shape.shift((shape.final_position - shape.initial_position) * alpha)
402: (12)                       shape.rotate(TAU * alpha, about_point=self.shape_center)
403: (12)                       shape.rotate(-TAU * alpha, about_point=shape.get_center_of_mass())
404: (12)                       shape.set_fill(opacity=new_fill_opacity)
405: (12)                       shape.set_stroke(opacity=new_stroke_opacity)
406: (0)            class ShowIncreasingSubsets(Animation):
407: (4)                """Show one submobject at a time, leaving all previous ones displayed on screen.
408: (4)                Examples
409: (4)                --------
410: (4)                .. manim:: ShowIncreasingSubsetsScene
411: (8)                    class ShowIncreasingSubsetsScene(Scene):
412: (12)                       def construct(self):
413: (16)                           p = VGroup(Dot(), Square(), Triangle())
414: (16)                           self.add(p)
415: (16)                           self.play(ShowIncreasingSubsets(p))
416: (16)                           self.wait()
417: (4)                """
418: (4)                def __init__(
419: (8)                    self,
420: (8)                    group: Mobject,
421: (8)                    suspend_mobject_updating: bool = False,
422: (8)                    int_func: Callable[[np.ndarray], np.ndarray] = np.floor,
423: (8)                    reverse_rate_function=False,
424: (8)                    **kwargs,
425: (4)                ) -> None:
426: (8)                    self.all_submobs = list(group.submobjects)
427: (8)                    self.int_func = int_func
428: (8)                    for mobj in self.all_submobs:
429: (12)                       mobj.set_opacity(0)
430: (8)                    super().__init__(
431: (12)                       group,
432: (12)                       suspend_mobject_updating=suspend_mobject_updating,
433: (12)                       reverse_rate_function=reverse_rate_function,
434: (12)                       **kwargs,
435: (8)                    )
436: (4)                def interpolate_mobject(self, alpha: float) -> None:
437: (8)                    n_submobs = len(self.all_submobs)
438: (8)                    value = (
439: (12)                       1 - self.rate_func(alpha)
440: (12)                       if self.reverse_rate_function
441: (12)                       else self.rate_func(alpha)
442: (8)                    )
443: (8)                    index = int(self.int_func(value * n_submobs))
444: (8)                    self.update_submobject_list(index)
445: (4)                def update_submobject_list(self, index: int) -> None:
446: (8)                    for mobj in self.all_submobs[:index]:
447: (12)                       mobj.set_opacity(1)
448: (8)                    for mobj in self.all_submobs[index:]:
449: (12)                       mobj.set_opacity(0)
450: (0)            class AddTextLetterByLetter(ShowIncreasingSubsets):
451: (4)                """Show a :class:`~.Text` letter by letter on the scene.
452: (4)                Parameters
453: (4)                ----------
454: (4)                time_per_char
455: (8)                    Frequency of appearance of the letters.
456: (4)                .. tip::
457: (8)                    This is currently only possible for class:`~.Text` and not for class:`~.MathTex`
458: (4)                """
459: (4)                def __init__(
460: (8)                    self,
461: (8)                    text: Text,
462: (8)                    suspend_mobject_updating: bool = False,
463: (8)                    int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,
464: (8)                    rate_func: Callable[[float], float] = linear,
465: (8)                    time_per_char: float = 0.1,
466: (8)                    run_time: float | None = None,
467: (8)                    reverse_rate_function=False,
468: (8)                    introducer=True,
469: (8)                    **kwargs,
470: (4)                ) -> None:
471: (8)                    self.time_per_char = time_per_char
472: (8)                    # Check for empty text using family_members_with_points()
473: (8)                    if not text.family_members_with_points():
474: (12)                       raise ValueError(
475: (16)                           f"The text mobject {text} does not seem to contain any characters."
476: (12)                       )
477: (8)                    if run_time is None:
478: (12)                       # minimum time per character is 1/frame_rate, otherwise
479: (12)                       # the animation does not finish.
480: (12)                       run_time = np.max((1 / config.frame_rate, self.time_per_char)) * len(text)
481: (8)                    super().__init__(
482: (12)                       text,
483: (12)                       suspend_mobject_updating=suspend_mobject_updating,
484: (12)                       int_func=int_func,
485: (12)                       rate_func=rate_func,
486: (12)                       run_time=run_time,
487: (12)                       reverse_rate_function=reverse_rate_function,
488: (12)                       introducer=introducer,
489: (12)                       **kwargs,
490: (8)                    )
491: (0)            class RemoveTextLetterByLetter(AddTextLetterByLetter):
492: (4)                """Remove a :class:`~.Text` letter by letter from the scene.
493: (4)                Parameters
494: (4)                ----------
495: (4)                time_per_char
496: (8)                    Frequency of appearance of the letters.
497: (4)                .. tip::
498: (8)                    This is currently only possible for class:`~.Text` and not for class:`~.MathTex`
499: (4)                """
500: (4)                def __init__(
501: (8)                    self,
502: (8)                    text: Text,
503: (8)                    suspend_mobject_updating: bool = False,
504: (8)                    int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,
505: (8)                    rate_func: Callable[[float], float] = linear,
506: (8)                    time_per_char: float = 0.1,
507: (8)                    run_time: float | None = None,
508: (8)                    reverse_rate_function=True,
509: (8)                    introducer=False,
510: (8)                    remover=True,
511: (8)                    **kwargs,
512: (4)                ) -> None:
513: (8)                    super().__init__(
514: (12)                       text,
515: (12)                       suspend_mobject_updating=suspend_mobject_updating,
516: (12)                       int_func=int_func,
517: (12)                       rate_func=rate_func,
518: (12)                       time_per_char=time_per_char,
519: (12)                       run_time=run_time,
520: (12)                       reverse_rate_function=reverse_rate_function,
521: (12)                       introducer=introducer,
522: (12)                       remover=remover,
523: (12)                       **kwargs,
524: (8)                    )
525: (0)            class ShowSubmobjectsOneByOne(ShowIncreasingSubsets):
526: (4)                """Show one submobject at a time, removing all previously displayed ones from screen."""
527: (4)                def __init__(
528: (8)                    self,
529: (8)                    group: Iterable[Mobject],
530: (8)                    int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,
531: (8)                    **kwargs,
532: (4)                ) -> None:
533: (8)                    new_group = Group(*group)
534: (8)                    super().__init__(new_group, int_func=int_func, **kwargs)
535: (4)                def update_submobject_list(self, index: int) -> None:
536: (8)                    current_submobjects = self.all_submobs[:index]
537: (8)                    for mobj in current_submobjects[:-1]:
538: (12)                       mobj.set_opacity(0)
539: (8)                    if len(current_submobjects) > 0:
540: (12)                       current_submobjects[-1].set_opacity(1)
541: (0)            # TODO, this is broken...
542: (0)            class AddTextWordByWord(Succession):
543: (4)                """Show a :class:`~.Text` word by word on the scene. Note: currently broken."""
544: (4)                def __init__(
545: (8)                    self,
546: (8)                    text_mobject: Text,
547: (8)                    run_time: float = None,
548: (8)                    time_per_char: float = 0.06,
549: (8)                    **kwargs,
550: (4)                ) -> None:
551: (8)                    self.time_per_char = time_per_char
552: (8)                    tpc = self.time_per_char
553: (8)                    anims = it.chain(
554: (12)                       *(
555: (16)                           [
556: (20)                               ShowIncreasingSubsets(word, run_time=tpc * len(word)),
557: (20)                               Animation(word, run_time=0.005 * len(word) ** 1.5),
558: (16)                           ]
559: (16)                           for word in text_mobject
560: (12)                       )
561: (8)                    )
562: (8)                    super().__init__(*anims, **kwargs)

----------------------------------------

File 5 - . \__init__.py:

1: (0)              

----------------------------------------

File 6 - . \animation.py:

1: (0)              """Animate mobjects."""
2: (0)              from __future__ import annotations
3: (0)              from manim.mobject.opengl.opengl_mobject import OpenGLMobject
4: (0)              from .. import config, logger
5: (0)              from ..constants import RendererType
6: (0)              from ..mobject import mobject
7: (0)              from ..mobject.mobject import Mobject
8: (0)              from ..mobject.opengl import opengl_mobject
9: (0)              from ..utils.rate_functions import linear, smooth
10: (0)             __all__ = ["Animation", "Wait", "override_animation"]
11: (0)             from copy import deepcopy
12: (0)             from typing import TYPE_CHECKING, Callable, Iterable, Sequence
13: (0)             from typing_extensions import Self
14: (0)             if TYPE_CHECKING:
15: (4)                 from manim.scene.scene import Scene
16: (0)             DEFAULT_ANIMATION_RUN_TIME: float = 1.0
17: (0)             DEFAULT_ANIMATION_LAG_RATIO: float = 0.0
18: (0)             class Animation:
19: (4)                 """An animation.
20: (4)                 Animations have a fixed time span.
21: (4)                 Parameters
22: (4)                 ----------
23: (4)                 mobject
24: (8)                     The mobject to be animated. This is not required for all types of animations.
25: (4)                 lag_ratio
26: (8)                     Defines the delay after which the animation is applied to submobjects. This lag
27: (8)                     is relative to the duration of the animation.
28: (8)                     This does not influence the total
29: (8)                     runtime of the animation. Instead the runtime of individual animations is
30: (8)                     adjusted so that the complete animation has the defined run time.
31: (4)                 run_time
32: (8)                     The duration of the animation in seconds.
33: (4)                 rate_func
34: (8)                     The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .
35: (8)                     For example ``rate_func(0.5)`` is the proportion of the animation that is done
36: (8)                     after half of the animations run time.
37: (4)                 reverse_rate_function
38: (8)                     Reverses the rate function of the animation. Setting ``reverse_rate_function``
39: (8)                     does not have any effect on ``remover`` or ``introducer``. These need to be
40: (8)                     set explicitly if an introducer-animation should be turned into a remover one
41: (8)                     and vice versa.
42: (4)                 name
43: (8)                     The name of the animation. This gets displayed while rendering the animation.
44: (8)                     Defaults to <class-name>(<Mobject-name>).
45: (4)                 remover
46: (8)                     Whether the given mobject should be removed from the scene after this animation.
47: (4)                 suspend_mobject_updating
48: (8)                     Whether updaters of the mobject should be suspended during the animation.
49: (4)                 .. NOTE::
50: (8)                     In the current implementation of this class, the specified rate function is applied
51: (8)                     within :meth:`.Animation.interpolate_mobject` call as part of the call to
52: (8)                     :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`
53: (8)                     that are implemented by overriding :meth:`interpolate_mobject`, the rate function
54: (8)                     has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead
55: (8)                     of just ``alpha``).
56: (4)                 Examples
57: (4)                 --------
58: (4)                 .. manim:: LagRatios
59: (8)                     class LagRatios(Scene):
60: (12)                        def construct(self):
61: (16)                            ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios
62: (16)                            # Create dot groups
63: (16)                            group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()
64: (16)                            groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)
65: (16)                            self.add(groups)
66: (16)                            # Label groups
67: (16)                            self.add(Text("lag_ratio = ", font_size=36).next_to(groups, UP, buff=1.5))
68: (16)                            for group, ratio in zip(groups, ratios):
69: (20)                                self.add(Text(str(ratio), font_size=36).next_to(group, UP))
70: (16)                            #Animate groups with different lag_ratios
71: (16)                            self.play(AnimationGroup(*[
72: (20)                                group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)
73: (20)                                for group, ratio in zip(groups, ratios)
74: (16)                            ]))
75: (16)                            # lag_ratio also works recursively on nested submobjects:
76: (16)                            self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))
77: (4)                 """
78: (4)                 def __new__(
79: (8)                     cls,
80: (8)                     mobject=None,
81: (8)                     *args,
82: (8)                     use_override=True,
83: (8)                     **kwargs,
84: (4)                 ) -> Self:
85: (8)                     if isinstance(mobject, Mobject) and use_override:
86: (12)                        func = mobject.animation_override_for(cls)
87: (12)                        if func is not None:
88: (16)                            anim = func(mobject, *args, **kwargs)
89: (16)                            logger.debug(
90: (20)                                f"The {cls.__name__} animation has been is overridden for "
91: (20)                                f"{type(mobject).__name__} mobjects. use_override = False can "
92: (20)                                f" be used as keyword argument to prevent animation overriding.",
93: (16)                            )
94: (16)                            return anim
95: (8)                     return super().__new__(cls)
96: (4)                 def __init__(
97: (8)                     self,
98: (8)                     mobject: Mobject | None,
99: (8)                     lag_ratio: float = DEFAULT_ANIMATION_LAG_RATIO,
100: (8)                    run_time: float = DEFAULT_ANIMATION_RUN_TIME,
101: (8)                    rate_func: Callable[[float], float] = smooth,
102: (8)                    reverse_rate_function: bool = False,
103: (8)                    name: str = None,
104: (8)                    remover: bool = False,  # remove a mobject from the screen?
105: (8)                    suspend_mobject_updating: bool = True,
106: (8)                    introducer: bool = False,
107: (8)                    *,
108: (8)                    _on_finish: Callable[[], None] = lambda _: None,
109: (8)                    **kwargs,
110: (4)                ) -> None:
111: (8)                    self._typecheck_input(mobject)
112: (8)                    self.run_time: float = run_time
113: (8)                    self.rate_func: Callable[[float], float] = rate_func
114: (8)                    self.reverse_rate_function: bool = reverse_rate_function
115: (8)                    self.name: str | None = name
116: (8)                    self.remover: bool = remover
117: (8)                    self.introducer: bool = introducer
118: (8)                    self.suspend_mobject_updating: bool = suspend_mobject_updating
119: (8)                    self.lag_ratio: float = lag_ratio
120: (8)                    self._on_finish: Callable[[Scene], None] = _on_finish
121: (8)                    if config["renderer"] == RendererType.OPENGL:
122: (12)                       self.starting_mobject: OpenGLMobject = OpenGLMobject()
123: (12)                       self.mobject: OpenGLMobject = (
124: (16)                           mobject if mobject is not None else OpenGLMobject()
125: (12)                       )
126: (8)                    else:
127: (12)                       self.starting_mobject: Mobject = Mobject()
128: (12)                       self.mobject: Mobject = mobject if mobject is not None else Mobject()
129: (8)                    if kwargs:
130: (12)                       logger.debug("Animation received extra kwargs: %s", kwargs)
131: (8)                    if hasattr(self, "CONFIG"):
132: (12)                       logger.error(
133: (16)                           (
134: (20)                               "CONFIG has been removed from ManimCommunity.",
135: (20)                               "Please use keyword arguments instead.",
136: (16)                           ),
137: (12)                       )
138: (4)                def _typecheck_input(self, mobject: Mobject | None) -> None:
139: (8)                    if mobject is None:
140: (12)                       logger.debug("Animation with empty mobject")
141: (8)                    elif not isinstance(mobject, (Mobject, OpenGLMobject)):
142: (12)                       raise TypeError("Animation only works on Mobjects")
143: (4)                def __str__(self) -> str:
144: (8)                    if self.name:
145: (12)                       return self.name
146: (8)                    return f"{self.__class__.__name__}({str(self.mobject)})"
147: (4)                def __repr__(self) -> str:
148: (8)                    return str(self)
149: (4)                def begin(self) -> None:
150: (8)                    """Begin the animation.
151: (8)                    This method is called right as an animation is being played. As much
152: (8)                    initialization as possible, especially any mobject copying, should live in this
153: (8)                    method.
154: (8)                    """
155: (8)                    if self.run_time <= 0:
156: (12)                       raise ValueError(
157: (16)                           f"{self} has a run_time of <= 0 seconds, this cannot be rendered correctly. "
158: (16)                           "Please set the run_time to be positive"
159: (12)                       )
160: (8)                    self.starting_mobject = self.create_starting_mobject()
161: (8)                    if self.suspend_mobject_updating:
162: (12)                       # All calls to self.mobject's internal updaters
163: (12)                       # during the animation, either from this Animation
164: (12)                       # or from the surrounding scene, should do nothing.
165: (12)                       # It is, however, okay and desirable to call
166: (12)                       # the internal updaters of self.starting_mobject,
167: (12)                       # or any others among self.get_all_mobjects()
168: (12)                       self.mobject.suspend_updating()
169: (8)                    self.interpolate(0)
170: (4)                def finish(self) -> None:
171: (8)                    # TODO: begin and finish should require a scene as parameter.
172: (8)                    # That way Animation.clean_up_from_screen and Scene.add_mobjects_from_animations
173: (8)                    # could be removed as they fulfill basically the same purpose.
174: (8)                    """Finish the animation.
175: (8)                    This method gets called when the animation is over.
176: (8)                    """
177: (8)                    self.interpolate(1)
178: (8)                    if self.suspend_mobject_updating and self.mobject is not None:
179: (12)                       self.mobject.resume_updating()
180: (4)                def clean_up_from_scene(self, scene: Scene) -> None:
181: (8)                    """Clean up the :class:`~.Scene` after finishing the animation.
182: (8)                    This includes to :meth:`~.Scene.remove` the Animation's
183: (8)                    :class:`~.Mobject` if the animation is a remover.
184: (8)                    Parameters
185: (8)                    ----------
186: (8)                    scene
187: (12)                       The scene the animation should be cleaned up from.
188: (8)                    """
189: (8)                    self._on_finish(scene)
190: (8)                    if self.is_remover():
191: (12)                       scene.remove(self.mobject)
192: (4)                def _setup_scene(self, scene: Scene) -> None:
193: (8)                    """Setup up the :class:`~.Scene` before starting the animation.
194: (8)                    This includes to :meth:`~.Scene.add` the Animation's
195: (8)                    :class:`~.Mobject` if the animation is an introducer.
196: (8)                    Parameters
197: (8)                    ----------
198: (8)                    scene
199: (12)                       The scene the animation should be cleaned up from.
200: (8)                    """
201: (8)                    if scene is None:
202: (12)                       return
203: (8)                    if (
204: (12)                       self.is_introducer()
205: (12)                       and self.mobject not in scene.get_mobject_family_members()
206: (8)                    ):
207: (12)                       scene.add(self.mobject)
208: (4)                def create_starting_mobject(self) -> Mobject:
209: (8)                    # Keep track of where the mobject starts
210: (8)                    return self.mobject.copy()
211: (4)                def get_all_mobjects(self) -> Sequence[Mobject]:
212: (8)                    """Get all mobjects involved in the animation.
213: (8)                    Ordering must match the ordering of arguments to interpolate_submobject
214: (8)                    Returns
215: (8)                    -------
216: (8)                    Sequence[Mobject]
217: (12)                       The sequence of mobjects.
218: (8)                    """
219: (8)                    return self.mobject, self.starting_mobject
220: (4)                def get_all_families_zipped(self) -> Iterable[tuple]:
221: (8)                    if config["renderer"] == RendererType.OPENGL:
222: (12)                       return zip(*(mob.get_family() for mob in self.get_all_mobjects()))
223: (8)                    return zip(
224: (12)                       *(mob.family_members_with_points() for mob in self.get_all_mobjects())
225: (8)                    )
226: (4)                def update_mobjects(self, dt: float) -> None:
227: (8)                    """
228: (8)                    Updates things like starting_mobject, and (for
229: (8)                    Transforms) target_mobject.  Note, since typically
230: (8)                    (always?) self.mobject will have its updating
231: (8)                    suspended during the animation, this will do
232: (8)                    nothing to self.mobject.
233: (8)                    """
234: (8)                    for mob in self.get_all_mobjects_to_update():
235: (12)                       mob.update(dt)
236: (4)                def get_all_mobjects_to_update(self) -> list[Mobject]:
237: (8)                    """Get all mobjects to be updated during the animation.
238: (8)                    Returns
239: (8)                    -------
240: (8)                    List[Mobject]
241: (12)                       The list of mobjects to be updated during the animation.
242: (8)                    """
243: (8)                    # The surrounding scene typically handles
244: (8)                    # updating of self.mobject.  Besides, in
245: (8)                    # most cases its updating is suspended anyway
246: (8)                    return list(filter(lambda m: m is not self.mobject, self.get_all_mobjects()))
247: (4)                def copy(self) -> Animation:
248: (8)                    """Create a copy of the animation.
249: (8)                    Returns
250: (8)                    -------
251: (8)                    Animation
252: (12)                       A copy of ``self``
253: (8)                    """
254: (8)                    return deepcopy(self)
255: (4)                # Methods for interpolation, the mean of an Animation
256: (4)                # TODO: stop using alpha as parameter name in different meanings.
257: (4)                def interpolate(self, alpha: float) -> None:
258: (8)                    """Set the animation progress.
259: (8)                    This method gets called for every frame during an animation.
260: (8)                    Parameters
261: (8)                    ----------
262: (8)                    alpha
263: (12)                       The relative time to set the animation to, 0 meaning the start, 1 meaning
264: (12)                       the end.
265: (8)                    """
266: (8)                    self.interpolate_mobject(alpha)
267: (4)                def interpolate_mobject(self, alpha: float) -> None:
268: (8)                    """Interpolates the mobject of the :class:`Animation` based on alpha value.
269: (8)                    Parameters
270: (8)                    ----------
271: (8)                    alpha
272: (12)                       A float between 0 and 1 expressing the ratio to which the animation
273: (12)                       is completed. For example, alpha-values of 0, 0.5, and 1 correspond
274: (12)                       to the animation being completed 0%, 50%, and 100%, respectively.
275: (8)                    """
276: (8)                    families = list(self.get_all_families_zipped())
277: (8)                    for i, mobs in enumerate(families):
278: (12)                       sub_alpha = self.get_sub_alpha(alpha, i, len(families))
279: (12)                       self.interpolate_submobject(*mobs, sub_alpha)
280: (4)                def interpolate_submobject(
281: (8)                    self,
282: (8)                    submobject: Mobject,
283: (8)                    starting_submobject: Mobject,
284: (8)                    # target_copy: Mobject, #Todo: fix - signature of interpolate_submobject differs in Transform().
285: (8)                    alpha: float,
286: (4)                ) -> Animation:
287: (8)                    # Typically implemented by subclass
288: (8)                    pass
289: (4)                def get_sub_alpha(self, alpha: float, index: int, num_submobjects: int) -> float:
290: (8)                    """Get the animation progress of any submobjects subanimation.
291: (8)                    Parameters
292: (8)                    ----------
293: (8)                    alpha
294: (12)                       The overall animation progress
295: (8)                    index
296: (12)                       The index of the subanimation.
297: (8)                    num_submobjects
298: (12)                       The total count of subanimations.
299: (8)                    Returns
300: (8)                    -------
301: (8)                    float
302: (12)                       The progress of the subanimation.
303: (8)                    """
304: (8)                    # TODO, make this more understandable, and/or combine
305: (8)                    # its functionality with AnimationGroup's method
306: (8)                    # build_animations_with_timings
307: (8)                    lag_ratio = self.lag_ratio
308: (8)                    full_length = (num_submobjects - 1) * lag_ratio + 1
309: (8)                    value = alpha * full_length
310: (8)                    lower = index * lag_ratio
311: (8)                    if self.reverse_rate_function:
312: (12)                       return self.rate_func(1 - (value - lower))
313: (8)                    else:
314: (12)                       return self.rate_func(value - lower)
315: (4)                # Getters and setters
316: (4)                def set_run_time(self, run_time: float) -> Animation:
317: (8)                    """Set the run time of the animation.
318: (8)                    Parameters
319: (8)                    ----------
320: (8)                    run_time
321: (12)                       The new time the animation should take in seconds.
322: (8)                    .. note::
323: (12)                       The run_time of an animation should not be changed while it is already
324: (12)                       running.
325: (8)                    Returns
326: (8)                    -------
327: (8)                    Animation
328: (12)                       ``self``
329: (8)                    """
330: (8)                    self.run_time = run_time
331: (8)                    return self
332: (4)                # TODO: is this getter even necessary?
333: (4)                def get_run_time(self) -> float:
334: (8)                    """Get the run time of the animation.
335: (8)                    Returns
336: (8)                    -------
337: (8)                    float
338: (12)                       The time the animation takes in seconds.
339: (8)                    """
340: (8)                    return self.run_time
341: (4)                def set_rate_func(
342: (8)                    self,
343: (8)                    rate_func: Callable[[float], float],
344: (4)                ) -> Animation:
345: (8)                    """Set the rate function of the animation.
346: (8)                    Parameters
347: (8)                    ----------
348: (8)                    rate_func
349: (12)                       The new function defining the animation progress based on the
350: (12)                       relative runtime (see :mod:`~.rate_functions`).
351: (8)                    Returns
352: (8)                    -------
353: (8)                    Animation
354: (12)                       ``self``
355: (8)                    """
356: (8)                    self.rate_func = rate_func
357: (8)                    return self
358: (4)                def get_rate_func(
359: (8)                    self,
360: (4)                ) -> Callable[[float], float]:
361: (8)                    """Get the rate function of the animation.
362: (8)                    Returns
363: (8)                    -------
364: (8)                    Callable[[float], float]
365: (12)                       The rate function of the animation.
366: (8)                    """
367: (8)                    return self.rate_func
368: (4)                def set_name(self, name: str) -> Animation:
369: (8)                    """Set the name of the animation.
370: (8)                    Parameters
371: (8)                    ----------
372: (8)                    name
373: (12)                       The new name of the animation.
374: (8)                    Returns
375: (8)                    -------
376: (8)                    Animation
377: (12)                       ``self``
378: (8)                    """
379: (8)                    self.name = name
380: (8)                    return self
381: (4)                def is_remover(self) -> bool:
382: (8)                    """Test if the animation is a remover.
383: (8)                    Returns
384: (8)                    -------
385: (8)                    bool
386: (12)                       ``True`` if the animation is a remover, ``False`` otherwise.
387: (8)                    """
388: (8)                    return self.remover
389: (4)                def is_introducer(self) -> bool:
390: (8)                    """Test if the animation is an introducer.
391: (8)                    Returns
392: (8)                    -------
393: (8)                    bool
394: (12)                       ``True`` if the animation is an introducer, ``False`` otherwise.
395: (8)                    """
396: (8)                    return self.introducer
397: (0)            def prepare_animation(
398: (4)                anim: Animation | mobject._AnimationBuilder,
399: (0)            ) -> Animation:
400: (4)                r"""Returns either an unchanged animation, or the animation built
401: (4)                from a passed animation factory.
402: (4)                Examples
403: (4)                --------
404: (4)                ::
405: (8)                    >>> from manim import Square, FadeIn
406: (8)                    >>> s = Square()
407: (8)                    >>> prepare_animation(FadeIn(s))
408: (8)                    FadeIn(Square)
409: (4)                ::
410: (8)                    >>> prepare_animation(s.animate.scale(2).rotate(42))
411: (8)                    _MethodAnimation(Square)
412: (4)                ::
413: (8)                    >>> prepare_animation(42)
414: (8)                    Traceback (most recent call last):
415: (8)                    ...
416: (8)                    TypeError: Object 42 cannot be converted to an animation
417: (4)                """
418: (4)                if isinstance(anim, mobject._AnimationBuilder):
419: (8)                    return anim.build()
420: (4)                if isinstance(anim, opengl_mobject._AnimationBuilder):
421: (8)                    return anim.build()
422: (4)                if isinstance(anim, Animation):
423: (8)                    return anim
424: (4)                raise TypeError(f"Object {anim} cannot be converted to an animation")
425: (0)            class Wait(Animation):
426: (4)                """A "no operation" animation.
427: (4)                Parameters
428: (4)                ----------
429: (4)                run_time
430: (8)                    The amount of time that should pass.
431: (4)                stop_condition
432: (8)                    A function without positional arguments that evaluates to a boolean.
433: (8)                    The function is evaluated after every new frame has been rendered.
434: (8)                    Playing the animation stops after the return value is truthy, or
435: (8)                    after the specified ``run_time`` has passed.
436: (4)                frozen_frame
437: (8)                    Controls whether or not the wait animation is static, i.e., corresponds
438: (8)                    to a frozen frame. If ``False`` is passed, the render loop still
439: (8)                    progresses through the animation as usual and (among other things)
440: (8)                    continues to call updater functions. If ``None`` (the default value),
441: (8)                    the :meth:`.Scene.play` call tries to determine whether the Wait call
442: (8)                    can be static or not itself via :meth:`.Scene.should_mobjects_update`.
443: (4)                kwargs
444: (8)                    Keyword arguments to be passed to the parent class, :class:`.Animation`.
445: (4)                """
446: (4)                def __init__(
447: (8)                    self,
448: (8)                    run_time: float = 1,
449: (8)                    stop_condition: Callable[[], bool] | None = None,
450: (8)                    frozen_frame: bool | None = None,
451: (8)                    rate_func: Callable[[float], float] = linear,
452: (8)                    **kwargs,
453: (4)                ):
454: (8)                    if stop_condition and frozen_frame:
455: (12)                       raise ValueError("A static Wait animation cannot have a stop condition.")
456: (8)                    self.duration: float = run_time
457: (8)                    self.stop_condition = stop_condition
458: (8)                    self.is_static_wait: bool = frozen_frame
459: (8)                    super().__init__(None, run_time=run_time, rate_func=rate_func, **kwargs)
460: (8)                    # quick fix to work in opengl setting:
461: (8)                    self.mobject.shader_wrapper_list = []
462: (4)                def begin(self) -> None:
463: (8)                    pass
464: (4)                def finish(self) -> None:
465: (8)                    pass
466: (4)                def clean_up_from_scene(self, scene: Scene) -> None:
467: (8)                    pass
468: (4)                def update_mobjects(self, dt: float) -> None:
469: (8)                    pass
470: (4)                def interpolate(self, alpha: float) -> None:
471: (8)                    pass
472: (0)            def override_animation(
473: (4)                animation_class: type[Animation],
474: (0)            ) -> Callable[[Callable], Callable]:
475: (4)                """Decorator used to mark methods as overrides for specific :class:`~.Animation` types.
476: (4)                Should only be used to decorate methods of classes derived from :class:`~.Mobject`.
477: (4)                ``Animation`` overrides get inherited to subclasses of the ``Mobject`` who defined
478: (4)                them. They don't override subclasses of the ``Animation`` they override.
479: (4)                See Also
480: (4)                --------
481: (4)                :meth:`~.Mobject.add_animation_override`
482: (4)                Parameters
483: (4)                ----------
484: (4)                animation_class
485: (8)                    The animation to be overridden.
486: (4)                Returns
487: (4)                -------
488: (4)                Callable[[Callable], Callable]
489: (8)                    The actual decorator. This marks the method as overriding an animation.
490: (4)                Examples
491: (4)                --------
492: (4)                .. manim:: OverrideAnimationExample
493: (8)                    class MySquare(Square):
494: (12)                       @override_animation(FadeIn)
495: (12)                       def _fade_in_override(self, **kwargs):
496: (16)                           return Create(self, **kwargs)
497: (8)                    class OverrideAnimationExample(Scene):
498: (12)                       def construct(self):
499: (16)                           self.play(FadeIn(MySquare()))
500: (4)                """
501: (4)                def decorator(func):
502: (8)                    func._override_animation = animation_class
503: (8)                    return func
504: (4)                return decorator

----------------------------------------

File 7 - . \indication.py:

1: (0)              """Animations drawing attention to particular mobjects.
2: (0)              Examples
3: (0)              --------
4: (0)              .. manim:: Indications
5: (4)                  class Indications(Scene):
6: (8)                      def construct(self):
7: (12)                         indications = [ApplyWave,Circumscribe,Flash,FocusOn,Indicate,ShowPassingFlash,Wiggle]
8: (12)                         names = [Tex(i.__name__).scale(3) for i in indications]
9: (12)                         self.add(names[0])
10: (12)                        for i in range(len(names)):
11: (16)                            if indications[i] is Flash:
12: (20)                                self.play(Flash(UP))
13: (16)                            elif indications[i] is ShowPassingFlash:
14: (20)                                self.play(ShowPassingFlash(Underline(names[i])))
15: (16)                            else:
16: (20)                                self.play(indications[i](names[i]))
17: (16)                            self.play(AnimationGroup(
18: (20)                                FadeOut(names[i], shift=UP*1.5),
19: (20)                                FadeIn(names[(i+1)%len(names)], shift=UP*1.5),
20: (16)                            ))
21: (0)             """
22: (0)             __all__ = [
23: (4)                 "FocusOn",
24: (4)                 "Indicate",
25: (4)                 "Flash",
26: (4)                 "ShowPassingFlash",
27: (4)                 "ShowPassingFlashWithThinningStrokeWidth",
28: (4)                 "ApplyWave",
29: (4)                 "Circumscribe",
30: (4)                 "Wiggle",
31: (0)             ]
32: (0)             from typing import Callable, Iterable, Optional, Tuple, Type, Union
33: (0)             import numpy as np
34: (0)             from manim.mobject.geometry.arc import Circle, Dot
35: (0)             from manim.mobject.geometry.line import Line
36: (0)             from manim.mobject.geometry.polygram import Rectangle
37: (0)             from manim.mobject.geometry.shape_matchers import SurroundingRectangle
38: (0)             from manim.scene.scene import Scene
39: (0)             from .. import config
40: (0)             from ..animation.animation import Animation
41: (0)             from ..animation.composition import AnimationGroup, Succession
42: (0)             from ..animation.creation import Create, ShowPartial, Uncreate
43: (0)             from ..animation.fading import FadeIn, FadeOut
44: (0)             from ..animation.movement import Homotopy
45: (0)             from ..animation.transform import Transform
46: (0)             from ..constants import *
47: (0)             from ..mobject.mobject import Mobject
48: (0)             from ..mobject.types.vectorized_mobject import VGroup, VMobject
49: (0)             from ..utils.bezier import interpolate, inverse_interpolate
50: (0)             from ..utils.color import GREY, YELLOW, ParsableManimColor
51: (0)             from ..utils.deprecation import deprecated
52: (0)             from ..utils.rate_functions import smooth, there_and_back, wiggle
53: (0)             from ..utils.space_ops import normalize
54: (0)             class FocusOn(Transform):
55: (4)                 """Shrink a spotlight to a position.
56: (4)                 Parameters
57: (4)                 ----------
58: (4)                 focus_point
59: (8)                     The point at which to shrink the spotlight. If it is a :class:`.~Mobject` its center will be used.
60: (4)                 opacity
61: (8)                     The opacity of the spotlight.
62: (4)                 color
63: (8)                     The color of the spotlight.
64: (4)                 run_time
65: (8)                     The duration of the animation.
66: (4)                 kwargs
67: (8)                     Additional arguments to be passed to the :class:`~.Succession` constructor
68: (4)                 Examples
69: (4)                 --------
70: (4)                 .. manim:: UsingFocusOn
71: (8)                     class UsingFocusOn(Scene):
72: (12)                        def construct(self):
73: (16)                            dot = Dot(color=YELLOW).shift(DOWN)
74: (16)                            self.add(Tex("Focusing on the dot below:"), dot)
75: (16)                            self.play(FocusOn(dot))
76: (16)                            self.wait()
77: (4)                 """
78: (4)                 def __init__(
79: (8)                     self,
80: (8)                     focus_point: Union[np.ndarray, Mobject],
81: (8)                     opacity: float = 0.2,
82: (8)                     color: str = GREY,
83: (8)                     run_time: float = 2,
84: (8)                     **kwargs
85: (4)                 ) -> None:
86: (8)                     self.focus_point = focus_point
87: (8)                     self.color = color
88: (8)                     self.opacity = opacity
89: (8)                     remover = True
90: (8)                     starting_dot = Dot(
91: (12)                        radius=config["frame_x_radius"] + config["frame_y_radius"],
92: (12)                        stroke_width=0,
93: (12)                        fill_color=self.color,
94: (12)                        fill_opacity=0,
95: (8)                     )
96: (8)                     super().__init__(starting_dot, run_time=run_time, remover=remover, **kwargs)
97: (4)                 def create_target(self) -> Dot:
98: (8)                     little_dot = Dot(radius=0)
99: (8)                     little_dot.set_fill(self.color, opacity=self.opacity)
100: (8)                    little_dot.add_updater(lambda d: d.move_to(self.focus_point))
101: (8)                    return little_dot
102: (0)            class Indicate(Transform):
103: (4)                """Indicate a Mobject by temporarily resizing and recoloring it.
104: (4)                Parameters
105: (4)                ----------
106: (4)                mobject
107: (8)                    The mobject to indicate.
108: (4)                scale_factor
109: (8)                    The factor by which the mobject will be temporally scaled
110: (4)                color
111: (8)                    The color the mobject temporally takes.
112: (4)                rate_func
113: (8)                    The function defining the animation progress at every point in time.
114: (4)                kwargs
115: (8)                    Additional arguments to be passed to the :class:`~.Succession` constructor
116: (4)                Examples
117: (4)                --------
118: (4)                .. manim:: UsingIndicate
119: (8)                    class UsingIndicate(Scene):
120: (12)                       def construct(self):
121: (16)                           tex = Tex("Indicate").scale(3)
122: (16)                           self.play(Indicate(tex))
123: (16)                           self.wait()
124: (4)                """
125: (4)                def __init__(
126: (8)                    self,
127: (8)                    mobject: Mobject,
128: (8)                    scale_factor: float = 1.2,
129: (8)                    color: str = YELLOW,
130: (8)                    rate_func: Callable[[float, Optional[float]], np.ndarray] = there_and_back,
131: (8)                    **kwargs
132: (4)                ) -> None:
133: (8)                    self.color = color
134: (8)                    self.scale_factor = scale_factor
135: (8)                    super().__init__(mobject, rate_func=rate_func, **kwargs)
136: (4)                def create_target(self) -> Mobject:
137: (8)                    target = self.mobject.copy()
138: (8)                    target.scale(self.scale_factor)
139: (8)                    target.set_color(self.color)
140: (8)                    return target
141: (0)            class Flash(AnimationGroup):
142: (4)                """Send out lines in all directions.
143: (4)                Parameters
144: (4)                ----------
145: (4)                point
146: (8)                    The center of the flash lines. If it is a :class:`.~Mobject` its center will be used.
147: (4)                line_length
148: (8)                    The length of the flash lines.
149: (4)                num_lines
150: (8)                    The number of flash lines.
151: (4)                flash_radius
152: (8)                    The distance from `point` at which the flash lines start.
153: (4)                line_stroke_width
154: (8)                    The stroke width of the flash lines.
155: (4)                color
156: (8)                    The color of the flash lines.
157: (4)                time_width
158: (8)                    The time width used for the flash lines. See :class:`.~ShowPassingFlash` for more details.
159: (4)                run_time
160: (8)                    The duration of the animation.
161: (4)                kwargs
162: (8)                    Additional arguments to be passed to the :class:`~.Succession` constructor
163: (4)                Examples
164: (4)                --------
165: (4)                .. manim:: UsingFlash
166: (8)                    class UsingFlash(Scene):
167: (12)                       def construct(self):
168: (16)                           dot = Dot(color=YELLOW).shift(DOWN)
169: (16)                           self.add(Tex("Flash the dot below:"), dot)
170: (16)                           self.play(Flash(dot))
171: (16)                           self.wait()
172: (4)                .. manim:: FlashOnCircle
173: (8)                    class FlashOnCircle(Scene):
174: (12)                       def construct(self):
175: (16)                           radius = 2
176: (16)                           circle = Circle(radius)
177: (16)                           self.add(circle)
178: (16)                           self.play(Flash(
179: (20)                               circle, line_length=1,
180: (20)                               num_lines=30, color=RED,
181: (20)                               flash_radius=radius+SMALL_BUFF,
182: (20)                               time_width=0.3, run_time=2,
183: (20)                               rate_func = rush_from
184: (16)                           ))
185: (4)                """
186: (4)                def __init__(
187: (8)                    self,
188: (8)                    point: Union[np.ndarray, Mobject],
189: (8)                    line_length: float = 0.2,
190: (8)                    num_lines: int = 12,
191: (8)                    flash_radius: float = 0.1,
192: (8)                    line_stroke_width: int = 3,
193: (8)                    color: str = YELLOW,
194: (8)                    time_width: float = 1,
195: (8)                    run_time: float = 1.0,
196: (8)                    **kwargs
197: (4)                ) -> None:
198: (8)                    if isinstance(point, Mobject):
199: (12)                       self.point = point.get_center()
200: (8)                    else:
201: (12)                       self.point = point
202: (8)                    self.color = color
203: (8)                    self.line_length = line_length
204: (8)                    self.num_lines = num_lines
205: (8)                    self.flash_radius = flash_radius
206: (8)                    self.line_stroke_width = line_stroke_width
207: (8)                    self.run_time = run_time
208: (8)                    self.time_width = time_width
209: (8)                    self.animation_config = kwargs
210: (8)                    self.lines = self.create_lines()
211: (8)                    animations = self.create_line_anims()
212: (8)                    super().__init__(*animations, group=self.lines)
213: (4)                def create_lines(self) -> VGroup:
214: (8)                    lines = VGroup()
215: (8)                    for angle in np.arange(0, TAU, TAU / self.num_lines):
216: (12)                       line = Line(self.point, self.point + self.line_length * RIGHT)
217: (12)                       line.shift((self.flash_radius) * RIGHT)
218: (12)                       line.rotate(angle, about_point=self.point)
219: (12)                       lines.add(line)
220: (8)                    lines.set_color(self.color)
221: (8)                    lines.set_stroke(width=self.line_stroke_width)
222: (8)                    return lines
223: (4)                def create_line_anims(self) -> Iterable["ShowPassingFlash"]:
224: (8)                    return [
225: (12)                       ShowPassingFlash(
226: (16)                           line,
227: (16)                           time_width=self.time_width,
228: (16)                           run_time=self.run_time,
229: (16)                           **self.animation_config,
230: (12)                       )
231: (12)                       for line in self.lines
232: (8)                    ]
233: (0)            class ShowPassingFlash(ShowPartial):
234: (4)                """Show only a sliver of the VMobject each frame.
235: (4)                Parameters
236: (4)                ----------
237: (4)                mobject
238: (8)                    The mobject whose stroke is animated.
239: (4)                time_width
240: (8)                    The length of the sliver relative to the length of the stroke.
241: (4)                Examples
242: (4)                --------
243: (4)                .. manim:: TimeWidthValues
244: (8)                    class TimeWidthValues(Scene):
245: (12)                       def construct(self):
246: (16)                           p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)
247: (16)                           lbl = VMobject()
248: (16)                           self.add(p, lbl)
249: (16)                           p = p.copy().set_color(BLUE)
250: (16)                           for time_width in [0.2, 0.5, 1, 2]:
251: (20)                               lbl.become(Tex(r"\\texttt{time\\_width={{%.1f}}}"%time_width))
252: (20)                               self.play(ShowPassingFlash(
253: (24)                                   p.copy().set_color(BLUE),
254: (24)                                   run_time=2,
255: (24)                                   time_width=time_width
256: (20)                               ))
257: (4)                See Also
258: (4)                --------
259: (4)                :class:`~.Create`
260: (4)                """
261: (4)                def __init__(self, mobject: "VMobject", time_width: float = 0.1, **kwargs) -> None:
262: (8)                    self.time_width = time_width
263: (8)                    super().__init__(mobject, remover=True, introducer=True, **kwargs)
264: (4)                def _get_bounds(self, alpha: float) -> Tuple[float]:
265: (8)                    tw = self.time_width
266: (8)                    upper = interpolate(0, 1 + tw, alpha)
267: (8)                    lower = upper - tw
268: (8)                    upper = min(upper, 1)
269: (8)                    lower = max(lower, 0)
270: (8)                    return (lower, upper)
271: (4)                def clean_up_from_scene(self, scene: Scene) -> None:
272: (8)                    super().clean_up_from_scene(scene)
273: (8)                    for submob, start in self.get_all_families_zipped():
274: (12)                       submob.pointwise_become_partial(start, 0, 1)
275: (0)            class ShowPassingFlashWithThinningStrokeWidth(AnimationGroup):
276: (4)                def __init__(self, vmobject, n_segments=10, time_width=0.1, remover=True, **kwargs):
277: (8)                    self.n_segments = n_segments
278: (8)                    self.time_width = time_width
279: (8)                    self.remover = remover
280: (8)                    max_stroke_width = vmobject.get_stroke_width()
281: (8)                    max_time_width = kwargs.pop("time_width", self.time_width)
282: (8)                    super().__init__(
283: (12)                       *(
284: (16)                           ShowPassingFlash(
285: (20)                               vmobject.copy().set_stroke(width=stroke_width),
286: (20)                               time_width=time_width,
287: (20)                               **kwargs,
288: (16)                           )
289: (16)                           for stroke_width, time_width in zip(
290: (20)                               np.linspace(0, max_stroke_width, self.n_segments),
291: (20)                               np.linspace(max_time_width, 0, self.n_segments),
292: (16)                           )
293: (12)                       ),
294: (8)                    )
295: (0)            class ApplyWave(Homotopy):
296: (4)                """Send a wave through the Mobject distorting it temporarily.
297: (4)                Parameters
298: (4)                ----------
299: (4)                mobject
300: (8)                    The mobject to be distorted.
301: (4)                direction
302: (8)                    The direction in which the wave nudges points of the shape
303: (4)                amplitude
304: (8)                    The distance points of the shape get shifted
305: (4)                wave_func
306: (8)                    The function defining the shape of one wave flank.
307: (4)                time_width
308: (8)                    The length of the wave relative to the width of the mobject.
309: (4)                ripples
310: (8)                    The number of ripples of the wave
311: (4)                run_time
312: (8)                    The duration of the animation.
313: (4)                Examples
314: (4)                --------
315: (4)                .. manim:: ApplyingWaves
316: (8)                    class ApplyingWaves(Scene):
317: (12)                       def construct(self):
318: (16)                           tex = Tex("WaveWaveWaveWaveWave").scale(2)
319: (16)                           self.play(ApplyWave(tex))
320: (16)                           self.play(ApplyWave(
321: (20)                               tex,
322: (20)                               direction=RIGHT,
323: (20)                               time_width=0.5,
324: (20)                               amplitude=0.3
325: (16)                           ))
326: (16)                           self.play(ApplyWave(
327: (20)                               tex,
328: (20)                               rate_func=linear,
329: (20)                               ripples=4
330: (16)                           ))
331: (4)                """
332: (4)                def __init__(
333: (8)                    self,
334: (8)                    mobject: Mobject,
335: (8)                    direction: np.ndarray = UP,
336: (8)                    amplitude: float = 0.2,
337: (8)                    wave_func: Callable[[float], float] = smooth,
338: (8)                    time_width: float = 1,
339: (8)                    ripples: int = 1,
340: (8)                    run_time: float = 2,
341: (8)                    **kwargs
342: (4)                ) -> None:
343: (8)                    x_min = mobject.get_left()[0]
344: (8)                    x_max = mobject.get_right()[0]
345: (8)                    vect = amplitude * normalize(direction)
346: (8)                    def wave(t):
347: (12)                       # Creates a wave with n ripples from a simple rate_func
348: (12)                       # This wave is build up as follows:
349: (12)                       # The time is split into 2*ripples phases. In every phase the amplitude
350: (12)                       # either rises to one or goes down to zero. Consecutive ripples will have
351: (12)                       # their amplitudes in opposing directions (first ripple from 0 to 1 to 0,
352: (12)                       # second from 0 to -1 to 0 and so on). This is how two ripples would be
353: (12)                       # divided into phases:
354: (12)                       #         ####|####        |            |
355: (12)                       #       ##    |    ##      |            |
356: (12)                       #     ##      |      ##    |            |
357: (12)                       # ####        |        ####|####        |        ####
358: (12)                       #             |            |    ##      |      ##
359: (12)                       #             |            |      ##    |    ##
360: (12)                       #             |            |        ####|####
361: (12)                       # However, this looks weird in the middle between two ripples. Therefore the
362: (12)                       # middle phases do actually use only one appropriately scaled version of the
363: (12)                       # rate like this:
364: (12)                       # 1 / 4 Time  | 2 / 4 Time            | 1 / 4 Time
365: (12)                       #         ####|######                 |
366: (12)                       #       ##    |      ###              |
367: (12)                       #     ##      |         ##            |
368: (12)                       # ####        |           #           |        ####
369: (12)                       #             |            ##         |      ##
370: (12)                       #             |              ###      |    ##
371: (12)                       #             |                 ######|####
372: (12)                       # Mirrored looks better in the way the wave is used.
373: (12)                       t = 1 - t
374: (12)                       # Clamp input
375: (12)                       if t >= 1 or t <= 0:
376: (16)                           return 0
377: (12)                       phases = ripples * 2
378: (12)                       phase = int(t * phases)
379: (12)                       if phase == 0:
380: (16)                           # First rising ripple
381: (16)                           return wave_func(t * phases)
382: (12)                       elif phase == phases - 1:
383: (16)                           # last ripple. Rising or falling depending on the number of ripples
384: (16)                           # The (ripples % 2)-term is used to make this distinction.
385: (16)                           t -= phase / phases  # Time relative to the phase
386: (16)                           return (1 - wave_func(t * phases)) * (2 * (ripples % 2) - 1)
387: (12)                       else:
388: (16)                           # Longer phases:
389: (16)                           phase = int((phase - 1) / 2)
390: (16)                           t -= (2 * phase + 1) / phases
391: (16)                           # Similar to last ripple:
392: (16)                           return (1 - 2 * wave_func(t * ripples)) * (1 - 2 * ((phase) % 2))
393: (8)                    def homotopy(
394: (12)                       x: float,
395: (12)                       y: float,
396: (12)                       z: float,
397: (12)                       t: float,
398: (8)                    ) -> Tuple[float, float, float]:
399: (12)                       upper = interpolate(0, 1 + time_width, t)
400: (12)                       lower = upper - time_width
401: (12)                       relative_x = inverse_interpolate(x_min, x_max, x)
402: (12)                       wave_phase = inverse_interpolate(lower, upper, relative_x)
403: (12)                       nudge = wave(wave_phase) * vect
404: (12)                       return np.array([x, y, z]) + nudge
405: (8)                    super().__init__(homotopy, mobject, run_time=run_time, **kwargs)
406: (0)            class Wiggle(Animation):
407: (4)                """Wiggle a Mobject.
408: (4)                Parameters
409: (4)                ----------
410: (4)                mobject
411: (8)                    The mobject to wiggle.
412: (4)                scale_value
413: (8)                    The factor by which the mobject will be temporarily scaled.
414: (4)                rotation_angle
415: (8)                    The wiggle angle.
416: (4)                n_wiggles
417: (8)                    The number of wiggles.
418: (4)                scale_about_point
419: (8)                    The point about which the mobject gets scaled.
420: (4)                rotate_about_point
421: (8)                    The point around which the mobject gets rotated.
422: (4)                run_time
423: (8)                    The duration of the animation
424: (4)                Examples
425: (4)                --------
426: (4)                .. manim:: ApplyingWaves
427: (8)                    class ApplyingWaves(Scene):
428: (12)                       def construct(self):
429: (16)                           tex = Tex("Wiggle").scale(3)
430: (16)                           self.play(Wiggle(tex))
431: (16)                           self.wait()
432: (4)                """
433: (4)                def __init__(
434: (8)                    self,
435: (8)                    mobject: Mobject,
436: (8)                    scale_value: float = 1.1,
437: (8)                    rotation_angle: float = 0.01 * TAU,
438: (8)                    n_wiggles: int = 6,
439: (8)                    scale_about_point: Optional[np.ndarray] = None,
440: (8)                    rotate_about_point: Optional[np.ndarray] = None,
441: (8)                    run_time: float = 2,
442: (8)                    **kwargs
443: (4)                ) -> None:
444: (8)                    self.scale_value = scale_value
445: (8)                    self.rotation_angle = rotation_angle
446: (8)                    self.n_wiggles = n_wiggles
447: (8)                    self.scale_about_point = scale_about_point
448: (8)                    self.rotate_about_point = rotate_about_point
449: (8)                    super().__init__(mobject, run_time=run_time, **kwargs)
450: (4)                def get_scale_about_point(self) -> np.ndarray:
451: (8)                    if self.scale_about_point is None:
452: (12)                       return self.mobject.get_center()
453: (8)                    return self.scale_about_point
454: (4)                def get_rotate_about_point(self) -> np.ndarray:
455: (8)                    if self.rotate_about_point is None:
456: (12)                       return self.mobject.get_center()
457: (8)                    return self.rotate_about_point
458: (4)                def interpolate_submobject(
459: (8)                    self,
460: (8)                    submobject: Mobject,
461: (8)                    starting_submobject: Mobject,
462: (8)                    alpha: float,
463: (4)                ) -> None:
464: (8)                    submobject.points[:, :] = starting_submobject.points
465: (8)                    submobject.scale(
466: (12)                       interpolate(1, self.scale_value, there_and_back(alpha)),
467: (12)                       about_point=self.get_scale_about_point(),
468: (8)                    )
469: (8)                    submobject.rotate(
470: (12)                       wiggle(alpha, self.n_wiggles) * self.rotation_angle,
471: (12)                       about_point=self.get_rotate_about_point(),
472: (8)                    )
473: (0)            class Circumscribe(Succession):
474: (4)                """Draw a temporary line surrounding the mobject.
475: (4)                Parameters
476: (4)                ----------
477: (4)                mobject
478: (8)                    The mobject to be circumscribed.
479: (4)                shape
480: (8)                    The shape with which to surround the given mobject. Should be either
481: (8)                    :class:`~.Rectangle` or :class:`~.Circle`
482: (4)                fade_in
483: (8)                    Whether to make the surrounding shape to fade in. It will be drawn otherwise.
484: (4)                fade_out
485: (8)                    Whether to make the surrounding shape to fade out. It will be undrawn otherwise.
486: (4)                time_width
487: (8)                    The time_width of the drawing and undrawing. Gets ignored if either `fade_in` or `fade_out` is `True`.
488: (4)                buff
489: (8)                    The distance between the surrounding shape and the given mobject.
490: (4)                color
491: (8)                    The color of the surrounding shape.
492: (4)                run_time
493: (8)                    The duration of the entire animation.
494: (4)                kwargs
495: (8)                    Additional arguments to be passed to the :class:`~.Succession` constructor
496: (4)                Examples
497: (4)                --------
498: (4)                .. manim:: UsingCircumscribe
499: (8)                    class UsingCircumscribe(Scene):
500: (12)                       def construct(self):
501: (16)                           lbl = Tex(r"Circum-\\\\scribe").scale(2)
502: (16)                           self.add(lbl)
503: (16)                           self.play(Circumscribe(lbl))
504: (16)                           self.play(Circumscribe(lbl, Circle))
505: (16)                           self.play(Circumscribe(lbl, fade_out=True))
506: (16)                           self.play(Circumscribe(lbl, time_width=2))
507: (16)                           self.play(Circumscribe(lbl, Circle, True))
508: (4)                """
509: (4)                def __init__(
510: (8)                    self,
511: (8)                    mobject: Mobject,
512: (8)                    shape: Type = Rectangle,
513: (8)                    fade_in=False,
514: (8)                    fade_out=False,
515: (8)                    time_width=0.3,
516: (8)                    buff: float = SMALL_BUFF,
517: (8)                    color: ParsableManimColor = YELLOW,
518: (8)                    run_time=1,
519: (8)                    stroke_width=DEFAULT_STROKE_WIDTH,
520: (8)                    **kwargs
521: (4)                ):
522: (8)                    if shape is Rectangle:
523: (12)                       frame = SurroundingRectangle(
524: (16)                           mobject,
525: (16)                           color,
526: (16)                           buff,
527: (16)                           stroke_width=stroke_width,
528: (12)                       )
529: (8)                    elif shape is Circle:
530: (12)                       frame = Circle(color=color, stroke_width=stroke_width).surround(
531: (16)                           mobject,
532: (16)                           buffer_factor=1,
533: (12)                       )
534: (12)                       radius = frame.width / 2
535: (12)                       frame.scale((radius + buff) / radius)
536: (8)                    else:
537: (12)                       raise ValueError("shape should be either Rectangle or Circle.")
538: (8)                    if fade_in and fade_out:
539: (12)                       super().__init__(
540: (16)                           FadeIn(frame, run_time=run_time / 2),
541: (16)                           FadeOut(frame, run_time=run_time / 2),
542: (16)                           **kwargs,
543: (12)                       )
544: (8)                    elif fade_in:
545: (12)                       frame.reverse_direction()
546: (12)                       super().__init__(
547: (16)                           FadeIn(frame, run_time=run_time / 2),
548: (16)                           Uncreate(frame, run_time=run_time / 2),
549: (16)                           **kwargs,
550: (12)                       )
551: (8)                    elif fade_out:
552: (12)                       super().__init__(
553: (16)                           Create(frame, run_time=run_time / 2),
554: (16)                           FadeOut(frame, run_time=run_time / 2),
555: (16)                           **kwargs,
556: (12)                       )
557: (8)                    else:
558: (12)                       super().__init__(
559: (16)                           ShowPassingFlash(frame, time_width, run_time=run_time), **kwargs
560: (12)                       )

----------------------------------------

File 8 - . \composition.py:

1: (0)              """Tools for displaying multiple animations at once."""
2: (0)              from __future__ import annotations
3: (0)              import types
4: (0)              from typing import TYPE_CHECKING, Callable, Iterable, Sequence
5: (0)              import numpy as np
6: (0)              from manim._config import config
7: (0)              from manim.animation.animation import Animation, prepare_animation
8: (0)              from manim.constants import RendererType
9: (0)              from manim.mobject.mobject import Group, Mobject
10: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLGroup
11: (0)             from manim.scene.scene import Scene
12: (0)             from manim.utils.iterables import remove_list_redundancies
13: (0)             from manim.utils.parameter_parsing import flatten_iterable_parameters
14: (0)             from manim.utils.rate_functions import linear
15: (0)             if TYPE_CHECKING:
16: (4)                 from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVGroup
17: (4)                 from manim.mobject.types.vectorized_mobject import VGroup
18: (0)             __all__ = ["AnimationGroup", "Succession", "LaggedStart", "LaggedStartMap"]
19: (0)             DEFAULT_LAGGED_START_LAG_RATIO: float = 0.05
20: (0)             class AnimationGroup(Animation):
21: (4)                 """Plays a group or series of :class:`~.Animation`.
22: (4)                 Parameters
23: (4)                 ----------
24: (4)                 animations
25: (8)                     Sequence of :class:`~.Animation` objects to be played.
26: (4)                 group
27: (8)                     A group of multiple :class:`~.Mobject`.
28: (4)                 run_time
29: (8)                     The duration of the animation in seconds.
30: (4)                 rate_func
31: (8)                     The function defining the animation progress based on the relative
32: (8)                     runtime (see :mod:`~.rate_functions`) .
33: (4)                 lag_ratio
34: (8)                     Defines the delay after which the animation is applied to submobjects. A lag_ratio of
35: (8)                     ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.
36: (8)                     Defaults to 0.0, meaning that all animations will be played together.
37: (8)                     This does not influence the total runtime of the animation. Instead the runtime
38: (8)                     of individual animations is adjusted so that the complete animation has the defined
39: (8)                     run time.
40: (4)                 """
41: (4)                 def __init__(
42: (8)                     self,
43: (8)                     *animations: Animation | Iterable[Animation] | types.GeneratorType[Animation],
44: (8)                     group: Group | VGroup | OpenGLGroup | OpenGLVGroup = None,
45: (8)                     run_time: float | None = None,
46: (8)                     rate_func: Callable[[float], float] = linear,
47: (8)                     lag_ratio: float = 0,
48: (8)                     **kwargs,
49: (4)                 ) -> None:
50: (8)                     arg_anim = flatten_iterable_parameters(animations)
51: (8)                     self.animations = [prepare_animation(anim) for anim in arg_anim]
52: (8)                     self.rate_func = rate_func
53: (8)                     self.group = group
54: (8)                     if self.group is None:
55: (12)                        mobjects = remove_list_redundancies(
56: (16)                            [anim.mobject for anim in self.animations if not anim.is_introducer()],
57: (12)                        )
58: (12)                        if config["renderer"] == RendererType.OPENGL:
59: (16)                            self.group = OpenGLGroup(*mobjects)
60: (12)                        else:
61: (16)                            self.group = Group(*mobjects)
62: (8)                     super().__init__(
63: (12)                        self.group, rate_func=self.rate_func, lag_ratio=lag_ratio, **kwargs
64: (8)                     )
65: (8)                     self.run_time: float = self.init_run_time(run_time)
66: (4)                 def get_all_mobjects(self) -> Sequence[Mobject]:
67: (8)                     return list(self.group)
68: (4)                 def begin(self) -> None:
69: (8)                     if self.run_time <= 0:
70: (12)                        tmp = (
71: (16)                            "Please set the run_time to be positive"
72: (16)                            if len(self.animations) != 0
73: (16)                            else "Please add at least one Animation with positive run_time"
74: (12)                        )
75: (12)                        raise ValueError(
76: (16)                            f"{self} has a run_time of 0 seconds, this cannot be "
77: (16)                            f"rendered correctly. {tmp}."
78: (12)                        )
79: (8)                     self.anim_group_time = 0.0
80: (8)                     if self.suspend_mobject_updating:
81: (12)                        self.group.suspend_updating()
82: (8)                     for anim in self.animations:
83: (12)                        anim.begin()
84: (4)                 def _setup_scene(self, scene) -> None:
85: (8)                     for anim in self.animations:
86: (12)                        anim._setup_scene(scene)
87: (4)                 def finish(self) -> None:
88: (8)                     self.interpolate(1)
89: (8)                     self.anims_begun[:] = True
90: (8)                     self.anims_finished[:] = True
91: (8)                     if self.suspend_mobject_updating:
92: (12)                        self.group.resume_updating()
93: (4)                 def clean_up_from_scene(self, scene: Scene) -> None:
94: (8)                     self._on_finish(scene)
95: (8)                     for anim in self.animations:
96: (12)                        if self.remover:
97: (16)                            anim.remover = self.remover
98: (12)                        anim.clean_up_from_scene(scene)
99: (4)                 def update_mobjects(self, dt: float) -> None:
100: (8)                    for anim in self.anims_with_timings["anim"][
101: (12)                       self.anims_begun & ~self.anims_finished
102: (8)                    ]:
103: (12)                       anim.update_mobjects(dt)
104: (4)                def init_run_time(self, run_time) -> float:
105: (8)                    """Calculates the run time of the animation, if different from ``run_time``.
106: (8)                    Parameters
107: (8)                    ----------
108: (8)                    run_time
109: (12)                       The duration of the animation in seconds.
110: (8)                    Returns
111: (8)                    -------
112: (8)                    run_time
113: (12)                       The duration of the animation in seconds.
114: (8)                    """
115: (8)                    self.build_animations_with_timings()
116: (8)                    # Note: if lag_ratio < 1, then not necessarily the final animation's
117: (8)                    # end time will be the max end time! Therefore we must calculate the
118: (8)                    # maximum over all the end times, and not just take the last one.
119: (8)                    # Example: if you want to play 2 animations of 10s and 1s with a
120: (8)                    # lag_ratio of 0.1, the 1st one will end at t=10 and the 2nd one will
121: (8)                    # end at t=2, so the AnimationGroup will end at t=10.
122: (8)                    self.max_end_time = max(self.anims_with_timings["end"], default=0)
123: (8)                    return self.max_end_time if run_time is None else run_time
124: (4)                def build_animations_with_timings(self) -> None:
125: (8)                    """Creates a list of triplets of the form (anim, start_time, end_time)."""
126: (8)                    run_times = np.array([anim.run_time for anim in self.animations])
127: (8)                    num_animations = run_times.shape[0]
128: (8)                    dtype = [("anim", "O"), ("start", "f8"), ("end", "f8")]
129: (8)                    self.anims_with_timings = np.zeros(num_animations, dtype=dtype)
130: (8)                    self.anims_begun = np.zeros(num_animations, dtype=bool)
131: (8)                    self.anims_finished = np.zeros(num_animations, dtype=bool)
132: (8)                    if num_animations == 0:
133: (12)                       return
134: (8)                    lags = run_times[:-1] * self.lag_ratio
135: (8)                    self.anims_with_timings["anim"] = self.animations
136: (8)                    self.anims_with_timings["start"][1:] = np.add.accumulate(lags)
137: (8)                    self.anims_with_timings["end"] = self.anims_with_timings["start"] + run_times
138: (4)                def interpolate(self, alpha: float) -> None:
139: (8)                    # Note, if the run_time of AnimationGroup has been
140: (8)                    # set to something other than its default, these
141: (8)                    # times might not correspond to actual times,
142: (8)                    # e.g. of the surrounding scene.  Instead they'd
143: (8)                    # be a rescaled version.  But that's okay!
144: (8)                    anim_group_time = self.rate_func(alpha) * self.max_end_time
145: (8)                    time_goes_back = anim_group_time < self.anim_group_time
146: (8)                    # Only update ongoing animations
147: (8)                    awt = self.anims_with_timings
148: (8)                    new_begun = anim_group_time >= awt["start"]
149: (8)                    new_finished = anim_group_time > awt["end"]
150: (8)                    to_update = awt[
151: (12)                       (self.anims_begun | new_begun) & (~self.anims_finished | ~new_finished)
152: (8)                    ]
153: (8)                    run_times = to_update["end"] - to_update["start"]
154: (8)                    sub_alphas = (anim_group_time - to_update["start"]) / run_times
155: (8)                    if time_goes_back:
156: (12)                       sub_alphas[sub_alphas < 0] = 0
157: (8)                    else:
158: (12)                       sub_alphas[sub_alphas > 1] = 1
159: (8)                    for anim_to_update, sub_alpha in zip(to_update["anim"], sub_alphas):
160: (12)                       anim_to_update.interpolate(sub_alpha)
161: (8)                    self.anim_group_time = anim_group_time
162: (8)                    self.anims_begun = new_begun
163: (8)                    self.anims_finished = new_finished
164: (0)            class Succession(AnimationGroup):
165: (4)                """Plays a series of animations in succession.
166: (4)                Parameters
167: (4)                ----------
168: (4)                animations
169: (8)                    Sequence of :class:`~.Animation` objects to be played.
170: (4)                lag_ratio
171: (8)                    Defines the delay after which the animation is applied to submobjects. A lag_ratio of
172: (8)                    ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.
173: (8)                    Defaults to 1.0, meaning that the next animation will begin when 100% of the current
174: (8)                    animation has played.
175: (8)                    This does not influence the total runtime of the animation. Instead the runtime
176: (8)                    of individual animations is adjusted so that the complete animation has the defined
177: (8)                    run time.
178: (4)                Examples
179: (4)                --------
180: (4)                .. manim:: SuccessionExample
181: (8)                    class SuccessionExample(Scene):
182: (12)                       def construct(self):
183: (16)                           dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)
184: (16)                           dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)
185: (16)                           dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)
186: (16)                           dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)
187: (16)                           self.add(dot1, dot2, dot3, dot4)
188: (16)                           self.play(Succession(
189: (20)                               dot1.animate.move_to(dot2),
190: (20)                               dot2.animate.move_to(dot3),
191: (20)                               dot3.animate.move_to(dot4),
192: (20)                               dot4.animate.move_to(dot1)
193: (16)                           ))
194: (4)                """
195: (4)                def __init__(self, *animations: Animation, lag_ratio: float = 1, **kwargs) -> None:
196: (8)                    super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)
197: (4)                def begin(self) -> None:
198: (8)                    assert len(self.animations) > 0
199: (8)                    self.update_active_animation(0)
200: (4)                def finish(self) -> None:
201: (8)                    while self.active_animation is not None:
202: (12)                       self.next_animation()
203: (4)                def update_mobjects(self, dt: float) -> None:
204: (8)                    if self.active_animation:
205: (12)                       self.active_animation.update_mobjects(dt)
206: (4)                def _setup_scene(self, scene) -> None:
207: (8)                    if scene is None:
208: (12)                       return
209: (8)                    if self.is_introducer():
210: (12)                       for anim in self.animations:
211: (16)                           if not anim.is_introducer() and anim.mobject is not None:
212: (20)                               scene.add(anim.mobject)
213: (8)                    self.scene = scene
214: (4)                def update_active_animation(self, index: int) -> None:
215: (8)                    self.active_index = index
216: (8)                    if index >= len(self.animations):
217: (12)                       self.active_animation: Animation | None = None
218: (12)                       self.active_start_time: float | None = None
219: (12)                       self.active_end_time: float | None = None
220: (8)                    else:
221: (12)                       self.active_animation = self.animations[index]
222: (12)                       self.active_animation._setup_scene(self.scene)
223: (12)                       self.active_animation.begin()
224: (12)                       self.active_start_time = self.anims_with_timings[index]["start"]
225: (12)                       self.active_end_time = self.anims_with_timings[index]["end"]
226: (4)                def next_animation(self) -> None:
227: (8)                    """Proceeds to the next animation.
228: (8)                    This method is called right when the active animation finishes.
229: (8)                    """
230: (8)                    if self.active_animation is not None:
231: (12)                       self.active_animation.finish()
232: (8)                    self.update_active_animation(self.active_index + 1)
233: (4)                def interpolate(self, alpha: float) -> None:
234: (8)                    current_time = self.rate_func(alpha) * self.max_end_time
235: (8)                    while self.active_end_time is not None and current_time >= self.active_end_time:
236: (12)                       self.next_animation()
237: (8)                    if self.active_animation is not None and self.active_start_time is not None:
238: (12)                       elapsed = current_time - self.active_start_time
239: (12)                       active_run_time = self.active_animation.run_time
240: (12)                       subalpha = elapsed / active_run_time if active_run_time != 0.0 else 1.0
241: (12)                       self.active_animation.interpolate(subalpha)
242: (0)            class LaggedStart(AnimationGroup):
243: (4)                """Adjusts the timing of a series of :class:`~.Animation` according to ``lag_ratio``.
244: (4)                Parameters
245: (4)                ----------
246: (4)                animations
247: (8)                    Sequence of :class:`~.Animation` objects to be played.
248: (4)                lag_ratio
249: (8)                    Defines the delay after which the animation is applied to submobjects. A lag_ratio of
250: (8)                    ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.
251: (8)                    Defaults to 0.05, meaning that the next animation will begin when 5% of the current
252: (8)                    animation has played.
253: (8)                    This does not influence the total runtime of the animation. Instead the runtime
254: (8)                    of individual animations is adjusted so that the complete animation has the defined
255: (8)                    run time.
256: (4)                Examples
257: (4)                --------
258: (4)                .. manim:: LaggedStartExample
259: (8)                    class LaggedStartExample(Scene):
260: (12)                       def construct(self):
261: (16)                           title = Text("lag_ratio = 0.25").to_edge(UP)
262: (16)                           dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)
263: (16)                           dot2 = Dot(point=LEFT * 2, radius=0.16)
264: (16)                           dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)
265: (16)                           line_25 = DashedLine(
266: (20)                               start=LEFT + UP * 2,
267: (20)                               end=LEFT + DOWN * 2,
268: (20)                               color=RED
269: (16)                           )
270: (16)                           label = Text("25%", font_size=24).next_to(line_25, UP)
271: (16)                           self.add(title, dot1, dot2, dot3, line_25, label)
272: (16)                           self.play(LaggedStart(
273: (20)                               dot1.animate.shift(RIGHT * 4),
274: (20)                               dot2.animate.shift(RIGHT * 4),
275: (20)                               dot3.animate.shift(RIGHT * 4),
276: (20)                               lag_ratio=0.25,
277: (20)                               run_time=4
278: (16)                           ))
279: (4)                """
280: (4)                def __init__(
281: (8)                    self,
282: (8)                    *animations: Animation,
283: (8)                    lag_ratio: float = DEFAULT_LAGGED_START_LAG_RATIO,
284: (8)                    **kwargs,
285: (4)                ):
286: (8)                    super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)
287: (0)            class LaggedStartMap(LaggedStart):
288: (4)                """Plays a series of :class:`~.Animation` while mapping a function to submobjects.
289: (4)                Parameters
290: (4)                ----------
291: (4)                AnimationClass
292: (8)                    :class:`~.Animation` to apply to mobject.
293: (4)                mobject
294: (8)                    :class:`~.Mobject` whose submobjects the animation, and optionally the function,
295: (8)                    are to be applied.
296: (4)                arg_creator
297: (8)                    Function which will be applied to :class:`~.Mobject`.
298: (4)                run_time
299: (8)                    The duration of the animation in seconds.
300: (4)                Examples
301: (4)                --------
302: (4)                .. manim:: LaggedStartMapExample
303: (8)                    class LaggedStartMapExample(Scene):
304: (12)                       def construct(self):
305: (16)                           title = Tex("LaggedStartMap").to_edge(UP, buff=LARGE_BUFF)
306: (16)                           dots = VGroup(
307: (20)                               *[Dot(radius=0.16) for _ in range(35)]
308: (20)                               ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)
309: (16)                           self.add(dots, title)
310: (16)                           # Animate yellow ripple effect
311: (16)                           for mob in dots, title:
312: (20)                               self.play(LaggedStartMap(
313: (24)                                   ApplyMethod, mob,
314: (24)                                   lambda m : (m.set_color, YELLOW),
315: (24)                                   lag_ratio = 0.1,
316: (24)                                   rate_func = there_and_back,
317: (24)                                   run_time = 2
318: (20)                               ))
319: (4)                """
320: (4)                def __init__(
321: (8)                    self,
322: (8)                    AnimationClass: Callable[..., Animation],
323: (8)                    mobject: Mobject,
324: (8)                    arg_creator: Callable[[Mobject], str] = None,
325: (8)                    run_time: float = 2,
326: (8)                    **kwargs,
327: (4)                ) -> None:
328: (8)                    args_list = []
329: (8)                    for submob in mobject:
330: (12)                       if arg_creator:
331: (16)                           args_list.append(arg_creator(submob))
332: (12)                       else:
333: (16)                           args_list.append((submob,))
334: (8)                    anim_kwargs = dict(kwargs)
335: (8)                    if "lag_ratio" in anim_kwargs:
336: (12)                       anim_kwargs.pop("lag_ratio")
337: (8)                    animations = [AnimationClass(*args, **anim_kwargs) for args in args_list]
338: (8)                    super().__init__(*animations, run_time=run_time, **kwargs)

----------------------------------------

File 9 - .\updaters \update.py:

1: (0)              """Animations that update mobjects."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["UpdateFromFunc", "UpdateFromAlphaFunc", "MaintainPositionRelativeTo"]
4: (0)              import operator as op
5: (0)              import typing
6: (0)              from manim.animation.animation import Animation
7: (0)              if typing.TYPE_CHECKING:
8: (4)                  from manim.mobject.mobject import Mobject
9: (0)              class UpdateFromFunc(Animation):
10: (4)                 """
11: (4)                 update_function of the form func(mobject), presumably
12: (4)                 to be used when the state of one mobject is dependent
13: (4)                 on another simultaneously animated mobject
14: (4)                 """
15: (4)                 def __init__(
16: (8)                     self,
17: (8)                     mobject: Mobject,
18: (8)                     update_function: typing.Callable[[Mobject], typing.Any],
19: (8)                     suspend_mobject_updating: bool = False,
20: (8)                     **kwargs,
21: (4)                 ) -> None:
22: (8)                     self.update_function = update_function
23: (8)                     super().__init__(
24: (12)                        mobject, suspend_mobject_updating=suspend_mobject_updating, **kwargs
25: (8)                     )
26: (4)                 def interpolate_mobject(self, alpha: float) -> None:
27: (8)                     self.update_function(self.mobject)
28: (0)             class UpdateFromAlphaFunc(UpdateFromFunc):
29: (4)                 def interpolate_mobject(self, alpha: float) -> None:
30: (8)                     self.update_function(self.mobject, self.rate_func(alpha))
31: (0)             class MaintainPositionRelativeTo(Animation):
32: (4)                 def __init__(self, mobject: Mobject, tracked_mobject: Mobject, **kwargs) -> None:
33: (8)                     self.tracked_mobject = tracked_mobject
34: (8)                     self.diff = op.sub(
35: (12)                        mobject.get_center(),
36: (12)                        tracked_mobject.get_center(),
37: (8)                     )
38: (8)                     super().__init__(mobject, **kwargs)
39: (4)                 def interpolate_mobject(self, alpha: float) -> None:
40: (8)                     target = self.tracked_mobject.get_center()
41: (8)                     location = self.mobject.get_center()
42: (8)                     self.mobject.shift(target - location + self.diff)

----------------------------------------

File 10 - . \numbers.py:

1: (0)              """Animations for changing numbers."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["ChangingDecimal", "ChangeDecimalToValue"]
4: (0)              import typing
5: (0)              from manim.mobject.text.numbers import DecimalNumber
6: (0)              from ..animation.animation import Animation
7: (0)              from ..utils.bezier import interpolate
8: (0)              class ChangingDecimal(Animation):
9: (4)                  def __init__(
10: (8)                     self,
11: (8)                     decimal_mob: DecimalNumber,
12: (8)                     number_update_func: typing.Callable[[float], float],
13: (8)                     suspend_mobject_updating: bool | None = False,
14: (8)                     **kwargs,
15: (4)                 ) -> None:
16: (8)                     self.check_validity_of_input(decimal_mob)
17: (8)                     self.number_update_func = number_update_func
18: (8)                     super().__init__(
19: (12)                        decimal_mob, suspend_mobject_updating=suspend_mobject_updating, **kwargs
20: (8)                     )
21: (4)                 def check_validity_of_input(self, decimal_mob: DecimalNumber) -> None:
22: (8)                     if not isinstance(decimal_mob, DecimalNumber):
23: (12)                        raise TypeError("ChangingDecimal can only take in a DecimalNumber")
24: (4)                 def interpolate_mobject(self, alpha: float) -> None:
25: (8)                     self.mobject.set_value(self.number_update_func(self.rate_func(alpha)))
26: (0)             class ChangeDecimalToValue(ChangingDecimal):
27: (4)                 def __init__(
28: (8)                     self, decimal_mob: DecimalNumber, target_number: int, **kwargs
29: (4)                 ) -> None:
30: (8)                     start_number = decimal_mob.number
31: (8)                     super().__init__(
32: (12)                        decimal_mob, lambda a: interpolate(start_number, target_number, a), **kwargs
33: (8)                     )

----------------------------------------

File 11 - . \movement.py:

1: (0)              """Animations related to movement."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "Homotopy",
5: (4)                  "SmoothedVectorizedHomotopy",
6: (4)                  "ComplexHomotopy",
7: (4)                  "PhaseFlow",
8: (4)                  "MoveAlongPath",
9: (0)              ]
10: (0)             from typing import TYPE_CHECKING, Any, Callable
11: (0)             import numpy as np
12: (0)             from ..animation.animation import Animation
13: (0)             from ..utils.rate_functions import linear
14: (0)             if TYPE_CHECKING:
15: (4)                 from ..mobject.mobject import Mobject, VMobject
16: (0)             class Homotopy(Animation):
17: (4)                 """A Homotopy.
18: (4)                 This is an animation transforming the points of a mobject according
19: (4)                 to the specified transformation function. With the parameter :math:`t`
20: (4)                 moving from 0 to 1 throughout the animation and :math:`(x, y, z)`
21: (4)                 describing the coordinates of the point of a mobject,
22: (4)                 the function passed to the ``homotopy`` keyword argument should
23: (4)                 transform the tuple :math:`(x, y, z, t)` to :math:`(x', y', z')`,
24: (4)                 the coordinates the original point is transformed to at time :math:`t`.
25: (4)                 Parameters
26: (4)                 ----------
27: (4)                 homotopy
28: (8)                     A function mapping :math:`(x, y, z, t)` to :math:`(x', y', z')`.
29: (4)                 mobject
30: (8)                     The mobject transformed under the given homotopy.
31: (4)                 run_time
32: (8)                     The run time of the animation.
33: (4)                 apply_function_kwargs
34: (8)                     Keyword arguments propagated to :meth:`.Mobject.apply_function`.
35: (4)                 kwargs
36: (8)                     Further keyword arguments passed to the parent class.
37: (4)                 """
38: (4)                 def __init__(
39: (8)                     self,
40: (8)                     homotopy: Callable[[float, float, float, float], tuple[float, float, float]],
41: (8)                     mobject: Mobject,
42: (8)                     run_time: float = 3,
43: (8)                     apply_function_kwargs: dict[str, Any] | None = None,
44: (8)                     **kwargs,
45: (4)                 ) -> None:
46: (8)                     self.homotopy = homotopy
47: (8)                     self.apply_function_kwargs = (
48: (12)                        apply_function_kwargs if apply_function_kwargs is not None else {}
49: (8)                     )
50: (8)                     super().__init__(mobject, run_time=run_time, **kwargs)
51: (4)                 def function_at_time_t(self, t: float) -> tuple[float, float, float]:
52: (8)                     return lambda p: self.homotopy(*p, t)
53: (4)                 def interpolate_submobject(
54: (8)                     self,
55: (8)                     submobject: Mobject,
56: (8)                     starting_submobject: Mobject,
57: (8)                     alpha: float,
58: (4)                 ) -> None:
59: (8)                     submobject.points = starting_submobject.points
60: (8)                     submobject.apply_function(
61: (12)                        self.function_at_time_t(alpha), **self.apply_function_kwargs
62: (8)                     )
63: (0)             class SmoothedVectorizedHomotopy(Homotopy):
64: (4)                 def interpolate_submobject(
65: (8)                     self,
66: (8)                     submobject: Mobject,
67: (8)                     starting_submobject: Mobject,
68: (8)                     alpha: float,
69: (4)                 ) -> None:
70: (8)                     super().interpolate_submobject(submobject, starting_submobject, alpha)
71: (8)                     submobject.make_smooth()
72: (0)             class ComplexHomotopy(Homotopy):
73: (4)                 def __init__(
74: (8)                     self, complex_homotopy: Callable[[complex], float], mobject: Mobject, **kwargs
75: (4)                 ) -> None:
76: (8)                     """
77: (8)                     Complex Homotopy a function Cx[0, 1] to C
78: (8)                     """
79: (8)                     def homotopy(
80: (12)                        x: float,
81: (12)                        y: float,
82: (12)                        z: float,
83: (12)                        t: float,
84: (8)                     ) -> tuple[float, float, float]:
85: (12)                        c = complex_homotopy(complex(x, y), t)
86: (12)                        return (c.real, c.imag, z)
87: (8)                     super().__init__(homotopy, mobject, **kwargs)
88: (0)             class PhaseFlow(Animation):
89: (4)                 def __init__(
90: (8)                     self,
91: (8)                     function: Callable[[np.ndarray], np.ndarray],
92: (8)                     mobject: Mobject,
93: (8)                     virtual_time: float = 1,
94: (8)                     suspend_mobject_updating: bool = False,
95: (8)                     rate_func: Callable[[float], float] = linear,
96: (8)                     **kwargs,
97: (4)                 ) -> None:
98: (8)                     self.virtual_time = virtual_time
99: (8)                     self.function = function
100: (8)                    super().__init__(
101: (12)                       mobject,
102: (12)                       suspend_mobject_updating=suspend_mobject_updating,
103: (12)                       rate_func=rate_func,
104: (12)                       **kwargs,
105: (8)                    )
106: (4)                def interpolate_mobject(self, alpha: float) -> None:
107: (8)                    if hasattr(self, "last_alpha"):
108: (12)                       dt = self.virtual_time * (
109: (16)                           self.rate_func(alpha) - self.rate_func(self.last_alpha)
110: (12)                       )
111: (12)                       self.mobject.apply_function(lambda p: p + dt * self.function(p))
112: (8)                    self.last_alpha = alpha
113: (0)            class MoveAlongPath(Animation):
114: (4)                """Make one mobject move along the path of another mobject.
115: (4)                .. manim:: MoveAlongPathExample
116: (8)                    class MoveAlongPathExample(Scene):
117: (12)                       def construct(self):
118: (16)                           d1 = Dot().set_color(ORANGE)
119: (16)                           l1 = Line(LEFT, RIGHT)
120: (16)                           l2 = VMobject()
121: (16)                           self.add(d1, l1, l2)
122: (16)                           l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))
123: (16)                           self.play(MoveAlongPath(d1, l1), rate_func=linear)
124: (4)                """
125: (4)                def __init__(
126: (8)                    self,
127: (8)                    mobject: Mobject,
128: (8)                    path: VMobject,
129: (8)                    suspend_mobject_updating: bool | None = False,
130: (8)                    **kwargs,
131: (4)                ) -> None:
132: (8)                    self.path = path
133: (8)                    super().__init__(
134: (12)                       mobject, suspend_mobject_updating=suspend_mobject_updating, **kwargs
135: (8)                    )
136: (4)                def interpolate_mobject(self, alpha: float) -> None:
137: (8)                    point = self.path.point_from_proportion(self.rate_func(alpha))
138: (8)                    self.mobject.move_to(point)

----------------------------------------

File 12 - . \rotation.py:

1: (0)              """Animations related to rotation."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["Rotating", "Rotate"]
4: (0)              from typing import TYPE_CHECKING, Callable, Sequence
5: (0)              import numpy as np
6: (0)              from ..animation.animation import Animation
7: (0)              from ..animation.transform import Transform
8: (0)              from ..constants import OUT, PI, TAU
9: (0)              from ..utils.rate_functions import linear
10: (0)             if TYPE_CHECKING:
11: (4)                 from ..mobject.mobject import Mobject
12: (0)             class Rotating(Animation):
13: (4)                 def __init__(
14: (8)                     self,
15: (8)                     mobject: Mobject,
16: (8)                     axis: np.ndarray = OUT,
17: (8)                     radians: np.ndarray = TAU,
18: (8)                     about_point: np.ndarray | None = None,
19: (8)                     about_edge: np.ndarray | None = None,
20: (8)                     run_time: float = 5,
21: (8)                     rate_func: Callable[[float], float] = linear,
22: (8)                     **kwargs,
23: (4)                 ) -> None:
24: (8)                     self.axis = axis
25: (8)                     self.radians = radians
26: (8)                     self.about_point = about_point
27: (8)                     self.about_edge = about_edge
28: (8)                     super().__init__(mobject, run_time=run_time, rate_func=rate_func, **kwargs)
29: (4)                 def interpolate_mobject(self, alpha: float) -> None:
30: (8)                     self.mobject.become(self.starting_mobject)
31: (8)                     self.mobject.rotate(
32: (12)                        self.rate_func(alpha) * self.radians,
33: (12)                        axis=self.axis,
34: (12)                        about_point=self.about_point,
35: (12)                        about_edge=self.about_edge,
36: (8)                     )
37: (0)             class Rotate(Transform):
38: (4)                 """Animation that rotates a Mobject.
39: (4)                 Parameters
40: (4)                 ----------
41: (4)                 mobject
42: (8)                     The mobject to be rotated.
43: (4)                 angle
44: (8)                     The rotation angle.
45: (4)                 axis
46: (8)                     The rotation axis as a numpy vector.
47: (4)                 about_point
48: (8)                     The rotation center.
49: (4)                 about_edge
50: (8)                     If ``about_point`` is ``None``, this argument specifies
51: (8)                     the direction of the bounding box point to be taken as
52: (8)                     the rotation center.
53: (4)                 Examples
54: (4)                 --------
55: (4)                 .. manim:: UsingRotate
56: (8)                     class UsingRotate(Scene):
57: (12)                        def construct(self):
58: (16)                            self.play(
59: (20)                                Rotate(
60: (24)                                    Square(side_length=0.5).shift(UP * 2),
61: (24)                                    angle=2*PI,
62: (24)                                    about_point=ORIGIN,
63: (24)                                    rate_func=linear,
64: (20)                                ),
65: (20)                                Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),
66: (20)                                )
67: (4)                 """
68: (4)                 def __init__(
69: (8)                     self,
70: (8)                     mobject: Mobject,
71: (8)                     angle: float = PI,
72: (8)                     axis: np.ndarray = OUT,
73: (8)                     about_point: Sequence[float] | None = None,
74: (8)                     about_edge: Sequence[float] | None = None,
75: (8)                     **kwargs,
76: (4)                 ) -> None:
77: (8)                     if "path_arc" not in kwargs:
78: (12)                        kwargs["path_arc"] = angle
79: (8)                     if "path_arc_axis" not in kwargs:
80: (12)                        kwargs["path_arc_axis"] = axis
81: (8)                     self.angle = angle
82: (8)                     self.axis = axis
83: (8)                     self.about_edge = about_edge
84: (8)                     self.about_point = about_point
85: (8)                     if self.about_point is None:
86: (12)                        self.about_point = mobject.get_center()
87: (8)                     super().__init__(mobject, path_arc_centers=self.about_point, **kwargs)
88: (4)                 def create_target(self) -> Mobject:
89: (8)                     target = self.mobject.copy()
90: (8)                     target.rotate(
91: (12)                        self.angle,
92: (12)                        axis=self.axis,
93: (12)                        about_point=self.about_point,
94: (12)                        about_edge=self.about_edge,
95: (8)                     )
96: (8)                     return target

----------------------------------------

File 13 - .\updaters \__init__.py:

1: (0)              """Animations and utility mobjects related to update functions.
2: (0)              Modules
3: (0)              =======
4: (0)              .. autosummary::
5: (4)                  :toctree: ../reference
6: (4)                  ~mobject_update_utils
7: (4)                  ~update
8: (0)              """

----------------------------------------

File 14 - . \transform.py:

1: (0)              """Animations transforming one mobject into another."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "Transform",
5: (4)                  "ReplacementTransform",
6: (4)                  "TransformFromCopy",
7: (4)                  "ClockwiseTransform",
8: (4)                  "CounterclockwiseTransform",
9: (4)                  "MoveToTarget",
10: (4)                 "ApplyMethod",
11: (4)                 "ApplyPointwiseFunction",
12: (4)                 "ApplyPointwiseFunctionToCenter",
13: (4)                 "FadeToColor",
14: (4)                 "FadeTransform",
15: (4)                 "FadeTransformPieces",
16: (4)                 "ScaleInPlace",
17: (4)                 "ShrinkToCenter",
18: (4)                 "Restore",
19: (4)                 "ApplyFunction",
20: (4)                 "ApplyMatrix",
21: (4)                 "ApplyComplexFunction",
22: (4)                 "CyclicReplace",
23: (4)                 "Swap",
24: (4)                 "TransformAnimations",
25: (0)             ]
26: (0)             import inspect
27: (0)             import types
28: (0)             from typing import TYPE_CHECKING, Any, Callable, Iterable, Sequence
29: (0)             import numpy as np
30: (0)             from manim.mobject.opengl.opengl_mobject import OpenGLGroup, OpenGLMobject
31: (0)             from .. import config
32: (0)             from ..animation.animation import Animation
33: (0)             from ..constants import (
34: (4)                 DEFAULT_POINTWISE_FUNCTION_RUN_TIME,
35: (4)                 DEGREES,
36: (4)                 ORIGIN,
37: (4)                 OUT,
38: (4)                 RendererType,
39: (0)             )
40: (0)             from ..mobject.mobject import Group, Mobject
41: (0)             from ..utils.paths import path_along_arc, path_along_circles
42: (0)             from ..utils.rate_functions import smooth, squish_rate_func
43: (0)             if TYPE_CHECKING:
44: (4)                 from ..scene.scene import Scene
45: (0)             class Transform(Animation):
46: (4)                 """A Transform transforms a Mobject into a target Mobject.
47: (4)                 Parameters
48: (4)                 ----------
49: (4)                 mobject
50: (8)                     The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``.
51: (4)                 target_mobject
52: (8)                     The target of the transformation.
53: (4)                 path_func
54: (8)                     A function defining the path that the points of the ``mobject`` are being moved
55: (8)                     along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`.
56: (4)                 path_arc
57: (8)                     The arc angle (in radians) that the points of ``mobject`` will follow to reach
58: (8)                     the points of the target if using a circular path arc, see ``path_arc_centers``.
59: (8)                     See also :func:`manim.utils.paths.path_along_arc`.
60: (4)                 path_arc_axis
61: (8)                     The axis to rotate along if using a circular path arc, see ``path_arc_centers``.
62: (4)                 path_arc_centers
63: (8)                     The center of the circular arcs along which the points of ``mobject`` are
64: (8)                     moved by the transformation.
65: (8)                     If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated
66: (8)                     using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the
67: (8)                     other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it.
68: (4)                 replace_mobject_with_target_in_scene
69: (8)                     Controls which mobject is replaced when the transformation is complete.
70: (8)                     If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will
71: (8)                     replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.
72: (4)                 Examples
73: (4)                 --------
74: (4)                 .. manim :: TransformPathArc
75: (8)                     class TransformPathArc(Scene):
76: (12)                        def construct(self):
77: (16)                            def make_arc_path(start, end, arc_angle):
78: (20)                                points = []
79: (20)                                p_fn = path_along_arc(arc_angle)
80: (20)                                # alpha animates between 0.0 and 1.0, where 0.0
81: (20)                                # is the beginning of the animation and 1.0 is the end.
82: (20)                                for alpha in range(0, 11):
83: (24)                                    points.append(p_fn(start, end, alpha / 10.0))
84: (20)                                path = VMobject(stroke_color=YELLOW)
85: (20)                                path.set_points_smoothly(points)
86: (20)                                return path
87: (16)                            left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)
88: (16)                            colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]
89: (16)                            # Positive angles move counter-clockwise, negative angles move clockwise.
90: (16)                            examples = [-90, 0, 30, 90, 180, 270]
91: (16)                            anims = []
92: (16)                            for idx, angle in enumerate(examples):
93: (20)                                left_c = left.copy().shift((3 - idx) * UP)
94: (20)                                left_c.fill_color = colors[idx]
95: (20)                                right_c = left_c.copy().shift(4 * RIGHT)
96: (20)                                path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),
97: (45)                                                         arc_angle=angle * DEGREES)
98: (20)                                desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)
99: (20)                                # Make the circles in front of the text in front of the arcs.
100: (20)                               self.add(
101: (24)                                   path_arc.set_z_index(1),
102: (24)                                   desc.set_z_index(2),
103: (24)                                   left_c.set_z_index(3),
104: (20)                               )
105: (20)                               anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))
106: (16)                           self.play(*anims, run_time=2)
107: (16)                           self.wait()
108: (4)                """
109: (4)                def __init__(
110: (8)                    self,
111: (8)                    mobject: Mobject | None,
112: (8)                    target_mobject: Mobject | None = None,
113: (8)                    path_func: Callable | None = None,
114: (8)                    path_arc: float = 0,
115: (8)                    path_arc_axis: np.ndarray = OUT,
116: (8)                    path_arc_centers: np.ndarray = None,
117: (8)                    replace_mobject_with_target_in_scene: bool = False,
118: (8)                    **kwargs,
119: (4)                ) -> None:
120: (8)                    self.path_arc_axis: np.ndarray = path_arc_axis
121: (8)                    self.path_arc_centers: np.ndarray = path_arc_centers
122: (8)                    self.path_arc: float = path_arc
123: (8)                    # path_func is a property a few lines below so it doesn't need to be set in any case
124: (8)                    if path_func is not None:
125: (12)                       self.path_func: Callable = path_func
126: (8)                    elif self.path_arc_centers is not None:
127: (12)                       self.path_func = path_along_circles(
128: (16)                           path_arc,
129: (16)                           self.path_arc_centers,
130: (16)                           self.path_arc_axis,
131: (12)                       )
132: (8)                    self.replace_mobject_with_target_in_scene: bool = (
133: (12)                       replace_mobject_with_target_in_scene
134: (8)                    )
135: (8)                    self.target_mobject: Mobject = (
136: (12)                       target_mobject if target_mobject is not None else Mobject()
137: (8)                    )
138: (8)                    super().__init__(mobject, **kwargs)
139: (4)                @property
140: (4)                def path_arc(self) -> float:
141: (8)                    return self._path_arc
142: (4)                @path_arc.setter
143: (4)                def path_arc(self, path_arc: float) -> None:
144: (8)                    self._path_arc = path_arc
145: (8)                    self._path_func = path_along_arc(
146: (12)                       arc_angle=self._path_arc,
147: (12)                       axis=self.path_arc_axis,
148: (8)                    )
149: (4)                @property
150: (4)                def path_func(
151: (8)                    self,
152: (4)                ) -> Callable[
153: (8)                    [Iterable[np.ndarray], Iterable[np.ndarray], float],
154: (8)                    Iterable[np.ndarray],
155: (4)                ]:
156: (8)                    return self._path_func
157: (4)                @path_func.setter
158: (4)                def path_func(
159: (8)                    self,
160: (8)                    path_func: Callable[
161: (12)                       [Iterable[np.ndarray], Iterable[np.ndarray], float],
162: (12)                       Iterable[np.ndarray],
163: (8)                    ],
164: (4)                ) -> None:
165: (8)                    if path_func is not None:
166: (12)                       self._path_func = path_func
167: (4)                def begin(self) -> None:
168: (8)                    # Use a copy of target_mobject for the align_data
169: (8)                    # call so that the actual target_mobject stays
170: (8)                    # preserved.
171: (8)                    self.target_mobject = self.create_target()
172: (8)                    self.target_copy = self.target_mobject.copy()
173: (8)                    # Note, this potentially changes the structure
174: (8)                    # of both mobject and target_mobject
175: (8)                    if config.renderer == RendererType.OPENGL:
176: (12)                       self.mobject.align_data_and_family(self.target_copy)
177: (8)                    else:
178: (12)                       self.mobject.align_data(self.target_copy)
179: (8)                    super().begin()
180: (4)                def create_target(self) -> Mobject:
181: (8)                    # Has no meaningful effect here, but may be useful
182: (8)                    # in subclasses
183: (8)                    return self.target_mobject
184: (4)                def clean_up_from_scene(self, scene: Scene) -> None:
185: (8)                    super().clean_up_from_scene(scene)
186: (8)                    if self.replace_mobject_with_target_in_scene:
187: (12)                       scene.replace(self.mobject, self.target_mobject)
188: (4)                def get_all_mobjects(self) -> Sequence[Mobject]:
189: (8)                    return [
190: (12)                       self.mobject,
191: (12)                       self.starting_mobject,
192: (12)                       self.target_mobject,
193: (12)                       self.target_copy,
194: (8)                    ]
195: (4)                def get_all_families_zipped(self) -> Iterable[tuple]:  # more precise typing?
196: (8)                    mobs = [
197: (12)                       self.mobject,
198: (12)                       self.starting_mobject,
199: (12)                       self.target_copy,
200: (8)                    ]
201: (8)                    if config.renderer == RendererType.OPENGL:
202: (12)                       return zip(*(mob.get_family() for mob in mobs))
203: (8)                    return zip(*(mob.family_members_with_points() for mob in mobs))
204: (4)                def interpolate_submobject(
205: (8)                    self,
206: (8)                    submobject: Mobject,
207: (8)                    starting_submobject: Mobject,
208: (8)                    target_copy: Mobject,
209: (8)                    alpha: float,
210: (4)                ) -> Transform:
211: (8)                    submobject.interpolate(starting_submobject, target_copy, alpha, self.path_func)
212: (8)                    return self
213: (0)            class ReplacementTransform(Transform):
214: (4)                """Replaces and morphs a mobject into a target mobject.
215: (4)                Parameters
216: (4)                ----------
217: (4)                mobject
218: (8)                    The starting :class:`~.Mobject`.
219: (4)                target_mobject
220: (8)                    The target :class:`~.Mobject`.
221: (4)                kwargs
222: (8)                    Further keyword arguments that are passed to :class:`Transform`.
223: (4)                Examples
224: (4)                --------
225: (4)                .. manim:: ReplacementTransformOrTransform
226: (8)                    :quality: low
227: (8)                    class ReplacementTransformOrTransform(Scene):
228: (12)                       def construct(self):
229: (16)                           # set up the numbers
230: (16)                           r_transform = VGroup(*[Integer(i) for i in range(1,4)])
231: (16)                           text_1 = Text("ReplacementTransform", color=RED)
232: (16)                           r_transform.add(text_1)
233: (16)                           transform = VGroup(*[Integer(i) for i in range(4,7)])
234: (16)                           text_2 = Text("Transform", color=BLUE)
235: (16)                           transform.add(text_2)
236: (16)                           ints = VGroup(r_transform, transform)
237: (16)                           texts = VGroup(text_1, text_2).scale(0.75)
238: (16)                           r_transform.arrange(direction=UP, buff=1)
239: (16)                           transform.arrange(direction=UP, buff=1)
240: (16)                           ints.arrange(buff=2)
241: (16)                           self.add(ints, texts)
242: (16)                           # The mobs replace each other and none are left behind
243: (16)                           self.play(ReplacementTransform(r_transform[0], r_transform[1]))
244: (16)                           self.play(ReplacementTransform(r_transform[1], r_transform[2]))
245: (16)                           # The mobs linger after the Transform()
246: (16)                           self.play(Transform(transform[0], transform[1]))
247: (16)                           self.play(Transform(transform[1], transform[2]))
248: (16)                           self.wait()
249: (4)                """
250: (4)                def __init__(self, mobject: Mobject, target_mobject: Mobject, **kwargs) -> None:
251: (8)                    super().__init__(
252: (12)                       mobject, target_mobject, replace_mobject_with_target_in_scene=True, **kwargs
253: (8)                    )
254: (0)            class TransformFromCopy(Transform):
255: (4)                """
256: (4)                Performs a reversed Transform
257: (4)                """
258: (4)                def __init__(self, mobject: Mobject, target_mobject: Mobject, **kwargs) -> None:
259: (8)                    super().__init__(target_mobject, mobject, **kwargs)
260: (4)                def interpolate(self, alpha: float) -> None:
261: (8)                    super().interpolate(1 - alpha)
262: (0)            class ClockwiseTransform(Transform):
263: (4)                """Transforms the points of a mobject along a clockwise oriented arc.
264: (4)                See also
265: (4)                --------
266: (4)                :class:`.Transform`, :class:`.CounterclockwiseTransform`
267: (4)                Examples
268: (4)                --------
269: (4)                .. manim:: ClockwiseExample
270: (8)                    class ClockwiseExample(Scene):
271: (12)                       def construct(self):
272: (16)                           dl, dr = Dot(), Dot()
273: (16)                           sl, sr = Square(), Square()
274: (16)                           VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)
275: (16)                           VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)
276: (16)                           self.add(dl, dr)
277: (16)                           self.wait()
278: (16)                           self.play(
279: (20)                               ClockwiseTransform(dl, sl),
280: (20)                               Transform(dr, sr)
281: (16)                           )
282: (16)                           self.wait()
283: (4)                """
284: (4)                def __init__(
285: (8)                    self,
286: (8)                    mobject: Mobject,
287: (8)                    target_mobject: Mobject,
288: (8)                    path_arc: float = -np.pi,
289: (8)                    **kwargs,
290: (4)                ) -> None:
291: (8)                    super().__init__(mobject, target_mobject, path_arc=path_arc, **kwargs)
292: (0)            class CounterclockwiseTransform(Transform):
293: (4)                """Transforms the points of a mobject along a counterclockwise oriented arc.
294: (4)                See also
295: (4)                --------
296: (4)                :class:`.Transform`, :class:`.ClockwiseTransform`
297: (4)                Examples
298: (4)                --------
299: (4)                .. manim:: CounterclockwiseTransform_vs_Transform
300: (8)                    class CounterclockwiseTransform_vs_Transform(Scene):
301: (12)                       def construct(self):
302: (16)                           # set up the numbers
303: (16)                           c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))
304: (16)                           text_1 = Text("CounterclockwiseTransform", color=RED)
305: (16)                           c_transform.add(text_1)
306: (16)                           transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))
307: (16)                           text_2 = Text("Transform", color=BLUE)
308: (16)                           transform.add(text_2)
309: (16)                           ints = VGroup(c_transform, transform)
310: (16)                           texts = VGroup(text_1, text_2).scale(0.75)
311: (16)                           c_transform.arrange(direction=UP, buff=1)
312: (16)                           transform.arrange(direction=UP, buff=1)
313: (16)                           ints.arrange(buff=2)
314: (16)                           self.add(ints, texts)
315: (16)                           # The mobs move in clockwise direction for ClockwiseTransform()
316: (16)                           self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))
317: (16)                           # The mobs move straight up for Transform()
318: (16)                           self.play(Transform(transform[0], transform[1]))
319: (4)                """
320: (4)                def __init__(
321: (8)                    self,
322: (8)                    mobject: Mobject,
323: (8)                    target_mobject: Mobject,
324: (8)                    path_arc: float = np.pi,
325: (8)                    **kwargs,
326: (4)                ) -> None:
327: (8)                    super().__init__(mobject, target_mobject, path_arc=path_arc, **kwargs)
328: (0)            class MoveToTarget(Transform):
329: (4)                """Transforms a mobject to the mobject stored in its ``target`` attribute.
330: (4)                After calling the :meth:`~.Mobject.generate_target` method, the :attr:`target`
331: (4)                attribute of the mobject is populated with a copy of it. After modifying the attribute,
332: (4)                playing the :class:`.MoveToTarget` animation transforms the original mobject
333: (4)                into the modified one stored in the :attr:`target` attribute.
334: (4)                Examples
335: (4)                --------
336: (4)                .. manim:: MoveToTargetExample
337: (8)                    class MoveToTargetExample(Scene):
338: (12)                       def construct(self):
339: (16)                           c = Circle()
340: (16)                           c.generate_target()
341: (16)                           c.target.set_fill(color=GREEN, opacity=0.5)
342: (16)                           c.target.shift(2*RIGHT + UP).scale(0.5)
343: (16)                           self.add(c)
344: (16)                           self.play(MoveToTarget(c))
345: (4)                """
346: (4)                def __init__(self, mobject: Mobject, **kwargs) -> None:
347: (8)                    self.check_validity_of_input(mobject)
348: (8)                    super().__init__(mobject, mobject.target, **kwargs)
349: (4)                def check_validity_of_input(self, mobject: Mobject) -> None:
350: (8)                    if not hasattr(mobject, "target"):
351: (12)                       raise ValueError(
352: (16)                           "MoveToTarget called on mobject" "without attribute 'target'",
353: (12)                       )
354: (0)            class _MethodAnimation(MoveToTarget):
355: (4)                def __init__(self, mobject, methods):
356: (8)                    self.methods = methods
357: (8)                    super().__init__(mobject)
358: (4)                def finish(self) -> None:
359: (8)                    for method, method_args, method_kwargs in self.methods:
360: (12)                       method.__func__(self.mobject, *method_args, **method_kwargs)
361: (8)                    super().finish()
362: (0)            class ApplyMethod(Transform):
363: (4)                """Animates a mobject by applying a method.
364: (4)                Note that only the method needs to be passed to this animation,
365: (4)                it is not required to pass the corresponding mobject. Furthermore,
366: (4)                this animation class only works if the method returns the modified
367: (4)                mobject.
368: (4)                Parameters
369: (4)                ----------
370: (4)                method
371: (8)                    The method that will be applied in the animation.
372: (4)                args
373: (8)                    Any positional arguments to be passed when applying the method.
374: (4)                kwargs
375: (8)                    Any keyword arguments passed to :class:`~.Transform`.
376: (4)                """
377: (4)                def __init__(
378: (8)                    self, method: Callable, *args, **kwargs
379: (4)                ) -> None:  # method typing (we want to specify Mobject method)? for args?
380: (8)                    self.check_validity_of_input(method)
381: (8)                    self.method = method
382: (8)                    self.method_args = args
383: (8)                    super().__init__(method.__self__, **kwargs)
384: (4)                def check_validity_of_input(self, method: Callable) -> None:
385: (8)                    if not inspect.ismethod(method):
386: (12)                       raise ValueError(
387: (16)                           "Whoops, looks like you accidentally invoked "
388: (16)                           "the method you want to animate",
389: (12)                       )
390: (8)                    assert isinstance(method.__self__, (Mobject, OpenGLMobject))
391: (4)                def create_target(self) -> Mobject:
392: (8)                    method = self.method
393: (8)                    # Make sure it's a list so that args.pop() works
394: (8)                    args = list(self.method_args)
395: (8)                    if len(args) > 0 and isinstance(args[-1], dict):
396: (12)                       method_kwargs = args.pop()
397: (8)                    else:
398: (12)                       method_kwargs = {}
399: (8)                    target = method.__self__.copy()
400: (8)                    method.__func__(target, *args, **method_kwargs)
401: (8)                    return target
402: (0)            class ApplyPointwiseFunction(ApplyMethod):
403: (4)                """Animation that applies a pointwise function to a mobject.
404: (4)                Examples
405: (4)                --------
406: (4)                .. manim:: WarpSquare
407: (8)                    :quality: low
408: (8)                    class WarpSquare(Scene):
409: (12)                       def construct(self):
410: (16)                           square = Square()
411: (16)                           self.play(
412: (20)                               ApplyPointwiseFunction(
413: (24)                                   lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square
414: (20)                               )
415: (16)                           )
416: (16)                           self.wait()
417: (4)                """
418: (4)                def __init__(
419: (8)                    self,
420: (8)                    function: types.MethodType,
421: (8)                    mobject: Mobject,
422: (8)                    run_time: float = DEFAULT_POINTWISE_FUNCTION_RUN_TIME,
423: (8)                    **kwargs,
424: (4)                ) -> None:
425: (8)                    super().__init__(mobject.apply_function, function, run_time=run_time, **kwargs)
426: (0)            class ApplyPointwiseFunctionToCenter(ApplyPointwiseFunction):
427: (4)                def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -> None:
428: (8)                    self.function = function
429: (8)                    super().__init__(mobject.move_to, **kwargs)
430: (4)                def begin(self) -> None:
431: (8)                    self.method_args = [self.function(self.mobject.get_center())]
432: (8)                    super().begin()
433: (0)            class FadeToColor(ApplyMethod):
434: (4)                """Animation that changes color of a mobject.
435: (4)                Examples
436: (4)                --------
437: (4)                .. manim:: FadeToColorExample
438: (8)                    class FadeToColorExample(Scene):
439: (12)                       def construct(self):
440: (16)                           self.play(FadeToColor(Text("Hello World!"), color=RED))
441: (4)                """
442: (4)                def __init__(self, mobject: Mobject, color: str, **kwargs) -> None:
443: (8)                    super().__init__(mobject.set_color, color, **kwargs)
444: (0)            class ScaleInPlace(ApplyMethod):
445: (4)                """Animation that scales a mobject by a certain factor.
446: (4)                Examples
447: (4)                --------
448: (4)                .. manim:: ScaleInPlaceExample
449: (8)                    class ScaleInPlaceExample(Scene):
450: (12)                       def construct(self):
451: (16)                           self.play(ScaleInPlace(Text("Hello World!"), 2))
452: (4)                """
453: (4)                def __init__(self, mobject: Mobject, scale_factor: float, **kwargs) -> None:
454: (8)                    super().__init__(mobject.scale, scale_factor, **kwargs)
455: (0)            class ShrinkToCenter(ScaleInPlace):
456: (4)                """Animation that makes a mobject shrink to center.
457: (4)                Examples
458: (4)                --------
459: (4)                .. manim:: ShrinkToCenterExample
460: (8)                    class ShrinkToCenterExample(Scene):
461: (12)                       def construct(self):
462: (16)                           self.play(ShrinkToCenter(Text("Hello World!")))
463: (4)                """
464: (4)                def __init__(self, mobject: Mobject, **kwargs) -> None:
465: (8)                    super().__init__(mobject, 0, **kwargs)
466: (0)            class Restore(ApplyMethod):
467: (4)                """Transforms a mobject to its last saved state.
468: (4)                To save the state of a mobject, use the :meth:`~.Mobject.save_state` method.
469: (4)                Examples
470: (4)                --------
471: (4)                .. manim:: RestoreExample
472: (8)                    class RestoreExample(Scene):
473: (12)                       def construct(self):
474: (16)                           s = Square()
475: (16)                           s.save_state()
476: (16)                           self.play(FadeIn(s))
477: (16)                           self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))
478: (16)                           self.play(s.animate.shift(5*DOWN).rotate(PI/4))
479: (16)                           self.wait()
480: (16)                           self.play(Restore(s), run_time=2)
481: (4)                """
482: (4)                def __init__(self, mobject: Mobject, **kwargs) -> None:
483: (8)                    super().__init__(mobject.restore, **kwargs)
484: (0)            class ApplyFunction(Transform):
485: (4)                def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -> None:
486: (8)                    self.function = function
487: (8)                    super().__init__(mobject, **kwargs)
488: (4)                def create_target(self) -> Any:
489: (8)                    target = self.function(self.mobject.copy())
490: (8)                    if not isinstance(target, (Mobject, OpenGLMobject)):
491: (12)                       raise TypeError(
492: (16)                           "Functions passed to ApplyFunction must return object of type Mobject",
493: (12)                       )
494: (8)                    return target
495: (0)            class ApplyMatrix(ApplyPointwiseFunction):
496: (4)                """Applies a matrix transform to an mobject.
497: (4)                Parameters
498: (4)                ----------
499: (4)                matrix
500: (8)                    The transformation matrix.
501: (4)                mobject
502: (8)                    The :class:`~.Mobject`.
503: (4)                about_point
504: (8)                    The origin point for the transform. Defaults to ``ORIGIN``.
505: (4)                kwargs
506: (8)                    Further keyword arguments that are passed to :class:`ApplyPointwiseFunction`.
507: (4)                Examples
508: (4)                --------
509: (4)                .. manim:: ApplyMatrixExample
510: (8)                    class ApplyMatrixExample(Scene):
511: (12)                       def construct(self):
512: (16)                           matrix = [[1, 1], [0, 2/3]]
513: (16)                           self.play(ApplyMatrix(matrix, Text("Hello World!")), ApplyMatrix(matrix, NumberPlane()))
514: (4)                """
515: (4)                def __init__(
516: (8)                    self,
517: (8)                    matrix: np.ndarray,
518: (8)                    mobject: Mobject,
519: (8)                    about_point: np.ndarray = ORIGIN,
520: (8)                    **kwargs,
521: (4)                ) -> None:
522: (8)                    matrix = self.initialize_matrix(matrix)
523: (8)                    def func(p):
524: (12)                       return np.dot(p - about_point, matrix.T) + about_point
525: (8)                    super().__init__(func, mobject, **kwargs)
526: (4)                def initialize_matrix(self, matrix: np.ndarray) -> np.ndarray:
527: (8)                    matrix = np.array(matrix)
528: (8)                    if matrix.shape == (2, 2):
529: (12)                       new_matrix = np.identity(3)
530: (12)                       new_matrix[:2, :2] = matrix
531: (12)                       matrix = new_matrix
532: (8)                    elif matrix.shape != (3, 3):
533: (12)                       raise ValueError("Matrix has bad dimensions")
534: (8)                    return matrix
535: (0)            class ApplyComplexFunction(ApplyMethod):
536: (4)                def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -> None:
537: (8)                    self.function = function
538: (8)                    method = mobject.apply_complex_function
539: (8)                    super().__init__(method, function, **kwargs)
540: (4)                def _init_path_func(self) -> None:
541: (8)                    func1 = self.function(complex(1))
542: (8)                    self.path_arc = np.log(func1).imag
543: (8)                    super()._init_path_func()
544: (0)            ###
545: (0)            class CyclicReplace(Transform):
546: (4)                """An animation moving mobjects cyclically.
547: (4)                In particular, this means: the first mobject takes the place
548: (4)                of the second mobject, the second one takes the place of
549: (4)                the third mobject, and so on. The last mobject takes the
550: (4)                place of the first one.
551: (4)                Parameters
552: (4)                ----------
553: (4)                mobjects
554: (8)                    List of mobjects to be transformed.
555: (4)                path_arc
556: (8)                    The angle of the arc (in radians) that the mobjects will follow to reach
557: (8)                    their target.
558: (4)                kwargs
559: (8)                    Further keyword arguments that are passed to :class:`.Transform`.
560: (4)                Examples
561: (4)                --------
562: (4)                .. manim :: CyclicReplaceExample
563: (8)                    class CyclicReplaceExample(Scene):
564: (12)                       def construct(self):
565: (16)                           group = VGroup(Square(), Circle(), Triangle(), Star())
566: (16)                           group.arrange(RIGHT)
567: (16)                           self.add(group)
568: (16)                           for _ in range(4):
569: (20)                               self.play(CyclicReplace(*group))
570: (4)                """
571: (4)                def __init__(
572: (8)                    self, *mobjects: Mobject, path_arc: float = 90 * DEGREES, **kwargs
573: (4)                ) -> None:
574: (8)                    self.group = Group(*mobjects)
575: (8)                    super().__init__(self.group, path_arc=path_arc, **kwargs)
576: (4)                def create_target(self) -> Group:
577: (8)                    target = self.group.copy()
578: (8)                    cycled_targets = [target[-1], *target[:-1]]
579: (8)                    for m1, m2 in zip(cycled_targets, self.group):
580: (12)                       m1.move_to(m2)
581: (8)                    return target
582: (0)            class Swap(CyclicReplace):
583: (4)                pass  # Renaming, more understandable for two entries
584: (0)            # TODO, this may be deprecated...worth reimplementing?
585: (0)            class TransformAnimations(Transform):
586: (4)                def __init__(
587: (8)                    self,
588: (8)                    start_anim: Animation,
589: (8)                    end_anim: Animation,
590: (8)                    rate_func: Callable = squish_rate_func(smooth),
591: (8)                    **kwargs,
592: (4)                ) -> None:
593: (8)                    self.start_anim = start_anim
594: (8)                    self.end_anim = end_anim
595: (8)                    if "run_time" in kwargs:
596: (12)                       self.run_time = kwargs.pop("run_time")
597: (8)                    else:
598: (12)                       self.run_time = max(start_anim.run_time, end_anim.run_time)
599: (8)                    for anim in start_anim, end_anim:
600: (12)                       anim.set_run_time(self.run_time)
601: (8)                    if (
602: (12)                       start_anim.starting_mobject is not None
603: (12)                       and end_anim.starting_mobject is not None
604: (12)                       and start_anim.starting_mobject.get_num_points()
605: (12)                       != end_anim.starting_mobject.get_num_points()
606: (8)                    ):
607: (12)                       start_anim.starting_mobject.align_data(end_anim.starting_mobject)
608: (12)                       for anim in start_anim, end_anim:
609: (16)                           if isinstance(anim, Transform) and anim.starting_mobject is not None:
610: (20)                               anim.starting_mobject.align_data(anim.target_mobject)
611: (8)                    super().__init__(
612: (12)                       start_anim.mobject, end_anim.mobject, rate_func=rate_func, **kwargs
613: (8)                    )
614: (8)                    # Rewire starting and ending mobjects
615: (8)                    start_anim.mobject = self.starting_mobject
616: (8)                    end_anim.mobject = self.target_mobject
617: (4)                def interpolate(self, alpha: float) -> None:
618: (8)                    self.start_anim.interpolate(alpha)
619: (8)                    self.end_anim.interpolate(alpha)
620: (8)                    super().interpolate(alpha)
621: (0)            class FadeTransform(Transform):
622: (4)                """Fades one mobject into another.
623: (4)                Parameters
624: (4)                ----------
625: (4)                mobject
626: (8)                    The starting :class:`~.Mobject`.
627: (4)                target_mobject
628: (8)                    The target :class:`~.Mobject`.
629: (4)                stretch
630: (8)                    Controls whether the target :class:`~.Mobject` is stretched during
631: (8)                    the animation. Default: ``True``.
632: (4)                dim_to_match
633: (8)                    If the target mobject is not stretched automatically, this allows
634: (8)                    to adjust the initial scale of the target :class:`~.Mobject` while
635: (8)                    it is shifted in. Setting this to 0, 1, and 2, respectively,
636: (8)                    matches the length of the target with the length of the starting
637: (8)                    :class:`~.Mobject` in x, y, and z direction, respectively.
638: (4)                kwargs
639: (8)                    Further keyword arguments are passed to the parent class.
640: (4)                Examples
641: (4)                --------
642: (4)                .. manim:: DifferentFadeTransforms
643: (8)                    class DifferentFadeTransforms(Scene):
644: (12)                       def construct(self):
645: (16)                           starts = [Rectangle(width=4, height=1) for _ in range(3)]
646: (16)                           VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)
647: (16)                           targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]
648: (16)                           VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)
649: (16)                           self.play(*[FadeIn(s) for s in starts])
650: (16)                           self.play(
651: (20)                               FadeTransform(starts[0], targets[0], stretch=True),
652: (20)                               FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),
653: (20)                               FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)
654: (16)                           )
655: (16)                           self.play(*[FadeOut(mobj) for mobj in self.mobjects])
656: (4)                """
657: (4)                def __init__(self, mobject, target_mobject, stretch=True, dim_to_match=1, **kwargs):
658: (8)                    self.to_add_on_completion = target_mobject
659: (8)                    self.stretch = stretch
660: (8)                    self.dim_to_match = dim_to_match
661: (8)                    mobject.save_state()
662: (8)                    if config.renderer == RendererType.OPENGL:
663: (12)                       group = OpenGLGroup(mobject, target_mobject.copy())
664: (8)                    else:
665: (12)                       group = Group(mobject, target_mobject.copy())
666: (8)                    super().__init__(group, **kwargs)
667: (4)                def begin(self):
668: (8)                    """Initial setup for the animation.
669: (8)                    The mobject to which this animation is bound is a group consisting of
670: (8)                    both the starting and the ending mobject. At the start, the ending
671: (8)                    mobject replaces the starting mobject (and is completely faded). In the
672: (8)                    end, it is set to be the other way around.
673: (8)                    """
674: (8)                    self.ending_mobject = self.mobject.copy()
675: (8)                    Animation.begin(self)
676: (8)                    # Both 'start' and 'end' consists of the source and target mobjects.
677: (8)                    # At the start, the target should be faded replacing the source,
678: (8)                    # and at the end it should be the other way around.
679: (8)                    start, end = self.starting_mobject, self.ending_mobject
680: (8)                    for m0, m1 in ((start[1], start[0]), (end[0], end[1])):
681: (12)                       self.ghost_to(m0, m1)
682: (4)                def ghost_to(self, source, target):
683: (8)                    """Replaces the source by the target and sets the opacity to 0.
684: (8)                    If the provided target has no points, and thus a location of [0, 0, 0]
685: (8)                    the source will simply fade out where it currently is.
686: (8)                    """
687: (8)                    # mobject.replace() does not work if the target has no points.
688: (8)                    if target.get_num_points() or target.submobjects:
689: (12)                       source.replace(target, stretch=self.stretch, dim_to_match=self.dim_to_match)
690: (8)                    source.set_opacity(0)
691: (4)                def get_all_mobjects(self) -> Sequence[Mobject]:
692: (8)                    return [
693: (12)                       self.mobject,
694: (12)                       self.starting_mobject,
695: (12)                       self.ending_mobject,
696: (8)                    ]
697: (4)                def get_all_families_zipped(self):
698: (8)                    return Animation.get_all_families_zipped(self)
699: (4)                def clean_up_from_scene(self, scene):
700: (8)                    Animation.clean_up_from_scene(self, scene)
701: (8)                    scene.remove(self.mobject)
702: (8)                    self.mobject[0].restore()
703: (8)                    scene.add(self.to_add_on_completion)
704: (0)            class FadeTransformPieces(FadeTransform):
705: (4)                """Fades submobjects of one mobject into submobjects of another one.
706: (4)                See also
707: (4)                --------
708: (4)                :class:`~.FadeTransform`
709: (4)                Examples
710: (4)                --------
711: (4)                .. manim:: FadeTransformSubmobjects
712: (8)                    class FadeTransformSubmobjects(Scene):
713: (12)                       def construct(self):
714: (16)                           src = VGroup(Square(), Circle().shift(LEFT + UP))
715: (16)                           src.shift(3*LEFT + 2*UP)
716: (16)                           src_copy = src.copy().shift(4*DOWN)
717: (16)                           target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))
718: (16)                           target.shift(3*RIGHT + 2*UP)
719: (16)                           target_copy = target.copy().shift(4*DOWN)
720: (16)                           self.play(FadeIn(src), FadeIn(src_copy))
721: (16)                           self.play(
722: (20)                               FadeTransform(src, target),
723: (20)                               FadeTransformPieces(src_copy, target_copy)
724: (16)                           )
725: (16)                           self.play(*[FadeOut(mobj) for mobj in self.mobjects])
726: (4)                """
727: (4)                def begin(self):
728: (8)                    self.mobject[0].align_submobjects(self.mobject[1])
729: (8)                    super().begin()
730: (4)                def ghost_to(self, source, target):
731: (8)                    """Replaces the source submobjects by the target submobjects and sets
732: (8)                    the opacity to 0.
733: (8)                    """
734: (8)                    for sm0, sm1 in zip(source.get_family(), target.get_family()):
735: (12)                       super().ghost_to(sm0, sm1)

----------------------------------------

File 15 - . \specialized.py:

1: (0)              from __future__ import annotations
2: (0)              __all__ = ["Broadcast"]
3: (0)              from typing import Any, Sequence
4: (0)              from manim.animation.transform import Restore
5: (0)              from ..constants import *
6: (0)              from .composition import LaggedStart
7: (0)              class Broadcast(LaggedStart):
8: (4)                  """Broadcast a mobject starting from an ``initial_width``, up to the actual size of the mobject.
9: (4)                  Parameters
10: (4)                 ----------
11: (4)                 mobject
12: (8)                     The mobject to be broadcast.
13: (4)                 focal_point
14: (8)                     The center of the broadcast, by default ORIGIN.
15: (4)                 n_mobs
16: (8)                     The number of mobjects that emerge from the focal point, by default 5.
17: (4)                 initial_opacity
18: (8)                     The starting stroke opacity of the mobjects emitted from the broadcast, by default 1.
19: (4)                 final_opacity
20: (8)                     The final stroke opacity of the mobjects emitted from the broadcast, by default 0.
21: (4)                 initial_width
22: (8)                     The initial width of the mobjects, by default 0.0.
23: (4)                 remover
24: (8)                     Whether the mobjects should be removed from the scene after the animation, by default True.
25: (4)                 lag_ratio
26: (8)                     The time between each iteration of the mobject, by default 0.2.
27: (4)                 run_time
28: (8)                     The total duration of the animation, by default 3.
29: (4)                 kwargs
30: (8)                     Additional arguments to be passed to :class:`~.LaggedStart`.
31: (4)                 Examples
32: (4)                 ---------
33: (4)                 .. manim:: BroadcastExample
34: (8)                     class BroadcastExample(Scene):
35: (12)                        def construct(self):
36: (16)                            mob = Circle(radius=4, color=TEAL_A)
37: (16)                            self.play(Broadcast(mob))
38: (4)                 """
39: (4)                 def __init__(
40: (8)                     self,
41: (8)                     mobject,
42: (8)                     focal_point: Sequence[float] = ORIGIN,
43: (8)                     n_mobs: int = 5,
44: (8)                     initial_opacity: float = 1,
45: (8)                     final_opacity: float = 0,
46: (8)                     initial_width: float = 0.0,
47: (8)                     remover: bool = True,
48: (8)                     lag_ratio: float = 0.2,
49: (8)                     run_time: float = 3,
50: (8)                     **kwargs: Any,
51: (4)                 ):
52: (8)                     self.focal_point = focal_point
53: (8)                     self.n_mobs = n_mobs
54: (8)                     self.initial_opacity = initial_opacity
55: (8)                     self.final_opacity = final_opacity
56: (8)                     self.initial_width = initial_width
57: (8)                     anims = []
58: (8)                     # Works by saving the mob that is passed into the animation, scaling it to 0 (or the initial_width) and then restoring the original mob.
59: (8)                     if mobject.fill_opacity:
60: (12)                        fill_o = True
61: (8)                     else:
62: (12)                        fill_o = False
63: (8)                     for _ in range(self.n_mobs):
64: (12)                        mob = mobject.copy()
65: (12)                        if fill_o:
66: (16)                            mob.set_opacity(self.final_opacity)
67: (12)                        else:
68: (16)                            mob.set_stroke(opacity=self.final_opacity)
69: (12)                        mob.move_to(self.focal_point)
70: (12)                        mob.save_state()
71: (12)                        mob.set(width=self.initial_width)
72: (12)                        if fill_o:
73: (16)                            mob.set_opacity(self.initial_opacity)
74: (12)                        else:
75: (16)                            mob.set_stroke(opacity=self.initial_opacity)
76: (12)                        anims.append(Restore(mob, remover=remover))
77: (8)                     super().__init__(*anims, run_time=run_time, lag_ratio=lag_ratio, **kwargs)

----------------------------------------

File 16 - . \speedmodifier.py:

1: (0)              """Utilities for modifying the speed at which animations are played."""
2: (0)              from __future__ import annotations
3: (0)              import inspect
4: (0)              import types
5: (0)              from typing import TYPE_CHECKING, Callable
6: (0)              from numpy import piecewise
7: (0)              from ..animation.animation import Animation, Wait, prepare_animation
8: (0)              from ..animation.composition import AnimationGroup
9: (0)              from ..mobject.mobject import Mobject, _AnimationBuilder
10: (0)             from ..scene.scene import Scene
11: (0)             if TYPE_CHECKING:
12: (4)                 from ..mobject.mobject import Updater
13: (0)             __all__ = ["ChangeSpeed"]
14: (0)             class ChangeSpeed(Animation):
15: (4)                 """Modifies the speed of passed animation.
16: (4)                 :class:`AnimationGroup` with different ``lag_ratio`` can also be used
17: (4)                 which combines multiple animations into one.
18: (4)                 The ``run_time`` of the passed animation is changed to modify the speed.
19: (4)                 Parameters
20: (4)                 ----------
21: (4)                 anim
22: (8)                     Animation of which the speed is to be modified.
23: (4)                 speedinfo
24: (8)                     Contains nodes (percentage of ``run_time``) and its corresponding speed factor.
25: (4)                 rate_func
26: (8)                     Overrides ``rate_func`` of passed animation, applied before changing speed.
27: (4)                 Examples
28: (4)                 --------
29: (4)                 .. manim:: SpeedModifierExample
30: (8)                     class SpeedModifierExample(Scene):
31: (12)                        def construct(self):
32: (16)                            a = Dot().shift(LEFT * 4)
33: (16)                            b = Dot().shift(RIGHT * 4)
34: (16)                            self.add(a, b)
35: (16)                            self.play(
36: (20)                                ChangeSpeed(
37: (24)                                    AnimationGroup(
38: (28)                                        a.animate(run_time=1).shift(RIGHT * 8),
39: (28)                                        b.animate(run_time=1).shift(LEFT * 8),
40: (24)                                    ),
41: (24)                                    speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},
42: (24)                                    rate_func=linear,
43: (20)                                )
44: (16)                            )
45: (4)                 .. manim:: SpeedModifierUpdaterExample
46: (8)                     class SpeedModifierUpdaterExample(Scene):
47: (12)                        def construct(self):
48: (16)                            a = Dot().shift(LEFT * 4)
49: (16)                            self.add(a)
50: (16)                            ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
51: (16)                            self.play(
52: (20)                                ChangeSpeed(
53: (24)                                    Wait(2),
54: (24)                                    speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},
55: (24)                                    affects_speed_updaters=True,
56: (20)                                )
57: (16)                            )
58: (4)                 .. manim:: SpeedModifierUpdaterExample2
59: (8)                     class SpeedModifierUpdaterExample2(Scene):
60: (12)                        def construct(self):
61: (16)                            a = Dot().shift(LEFT * 4)
62: (16)                            self.add(a)
63: (16)                            ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
64: (16)                            self.wait()
65: (16)                            self.play(
66: (20)                                ChangeSpeed(
67: (24)                                    Wait(),
68: (24)                                    speedinfo={1: 0},
69: (24)                                    affects_speed_updaters=True,
70: (20)                                )
71: (16)                            )
72: (4)                 """
73: (4)                 dt = 0
74: (4)                 is_changing_dt = False
75: (4)                 def __init__(
76: (8)                     self,
77: (8)                     anim: Animation | _AnimationBuilder,
78: (8)                     speedinfo: dict[float, float],
79: (8)                     rate_func: Callable[[float], float] | None = None,
80: (8)                     affects_speed_updaters: bool = True,
81: (8)                     **kwargs,
82: (4)                 ) -> None:
83: (8)                     if issubclass(type(anim), AnimationGroup):
84: (12)                        self.anim = type(anim)(
85: (16)                            *map(self.setup, anim.animations),
86: (16)                            group=anim.group,
87: (16)                            run_time=anim.run_time,
88: (16)                            rate_func=anim.rate_func,
89: (16)                            lag_ratio=anim.lag_ratio,
90: (12)                        )
91: (8)                     else:
92: (12)                        self.anim = self.setup(anim)
93: (8)                     if affects_speed_updaters:
94: (12)                        assert (
95: (16)                            ChangeSpeed.is_changing_dt is False
96: (12)                        ), "Only one animation at a time can play that changes speed (dt) for ChangeSpeed updaters"
97: (12)                        ChangeSpeed.is_changing_dt = True
98: (12)                        self.t = 0
99: (8)                     self.affects_speed_updaters = affects_speed_updaters
100: (8)                    self.rate_func = self.anim.rate_func if rate_func is None else rate_func
101: (8)                    # A function where, f(0) = 0, f'(0) = initial speed, f'( f-1(1) ) = final speed
102: (8)                    # Following function obtained when conditions applied to vertical parabola
103: (8)                    self.speed_modifier = lambda x, init_speed, final_speed: (
104: (12)                       (final_speed**2 - init_speed**2) * x**2 / 4 + init_speed * x
105: (8)                    )
106: (8)                    # f-1(1), returns x for which f(x) = 1 in `speed_modifier` function
107: (8)                    self.f_inv_1 = lambda init_speed, final_speed: 2 / (init_speed + final_speed)
108: (8)                    # if speed factors for the starting node (0) and the final node (1) are
109: (8)                    # not set, set them to 1 and the penultimate factor, respectively
110: (8)                    if 0 not in speedinfo:
111: (12)                       speedinfo[0] = 1
112: (8)                    if 1 not in speedinfo:
113: (12)                       speedinfo[1] = sorted(speedinfo.items())[-1][1]
114: (8)                    self.speedinfo = dict(sorted(speedinfo.items()))
115: (8)                    self.functions = []
116: (8)                    self.conditions = []
117: (8)                    # Get the time taken by amimation if `run_time` is assumed to be 1
118: (8)                    scaled_total_time = self.get_scaled_total_time()
119: (8)                    prevnode = 0
120: (8)                    init_speed = self.speedinfo[0]
121: (8)                    curr_time = 0
122: (8)                    for node, final_speed in list(self.speedinfo.items())[1:]:
123: (12)                       dur = node - prevnode
124: (12)                       def condition(
125: (16)                           t,
126: (16)                           curr_time=curr_time,
127: (16)                           init_speed=init_speed,
128: (16)                           final_speed=final_speed,
129: (16)                           dur=dur,
130: (12)                       ):
131: (16)                           lower_bound = curr_time / scaled_total_time
132: (16)                           upper_bound = (
133: (20)                               curr_time + self.f_inv_1(init_speed, final_speed) * dur
134: (16)                           ) / scaled_total_time
135: (16)                           return lower_bound <= t <= upper_bound
136: (12)                       self.conditions.append(condition)
137: (12)                       def function(
138: (16)                           t,
139: (16)                           curr_time=curr_time,
140: (16)                           init_speed=init_speed,
141: (16)                           final_speed=final_speed,
142: (16)                           dur=dur,
143: (16)                           prevnode=prevnode,
144: (12)                       ):
145: (16)                           return (
146: (20)                               self.speed_modifier(
147: (24)                                   (scaled_total_time * t - curr_time) / dur,
148: (24)                                   init_speed,
149: (24)                                   final_speed,
150: (20)                               )
151: (20)                               * dur
152: (20)                               + prevnode
153: (16)                           )
154: (12)                       self.functions.append(function)
155: (12)                       curr_time += self.f_inv_1(init_speed, final_speed) * dur
156: (12)                       prevnode = node
157: (12)                       init_speed = final_speed
158: (8)                    def func(t):
159: (12)                       if t == 1:
160: (16)                           ChangeSpeed.is_changing_dt = False
161: (12)                       new_t = piecewise(
162: (16)                           self.rate_func(t),
163: (16)                           [condition(self.rate_func(t)) for condition in self.conditions],
164: (16)                           self.functions,
165: (12)                       )
166: (12)                       if self.affects_speed_updaters:
167: (16)                           ChangeSpeed.dt = (new_t - self.t) * self.anim.run_time
168: (16)                           self.t = new_t
169: (12)                       return new_t
170: (8)                    self.anim.set_rate_func(func)
171: (8)                    super().__init__(
172: (12)                       self.anim.mobject,
173: (12)                       rate_func=self.rate_func,
174: (12)                       run_time=scaled_total_time * self.anim.run_time,
175: (12)                       **kwargs,
176: (8)                    )
177: (4)                def setup(self, anim):
178: (8)                    if type(anim) is Wait:
179: (12)                       anim.interpolate = types.MethodType(
180: (16)                           lambda self, alpha: self.rate_func(alpha), anim
181: (12)                       )
182: (8)                    return prepare_animation(anim)
183: (4)                def get_scaled_total_time(self) -> float:
184: (8)                    """The time taken by the animation under the assumption that the ``run_time`` is 1."""
185: (8)                    prevnode = 0
186: (8)                    init_speed = self.speedinfo[0]
187: (8)                    total_time = 0
188: (8)                    for node, final_speed in list(self.speedinfo.items())[1:]:
189: (12)                       dur = node - prevnode
190: (12)                       total_time += dur * self.f_inv_1(init_speed, final_speed)
191: (12)                       prevnode = node
192: (12)                       init_speed = final_speed
193: (8)                    return total_time
194: (4)                @classmethod
195: (4)                def add_updater(
196: (8)                    cls,
197: (8)                    mobject: Mobject,
198: (8)                    update_function: Updater,
199: (8)                    index: int | None = None,
200: (8)                    call_updater: bool = False,
201: (4)                ):
202: (8)                    """This static method can be used to apply speed change to updaters.
203: (8)                    This updater will follow speed and rate function of any :class:`.ChangeSpeed`
204: (8)                    animation that is playing with ``affects_speed_updaters=True``. By default,
205: (8)                    updater functions added via the usual :meth:`.Mobject.add_updater` method
206: (8)                    do not respect the change of animation speed.
207: (8)                    Parameters
208: (8)                    ----------
209: (8)                    mobject
210: (12)                       The mobject to which the updater should be attached.
211: (8)                    update_function
212: (12)                       The function that is called whenever a new frame is rendered.
213: (8)                    index
214: (12)                       The position in the list of the mobject's updaters at which the
215: (12)                       function should be inserted.
216: (8)                    call_updater
217: (12)                       If ``True``, calls the update function when attaching it to the
218: (12)                       mobject.
219: (8)                    See also
220: (8)                    --------
221: (8)                    :class:`.ChangeSpeed`
222: (8)                    :meth:`.Mobject.add_updater`
223: (8)                    """
224: (8)                    if "dt" in inspect.signature(update_function).parameters:
225: (12)                       mobject.add_updater(
226: (16)                           lambda mob, dt: update_function(
227: (20)                               mob, ChangeSpeed.dt if ChangeSpeed.is_changing_dt else dt
228: (16)                           ),
229: (16)                           index=index,
230: (16)                           call_updater=call_updater,
231: (12)                       )
232: (8)                    else:
233: (12)                       mobject.add_updater(update_function, index=index, call_updater=call_updater)
234: (4)                def interpolate(self, alpha: float) -> None:
235: (8)                    self.anim.interpolate(alpha)
236: (4)                def update_mobjects(self, dt: float) -> None:
237: (8)                    self.anim.update_mobjects(dt)
238: (4)                def finish(self) -> None:
239: (8)                    ChangeSpeed.is_changing_dt = False
240: (8)                    self.anim.finish()
241: (4)                def begin(self) -> None:
242: (8)                    self.anim.begin()
243: (4)                def clean_up_from_scene(self, scene: Scene) -> None:
244: (8)                    self.anim.clean_up_from_scene(scene)
245: (4)                def _setup_scene(self, scene) -> None:
246: (8)                    self.anim._setup_scene(scene)

----------------------------------------

File 17 - .\updaters \mobject_update_utils.py:

1: (0)              """Utility functions for continuous animation of mobjects."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = [
4: (4)                  "assert_is_mobject_method",
5: (4)                  "always",
6: (4)                  "f_always",
7: (4)                  "always_redraw",
8: (4)                  "always_shift",
9: (4)                  "always_rotate",
10: (4)                 "turn_animation_into_updater",
11: (4)                 "cycle_animation",
12: (0)             ]
13: (0)             import inspect
14: (0)             from typing import TYPE_CHECKING, Callable
15: (0)             import numpy as np
16: (0)             from manim.constants import DEGREES, RIGHT
17: (0)             from manim.mobject.mobject import Mobject
18: (0)             from manim.opengl import OpenGLMobject
19: (0)             from manim.utils.space_ops import normalize
20: (0)             if TYPE_CHECKING:
21: (4)                 from manim.animation.animation import Animation
22: (0)             def assert_is_mobject_method(method: Callable) -> None:
23: (4)                 assert inspect.ismethod(method)
24: (4)                 mobject = method.__self__
25: (4)                 assert isinstance(mobject, (Mobject, OpenGLMobject))
26: (0)             def always(method: Callable, *args, **kwargs) -> Mobject:
27: (4)                 assert_is_mobject_method(method)
28: (4)                 mobject = method.__self__
29: (4)                 func = method.__func__
30: (4)                 mobject.add_updater(lambda m: func(m, *args, **kwargs))
31: (4)                 return mobject
32: (0)             def f_always(method: Callable[[Mobject], None], *arg_generators, **kwargs) -> Mobject:
33: (4)                 """
34: (4)                 More functional version of always, where instead
35: (4)                 of taking in args, it takes in functions which output
36: (4)                 the relevant arguments.
37: (4)                 """
38: (4)                 assert_is_mobject_method(method)
39: (4)                 mobject = method.__self__
40: (4)                 func = method.__func__
41: (4)                 def updater(mob):
42: (8)                     args = [arg_generator() for arg_generator in arg_generators]
43: (8)                     func(mob, *args, **kwargs)
44: (4)                 mobject.add_updater(updater)
45: (4)                 return mobject
46: (0)             def always_redraw(func: Callable[[], Mobject]) -> Mobject:
47: (4)                 """Redraw the mobject constructed by a function every frame.
48: (4)                 This function returns a mobject with an attached updater that
49: (4)                 continuously regenerates the mobject according to the
50: (4)                 specified function.
51: (4)                 Parameters
52: (4)                 ----------
53: (4)                 func
54: (8)                     A function without (required) input arguments that returns
55: (8)                     a mobject.
56: (4)                 Examples
57: (4)                 --------
58: (4)                 .. manim:: TangentAnimation
59: (8)                     class TangentAnimation(Scene):
60: (12)                        def construct(self):
61: (16)                            ax = Axes()
62: (16)                            sine = ax.plot(np.sin, color=RED)
63: (16)                            alpha = ValueTracker(0)
64: (16)                            point = always_redraw(
65: (20)                                lambda: Dot(
66: (24)                                    sine.point_from_proportion(alpha.get_value()),
67: (24)                                    color=BLUE
68: (20)                                )
69: (16)                            )
70: (16)                            tangent = always_redraw(
71: (20)                                lambda: TangentLine(
72: (24)                                    sine,
73: (24)                                    alpha=alpha.get_value(),
74: (24)                                    color=YELLOW,
75: (24)                                    length=4
76: (20)                                )
77: (16)                            )
78: (16)                            self.add(ax, sine, point, tangent)
79: (16)                            self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)
80: (4)                 """
81: (4)                 mob = func()
82: (4)                 mob.add_updater(lambda _: mob.become(func()))
83: (4)                 return mob
84: (0)             def always_shift(
85: (4)                 mobject: Mobject, direction: np.ndarray[np.float64] = RIGHT, rate: float = 0.1
86: (0)             ) -> Mobject:
87: (4)                 """A mobject which is continuously shifted along some direction
88: (4)                 at a certain rate.
89: (4)                 Parameters
90: (4)                 ----------
91: (4)                 mobject
92: (8)                     The mobject to shift.
93: (4)                 direction
94: (8)                     The direction to shift. The vector is normalized, the specified magnitude
95: (8)                     is not relevant.
96: (4)                 rate
97: (8)                     Length in Manim units which the mobject travels in one
98: (8)                     second along the specified direction.
99: (4)                 Examples
100: (4)                --------
101: (4)                .. manim:: ShiftingSquare
102: (8)                    class ShiftingSquare(Scene):
103: (12)                       def construct(self):
104: (16)                           sq = Square().set_fill(opacity=1)
105: (16)                           tri = Triangle()
106: (16)                           VGroup(sq, tri).arrange(LEFT)
107: (16)                           # construct a square which is continuously
108: (16)                           # shifted to the right
109: (16)                           always_shift(sq, RIGHT, rate=5)
110: (16)                           self.add(sq)
111: (16)                           self.play(tri.animate.set_fill(opacity=1))
112: (4)                """
113: (4)                mobject.add_updater(lambda m, dt: m.shift(dt * rate * normalize(direction)))
114: (4)                return mobject
115: (0)            def always_rotate(mobject: Mobject, rate: float = 20 * DEGREES, **kwargs) -> Mobject:
116: (4)                """A mobject which is continuously rotated at a certain rate.
117: (4)                Parameters
118: (4)                ----------
119: (4)                mobject
120: (8)                    The mobject to be rotated.
121: (4)                rate
122: (8)                    The angle which the mobject is rotated by
123: (8)                    over one second.
124: (4)                kwags
125: (8)                    Further arguments to be passed to :meth:`.Mobject.rotate`.
126: (4)                Examples
127: (4)                --------
128: (4)                .. manim:: SpinningTriangle
129: (8)                    class SpinningTriangle(Scene):
130: (12)                       def construct(self):
131: (16)                           tri = Triangle().set_fill(opacity=1).set_z_index(2)
132: (16)                           sq = Square().to_edge(LEFT)
133: (16)                           # will keep spinning while there is an animation going on
134: (16)                           always_rotate(tri, rate=2*PI, about_point=ORIGIN)
135: (16)                           self.add(tri, sq)
136: (16)                           self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)
137: (4)                """
138: (4)                mobject.add_updater(lambda m, dt: m.rotate(dt * rate, **kwargs))
139: (4)                return mobject
140: (0)            def turn_animation_into_updater(
141: (4)                animation: Animation, cycle: bool = False, **kwargs
142: (0)            ) -> Mobject:
143: (4)                """
144: (4)                Add an updater to the animation's mobject which applies
145: (4)                the interpolation and update functions of the animation
146: (4)                If cycle is True, this repeats over and over.  Otherwise,
147: (4)                the updater will be popped upon completion
148: (4)                Examples
149: (4)                --------
150: (4)                .. manim:: WelcomeToManim
151: (8)                    class WelcomeToManim(Scene):
152: (12)                       def construct(self):
153: (16)                           words = Text("Welcome to")
154: (16)                           banner = ManimBanner().scale(0.5)
155: (16)                           VGroup(words, banner).arrange(DOWN)
156: (16)                           turn_animation_into_updater(Write(words, run_time=0.9))
157: (16)                           self.add(words)
158: (16)                           self.wait(0.5)
159: (16)                           self.play(banner.expand(), run_time=0.5)
160: (4)                """
161: (4)                mobject = animation.mobject
162: (4)                animation.suspend_mobject_updating = False
163: (4)                animation.begin()
164: (4)                animation.total_time = 0
165: (4)                def update(m: Mobject, dt: float):
166: (8)                    run_time = animation.get_run_time()
167: (8)                    time_ratio = animation.total_time / run_time
168: (8)                    if cycle:
169: (12)                       alpha = time_ratio % 1
170: (8)                    else:
171: (12)                       alpha = np.clip(time_ratio, 0, 1)
172: (12)                       if alpha >= 1:
173: (16)                           animation.finish()
174: (16)                           m.remove_updater(update)
175: (16)                           return
176: (8)                    animation.interpolate(alpha)
177: (8)                    animation.update_mobjects(dt)
178: (8)                    animation.total_time += dt
179: (4)                mobject.add_updater(update)
180: (4)                return mobject
181: (0)            def cycle_animation(animation: Animation, **kwargs) -> Mobject:
182: (4)                return turn_animation_into_updater(animation, cycle=True, **kwargs)

----------------------------------------

File 18 - . \transform_matching_parts.py:

1: (0)              """Animations that try to transform Mobjects while keeping track of identical parts."""
2: (0)              from __future__ import annotations
3: (0)              __all__ = ["TransformMatchingShapes", "TransformMatchingTex"]
4: (0)              from typing import TYPE_CHECKING
5: (0)              import numpy as np
6: (0)              from manim.mobject.opengl.opengl_mobject import OpenGLGroup, OpenGLMobject
7: (0)              from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVGroup, OpenGLVMobject
8: (0)              from .._config import config
9: (0)              from ..constants import RendererType
10: (0)             from ..mobject.mobject import Group, Mobject
11: (0)             from ..mobject.types.vectorized_mobject import VGroup, VMobject
12: (0)             from .composition import AnimationGroup
13: (0)             from .fading import FadeIn, FadeOut
14: (0)             from .transform import FadeTransformPieces, Transform
15: (0)             if TYPE_CHECKING:
16: (4)                 from ..scene.scene import Scene
17: (0)             class TransformMatchingAbstractBase(AnimationGroup):
18: (4)                 """Abstract base class for transformations that keep track of matching parts.
19: (4)                 Subclasses have to implement the two static methods
20: (4)                 :meth:`~.TransformMatchingAbstractBase.get_mobject_parts` and
21: (4)                 :meth:`~.TransformMatchingAbstractBase.get_mobject_key`.
22: (4)                 Basically, this transformation first maps all submobjects returned
23: (4)                 by the ``get_mobject_parts`` method to certain keys by applying the
24: (4)                 ``get_mobject_key`` method. Then, submobjects with matching keys
25: (4)                 are transformed into each other.
26: (4)                 Parameters
27: (4)                 ----------
28: (4)                 mobject
29: (8)                     The starting :class:`~.Mobject`.
30: (4)                 target_mobject
31: (8)                     The target :class:`~.Mobject`.
32: (4)                 transform_mismatches
33: (8)                     Controls whether submobjects without a matching key are transformed
34: (8)                     into each other by using :class:`~.Transform`. Default: ``False``.
35: (4)                 fade_transform_mismatches
36: (8)                     Controls whether submobjects without a matching key are transformed
37: (8)                     into each other by using :class:`~.FadeTransform`. Default: ``False``.
38: (4)                 key_map
39: (8)                     Optional. A dictionary mapping keys belonging to some of the starting mobject's
40: (8)                     submobjects (i.e., the return values of the ``get_mobject_key`` method)
41: (8)                     to some keys belonging to the target mobject's submobjects that should
42: (8)                     be transformed although the keys don't match.
43: (4)                 kwargs
44: (8)                     All further keyword arguments are passed to the submobject transformations.
45: (4)                 Note
46: (4)                 ----
47: (4)                 If neither ``transform_mismatches`` nor ``fade_transform_mismatches``
48: (4)                 are set to ``True``, submobjects without matching keys in the starting
49: (4)                 mobject are faded out in the direction of the unmatched submobjects in
50: (4)                 the target mobject, and unmatched submobjects in the target mobject
51: (4)                 are faded in from the direction of the unmatched submobjects in the
52: (4)                 start mobject.
53: (4)                 """
54: (4)                 def __init__(
55: (8)                     self,
56: (8)                     mobject: Mobject,
57: (8)                     target_mobject: Mobject,
58: (8)                     transform_mismatches: bool = False,
59: (8)                     fade_transform_mismatches: bool = False,
60: (8)                     key_map: dict | None = None,
61: (8)                     **kwargs,
62: (4)                 ):
63: (8)                     if isinstance(mobject, OpenGLVMobject):
64: (12)                        group_type = OpenGLVGroup
65: (8)                     elif isinstance(mobject, OpenGLMobject):
66: (12)                        group_type = OpenGLGroup
67: (8)                     elif isinstance(mobject, VMobject):
68: (12)                        group_type = VGroup
69: (8)                     else:
70: (12)                        group_type = Group
71: (8)                     source_map = self.get_shape_map(mobject)
72: (8)                     target_map = self.get_shape_map(target_mobject)
73: (8)                     if key_map is None:
74: (12)                        key_map = {}
75: (8)                     # Create two mobjects whose submobjects all match each other
76: (8)                     # according to whatever keys are used for source_map and
77: (8)                     # target_map
78: (8)                     transform_source = group_type()
79: (8)                     transform_target = group_type()
80: (8)                     kwargs["final_alpha_value"] = 0
81: (8)                     for key in set(source_map).intersection(target_map):
82: (12)                        transform_source.add(source_map[key])
83: (12)                        transform_target.add(target_map[key])
84: (8)                     anims = [Transform(transform_source, transform_target, **kwargs)]
85: (8)                     # User can manually specify when one part should transform
86: (8)                     # into another despite not matching by using key_map
87: (8)                     key_mapped_source = group_type()
88: (8)                     key_mapped_target = group_type()
89: (8)                     for key1, key2 in key_map.items():
90: (12)                        if key1 in source_map and key2 in target_map:
91: (16)                            key_mapped_source.add(source_map[key1])
92: (16)                            key_mapped_target.add(target_map[key2])
93: (16)                            source_map.pop(key1, None)
94: (16)                            target_map.pop(key2, None)
95: (8)                     if len(key_mapped_source) > 0:
96: (12)                        anims.append(
97: (16)                            FadeTransformPieces(key_mapped_source, key_mapped_target, **kwargs),
98: (12)                        )
99: (8)                     fade_source = group_type()
100: (8)                    fade_target = group_type()
101: (8)                    for key in set(source_map).difference(target_map):
102: (12)                       fade_source.add(source_map[key])
103: (8)                    for key in set(target_map).difference(source_map):
104: (12)                       fade_target.add(target_map[key])
105: (8)                    fade_target_copy = fade_target.copy()
106: (8)                    if transform_mismatches:
107: (12)                       if "replace_mobject_with_target_in_scene" not in kwargs:
108: (16)                           kwargs["replace_mobject_with_target_in_scene"] = True
109: (12)                       anims.append(Transform(fade_source, fade_target, **kwargs))
110: (8)                    elif fade_transform_mismatches:
111: (12)                       anims.append(FadeTransformPieces(fade_source, fade_target, **kwargs))
112: (8)                    else:
113: (12)                       anims.append(FadeOut(fade_source, target_position=fade_target, **kwargs))
114: (12)                       anims.append(
115: (16)                           FadeIn(fade_target_copy, target_position=fade_target, **kwargs),
116: (12)                       )
117: (8)                    super().__init__(*anims)
118: (8)                    self.to_remove = [mobject, fade_target_copy]
119: (8)                    self.to_add = target_mobject
120: (4)                def get_shape_map(self, mobject: Mobject) -> dict:
121: (8)                    shape_map = {}
122: (8)                    for sm in self.get_mobject_parts(mobject):
123: (12)                       key = self.get_mobject_key(sm)
124: (12)                       if key not in shape_map:
125: (16)                           if config["renderer"] == RendererType.OPENGL:
126: (20)                               shape_map[key] = OpenGLVGroup()
127: (16)                           else:
128: (20)                               shape_map[key] = VGroup()
129: (12)                       shape_map[key].add(sm)
130: (8)                    return shape_map
131: (4)                def clean_up_from_scene(self, scene: Scene) -> None:
132: (8)                    # Interpolate all animations back to 0 to ensure source mobjects remain unchanged.
133: (8)                    for anim in self.animations:
134: (12)                       anim.interpolate(0)
135: (8)                    scene.remove(self.mobject)
136: (8)                    scene.remove(*self.to_remove)
137: (8)                    scene.add(self.to_add)
138: (4)                @staticmethod
139: (4)                def get_mobject_parts(mobject: Mobject):
140: (8)                    raise NotImplementedError("To be implemented in subclass.")
141: (4)                @staticmethod
142: (4)                def get_mobject_key(mobject: Mobject):
143: (8)                    raise NotImplementedError("To be implemented in subclass.")
144: (0)            class TransformMatchingShapes(TransformMatchingAbstractBase):
145: (4)                """An animation trying to transform groups by matching the shape
146: (4)                of their submobjects.
147: (4)                Two submobjects match if the hash of their point coordinates after
148: (4)                normalization (i.e., after translation to the origin, fixing the submobject
149: (4)                height at 1 unit, and rounding the coordinates to three decimal places)
150: (4)                matches.
151: (4)                See also
152: (4)                --------
153: (4)                :class:`~.TransformMatchingAbstractBase`
154: (4)                Examples
155: (4)                --------
156: (4)                .. manim:: Anagram
157: (8)                    class Anagram(Scene):
158: (12)                       def construct(self):
159: (16)                           src = Text("the morse code")
160: (16)                           tar = Text("here come dots")
161: (16)                           self.play(Write(src))
162: (16)                           self.wait(0.5)
163: (16)                           self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))
164: (16)                           self.wait(0.5)
165: (4)                """
166: (4)                def __init__(
167: (8)                    self,
168: (8)                    mobject: Mobject,
169: (8)                    target_mobject: Mobject,
170: (8)                    transform_mismatches: bool = False,
171: (8)                    fade_transform_mismatches: bool = False,
172: (8)                    key_map: dict | None = None,
173: (8)                    **kwargs,
174: (4)                ):
175: (8)                    super().__init__(
176: (12)                       mobject,
177: (12)                       target_mobject,
178: (12)                       transform_mismatches=transform_mismatches,
179: (12)                       fade_transform_mismatches=fade_transform_mismatches,
180: (12)                       key_map=key_map,
181: (12)                       **kwargs,
182: (8)                    )
183: (4)                @staticmethod
184: (4)                def get_mobject_parts(mobject: Mobject) -> list[Mobject]:
185: (8)                    return mobject.family_members_with_points()
186: (4)                @staticmethod
187: (4)                def get_mobject_key(mobject: Mobject) -> int:
188: (8)                    mobject.save_state()
189: (8)                    mobject.center()
190: (8)                    mobject.set(height=1)
191: (8)                    result = hash(np.round(mobject.points, 3).tobytes())
192: (8)                    mobject.restore()
193: (8)                    return result
194: (0)            class TransformMatchingTex(TransformMatchingAbstractBase):
195: (4)                """A transformation trying to transform rendered LaTeX strings.
196: (4)                Two submobjects match if their ``tex_string`` matches.
197: (4)                See also
198: (4)                --------
199: (4)                :class:`~.TransformMatchingAbstractBase`
200: (4)                Examples
201: (4)                --------
202: (4)                .. manim:: MatchingEquationParts
203: (8)                    class MatchingEquationParts(Scene):
204: (12)                       def construct(self):
205: (16)                           variables = VGroup(MathTex("a"), MathTex("b"), MathTex("c")).arrange_submobjects().shift(UP)
206: (16)                           eq1 = MathTex("{{x}}^2", "+", "{{y}}^2", "=", "{{z}}^2")
207: (16)                           eq2 = MathTex("{{a}}^2", "+", "{{b}}^2", "=", "{{c}}^2")
208: (16)                           eq3 = MathTex("{{a}}^2", "=", "{{c}}^2", "-", "{{b}}^2")
209: (16)                           self.add(eq1)
210: (16)                           self.wait(0.5)
211: (16)                           self.play(TransformMatchingTex(Group(eq1, variables), eq2))
212: (16)                           self.wait(0.5)
213: (16)                           self.play(TransformMatchingTex(eq2, eq3))
214: (16)                           self.wait(0.5)
215: (4)                """
216: (4)                def __init__(
217: (8)                    self,
218: (8)                    mobject: Mobject,
219: (8)                    target_mobject: Mobject,
220: (8)                    transform_mismatches: bool = False,
221: (8)                    fade_transform_mismatches: bool = False,
222: (8)                    key_map: dict | None = None,
223: (8)                    **kwargs,
224: (4)                ):
225: (8)                    super().__init__(
226: (12)                       mobject,
227: (12)                       target_mobject,
228: (12)                       transform_mismatches=transform_mismatches,
229: (12)                       fade_transform_mismatches=fade_transform_mismatches,
230: (12)                       key_map=key_map,
231: (12)                       **kwargs,
232: (8)                    )
233: (4)                @staticmethod
234: (4)                def get_mobject_parts(mobject: Mobject) -> list[Mobject]:
235: (8)                    if isinstance(mobject, (Group, VGroup, OpenGLGroup, OpenGLVGroup)):
236: (12)                       return [
237: (16)                           p
238: (16)                           for s in mobject.submobjects
239: (16)                           for p in TransformMatchingTex.get_mobject_parts(s)
240: (12)                       ]
241: (8)                    else:
242: (12)                       assert hasattr(mobject, "tex_string")
243: (12)                       return mobject.submobjects
244: (4)                @staticmethod
245: (4)                def get_mobject_key(mobject: Mobject) -> str:
246: (8)                    return mobject.tex_string

----------------------------------------

File 19 - . \SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRYCOMBINER_aligner_20_characters_for_pythons_codes.py:

1: (0)              import os
2: (0)              from datetime import datetime
3: (0)              def get_file_info(root_folder):
4: (4)                  file_info_list = []
5: (4)                  for root, dirs, files in os.walk(root_folder):
6: (8)                      for file in files:
7: (12)                         try:
8: (16)                             # Check if the file is a Python file
9: (16)                             if file.endswith('.py'):
10: (20)                                file_path = os.path.join(root, file)
11: (20)                                # Get file times
12: (20)                                creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
13: (20)                                modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))
14: (20)                                # Get file extension
15: (20)                                file_extension = os.path.splitext(file)[1].lower()
16: (20)                                # Append file info to list
17: (20)                                file_info_list.append([file, file_path, creation_time, modified_time, file_extension, root])
18: (12)                        except Exception as e:
19: (16)                            print(f"Error processing file {file}: {e}")
20: (4)                 # Sort the files by multiple criteria
21: (4)                 file_info_list.sort(key=lambda x: (x[2], x[3], len(x[0]), x[4]))  # Sort by creation, modification time, name length, extension
22: (4)                 return file_info_list
23: (0)             def process_file(file_info_list):
24: (4)                 combined_output = []
25: (4)                 for idx, (file_name, file_path, creation_time, modified_time, file_extension, root) in enumerate(file_info_list):
26: (8)                     with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
27: (12)                        content = f.read()
28: (12)                        # Remove Python comments and blank lines
29: (10)                      ###  content = "\n".join([line for line in content.split('\n') if line.strip() and not line.strip().startswith("#")])
30: (12)                        content = "\n".join([line for line in content.split('\n') if line.strip() ])###and not line.strip().startswith("#")
31: (12)                        # Replace tabs with spaces
32: (12)                        content = content.replace('\t', '    ')
33: (12)                        # Process each line
34: (12)                        processed_lines = []
35: (12)                        for i, line in enumerate(content.split('\n')):
36: (16)                            # Count the number of starting blank spaces
37: (16)                            leading_spaces = len(line) - len(line.lstrip(' '))
38: (16)                            # Create the line with line number and leading spaces count
39: (16)                            line_number_str = f"{i+1}: ({leading_spaces})"
40: (16)                            # Calculate padding to align the original code at the 61st character
41: (16)                            padding = ' ' * (20 - len(line_number_str))
42: (16)                            processed_line = f"{line_number_str}{padding}{line}"
43: (16)                            processed_lines.append(processed_line)
44: (12)                        content_with_line_numbers = "\n".join(processed_lines)
45: (12)                        # Add file listing order and line number
46: (12)                        combined_output.append(f"File {idx + 1} - {root} \\{file_name}:\n")
47: (12)                        combined_output.append(content_with_line_numbers)
48: (12)                        combined_output.append("\n" + "-"*40 + "\n")
49: (4)                 return combined_output
50: (0)             # Set the root folder path
51: (0)             root_folder_path = '.'  # Set this to the desired folder
52: (0)             # Get file information and process files
53: (0)             file_info_list = get_file_info(root_folder_path)
54: (0)             combined_output = process_file(file_info_list)
55: (0)             # Save the processed data to an output file
56: (0)             output_file = 'WITHRELPATH_COMMENTSKEPT_SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRY_combined_python_files_20_chars.txt'
57: (0)             with open(output_file, 'w', encoding='utf-8') as logfile:
58: (4)                 logfile.write("\n".join(combined_output))
59: (0)             print(f"Processed file info logged to {output_file}")

----------------------------------------
