File 1 - core.py:

1: (0)              """An interface to GraphViz."""
2: (0)              import copy
3: (0)              import errno
4: (0)              import logging
5: (0)              import os
6: (0)              import re
7: (0)              import subprocess
8: (0)              import sys
9: (0)              import pydot
10: (0)             import pydot.dot_parser
11: (0)             from pydot._vendor import tempfile
12: (0)             _logger = logging.getLogger(__name__)
13: (0)             _logger.debug("pydot core module initializing")
14: (0)             GRAPH_ATTRIBUTES = {
15: (4)                 "Damping", "K", "URL", "aspect", "bb", "bgcolor",
16: (4)                 "center", "charset", "clusterrank", "colorscheme", "comment", "compound",
17: (4)                 "concentrate", "defaultdist", "dim", "dimen", "diredgeconstraints",
18: (4)                 "dpi", "epsilon", "esep", "fontcolor", "fontname", "fontnames",
19: (4)                 "fontpath", "fontsize", "id", "label", "labeljust", "labelloc",
20: (4)                 "landscape", "layers", "layersep", "layout", "levels", "levelsgap",
21: (4)                 "lheight", "lp", "lwidth", "margin", "maxiter", "mclimit", "mindist",
22: (4)                 "mode", "model", "mosek", "nodesep", "nojustify", "normalize", "nslimit",
23: (4)                 "nslimit1", "ordering", "orientation", "outputorder", "overlap",
24: (4)                 "overlap_scaling", "pack", "packmode", "pad", "page", "pagedir",
25: (4)                 "quadtree", "quantum", "rankdir", "ranksep", "ratio", "remincross",
26: (4)                 "repulsiveforce", "resolution", "root", "rotate", "searchsize", "sep",
27: (4)                 "showboxes", "size", "smoothing", "sortv", "splines", "start",
28: (4)                 "stylesheet", "target", "truecolor", "viewport", "voro_margin",
29: (4)                 "rank"
30: (0)             }
31: (0)             EDGE_ATTRIBUTES = {
32: (4)                 "URL", "arrowhead", "arrowsize", "arrowtail",
33: (4)                 "color", "colorscheme", "comment", "constraint", "decorate", "dir",
34: (4)                 "edgeURL", "edgehref", "edgetarget", "edgetooltip", "fontcolor",
35: (4)                 "fontname", "fontsize", "headURL", "headclip", "headhref", "headlabel",
36: (4)                 "headport", "headtarget", "headtooltip", "href", "id", "label",
37: (4)                 "labelURL", "labelangle", "labeldistance", "labelfloat", "labelfontcolor",
38: (4)                 "labelfontname", "labelfontsize", "labelhref", "labeltarget",
39: (4)                 "labeltooltip", "layer", "len", "lhead", "lp", "ltail", "minlen",
40: (4)                 "nojustify", "penwidth", "pos", "samehead", "sametail", "showboxes",
41: (4)                 "style", "tailURL", "tailclip", "tailhref", "taillabel", "tailport",
42: (4)                 "tailtarget", "tailtooltip", "target", "tooltip", "weight",
43: (4)                 "rank"
44: (0)             }
45: (0)             NODE_ATTRIBUTES = {
46: (4)                 "URL", "color", "colorscheme", "comment",
47: (4)                 "distortion", "fillcolor", "fixedsize", "fontcolor", "fontname",
48: (4)                 "fontsize", "group", "height", "id", "image", "imagescale", "label",
49: (4)                 "labelloc", "layer", "margin", "nojustify", "orientation", "penwidth",
50: (4)                 "peripheries", "pin", "pos", "rects", "regular", "root", "samplepoints",
51: (4)                 "shape", "shapefile", "showboxes", "sides", "skew", "sortv", "style",
52: (4)                 "target", "tooltip", "vertices", "width", "z",
53: (4)                 "texlbl",  "texmode"
54: (0)             }
55: (0)             CLUSTER_ATTRIBUTES = {
56: (4)                 "K", "URL", "bgcolor", "color", "colorscheme",
57: (4)                 "fillcolor", "fontcolor", "fontname", "fontsize", "label", "labeljust",
58: (4)                 "labelloc", "lheight", "lp", "lwidth", "nojustify", "pencolor",
59: (4)                 "penwidth", "peripheries", "sortv", "style", "target", "tooltip"
60: (0)             }
61: (0)             OUTPUT_FORMATS = {
62: (4)                 "canon",
63: (4)                 "cmap",
64: (4)                 "cmapx",
65: (4)                 "cmapx_np",
66: (4)                 "dia",
67: (4)                 "dot",
68: (4)                 "fig",
69: (4)                 "gd",
70: (4)                 "gd2",
71: (4)                 "gif",
72: (4)                 "hpgl",
73: (4)                 "imap",
74: (4)                 "imap_np",
75: (4)                 "ismap",
76: (4)                 "jpe",
77: (4)                 "jpeg",
78: (4)                 "jpg",
79: (4)                 "mif",
80: (4)                 "mp",
81: (4)                 "pcl",
82: (4)                 "pdf",
83: (4)                 "pic",
84: (4)                 "plain",
85: (4)                 "plain-ext",
86: (4)                 "png",
87: (4)                 "ps",
88: (4)                 "ps2",
89: (4)                 "svg",
90: (4)                 "svgz",
91: (4)                 "vml",
92: (4)                 "vmlz",
93: (4)                 "vrml",
94: (4)                 "vtx",
95: (4)                 "wbmp",
96: (4)                 "xdot",
97: (4)                 "xlib",
98: (0)             }
99: (0)             DEFAULT_PROGRAMS = {
100: (4)                "dot",
101: (4)                "twopi",
102: (4)                "neato",
103: (4)                "circo",
104: (4)                "fdp",
105: (4)                "sfdp",
106: (0)            }
107: (0)            def __generate_attribute_methods(Klass, attrs):
108: (4)                """Generate setter and getter methods for attributes."""
109: (4)                for attr in attrs:
110: (8)                    def __getter(self, _attr=attr):
111: (12)                       return self.get(_attr)
112: (8)                    setattr(Klass, f"get_{attr}", __getter)
113: (8)                    def __setter(self, *args, _attr=attr):
114: (12)                       return self.set(_attr, *args)
115: (8)                    setattr(Klass, f"set_{attr}", __setter)
116: (0)            def __generate_format_methods(Klass):
117: (4)                """Generate create_ and write_ methods for formats."""
118: (4)                for frmt in OUTPUT_FORMATS:
119: (8)                    def __create_method(self, f=frmt, prog=None, encoding=None):
120: (12)                       """Refer to docstring of method `create`."""
121: (12)                       return self.create(format=f, prog=prog, encoding=encoding)
122: (8)                    setattr(Klass, f"create_{frmt}", __create_method)
123: (4)                for frmt in OUTPUT_FORMATS ^ {"raw"}:
124: (8)                    def __write_method(self, path, f=frmt, prog=None, encoding=None):
125: (12)                       """Refer to docstring of method `write`."""
126: (12)                       self.write(path, format=f, prog=prog, encoding=encoding)
127: (8)                    setattr(Klass, f"write_{frmt}", __write_method)
128: (0)            def is_windows():
129: (4)                return os.name == "nt"
130: (0)            def is_anaconda():
131: (4)                import glob
132: (4)                conda_pattern = os.path.join(sys.prefix, "conda-meta\\graphviz*.json")
133: (4)                return glob.glob(conda_pattern) != []
134: (0)            def get_executable_extension():
135: (4)                if is_windows():
136: (8)                    return ".bat" if is_anaconda() else ".exe"
137: (4)                else:
138: (8)                    return ""
139: (0)            def call_graphviz(program, arguments, working_dir, **kwargs):
140: (4)                if program in DEFAULT_PROGRAMS:
141: (8)                    extension = get_executable_extension()
142: (8)                    program += extension
143: (4)                if arguments is None:
144: (8)                    arguments = []
145: (4)                env = {
146: (8)                    "PATH": os.environ.get("PATH", ""),
147: (8)                    "LD_LIBRARY_PATH": os.environ.get("LD_LIBRARY_PATH", ""),
148: (8)                    "SYSTEMROOT": os.environ.get("SYSTEMROOT", ""),
149: (4)                }
150: (4)                program_with_args = [program] + arguments
151: (4)                process = subprocess.Popen(
152: (8)                    program_with_args,
153: (8)                    env=env,
154: (8)                    cwd=working_dir,
155: (8)                    shell=False,
156: (8)                    stderr=subprocess.PIPE,
157: (8)                    stdout=subprocess.PIPE,
158: (8)                    **kwargs,
159: (4)                )
160: (4)                stdout_data, stderr_data = process.communicate()
161: (4)                return stdout_data, stderr_data, process
162: (0)            class frozendict(dict):
163: (4)                def _blocked_attribute(obj):
164: (8)                    raise AttributeError("A frozendict cannot be modified.")
165: (4)                _blocked_attribute = property(_blocked_attribute)
166: (4)                __delitem__ = __setitem__ = clear = _blocked_attribute
167: (4)                pop = popitem = setdefault = update = _blocked_attribute
168: (4)                def __new__(cls, *args, **kw):
169: (8)                    new = dict.__new__(cls)
170: (8)                    args_ = []
171: (8)                    for arg in args:
172: (12)                       if isinstance(arg, dict):
173: (16)                           arg = copy.copy(arg)
174: (16)                           for k in arg:
175: (20)                               v = arg[k]
176: (20)                               if isinstance(v, frozendict):
177: (24)                                   arg[k] = v
178: (20)                               elif isinstance(v, dict):
179: (24)                                   arg[k] = frozendict(v)
180: (20)                               elif isinstance(v, list):
181: (24)                                   v_ = []
182: (24)                                   for elm in v:
183: (28)                                       if isinstance(elm, dict):
184: (32)                                           v_.append(frozendict(elm))
185: (28)                                       else:
186: (32)                                           v_.append(elm)
187: (24)                                   arg[k] = tuple(v_)
188: (16)                           args_.append(arg)
189: (12)                       else:
190: (16)                           args_.append(arg)
191: (8)                    dict.__init__(new, *args_, **kw)
192: (8)                    return new
193: (4)                def __init__(self, *args, **kw):
194: (8)                    pass
195: (4)                def __hash__(self):
196: (8)                    try:
197: (12)                       return self._cached_hash
198: (8)                    except AttributeError:
199: (12)                       h = self._cached_hash = hash(tuple(sorted(self.items())))
200: (12)                       return h
201: (4)                def __repr__(self):
202: (8)                    dict_repr = dict.__repr__(self)
203: (8)                    return f"frozendict({dict_repr})"
204: (0)            def make_quoted(s):
205: (4)                """Transform a string into a quoted string, escaping specials."""
206: (4)                replace = {
207: (8)                    ord('"'): r"\"",
208: (8)                    ord("\n"): r"\n",
209: (8)                    ord("\r"): r"\r",
210: (4)                }
211: (4)                return rf'"{s.translate(replace)}"'
212: (0)            dot_keywords = ["graph", "subgraph", "digraph", "node", "edge", "strict"]
213: (0)            re_numeric = re.compile(r"^([0-9]+\.?[0-9]*|[0-9]*\.[0-9]+)$")
214: (0)            re_dbl_quoted = re.compile(r'^".*"$', re.S)
215: (0)            re_html = re.compile(r"^<.*>$", re.S)
216: (0)            id_re_alpha_nums = re.compile(r"^[_a-zA-Z][a-zA-Z0-9_]*$")
217: (0)            id_re_alpha_nums_with_ports = re.compile(
218: (4)                r'^[_a-zA-Z][a-zA-Z0-9_:"]*[a-zA-Z0-9_"]+$'
219: (0)            )
220: (0)            id_re_with_port = re.compile(r"^([^:]*):([^:]*)$")
221: (0)            def any_needs_quotes(s):
222: (4)                """Determine if a string needs to be quoted.
223: (4)                Returns True, False, or None if the result is indeterminate.
224: (4)                """
225: (4)                if s.isdigit():
226: (8)                    return False
227: (4)                if s.isalnum():
228: (8)                    return s[0].isdigit()
229: (4)                has_high_chars = any(ord(c) > 0x7F or ord(c) == 0 for c in s)
230: (4)                if has_high_chars and not re_dbl_quoted.match(s) and not re_html.match(s):
231: (8)                    return True
232: (4)                for test_re in [re_numeric, re_dbl_quoted, re_html]:
233: (8)                    if test_re.match(s):
234: (12)                       return False
235: (4)                return None
236: (0)            def id_needs_quotes(s):
237: (4)                """Checks whether a string is a dot language ID.
238: (4)                It will check whether the string is solely composed
239: (4)                by the characters allowed in an ID or not.
240: (4)                If the string is one of the reserved keywords it will
241: (4)                need quotes too but the user will need to add them
242: (4)                manually.
243: (4)                """
244: (4)                if s in dot_keywords:
245: (8)                    return False
246: (4)                any_result = any_needs_quotes(s)
247: (4)                if any_result is not None:
248: (8)                    return any_result
249: (4)                for test_re in [
250: (8)                    id_re_alpha_nums,
251: (8)                    id_re_alpha_nums_with_ports,
252: (4)                ]:
253: (8)                    if test_re.match(s):
254: (12)                       return False
255: (4)                m = id_re_with_port.match(s)
256: (4)                if m:
257: (8)                    return id_needs_quotes(m.group(1)) or id_needs_quotes(m.group(2))
258: (4)                return True
259: (0)            def quote_id_if_necessary(s, unquoted_keywords=None):
260: (4)                """Enclose identifier in quotes, if needed."""
261: (4)                unquoted = [
262: (8)                    w.lower() for w in list(unquoted_keywords if unquoted_keywords else [])
263: (4)                ]
264: (4)                if isinstance(s, bool):
265: (8)                    return str(s).lower()
266: (4)                if not isinstance(s, str):
267: (8)                    return s
268: (4)                if not s:
269: (8)                    return s
270: (4)                if s.lower() in unquoted:
271: (8)                    return s
272: (4)                if s.lower() in dot_keywords:
273: (8)                    return make_quoted(s)
274: (4)                if id_needs_quotes(s):
275: (8)                    return make_quoted(s)
276: (4)                return s
277: (0)            def quote_attr_if_necessary(s):
278: (4)                """Enclose attribute value in quotes, if needed."""
279: (4)                if isinstance(s, bool):
280: (8)                    return str(s).lower()
281: (4)                if not isinstance(s, str):
282: (8)                    return s
283: (4)                if s in dot_keywords:
284: (8)                    return make_quoted(s)
285: (4)                any_result = any_needs_quotes(s)
286: (4)                if any_result is not None and not any_result:
287: (8)                    return s
288: (4)                return make_quoted(s)
289: (0)            def graph_from_dot_data(s):
290: (4)                """Load graphs from DOT description in string `s`.
291: (4)                This function is NOT thread-safe due to the internal use of `pyparsing`.
292: (4)                Use a lock if needed.
293: (4)                @param s: string in [DOT language](
294: (8)                    https://en.wikipedia.org/wiki/DOT_(graph_description_language))
295: (4)                @return: Graphs that result from parsing.
296: (4)                @rtype: `list` of `pydot.Dot`
297: (4)                """
298: (4)                return pydot.dot_parser.parse_dot_data(s)
299: (0)            def graph_from_dot_file(path, encoding=None):
300: (4)                """Load graphs from DOT file at `path`.
301: (4)                This function is NOT thread-safe due to the internal use of `pyparsing`.
302: (4)                Use a lock if needed.
303: (4)                @param path: to DOT file
304: (4)                @param encoding: as passed to `io.open`.
305: (8)                    For example, `'utf-8'`.
306: (4)                @return: Graphs that result from parsing.
307: (4)                @rtype: `list` of `pydot.Dot`
308: (4)                """
309: (4)                with open(path, encoding=encoding) as f:
310: (8)                    s = f.read()
311: (4)                graphs = graph_from_dot_data(s)
312: (4)                return graphs
313: (0)            def graph_from_edges(edge_list, node_prefix="", directed=False):
314: (4)                """Creates a basic graph out of an edge list.
315: (4)                The edge list has to be a list of tuples representing
316: (4)                the nodes connected by the edge.
317: (4)                The values can be anything: bool, int, float, str.
318: (4)                If the graph is undirected by default, it is only
319: (4)                calculated from one of the symmetric halves of the matrix.
320: (4)                """
321: (4)                if directed:
322: (8)                    graph = Dot(graph_type="digraph")
323: (4)                else:
324: (8)                    graph = Dot(graph_type="graph")
325: (4)                for edge in edge_list:
326: (8)                    if isinstance(edge[0], str):
327: (12)                       src = node_prefix + edge[0]
328: (8)                    else:
329: (12)                       src = node_prefix + str(edge[0])
330: (8)                    if isinstance(edge[1], str):
331: (12)                       dst = node_prefix + edge[1]
332: (8)                    else:
333: (12)                       dst = node_prefix + str(edge[1])
334: (8)                    e = Edge(src, dst)
335: (8)                    graph.add_edge(e)
336: (4)                return graph
337: (0)            def graph_from_adjacency_matrix(matrix, node_prefix="", directed=False):
338: (4)                """Creates a basic graph out of an adjacency matrix.
339: (4)                The matrix has to be a list of rows of values
340: (4)                representing an adjacency matrix.
341: (4)                The values can be anything: bool, int, float, as long
342: (4)                as they can evaluate to True or False.
343: (4)                """
344: (4)                node_orig = 1
345: (4)                if directed:
346: (8)                    graph = Dot(graph_type="digraph")
347: (4)                else:
348: (8)                    graph = Dot(graph_type="graph")
349: (4)                for row in matrix:
350: (8)                    if not directed:
351: (12)                       skip = matrix.index(row)
352: (12)                       r = row[skip:]
353: (8)                    else:
354: (12)                       skip = 0
355: (12)                       r = row
356: (8)                    node_dest = skip + 1
357: (8)                    for e in r:
358: (12)                       if e:
359: (16)                           graph.add_edge(
360: (20)                               Edge(
361: (24)                                   f"{node_prefix}{node_orig}",
362: (24)                                   f"{node_prefix}{node_dest}",
363: (20)                               )
364: (16)                           )
365: (12)                       node_dest += 1
366: (8)                    node_orig += 1
367: (4)                return graph
368: (0)            def graph_from_incidence_matrix(matrix, node_prefix="", directed=False):
369: (4)                """Creates a basic graph out of an incidence matrix.
370: (4)                The matrix has to be a list of rows of values
371: (4)                representing an incidence matrix.
372: (4)                The values can be anything: bool, int, float, as long
373: (4)                as they can evaluate to True or False.
374: (4)                """
375: (4)                if directed:
376: (8)                    graph = Dot(graph_type="digraph")
377: (4)                else:
378: (8)                    graph = Dot(graph_type="graph")
379: (4)                for row in matrix:
380: (8)                    nodes = []
381: (8)                    c = 1
382: (8)                    for node in row:
383: (12)                       if node:
384: (16)                           nodes.append(c * node)
385: (12)                       c += 1
386: (12)                       nodes.sort()
387: (8)                    if len(nodes) == 2:
388: (12)                       graph.add_edge(
389: (16)                           Edge(
390: (20)                               f"{node_prefix}{abs(nodes[0])}",
391: (20)                               f"{node_prefix}{nodes[1]}",
392: (16)                           )
393: (12)                       )
394: (4)                if not directed:
395: (8)                    graph.set_simplify(True)
396: (4)                return graph
397: (0)            class Common:
398: (4)                """Common information to several classes.
399: (4)                Should not be directly used, several classes are derived from
400: (4)                this one.
401: (4)                """
402: (4)                def __getstate__(self):
403: (8)                    dict = copy.copy(self.obj_dict)
404: (8)                    return dict
405: (4)                def __setstate__(self, state):
406: (8)                    self.obj_dict = state
407: (4)                def __get_attribute__(self, attr):
408: (8)                    """Look for default attributes for this node"""
409: (8)                    attr_val = self.obj_dict["attributes"].get(attr, None)
410: (8)                    if attr_val is None:
411: (12)                       default_node_name = self.obj_dict["type"]
412: (12)                       if default_node_name in ("subgraph", "digraph", "cluster"):
413: (16)                           default_node_name = "graph"
414: (12)                       g = self.get_parent_graph()
415: (12)                       if g is not None:
416: (16)                           defaults = g.get_node(default_node_name)
417: (12)                       else:
418: (16)                           return None
419: (12)                       if not isinstance(defaults, (list, tuple)):
420: (16)                           defaults = [defaults]
421: (12)                       for default in defaults:
422: (16)                           attr_val = default.obj_dict["attributes"].get(attr, None)
423: (16)                           if attr_val:
424: (20)                               return attr_val
425: (8)                    else:
426: (12)                       return attr_val
427: (8)                    return None
428: (4)                def set_parent_graph(self, parent_graph):
429: (8)                    self.obj_dict["parent_graph"] = parent_graph
430: (4)                def get_parent_graph(self):
431: (8)                    return self.obj_dict.get("parent_graph", None)
432: (4)                def get_top_graph_type(self):
433: (8)                    """Find the topmost parent graph type for the current object."""
434: (8)                    parent = self.get_parent_graph()
435: (8)                    if parent is None:
436: (12)                       return None
437: (8)                    while True:
438: (12)                       parent_ = parent.get_parent_graph()
439: (12)                       if parent_ == parent:
440: (16)                           break
441: (12)                       parent = parent_
442: (8)                    return parent.obj_dict["type"]
443: (4)                def set(self, name, value):
444: (8)                    """Set an attribute value by name.
445: (8)                    Given an attribute 'name' it will set its value to 'value'.
446: (8)                    There's always the possibility of using the methods:
447: (12)                       set_'name'(value)
448: (8)                    which are defined for all the existing attributes.
449: (8)                    """
450: (8)                    self.obj_dict["attributes"][name] = value
451: (4)                def get(self, name):
452: (8)                    """Get an attribute value by name.
453: (8)                    Given an attribute 'name' it will get its value.
454: (8)                    There's always the possibility of using the methods:
455: (12)                       get_'name'()
456: (8)                    which are defined for all the existing attributes.
457: (8)                    """
458: (8)                    return self.obj_dict["attributes"].get(name, None)
459: (4)                def get_attributes(self):
460: (8)                    """Get attributes of the object"""
461: (8)                    return self.obj_dict["attributes"]
462: (4)                def set_sequence(self, seq):
463: (8)                    """Set sequence"""
464: (8)                    self.obj_dict["sequence"] = seq
465: (4)                def get_sequence(self):
466: (8)                    """Get sequence"""
467: (8)                    return self.obj_dict["sequence"]
468: (4)                @staticmethod
469: (4)                def get_indent(indent, indent_level):
470: (8)                    if isinstance(indent, (int, float)):
471: (12)                       indent_str = " " * int(indent)
472: (8)                    else:
473: (12)                       indent_str = str(indent)
474: (8)                    return indent_str * indent_level
475: (4)                @staticmethod
476: (4)                def _format_attr(key: str, value):
477: (8)                    """Turn a key-value pair into an attribute, properly quoted."""
478: (8)                    if value == "":
479: (12)                       value = '""'
480: (8)                    if value is not None:
481: (12)                       return f"{key}={quote_attr_if_necessary(value)}"
482: (8)                    return key
483: (4)                def formatted_attr_list(self):
484: (8)                    """Return a list of the class's attributes as formatted strings."""
485: (8)                    return [
486: (12)                       self._format_attr(k, v)
487: (12)                       for k, v in self.obj_dict["attributes"].items()
488: (8)                    ]
489: (4)                def attrs_string(self, prefix=""):
490: (8)                    """Format the current attributes list for output.
491: (8)                    The `prefix` string will be prepended if and only if some
492: (8)                    output is generated."""
493: (8)                    attrs = self.formatted_attr_list()
494: (8)                    if not attrs:
495: (12)                       return ""
496: (8)                    return f"{prefix}[{', '.join(attrs)}]"
497: (0)            class Node(Common):
498: (4)                """A graph node.
499: (4)                This class represents a graph's node with all its attributes.
500: (4)                node(name, attribute=value, ...)
501: (4)                name: node's name
502: (4)                All the attributes defined in the Graphviz dot language should
503: (4)                be supported.
504: (4)                """
505: (4)                def __init__(self, name="", obj_dict=None, **attrs):
506: (8)                    if obj_dict is not None:
507: (12)                       self.obj_dict = obj_dict
508: (8)                    else:
509: (12)                       self.obj_dict = {}
510: (12)                       self.obj_dict["attributes"] = dict(attrs)
511: (12)                       self.obj_dict["type"] = "node"
512: (12)                       self.obj_dict["parent_graph"] = None
513: (12)                       self.obj_dict["sequence"] = None
514: (12)                       port = None
515: (12)                       if isinstance(name, str) and not name.startswith('"'):
516: (16)                           idx = name.find(":")
517: (16)                           if idx > 0 and idx + 1 < len(name):
518: (20)                               name, port = name[:idx], name[idx:]
519: (12)                       if isinstance(name, int):
520: (16)                           name = str(name)
521: (12)                       self.obj_dict["name"] = name
522: (12)                       self.obj_dict["port"] = port
523: (4)                def __str__(self):
524: (8)                    return self.to_string()
525: (4)                def set_name(self, node_name):
526: (8)                    """Set the node's name."""
527: (8)                    self.obj_dict["name"] = node_name
528: (4)                def get_name(self):
529: (8)                    """Get the node's name."""
530: (8)                    return self.obj_dict["name"]
531: (4)                def get_port(self):
532: (8)                    """Get the node's port."""
533: (8)                    return self.obj_dict["port"]
534: (4)                def add_style(self, style):
535: (8)                    styles = self.obj_dict["attributes"].get("style", None)
536: (8)                    if not styles and style:
537: (12)                       styles = [style]
538: (8)                    else:
539: (12)                       styles = styles.split(",")
540: (12)                       styles.append(style)
541: (8)                    self.obj_dict["attributes"]["style"] = ",".join(styles)
542: (4)                def to_string(self, indent="", indent_level=1):
543: (8)                    """Return string representation of node in DOT language."""
544: (8)                    indent_str = self.get_indent(indent, indent_level)
545: (8)                    node = quote_id_if_necessary(
546: (12)                       self.obj_dict["name"], unquoted_keywords=("graph", "node", "edge")
547: (8)                    )
548: (8)                    if (
549: (12)                       node in ("graph", "node", "edge")
550: (12)                       and len(self.obj_dict.get("attributes", {})) == 0
551: (8)                    ):
552: (12)                       return ""
553: (8)                    return f"{indent_str}{node}{self.attrs_string(prefix=' ')};"
554: (0)            __generate_attribute_methods(Node, NODE_ATTRIBUTES)
555: (0)            class Edge(Common):
556: (4)                """A graph edge.
557: (4)                This class represents a graph's edge with all its attributes.
558: (4)                edge(src, dst, attribute=value, ...)
559: (4)                src: source node, subgraph or cluster
560: (4)                dst: destination node, subgraph or cluster
561: (4)                `src` and `dst` can be specified as a `Node`, `Subgraph` or
562: (4)                `Cluster` object, or as the name string of such a component.
563: (4)                All the attributes defined in the Graphviz dot language should
564: (4)                be supported.
565: (4)                Attributes can be set through the dynamically generated methods:
566: (5)                 set_[attribute name], i.e. set_label, set_fontname
567: (4)                or directly by using the instance's special dictionary:
568: (5)                 Edge.obj_dict['attributes'][attribute name], i.e.
569: (8)                    edge_instance.obj_dict['attributes']['label']
570: (8)                    edge_instance.obj_dict['attributes']['fontname']
571: (4)                """
572: (4)                def __init__(self, src="", dst="", obj_dict=None, **attrs):
573: (8)                    self.obj_dict = {}
574: (8)                    if isinstance(src, (Node, Subgraph, Cluster)):
575: (12)                       src = src.get_name()
576: (8)                    if isinstance(dst, (Node, Subgraph, Cluster)):
577: (12)                       dst = dst.get_name()
578: (8)                    points = (src, dst)
579: (8)                    self.obj_dict["points"] = points
580: (8)                    if obj_dict is None:
581: (12)                       self.obj_dict["attributes"] = dict(attrs)
582: (12)                       self.obj_dict["type"] = "edge"
583: (12)                       self.obj_dict["parent_graph"] = None
584: (12)                       self.obj_dict["sequence"] = None
585: (8)                    else:
586: (12)                       self.obj_dict = obj_dict
587: (4)                def __str__(self):
588: (8)                    return self.to_string()
589: (4)                def get_source(self):
590: (8)                    """Get the edges source node name."""
591: (8)                    return self.obj_dict["points"][0]
592: (4)                def get_destination(self):
593: (8)                    """Get the edge's destination node name."""
594: (8)                    return self.obj_dict["points"][1]
595: (4)                def __hash__(self):
596: (8)                    return hash(hash(self.get_source()) + hash(self.get_destination()))
597: (4)                def __eq__(self, edge):
598: (8)                    """Compare two edges.
599: (8)                    If the parent graph is directed, arcs linking
600: (8)                    node A to B are considered equal and A->B != B->A
601: (8)                    If the parent graph is undirected, any edge
602: (8)                    connecting two nodes is equal to any other
603: (8)                    edge connecting the same nodes, A->B == B->A
604: (8)                    """
605: (8)                    if not isinstance(edge, Edge):
606: (12)                       raise pydot.Error("Can not compare an edge to a non-edge object.")
607: (8)                    if self.get_top_graph_type() == "graph":
608: (12)                       if (
609: (16)                           self.get_source() == edge.get_source()
610: (16)                           and self.get_destination() == edge.get_destination()
611: (12)                       ) or (
612: (16)                           edge.get_source() == self.get_destination()
613: (16)                           and edge.get_destination() == self.get_source()
614: (12)                       ):
615: (16)                           return True
616: (8)                    else:
617: (12)                       if (
618: (16)                           self.get_source() == edge.get_source()
619: (16)                           and self.get_destination() == edge.get_destination()
620: (12)                       ):
621: (16)                           return True
622: (8)                    return False
623: (4)                def parse_node_ref(self, node_str):
624: (8)                    if not isinstance(node_str, str):
625: (12)                       return node_str
626: (8)                    if node_str.startswith('"') and node_str.endswith('"'):
627: (12)                       return node_str
628: (8)                    node_port_idx = node_str.rfind(":")
629: (8)                    if (
630: (12)                       node_port_idx > 0
631: (12)                       and node_str[0] == '"'
632: (12)                       and node_str[node_port_idx - 1] == '"'
633: (8)                    ):
634: (12)                       return node_str
635: (8)                    if node_port_idx > 0:
636: (12)                       a = node_str[:node_port_idx]
637: (12)                       b = node_str[node_port_idx + 1 :]
638: (12)                       node = quote_id_if_necessary(a)
639: (12)                       node += ":" + quote_id_if_necessary(b)
640: (12)                       return node
641: (8)                    return quote_id_if_necessary(node_str)
642: (4)                def to_string(self, indent="", indent_level=1):
643: (8)                    """Return string representation of edge in DOT language."""
644: (8)                    src = self.parse_node_ref(self.get_source())
645: (8)                    dst = self.parse_node_ref(self.get_destination())
646: (8)                    indent_str = self.get_indent(indent, indent_level)
647: (8)                    if isinstance(src, frozendict):
648: (12)                       sgraph = Subgraph(obj_dict=src)
649: (12)                       edge = [
650: (16)                           sgraph.to_string(
651: (20)                               indent=indent, indent_level=indent_level, inline=True
652: (16)                           )
653: (12)                       ]
654: (8)                    elif isinstance(src, int):
655: (12)                       edge = [str(src)]
656: (8)                    else:
657: (12)                       edge = [src]
658: (8)                    if self.get_top_graph_type() == "digraph":
659: (12)                       edge.append("->")
660: (8)                    else:
661: (12)                       edge.append("--")
662: (8)                    if isinstance(dst, frozendict):
663: (12)                       sgraph = Subgraph(obj_dict=dst)
664: (12)                       edge.append(
665: (16)                           sgraph.to_string(
666: (20)                               indent=indent, indent_level=indent_level, inline=True
667: (16)                           )
668: (12)                       )
669: (8)                    elif isinstance(dst, int):
670: (12)                       edge.append(str(dst))
671: (8)                    else:
672: (12)                       edge.append(dst)
673: (8)                    return f"{indent_str}{' '.join(edge)}{self.attrs_string(prefix=' ')};"
674: (0)            __generate_attribute_methods(Edge, EDGE_ATTRIBUTES)
675: (0)            class Graph(Common):
676: (4)                """Class representing a graph in Graphviz's dot language.
677: (4)                This class implements the methods to work on a representation
678: (4)                of a graph in Graphviz's dot language.
679: (4)                graph(  graph_name='G', graph_type='digraph',
680: (8)                    strict=False, suppress_disconnected=False, attribute=value, ...)
681: (4)                graph_name:
682: (8)                    the graph's name
683: (4)                graph_type:
684: (8)                    can be 'graph' or 'digraph'
685: (4)                suppress_disconnected:
686: (8)                    defaults to False, which will remove from the
687: (8)                    graph any disconnected nodes.
688: (4)                simplify:
689: (8)                    if True it will avoid displaying equal edges, i.e.
690: (8)                    only one edge between two nodes. removing the
691: (8)                    duplicated ones.
692: (4)                All the attributes defined in the Graphviz dot language should
693: (4)                be supported.
694: (4)                Attributes can be set through the dynamically generated methods:
695: (5)                 set_[attribute name], i.e. set_size, set_fontname
696: (4)                or using the instance's attributes:
697: (5)                 Graph.obj_dict['attributes'][attribute name], i.e.
698: (8)                    graph_instance.obj_dict['attributes']['label']
699: (8)                    graph_instance.obj_dict['attributes']['fontname']
700: (4)                """
701: (4)                def __init__(
702: (8)                    self,
703: (8)                    graph_name="G",
704: (8)                    obj_dict=None,
705: (8)                    graph_type="digraph",
706: (8)                    strict=False,
707: (8)                    suppress_disconnected=False,
708: (8)                    simplify=False,
709: (8)                    **attrs,
710: (4)                ):
711: (8)                    if obj_dict is not None:
712: (12)                       self.obj_dict = obj_dict
713: (8)                    else:
714: (12)                       self.obj_dict = {}
715: (12)                       self.obj_dict["attributes"] = dict(attrs)
716: (12)                       if graph_type not in ["graph", "digraph"]:
717: (16)                           raise pydot.Error(
718: (20)                               f'Invalid type "{graph_type}". '
719: (20)                               "Accepted graph types are: graph, digraph"
720: (16)                           )
721: (12)                       self.obj_dict["name"] = graph_name
722: (12)                       self.obj_dict["type"] = graph_type
723: (12)                       self.obj_dict["strict"] = strict
724: (12)                       self.obj_dict["suppress_disconnected"] = suppress_disconnected
725: (12)                       self.obj_dict["simplify"] = simplify
726: (12)                       self.obj_dict["current_child_sequence"] = 1
727: (12)                       self.obj_dict["nodes"] = {}
728: (12)                       self.obj_dict["edges"] = {}
729: (12)                       self.obj_dict["subgraphs"] = {}
730: (12)                       self.set_parent_graph(self)
731: (4)                def __str__(self):
732: (8)                    return self.to_string()
733: (4)                def get_graph_type(self):
734: (8)                    return self.obj_dict["type"]
735: (4)                def set_graph_defaults(self, **attrs):
736: (8)                    self.add_node(Node("graph", **attrs))
737: (4)                def get_graph_defaults(self, **attrs):
738: (8)                    graph_nodes = self.get_node("graph")
739: (8)                    if isinstance(graph_nodes, (list, tuple)):
740: (12)                       return [node.get_attributes() for node in graph_nodes]
741: (8)                    return graph_nodes.get_attributes()
742: (4)                def set_node_defaults(self, **attrs):
743: (8)                    """Define default node attributes.
744: (8)                    These attributes only apply to nodes added to the graph after
745: (8)                    calling this method.
746: (8)                    """
747: (8)                    self.add_node(Node("node", **attrs))
748: (4)                def get_node_defaults(self, **attrs):
749: (8)                    graph_nodes = self.get_node("node")
750: (8)                    if isinstance(graph_nodes, (list, tuple)):
751: (12)                       return [node.get_attributes() for node in graph_nodes]
752: (8)                    return graph_nodes.get_attributes()
753: (4)                def set_edge_defaults(self, **attrs):
754: (8)                    self.add_node(Node("edge", **attrs))
755: (4)                def get_edge_defaults(self, **attrs):
756: (8)                    graph_nodes = self.get_node("edge")
757: (8)                    if isinstance(graph_nodes, (list, tuple)):
758: (12)                       return [node.get_attributes() for node in graph_nodes]
759: (8)                    return graph_nodes.get_attributes()
760: (4)                def set_simplify(self, simplify):
761: (8)                    """Set whether to simplify or not.
762: (8)                    If True it will avoid displaying equal edges, i.e.
763: (8)                    only one edge between two nodes. removing the
764: (8)                    duplicated ones.
765: (8)                    """
766: (8)                    self.obj_dict["simplify"] = simplify
767: (4)                def get_simplify(self):
768: (8)                    """Get whether to simplify or not.
769: (8)                    Refer to set_simplify for more information.
770: (8)                    """
771: (8)                    return self.obj_dict["simplify"]
772: (4)                def set_type(self, graph_type):
773: (8)                    """Set the graph's type, 'graph' or 'digraph'."""
774: (8)                    self.obj_dict["type"] = graph_type
775: (4)                def get_type(self):
776: (8)                    """Get the graph's type, 'graph' or 'digraph'."""
777: (8)                    return self.obj_dict["type"]
778: (4)                def set_name(self, graph_name):
779: (8)                    """Set the graph's name."""
780: (8)                    self.obj_dict["name"] = graph_name
781: (4)                def get_name(self):
782: (8)                    """Get the graph's name."""
783: (8)                    return self.obj_dict["name"]
784: (4)                def set_strict(self, val):
785: (8)                    """Set graph to 'strict' mode.
786: (8)                    This option is only valid for top level graphs.
787: (8)                    """
788: (8)                    self.obj_dict["strict"] = val
789: (4)                def get_strict(self, val):
790: (8)                    """Get graph's 'strict' mode (True, False).
791: (8)                    This option is only valid for top level graphs.
792: (8)                    """
793: (8)                    return self.obj_dict["strict"]
794: (4)                def set_suppress_disconnected(self, val):
795: (8)                    """Suppress disconnected nodes in the output graph.
796: (8)                    This option will skip nodes in
797: (8)                    the graph with no incoming or outgoing
798: (8)                    edges. This option works also
799: (8)                    for subgraphs and has effect only in the
800: (8)                    current graph/subgraph.
801: (8)                    """
802: (8)                    self.obj_dict["suppress_disconnected"] = val
803: (4)                def get_suppress_disconnected(self, val):
804: (8)                    """Get if suppress disconnected is set.
805: (8)                    Refer to set_suppress_disconnected for more information.
806: (8)                    """
807: (8)                    return self.obj_dict["suppress_disconnected"]
808: (4)                def get_next_sequence_number(self):
809: (8)                    seq = self.obj_dict["current_child_sequence"]
810: (8)                    self.obj_dict["current_child_sequence"] += 1
811: (8)                    return seq
812: (4)                def add_node(self, graph_node):
813: (8)                    """Adds a node object to the graph.
814: (8)                    It takes a node object as its only argument and returns
815: (8)                    None.
816: (8)                    """
817: (8)                    if not isinstance(graph_node, Node):
818: (12)                       raise TypeError(
819: (16)                           "add_node() received "
820: (16)                           + "a non node class object: "
821: (16)                           + str(graph_node)
822: (12)                       )
823: (8)                    node = self.get_node(graph_node.get_name())
824: (8)                    if not node:
825: (12)                       self.obj_dict["nodes"][graph_node.get_name()] = [
826: (16)                           graph_node.obj_dict
827: (12)                       ]
828: (8)                    else:
829: (12)                       self.obj_dict["nodes"][graph_node.get_name()].append(
830: (16)                           graph_node.obj_dict
831: (12)                       )
832: (8)                    if not node or graph_node.get_parent_graph() is None:
833: (12)                       graph_node.set_parent_graph(self.get_parent_graph())
834: (8)                    graph_node.set_sequence(self.get_next_sequence_number())
835: (4)                def del_node(self, name, index=None):
836: (8)                    """Delete a node from the graph.
837: (8)                    Given a node's name all node(s) with that same name
838: (8)                    will be deleted if 'index' is not specified or set
839: (8)                    to None.
840: (8)                    If there are several nodes with that same name and
841: (8)                    'index' is given, only the node in that position
842: (8)                    will be deleted.
843: (8)                    'index' should be an integer specifying the position
844: (8)                    of the node to delete. If index is larger than the
845: (8)                    number of nodes with that name, no action is taken.
846: (8)                    If nodes are deleted it returns True. If no action
847: (8)                    is taken it returns False.
848: (8)                    """
849: (8)                    if isinstance(name, Node):
850: (12)                       name = name.get_name()
851: (8)                    if name in self.obj_dict["nodes"]:
852: (12)                       if index is not None and index < len(self.obj_dict["nodes"][name]):
853: (16)                           del self.obj_dict["nodes"][name][index]
854: (16)                           return True
855: (12)                       else:
856: (16)                           del self.obj_dict["nodes"][name]
857: (16)                           return True
858: (8)                    return False
859: (4)                def get_node(self, name):
860: (8)                    """Retrieve a node from the graph.
861: (8)                    Given a node's name the corresponding Node
862: (8)                    instance will be returned.
863: (8)                    If one or more nodes exist with that name a list of
864: (8)                    Node instances is returned.
865: (8)                    An empty list is returned otherwise.
866: (8)                    """
867: (8)                    match = []
868: (8)                    if name in self.obj_dict["nodes"]:
869: (12)                       match.extend(
870: (16)                           [
871: (20)                               Node(obj_dict=obj_dict)
872: (20)                               for obj_dict in self.obj_dict["nodes"][name]
873: (16)                           ]
874: (12)                       )
875: (8)                    return match
876: (4)                def get_nodes(self):
877: (8)                    """Get the list of Node instances."""
878: (8)                    return self.get_node_list()
879: (4)                def get_node_list(self):
880: (8)                    """Get the list of Node instances.
881: (8)                    This method returns the list of Node instances
882: (8)                    composing the graph.
883: (8)                    """
884: (8)                    node_objs = []
885: (8)                    for node in self.obj_dict["nodes"]:
886: (12)                       obj_dict_list = self.obj_dict["nodes"][node]
887: (12)                       node_objs.extend([Node(obj_dict=obj_d) for obj_d in obj_dict_list])
888: (8)                    return node_objs
889: (4)                def add_edge(self, graph_edge):
890: (8)                    """Adds an edge object to the graph.
891: (8)                    It takes a edge object as its only argument and returns
892: (8)                    None.
893: (8)                    """
894: (8)                    if not isinstance(graph_edge, Edge):
895: (12)                       raise TypeError(
896: (16)                           "add_edge() received a non edge class object: "
897: (16)                           + str(graph_edge)
898: (12)                       )
899: (8)                    edge_points = (graph_edge.get_source(), graph_edge.get_destination())
900: (8)                    if edge_points in self.obj_dict["edges"]:
901: (12)                       edge_list = self.obj_dict["edges"][edge_points]
902: (12)                       edge_list.append(graph_edge.obj_dict)
903: (8)                    else:
904: (12)                       self.obj_dict["edges"][edge_points] = [graph_edge.obj_dict]
905: (8)                    graph_edge.set_sequence(self.get_next_sequence_number())
906: (8)                    graph_edge.set_parent_graph(self.get_parent_graph())
907: (4)                def del_edge(self, src_or_list, dst=None, index=None):
908: (8)                    """Delete an edge from the graph.
909: (8)                    Given an edge's (source, destination) node names all
910: (8)                    matching edges(s) will be deleted if 'index' is not
911: (8)                    specified or set to None.
912: (8)                    If there are several matching edges and 'index' is
913: (8)                    given, only the edge in that position will be deleted.
914: (8)                    'index' should be an integer specifying the position
915: (8)                    of the edge to delete. If index is larger than the
916: (8)                    number of matching edges, no action is taken.
917: (8)                    If edges are deleted it returns True. If no action
918: (8)                    is taken it returns False.
919: (8)                    """
920: (8)                    if isinstance(src_or_list, (list, tuple)):
921: (12)                       if dst is not None and isinstance(dst, int):
922: (16)                           index = dst
923: (12)                       src, dst = src_or_list
924: (8)                    else:
925: (12)                       src, dst = src_or_list, dst
926: (8)                    if isinstance(src, Node):
927: (12)                       src = src.get_name()
928: (8)                    if isinstance(dst, Node):
929: (12)                       dst = dst.get_name()
930: (8)                    if (src, dst) in self.obj_dict["edges"]:
931: (12)                       if index is not None and index < len(
932: (16)                           self.obj_dict["edges"][(src, dst)]
933: (12)                       ):
934: (16)                           del self.obj_dict["edges"][(src, dst)][index]
935: (16)                           return True
936: (12)                       else:
937: (16)                           del self.obj_dict["edges"][(src, dst)]
938: (16)                           return True
939: (8)                    return False
940: (4)                def get_edge(self, src_or_list, dst=None):
941: (8)                    """Retrieved an edge from the graph.
942: (8)                    Given an edge's source and destination the corresponding
943: (8)                    Edge instance(s) will be returned.
944: (8)                    If one or more edges exist with that source and destination
945: (8)                    a list of Edge instances is returned.
946: (8)                    An empty list is returned otherwise.
947: (8)                    """
948: (8)                    if isinstance(src_or_list, (list, tuple)) and dst is None:
949: (12)                       edge_points = tuple(src_or_list)
950: (12)                       edge_points_reverse = (edge_points[1], edge_points[0])
951: (8)                    else:
952: (12)                       edge_points = (src_or_list, dst)
953: (12)                       edge_points_reverse = (dst, src_or_list)
954: (8)                    match = []
955: (8)                    if edge_points in self.obj_dict["edges"] or (
956: (12)                       self.get_top_graph_type() == "graph"
957: (12)                       and edge_points_reverse in self.obj_dict["edges"]
958: (8)                    ):
959: (12)                       edges_obj_dict = self.obj_dict["edges"].get(
960: (16)                           edge_points,
961: (16)                           self.obj_dict["edges"].get(edge_points_reverse, None),
962: (12)                       )
963: (12)                       for edge_obj_dict in edges_obj_dict:
964: (16)                           match.append(
965: (20)                               Edge(
966: (24)                                   edge_points[0], edge_points[1], obj_dict=edge_obj_dict
967: (20)                               )
968: (16)                           )
969: (8)                    return match
970: (4)                def get_edges(self):
971: (8)                    return self.get_edge_list()
972: (4)                def get_edge_list(self):
973: (8)                    """Get the list of Edge instances.
974: (8)                    This method returns the list of Edge instances
975: (8)                    composing the graph.
976: (8)                    """
977: (8)                    edge_objs = []
978: (8)                    for edge in self.obj_dict["edges"]:
979: (12)                       obj_dict_list = self.obj_dict["edges"][edge]
980: (12)                       edge_objs.extend([Edge(obj_dict=obj_d) for obj_d in obj_dict_list])
981: (8)                    return edge_objs
982: (4)                def add_subgraph(self, sgraph):
983: (8)                    """Adds an subgraph object to the graph.
984: (8)                    It takes a subgraph object as its only argument and returns
985: (8)                    None.
986: (8)                    """
987: (8)                    if not isinstance(sgraph, Subgraph) and not isinstance(
988: (12)                       sgraph, Cluster
989: (8)                    ):
990: (12)                       raise TypeError(
991: (16)                           "add_subgraph() received a non subgraph class object:"
992: (16)                           + str(sgraph)
993: (12)                       )
994: (8)                    if sgraph.get_name() in self.obj_dict["subgraphs"]:
995: (12)                       sgraph_list = self.obj_dict["subgraphs"][sgraph.get_name()]
996: (12)                       sgraph_list.append(sgraph.obj_dict)
997: (8)                    else:
998: (12)                       self.obj_dict["subgraphs"][sgraph.get_name()] = [sgraph.obj_dict]
999: (8)                    sgraph.set_sequence(self.get_next_sequence_number())
1000: (8)                   sgraph.set_parent_graph(self.get_parent_graph())
1001: (4)               def get_subgraph(self, name):
1002: (8)                   """Retrieved a subgraph from the graph.
1003: (8)                   Given a subgraph's name the corresponding
1004: (8)                   Subgraph instance will be returned.
1005: (8)                   If one or more subgraphs exist with the same name, a list of
1006: (8)                   Subgraph instances is returned.
1007: (8)                   An empty list is returned otherwise.
1008: (8)                   """
1009: (8)                   match = []
1010: (8)                   if name in self.obj_dict["subgraphs"]:
1011: (12)                      sgraphs_obj_dict = self.obj_dict["subgraphs"].get(name)
1012: (12)                      for obj_dict_list in sgraphs_obj_dict:
1013: (16)                          match.append(Subgraph(obj_dict=obj_dict_list))
1014: (8)                   return match
1015: (4)               def get_subgraphs(self):
1016: (8)                   return self.get_subgraph_list()
1017: (4)               def get_subgraph_list(self):
1018: (8)                   """Get the list of Subgraph instances.
1019: (8)                   This method returns the list of Subgraph instances
1020: (8)                   in the graph.
1021: (8)                   """
1022: (8)                   sgraph_objs = []
1023: (8)                   for sgraph in self.obj_dict["subgraphs"]:
1024: (12)                      obj_dict_list = self.obj_dict["subgraphs"][sgraph]
1025: (12)                      sgraph_objs.extend(
1026: (16)                          [Subgraph(obj_dict=obj_d) for obj_d in obj_dict_list]
1027: (12)                      )
1028: (8)                   return sgraph_objs
1029: (4)               def set_parent_graph(self, parent_graph):
1030: (8)                   self.obj_dict["parent_graph"] = parent_graph
1031: (8)                   for k in self.obj_dict["nodes"]:
1032: (12)                      obj_list = self.obj_dict["nodes"][k]
1033: (12)                      for obj in obj_list:
1034: (16)                          obj["parent_graph"] = parent_graph
1035: (8)                   for k in self.obj_dict["edges"]:
1036: (12)                      obj_list = self.obj_dict["edges"][k]
1037: (12)                      for obj in obj_list:
1038: (16)                          obj["parent_graph"] = parent_graph
1039: (8)                   for k in self.obj_dict["subgraphs"]:
1040: (12)                      obj_list = self.obj_dict["subgraphs"][k]
1041: (12)                      for obj in obj_list:
1042: (16)                          Graph(obj_dict=obj).set_parent_graph(parent_graph)
1043: (4)               def to_string(self, indent="", indent_level=0, inline=False):
1044: (8)                   """Return string representation of graph in DOT language.
1045: (8)                   @return: graph and subelements
1046: (8)                   @rtype: `str`
1047: (8)                   """
1048: (8)                   indent_str = self.get_indent(indent, indent_level)
1049: (8)                   child_indent = self.get_indent(indent, indent_level + 1)
1050: (8)                   graph = []
1051: (8)                   if not inline:
1052: (12)                      graph.append(indent_str)
1053: (8)                   first_line = []
1054: (8)                   if self == self.get_parent_graph() and self.obj_dict.get(
1055: (12)                      "strict", False
1056: (8)                   ):
1057: (12)                      first_line.append("strict")
1058: (8)                   graph_type = self.obj_dict["type"]
1059: (8)                   if graph_type != "subgraph" or self.obj_dict.get("show_keyword", True):
1060: (12)                      first_line.append(graph_type)
1061: (12)                      graph_name = self.obj_dict.get("name")
1062: (12)                      if graph_name:
1063: (16)                          first_line.append(quote_id_if_necessary(graph_name))
1064: (8)                   first_line.append("{\n")
1065: (8)                   graph.append(" ".join(first_line))
1066: (8)                   graph.extend(
1067: (12)                      f"{child_indent}{a};\n" for a in self.formatted_attr_list()
1068: (8)                   )
1069: (8)                   edges_done = set()
1070: (8)                   edge_obj_dicts = []
1071: (8)                   for k in self.obj_dict["edges"]:
1072: (12)                      edge_obj_dicts.extend(self.obj_dict["edges"][k])
1073: (8)                   if edge_obj_dicts:
1074: (12)                      edge_src_set, edge_dst_set = list(
1075: (16)                          zip(*[obj["points"] for obj in edge_obj_dicts])
1076: (12)                      )
1077: (12)                      edge_src_set, edge_dst_set = set(edge_src_set), set(edge_dst_set)
1078: (8)                   else:
1079: (12)                      edge_src_set, edge_dst_set = set(), set()
1080: (8)                   node_obj_dicts = []
1081: (8)                   for k in self.obj_dict["nodes"]:
1082: (12)                      node_obj_dicts.extend(self.obj_dict["nodes"][k])
1083: (8)                   sgraph_obj_dicts = []
1084: (8)                   for k in self.obj_dict["subgraphs"]:
1085: (12)                      sgraph_obj_dicts.extend(self.obj_dict["subgraphs"][k])
1086: (8)                   obj_list = [
1087: (12)                      (obj["sequence"], obj)
1088: (12)                      for obj in (edge_obj_dicts + node_obj_dicts + sgraph_obj_dicts)
1089: (8)                   ]
1090: (8)                   obj_list.sort(key=lambda x: x[0])
1091: (8)                   for idx, obj in obj_list:
1092: (12)                      if obj["type"] == "node":
1093: (16)                          node = Node(obj_dict=obj)
1094: (16)                          if self.obj_dict.get("suppress_disconnected", False):
1095: (20)                              if (
1096: (24)                                  node.get_name() not in edge_src_set
1097: (24)                                  and node.get_name() not in edge_dst_set
1098: (20)                              ):
1099: (24)                                  continue
1100: (16)                          node_str = node.to_string(
1101: (20)                              indent=indent, indent_level=indent_level + 1
1102: (16)                          )
1103: (16)                          graph.append(f"{node_str}\n")
1104: (12)                      elif obj["type"] == "edge":
1105: (16)                          edge = Edge(obj_dict=obj)
1106: (16)                          if self.obj_dict.get("simplify", False) and edge in edges_done:
1107: (20)                              continue
1108: (16)                          edge_str = edge.to_string(
1109: (20)                              indent=indent, indent_level=indent_level + 1
1110: (16)                          )
1111: (16)                          graph.append(f"{edge_str}\n")
1112: (16)                          edges_done.add(edge)
1113: (12)                      else:
1114: (16)                          sgraph_str = Subgraph(obj_dict=obj).to_string(
1115: (20)                              indent=indent, indent_level=indent_level + 1
1116: (16)                          )
1117: (16)                          graph.append(f"{sgraph_str}\n")
1118: (8)                   graph.append(f"{indent_str}}}")
1119: (8)                   if not inline:
1120: (12)                      graph.append("\n")
1121: (8)                   return "".join(graph)
1122: (0)           __generate_attribute_methods(Graph, GRAPH_ATTRIBUTES)
1123: (0)           class Subgraph(Graph):
1124: (4)               """Class representing a subgraph in Graphviz's dot language.
1125: (4)               This class implements the methods to work on a representation
1126: (4)               of a subgraph in Graphviz's dot language.
1127: (4)               subgraph(graph_name='subG',
1128: (13)                       suppress_disconnected=False,
1129: (13)                       attribute=value,
1130: (13)                       ...)
1131: (4)               graph_name:
1132: (8)                   the subgraph's name
1133: (4)               suppress_disconnected:
1134: (8)                   defaults to false, which will remove from the
1135: (8)                   subgraph any disconnected nodes.
1136: (4)               All the attributes defined in the Graphviz dot language should
1137: (4)               be supported.
1138: (4)               Attributes can be set through the dynamically generated methods:
1139: (5)                set_[attribute name], i.e. set_size, set_fontname
1140: (4)               or using the instance's attributes:
1141: (5)                Subgraph.obj_dict['attributes'][attribute name], i.e.
1142: (8)                   subgraph_instance.obj_dict['attributes']['label']
1143: (8)                   subgraph_instance.obj_dict['attributes']['fontname']
1144: (4)               """
1145: (4)               def __init__(
1146: (8)                   self,
1147: (8)                   graph_name="",
1148: (8)                   obj_dict=None,
1149: (8)                   suppress_disconnected=False,
1150: (8)                   simplify=False,
1151: (8)                   **attrs,
1152: (4)               ):
1153: (8)                   Graph.__init__(
1154: (12)                      self,
1155: (12)                      graph_name=graph_name,
1156: (12)                      obj_dict=obj_dict,
1157: (12)                      suppress_disconnected=suppress_disconnected,
1158: (12)                      simplify=simplify,
1159: (12)                      **attrs,
1160: (8)                   )
1161: (8)                   if obj_dict is None:
1162: (12)                      self.obj_dict["type"] = "subgraph"
1163: (0)           class Cluster(Graph):
1164: (4)               """Class representing a cluster in Graphviz's dot language.
1165: (4)               This class implements the methods to work on a representation
1166: (4)               of a cluster in Graphviz's dot language.
1167: (4)               cluster(graph_name='subG',
1168: (12)                      suppress_disconnected=False,
1169: (12)                      attribute=value,
1170: (12)                      ...)
1171: (4)               graph_name:
1172: (8)                   the cluster's name
1173: (8)                   (the string 'cluster' will be always prepended)
1174: (4)               suppress_disconnected:
1175: (8)                   defaults to false, which will remove from the
1176: (8)                   cluster any disconnected nodes.
1177: (4)               All the attributes defined in the Graphviz dot language should
1178: (4)               be supported.
1179: (4)               Attributes can be set through the dynamically generated methods:
1180: (5)                set_[attribute name], i.e. set_color, set_fontname
1181: (4)               or using the instance's attributes:
1182: (5)                Cluster.obj_dict['attributes'][attribute name], i.e.
1183: (8)                   cluster_instance.obj_dict['attributes']['label']
1184: (8)                   cluster_instance.obj_dict['attributes']['fontname']
1185: (4)               """
1186: (4)               def __init__(
1187: (8)                   self,
1188: (8)                   graph_name="subG",
1189: (8)                   obj_dict=None,
1190: (8)                   suppress_disconnected=False,
1191: (8)                   simplify=False,
1192: (8)                   **attrs,
1193: (4)               ):
1194: (8)                   Graph.__init__(
1195: (12)                      self,
1196: (12)                      graph_name=graph_name,
1197: (12)                      obj_dict=obj_dict,
1198: (12)                      suppress_disconnected=suppress_disconnected,
1199: (12)                      simplify=simplify,
1200: (12)                      **attrs,
1201: (8)                   )
1202: (8)                   if obj_dict is None:
1203: (12)                      self.obj_dict["type"] = "subgraph"
1204: (12)                      self.obj_dict["name"] = quote_id_if_necessary(
1205: (16)                          "cluster_" + graph_name
1206: (12)                      )
1207: (0)           __generate_attribute_methods(Cluster, CLUSTER_ATTRIBUTES)
1208: (0)           class Dot(Graph):
1209: (4)               """A container for handling a dot language file.
1210: (4)               This class implements methods to write and process
1211: (4)               a dot language file. It is a derived class of
1212: (4)               the base class 'Graph'.
1213: (4)               """
1214: (4)               def __init__(self, *argsl, **argsd):
1215: (8)                   Graph.__init__(self, *argsl, **argsd)
1216: (8)                   self.shape_files = []
1217: (8)                   self.formats = OUTPUT_FORMATS
1218: (8)                   self.prog = "dot"
1219: (4)               def __getstate__(self):
1220: (8)                   state = {
1221: (12)                      "obj_dict": copy.copy(self.obj_dict),
1222: (12)                      "prog": self.prog,
1223: (12)                      "shape_files": copy.deepcopy(self.shape_files),
1224: (12)                      "formats": copy.copy(self.formats),
1225: (8)                   }
1226: (8)                   return state
1227: (4)               def __setstate__(self, state):
1228: (8)                   if "obj_dict" not in state:
1229: (12)                      state = {"obj_dict": state}
1230: (8)                   self.obj_dict = state.get("obj_dict", {})
1231: (8)                   self.prog = state.get("prog", "dot")
1232: (8)                   self.shape_files = state.get("shape_files", [])
1233: (8)                   self.formats = state.get("formats", OUTPUT_FORMATS)
1234: (4)               def set_shape_files(self, file_paths):
1235: (8)                   """Add the paths of the required image files.
1236: (8)                   If the graph needs graphic objects to
1237: (8)                   be used as shapes or otherwise
1238: (8)                   those need to be in the same folder as
1239: (8)                   the graph is going to be rendered
1240: (8)                   from. Alternatively the absolute path to
1241: (8)                   the files can be specified when
1242: (8)                   including the graphics in the graph.
1243: (8)                   The files in the location pointed to by
1244: (8)                   the path(s) specified as arguments
1245: (8)                   to this method will be copied to
1246: (8)                   the same temporary location where the
1247: (8)                   graph is going to be rendered.
1248: (8)                   """
1249: (8)                   if isinstance(file_paths, str):
1250: (12)                      self.shape_files.append(file_paths)
1251: (8)                   if isinstance(file_paths, (list, tuple)):
1252: (12)                      self.shape_files.extend(file_paths)
1253: (4)               def set_prog(self, prog):
1254: (8)                   """Sets the default program.
1255: (8)                   Sets the default program in charge of processing
1256: (8)                   the dot file into a graph.
1257: (8)                   """
1258: (8)                   self.prog = prog
1259: (4)               def write(self, path, prog=None, format="raw", encoding=None):
1260: (8)                   """Writes a graph to a file.
1261: (8)                   Given a filename 'path' it will open/create and truncate
1262: (8)                   such file and write on it a representation of the graph
1263: (8)                   defined by the dot object in the format specified by
1264: (8)                   'format' and using the encoding specified by `encoding` for text.
1265: (8)                   The format 'raw' is used to dump the string representation
1266: (8)                   of the Dot object, without further processing.
1267: (8)                   The output can be processed by any of graphviz tools, defined
1268: (8)                   in 'prog', which defaults to 'dot'
1269: (8)                   Returns True or False according to the success of the write
1270: (8)                   operation.
1271: (8)                   There's also the preferred possibility of using:
1272: (12)                      write_'format'(path, prog='program')
1273: (8)                   which are automatically defined for all the supported formats.
1274: (8)                   [write_ps(), write_gif(), write_dia(), ...]
1275: (8)                   The encoding is passed to `open` [1].
1276: (8)                   [1] https://docs.python.org/3/library/functions.html#open
1277: (8)                   """
1278: (8)                   if prog is None:
1279: (12)                      prog = self.prog
1280: (8)                   if format == "raw":
1281: (12)                      s = self.to_string()
1282: (12)                      with open(path, mode="w", encoding=encoding) as f:
1283: (16)                          f.write(s)
1284: (8)                   else:
1285: (12)                      s = self.create(prog, format, encoding=encoding)
1286: (12)                      with open(path, mode="wb") as f:
1287: (16)                          f.write(s)
1288: (8)                   return True
1289: (4)               def create(self, prog=None, format="ps", encoding=None):
1290: (8)                   """Creates and returns a binary image for the graph.
1291: (8)                   create will write the graph to a temporary dot file in the
1292: (8)                   encoding specified by `encoding` and process it with the
1293: (8)                   program given by 'prog' (which defaults to 'twopi'), reading
1294: (8)                   the binary image output and return it as `bytes`.
1295: (8)                   There's also the preferred possibility of using:
1296: (12)                      create_'format'(prog='program')
1297: (8)                   which are automatically defined for all the supported formats,
1298: (8)                   for example:
1299: (10)                    - `create_ps()`
1300: (10)                    - `create_gif()`
1301: (10)                    - `create_dia()`
1302: (8)                   If 'prog' is a list, instead of a string,
1303: (8)                   then the fist item is expected to be the program name,
1304: (8)                   followed by any optional command-line arguments for it:
1305: (12)                      [ 'twopi', '-Tdot', '-s10' ]
1306: (8)                   @param prog: either:
1307: (10)                    - name of GraphViz executable that
1308: (12)                      can be found in the `$PATH`, or
1309: (10)                    - absolute path to GraphViz executable.
1310: (10)                    If you have added GraphViz to the `$PATH` and
1311: (10)                    use its executables as installed
1312: (10)                    (without renaming any of them)
1313: (10)                    then their names are:
1314: (12)                      - `'dot'`
1315: (12)                      - `'twopi'`
1316: (12)                      - `'neato'`
1317: (12)                      - `'circo'`
1318: (12)                      - `'fdp'`
1319: (12)                      - `'sfdp'`
1320: (10)                    On Windows, these have the notorious ".exe" extension that,
1321: (10)                    only for the above strings, will be added automatically.
1322: (10)                    The `$PATH` is inherited from `os.env['PATH']` and
1323: (10)                    passed to `subprocess.Popen` using the `env` argument.
1324: (10)                    If you haven't added GraphViz to your `$PATH` on Windows,
1325: (10)                    then you may want to give the absolute path to the
1326: (10)                    executable (for example, to `dot.exe`) in `prog`.
1327: (8)                   """
1328: (8)                   if prog is None:
1329: (12)                      prog = self.prog
1330: (8)                   assert prog is not None
1331: (8)                   if isinstance(prog, (list, tuple)):
1332: (12)                      prog, args = prog[0], prog[1:]
1333: (8)                   else:
1334: (12)                      args = []
1335: (8)                   with tempfile.TemporaryDirectory(
1336: (12)                      ignore_cleanup_errors=True
1337: (8)                   ) as tmp_dir:
1338: (12)                      fp = tempfile.NamedTemporaryFile(dir=tmp_dir, delete=False)
1339: (12)                      fp.close()
1340: (12)                      self.write(fp.name, encoding=encoding)
1341: (12)                      for img in self.shape_files:
1342: (16)                          outfile = os.path.join(tmp_dir, os.path.basename(img))
1343: (16)                          with open(img, "rb") as img_in, open(outfile, "wb") as img_out:
1344: (20)                              img_data = img_in.read()
1345: (20)                              img_out.write(img_data)
1346: (12)                      arguments = [f"-T{format}"] + args + [fp.name]
1347: (12)                      try:
1348: (16)                          stdout_data, stderr_data, process = call_graphviz(
1349: (20)                              program=prog,
1350: (20)                              arguments=arguments,
1351: (20)                              working_dir=tmp_dir,
1352: (16)                          )
1353: (12)                      except OSError as e:
1354: (16)                          if e.errno == errno.ENOENT:
1355: (20)                              args = list(e.args)
1356: (20)                              args[1] = f'"{prog}" not found in path.'
1357: (20)                              raise OSError(*args)
1358: (16)                          else:
1359: (20)                              raise
1360: (8)                   if process.returncode != 0:
1361: (12)                      code = process.returncode
1362: (12)                      print(
1363: (16)                          f'"{prog}" with args {arguments} returned code: {code}\n\n'
1364: (16)                          f"stdout, stderr:\n {stdout_data}\n{stderr_data}\n"
1365: (12)                      )
1366: (8)                   assert process.returncode == 0, (
1367: (12)                      f'"{prog}" with args {arguments} '
1368: (12)                      f"returned code: {process.returncode}"
1369: (8)                   )
1370: (8)                   return stdout_data
1371: (0)           __generate_format_methods(Dot)

----------------------------------------

File 2 - __init__.py:

1: (0)              """An interface to GraphViz."""
2: (0)              import logging
3: (0)              __author__ = "Ero Carrera"
4: (0)              __version__ = "3.0.3"
5: (0)              __license__ = "MIT"
6: (0)              _logger = logging.getLogger(__name__)
7: (0)              _logger.debug("pydot initializing")
8: (0)              _logger.debug("pydot %s", __version__)
9: (0)              from pydot.core import *  # noqa: F403, E402
10: (0)             from pydot.exceptions import *  # noqa: E402, F403

----------------------------------------

File 3 - dot_parser.py:

1: (0)              """Graphviz's dot language parser.
2: (0)              The dotparser parses GraphViz files in
3: (0)              dot and dot files and transforms them
4: (0)              into a class representation defined by `pydot`.
5: (0)              Author: Michael Krause <michael@krause-software.de>
6: (0)              Fixes by: Ero Carrera <ero.carrera@gmail.com>
7: (0)              """
8: (0)              import logging
9: (0)              from pyparsing import (
10: (4)                 CaselessLiteral,
11: (4)                 CharsNotIn,
12: (4)                 Combine,
13: (4)                 Forward,
14: (4)                 Group,
15: (4)                 Literal,
16: (4)                 OneOrMore,
17: (4)                 Optional,
18: (4)                 ParseException,
19: (4)                 ParseResults,
20: (4)                 QuotedString,
21: (4)                 Word,
22: (4)                 cStyleComment,
23: (4)                 nums,
24: (4)                 pyparsing_unicode,
25: (4)                 restOfLine,
26: (0)             )
27: (0)             import pydot
28: (0)             __author__ = ["Michael Krause", "Ero Carrera"]
29: (0)             __license__ = "MIT"
30: (0)             _logger = logging.getLogger(__name__)
31: (0)             _logger.debug("pydot dot_parser module initializing")
32: (0)             class P_AttrList:
33: (4)                 def __init__(self, toks):
34: (8)                     self.attrs = {}
35: (8)                     i = 0
36: (8)                     while i < len(toks):
37: (12)                        attrname = toks[i]
38: (12)                        if i + 2 < len(toks) and toks[i + 1] == "=":
39: (16)                            attrvalue = toks[i + 2]
40: (16)                            i += 3
41: (12)                        else:
42: (16)                            attrvalue = None
43: (16)                            i += 1
44: (12)                        self.attrs[attrname] = attrvalue
45: (4)                 def __repr__(self):
46: (8)                     name = self.__class__.__name__
47: (8)                     return f"{name}({self.attrs!r})"
48: (0)             class DefaultStatement(P_AttrList):
49: (4)                 def __init__(self, default_type, attrs):
50: (8)                     self.default_type = default_type
51: (8)                     self.attrs = attrs
52: (4)                 def __repr__(self):
53: (8)                     name = self.__class__.__name__
54: (8)                     return f"{name}({self.default_type}, {self.attrs!r})"
55: (0)             def push_top_graph_stmt(s, loc, toks):
56: (4)                 attrs = {}
57: (4)                 top_graphs = []
58: (4)                 g = None
59: (4)                 for element in toks:
60: (8)                     if (
61: (12)                        isinstance(element, (ParseResults, tuple, list))
62: (12)                        and len(element) == 1
63: (12)                        and isinstance(element[0], str)
64: (8)                     ):
65: (12)                        element = element[0]
66: (8)                     if element == "strict":
67: (12)                        attrs["strict"] = True
68: (8)                     elif element in ["graph", "digraph"]:
69: (12)                        attrs = {}
70: (12)                        g = pydot.Dot(graph_type=element, **attrs)
71: (12)                        attrs["type"] = element
72: (12)                        top_graphs.append(g)
73: (8)                     elif isinstance(element, str):
74: (12)                        g.set_name(element)
75: (8)                     elif isinstance(element, pydot.Subgraph):
76: (12)                        g.obj_dict["attributes"].update(element.obj_dict["attributes"])
77: (12)                        g.obj_dict["edges"].update(element.obj_dict["edges"])
78: (12)                        g.obj_dict["nodes"].update(element.obj_dict["nodes"])
79: (12)                        g.obj_dict["subgraphs"].update(element.obj_dict["subgraphs"])
80: (12)                        g.set_parent_graph(g)
81: (8)                     elif isinstance(element, P_AttrList):
82: (12)                        attrs.update(element.attrs)
83: (8)                     elif isinstance(element, (ParseResults, list)):
84: (12)                        add_elements(g, element)
85: (8)                     else:
86: (12)                        raise ValueError(f"Unknown element statement: {element}")
87: (4)                 for g in top_graphs:
88: (8)                     update_parent_graph_hierarchy(g)
89: (4)                 if len(top_graphs) == 1:
90: (8)                     return top_graphs[0]
91: (4)                 return top_graphs
92: (0)             def update_parent_graph_hierarchy(g, parent_graph=None, level=0):
93: (4)                 if parent_graph is None:
94: (8)                     parent_graph = g
95: (4)                 for key_name in ("edges",):
96: (8)                     if isinstance(g, pydot.frozendict):
97: (12)                        item_dict = g
98: (8)                     else:
99: (12)                        item_dict = g.obj_dict
100: (8)                    if key_name not in item_dict:
101: (12)                       continue
102: (8)                    for key, objs in item_dict[key_name].items():
103: (12)                       for obj in objs:
104: (16)                           if (
105: (20)                               "parent_graph" in obj
106: (20)                               and obj["parent_graph"].get_parent_graph() == g
107: (16)                           ):
108: (20)                               if obj["parent_graph"] is g:
109: (24)                                   pass
110: (20)                               else:
111: (24)                                   obj["parent_graph"].set_parent_graph(parent_graph)
112: (16)                           if key_name == "edges" and len(key) == 2:
113: (20)                               for idx, vertex in enumerate(obj["points"]):
114: (24)                                   if isinstance(
115: (28)                                       vertex,
116: (28)                                       (pydot.Graph, pydot.Subgraph, pydot.Cluster),
117: (24)                                   ):
118: (28)                                       vertex.set_parent_graph(parent_graph)
119: (24)                                   if isinstance(vertex, pydot.frozendict):
120: (28)                                       if vertex["parent_graph"] is g:
121: (32)                                           pass
122: (28)                                       else:
123: (32)                                           vertex["parent_graph"].set_parent_graph(
124: (36)                                               parent_graph
125: (32)                                           )
126: (0)            def add_defaults(element, defaults):
127: (4)                d = element.__dict__
128: (4)                for key, value in defaults.items():
129: (8)                    if not d.get(key):
130: (12)                       d[key] = value
131: (0)            def add_elements(
132: (4)                g, toks, defaults_graph=None, defaults_node=None, defaults_edge=None
133: (0)            ):
134: (4)                if defaults_graph is None:
135: (8)                    defaults_graph = {}
136: (4)                if defaults_node is None:
137: (8)                    defaults_node = {}
138: (4)                if defaults_edge is None:
139: (8)                    defaults_edge = {}
140: (4)                for elm_idx, element in enumerate(toks):
141: (8)                    if isinstance(element, (pydot.Subgraph, pydot.Cluster)):
142: (12)                       add_defaults(element, defaults_graph)
143: (12)                       g.add_subgraph(element)
144: (8)                    elif isinstance(element, pydot.Node):
145: (12)                       add_defaults(element, defaults_node)
146: (12)                       g.add_node(element)
147: (8)                    elif isinstance(element, pydot.Edge):
148: (12)                       add_defaults(element, defaults_edge)
149: (12)                       g.add_edge(element)
150: (8)                    elif isinstance(element, ParseResults):
151: (12)                       for e in element:
152: (16)                           add_elements(
153: (20)                               g, [e], defaults_graph, defaults_node, defaults_edge
154: (16)                           )
155: (8)                    elif isinstance(element, DefaultStatement):
156: (12)                       if element.default_type == "graph":
157: (16)                           default_graph_attrs = pydot.Node("graph", **element.attrs)
158: (16)                           g.add_node(default_graph_attrs)
159: (12)                       elif element.default_type == "node":
160: (16)                           default_node_attrs = pydot.Node("node", **element.attrs)
161: (16)                           g.add_node(default_node_attrs)
162: (12)                       elif element.default_type == "edge":
163: (16)                           default_edge_attrs = pydot.Node("edge", **element.attrs)
164: (16)                           g.add_node(default_edge_attrs)
165: (16)                           defaults_edge.update(element.attrs)
166: (12)                       else:
167: (16)                           raise ValueError(
168: (20)                               f"Unknown DefaultStatement: {element.default_type}"
169: (16)                           )
170: (8)                    elif isinstance(element, P_AttrList):
171: (12)                       g.obj_dict["attributes"].update(element.attrs)
172: (8)                    else:
173: (12)                       raise ValueError(f"Unknown element statement: {element}")
174: (0)            def push_graph_stmt(s, loc, toks):
175: (4)                g = pydot.Subgraph("")
176: (4)                add_elements(g, toks)
177: (4)                return g
178: (0)            def push_subgraph_stmt(s, loc, toks):
179: (4)                g = pydot.Subgraph("")
180: (4)                for e in toks:
181: (8)                    if len(e) == 3:
182: (12)                       e[2].set_name(e[1])
183: (12)                       if e[0] == "subgraph":
184: (16)                           e[2].obj_dict["show_keyword"] = True
185: (12)                       return e[2]
186: (8)                    else:
187: (12)                       if e[0] == "subgraph":
188: (16)                           e[1].obj_dict["show_keyword"] = True
189: (12)                       return e[1]
190: (4)                return g
191: (0)            def push_default_stmt(s, loc, toks):
192: (4)                default_type = toks[0][0]
193: (4)                if len(toks) > 1:
194: (8)                    attrs = toks[1].attrs
195: (4)                else:
196: (8)                    attrs = {}
197: (4)                if default_type in ["graph", "node", "edge"]:
198: (8)                    return DefaultStatement(default_type, attrs)
199: (4)                else:
200: (8)                    raise ValueError(f"Unknown default statement: {toks}")
201: (0)            def push_attr_list(s, loc, toks):
202: (4)                p = P_AttrList(toks)
203: (4)                return p
204: (0)            def get_port(node):
205: (4)                if len(node) > 1:
206: (8)                    if isinstance(node[1], ParseResults):
207: (12)                       if len(node[1][0]) == 2:
208: (16)                           if node[1][0][0] == ":":
209: (20)                               return node[1][0][1]
210: (4)                return None
211: (0)            def do_node_ports(node):
212: (4)                node_port = ""
213: (4)                if len(node) > 1:
214: (8)                    node_port = "".join([str(a) + str(b) for a, b in node[1]])
215: (4)                return node_port
216: (0)            def push_edge_stmt(s, loc, toks):
217: (4)                tok_attrs = [a for a in toks if isinstance(a, P_AttrList)]
218: (4)                attrs = {}
219: (4)                for a in tok_attrs:
220: (8)                    attrs.update(a.attrs)
221: (4)                e = []
222: (4)                if isinstance(toks[0][0], pydot.Graph):
223: (8)                    n_prev = pydot.frozendict(toks[0][0].obj_dict)
224: (4)                else:
225: (8)                    n_prev = toks[0][0] + do_node_ports(toks[0])
226: (4)                if isinstance(toks[2][0], ParseResults):
227: (8)                    n_next_list = [[n.get_name()] for n in toks[2][0]]
228: (8)                    for n_next in list(n_next_list):
229: (12)                       n_next_port = do_node_ports(n_next)
230: (12)                       e.append(pydot.Edge(n_prev, n_next[0] + n_next_port, **attrs))
231: (4)                elif isinstance(toks[2][0], pydot.Graph):
232: (8)                    e.append(
233: (12)                       pydot.Edge(n_prev, pydot.frozendict(toks[2][0].obj_dict), **attrs)
234: (8)                    )
235: (4)                elif isinstance(toks[2][0], pydot.Node):
236: (8)                    node = toks[2][0]
237: (8)                    if node.get_port() is not None:
238: (12)                       name_port = node.get_name() + ":" + node.get_port()
239: (8)                    else:
240: (12)                       name_port = node.get_name()
241: (8)                    e.append(pydot.Edge(n_prev, name_port, **attrs))
242: (4)                elif isinstance(toks[2][0], str):
243: (8)                    for n_next in list(tuple(toks)[2::2]):
244: (12)                       if isinstance(n_next, P_AttrList) or not isinstance(
245: (16)                           n_next[0], str
246: (12)                       ):
247: (16)                           continue
248: (12)                       n_next_port = do_node_ports(n_next)
249: (12)                       e.append(pydot.Edge(n_prev, n_next[0] + n_next_port, **attrs))
250: (12)                       n_prev = n_next[0] + n_next_port
251: (4)                else:
252: (8)                    raise Exception(
253: (12)                       f"Edge target {toks[2][0]} with type {type(toks[2][0])}"
254: (12)                       " unsupported."
255: (8)                    )
256: (4)                return e
257: (0)            def push_node_stmt(s, loc, toks):
258: (4)                if len(toks) == 2:
259: (8)                    attrs = toks[1].attrs
260: (4)                else:
261: (8)                    attrs = {}
262: (4)                node_name = toks[0]
263: (4)                if isinstance(node_name, list) or isinstance(node_name, tuple):
264: (8)                    if len(node_name) > 0:
265: (12)                       node_name = node_name[0]
266: (4)                n = pydot.Node(str(node_name), **attrs)
267: (4)                return n
268: (0)            graphparser = None
269: (0)            def graph_definition():
270: (4)                global graphparser
271: (4)                if not graphparser:
272: (8)                    colon = Literal(":")
273: (8)                    lbrace = Literal("{")
274: (8)                    rbrace = Literal("}")
275: (8)                    lbrack = Literal("[")
276: (8)                    rbrack = Literal("]")
277: (8)                    equals = Literal("=")
278: (8)                    comma = Literal(",")
279: (8)                    semi = Literal(";")
280: (8)                    minus = Literal("-")
281: (8)                    strict_ = CaselessLiteral("strict")
282: (8)                    graph_ = CaselessLiteral("graph")
283: (8)                    digraph_ = CaselessLiteral("digraph")
284: (8)                    subgraph_ = CaselessLiteral("subgraph")
285: (8)                    node_ = CaselessLiteral("node")
286: (8)                    edge_ = CaselessLiteral("edge")
287: (8)                    identifier = Word(
288: (12)                       pyparsing_unicode.BasicMultilingualPlane.alphanums + "_."
289: (8)                    ).setName("identifier")
290: (8)                    double_quoted_string = QuotedString(
291: (12)                       '"', multiline=True, unquoteResults=False, escChar="\\"
292: (8)                    )
293: (8)                    html_text = Forward()
294: (8)                    inner_html = OneOrMore(CharsNotIn("<>") | html_text)
295: (8)                    html_text << "<" + inner_html + ">"
296: (8)                    html_text.setParseAction(lambda arr: "".join(arr))
297: (8)                    ID = (identifier | html_text | double_quoted_string).setName("ID")
298: (8)                    float_number = Combine(
299: (12)                       Optional(minus) + OneOrMore(Word(nums + "."))
300: (8)                    ).setName("float_number")
301: (8)                    righthand_id = (float_number | ID).setName("righthand_id")
302: (8)                    port = (
303: (12)                       Group(Group(colon + ID) + Group(colon + ID))
304: (12)                       | Group(Group(colon + ID))
305: (8)                    ).setName("port")
306: (8)                    node_id = ID + Optional(port)
307: (8)                    a_list = OneOrMore(
308: (12)                       ID + Optional(equals + righthand_id) + Optional(comma.suppress())
309: (8)                    ).setName("a_list")
310: (8)                    attr_list = OneOrMore(
311: (12)                       lbrack.suppress() + Optional(a_list) + rbrack.suppress()
312: (8)                    ).setName("attr_list")
313: (8)                    attr_stmt = (Group(graph_ | node_ | edge_) + attr_list).setName(
314: (12)                       "attr_stmt"
315: (8)                    )
316: (8)                    edgeop = (Literal("--") | Literal("->")).setName("edgeop")
317: (8)                    stmt_list = Forward()
318: (8)                    graph_stmt = Group(
319: (12)                       lbrace.suppress()
320: (12)                       + Optional(stmt_list)
321: (12)                       + rbrace.suppress()
322: (12)                       + Optional(semi.suppress())
323: (8)                    ).setName("graph_stmt")
324: (8)                    edge_point = Forward()
325: (8)                    edgeRHS = OneOrMore(edgeop + edge_point)
326: (8)                    edge_stmt = edge_point + edgeRHS + Optional(attr_list)
327: (8)                    subgraph = Group(subgraph_ + Optional(ID) + graph_stmt).setName(
328: (12)                       "subgraph"
329: (8)                    )
330: (8)                    edge_point << Group(subgraph | graph_stmt | node_id).setName(
331: (12)                       "edge_point"
332: (8)                    )
333: (8)                    node_stmt = (
334: (12)                       node_id + Optional(attr_list) + Optional(semi.suppress())
335: (8)                    ).setName("node_stmt")
336: (8)                    assignment = (ID + equals + righthand_id).setName("assignment")
337: (8)                    stmt = (
338: (12)                       assignment
339: (12)                       | edge_stmt
340: (12)                       | attr_stmt
341: (12)                       | subgraph
342: (12)                       | graph_stmt
343: (12)                       | node_stmt
344: (8)                    ).setName("stmt")
345: (8)                    stmt_list << OneOrMore(stmt + Optional(semi.suppress()))
346: (8)                    graphparser = OneOrMore(
347: (12)                       (
348: (16)                           Optional(strict_)
349: (16)                           + Group(graph_ | digraph_)
350: (16)                           + Optional(ID)
351: (16)                           + graph_stmt
352: (12)                       ).setResultsName("graph")
353: (8)                    )
354: (8)                    singleLineComment = Group("//" + restOfLine) | Group("#" + restOfLine)
355: (8)                    graphparser.ignore(singleLineComment)
356: (8)                    graphparser.ignore(cStyleComment)
357: (8)                    assignment.setParseAction(push_attr_list)
358: (8)                    a_list.setParseAction(push_attr_list)
359: (8)                    edge_stmt.setParseAction(push_edge_stmt)
360: (8)                    node_stmt.setParseAction(push_node_stmt)
361: (8)                    attr_stmt.setParseAction(push_default_stmt)
362: (8)                    subgraph.setParseAction(push_subgraph_stmt)
363: (8)                    graph_stmt.setParseAction(push_graph_stmt)
364: (8)                    graphparser.setParseAction(push_top_graph_stmt)
365: (4)                return graphparser
366: (0)            def parse_dot_data(s):
367: (4)                """Parse DOT description in (unicode) string `s`.
368: (4)                This function is NOT thread-safe due to the internal use of `pyparsing`.
369: (4)                Use a lock if needed.
370: (4)                @return: Graphs that result from parsing.
371: (4)                @rtype: `list` of `pydot.Dot`
372: (4)                """
373: (4)                try:
374: (8)                    graphparser = graph_definition()
375: (8)                    graphparser.parseWithTabs()
376: (8)                    tokens = graphparser.parseString(s)
377: (8)                    return list(tokens)
378: (4)                except ParseException as err:
379: (8)                    print(err.line)
380: (8)                    print(" " * (err.column - 1) + "^")
381: (8)                    print(err)
382: (8)                    return None

----------------------------------------

File 4 - exceptions.py:

1: (0)              """Exception classes for pydot."""
2: (0)              class PydotException(Exception):
3: (4)                  """Base class for exceptions in Pydot.
4: (4)                  This base class will not be raised directly.
5: (4)                  Catch this base class to catch all derived exceptions, though be
6: (4)                  aware that pydot may raise Python built-in exceptions or pyparsing
7: (4)                  exceptions as well.
8: (4)                  """
9: (0)              class Error(PydotException):
10: (4)                 """General error handling class."""
11: (4)                 def __init__(self, value):
12: (8)                     self.value = value
13: (4)                 def __str__(self):
14: (8)                     return self.value

----------------------------------------

File 5 - tempfile.py:

1: (0)              """Temporary files.
2: (0)              This module provides generic, low- and high-level interfaces for
3: (0)              creating temporary files and directories.  All of the interfaces
4: (0)              provided by this module can be used without fear of race conditions
5: (0)              except for 'mktemp'.  'mktemp' is subject to race conditions and
6: (0)              should not be used; it is provided for backward compatibility only.
7: (0)              The default path names are returned as str.  If you supply bytes as
8: (0)              input, all return values will be in bytes.  Ex:
9: (4)                  >>> tempfile.mkstemp()
10: (4)                 (4, '/tmp/tmptpu9nin8')
11: (4)                 >>> tempfile.mkdtemp(suffix=b'')
12: (4)                 b'/tmp/tmppbi8f0hy'
13: (0)             This module also provides some data items to the user:
14: (2)               TMP_MAX  - maximum number of names that will be tried before
15: (13)                         giving up.
16: (2)               tempdir  - If this is set to a string before the first use of
17: (13)                         any routine from this module, it will be considered as
18: (13)                         another candidate location to store temporary files.
19: (0)             """
20: (0)             __all__ = [
21: (4)                 "NamedTemporaryFile", "TemporaryFile", # high level safe interfaces
22: (4)                 "SpooledTemporaryFile", "TemporaryDirectory",
23: (4)                 "mkstemp", "mkdtemp",                  # low level safe interfaces
24: (4)                 "mktemp",                              # deprecated unsafe interface
25: (4)                 "TMP_MAX", "gettempprefix",            # constants
26: (4)                 "tempdir", "gettempdir",
27: (4)                 "gettempprefixb", "gettempdirb",
28: (3)                ]
29: (0)             import functools as _functools
30: (0)             import warnings as _warnings
31: (0)             import io as _io
32: (0)             import os as _os
33: (0)             import shutil as _shutil
34: (0)             import errno as _errno
35: (0)             from random import Random as _Random
36: (0)             import sys as _sys
37: (0)             import types as _types
38: (0)             import weakref as _weakref
39: (0)             import _thread
40: (0)             _allocate_lock = _thread.allocate_lock
41: (0)             _text_openflags = _os.O_RDWR | _os.O_CREAT | _os.O_EXCL
42: (0)             if hasattr(_os, 'O_NOFOLLOW'):
43: (4)                 _text_openflags |= _os.O_NOFOLLOW
44: (0)             _bin_openflags = _text_openflags
45: (0)             if hasattr(_os, 'O_BINARY'):
46: (4)                 _bin_openflags |= _os.O_BINARY
47: (0)             if hasattr(_os, 'TMP_MAX'):
48: (4)                 TMP_MAX = _os.TMP_MAX
49: (0)             else:
50: (4)                 TMP_MAX = 10000
51: (0)             template = "tmp"
52: (0)             _once_lock = _allocate_lock()
53: (0)             def _exists(fn):
54: (4)                 try:
55: (8)                     _os.lstat(fn)
56: (4)                 except OSError:
57: (8)                     return False
58: (4)                 else:
59: (8)                     return True
60: (0)             def _infer_return_type(*args):
61: (4)                 """Look at the type of all args and divine their implied return type."""
62: (4)                 return_type = None
63: (4)                 for arg in args:
64: (8)                     if arg is None:
65: (12)                        continue
66: (8)                     if isinstance(arg, _os.PathLike):
67: (12)                        arg = _os.fspath(arg)
68: (8)                     if isinstance(arg, bytes):
69: (12)                        if return_type is str:
70: (16)                            raise TypeError("Can't mix bytes and non-bytes in "
71: (32)                                            "path components.")
72: (12)                        return_type = bytes
73: (8)                     else:
74: (12)                        if return_type is bytes:
75: (16)                            raise TypeError("Can't mix bytes and non-bytes in "
76: (32)                                            "path components.")
77: (12)                        return_type = str
78: (4)                 if return_type is None:
79: (8)                     if tempdir is None or isinstance(tempdir, str):
80: (12)                        return str  # tempfile APIs return a str by default.
81: (8)                     else:
82: (12)                        return bytes
83: (4)                 return return_type
84: (0)             def _sanitize_params(prefix, suffix, dir):
85: (4)                 """Common parameter processing for most APIs in this module."""
86: (4)                 output_type = _infer_return_type(prefix, suffix, dir)
87: (4)                 if suffix is None:
88: (8)                     suffix = output_type()
89: (4)                 if prefix is None:
90: (8)                     if output_type is str:
91: (12)                        prefix = template
92: (8)                     else:
93: (12)                        prefix = _os.fsencode(template)
94: (4)                 if dir is None:
95: (8)                     if output_type is str:
96: (12)                        dir = gettempdir()
97: (8)                     else:
98: (12)                        dir = gettempdirb()
99: (4)                 return prefix, suffix, dir, output_type
100: (0)            class _RandomNameSequence:
101: (4)                """An instance of _RandomNameSequence generates an endless
102: (4)                sequence of unpredictable strings which can safely be incorporated
103: (4)                into file names.  Each string is eight characters long.  Multiple
104: (4)                threads can safely use the same instance at the same time.
105: (4)                _RandomNameSequence is an iterator."""
106: (4)                characters = "abcdefghijklmnopqrstuvwxyz0123456789_"
107: (4)                @property
108: (4)                def rng(self):
109: (8)                    cur_pid = _os.getpid()
110: (8)                    if cur_pid != getattr(self, '_rng_pid', None):
111: (12)                       self._rng = _Random()
112: (12)                       self._rng_pid = cur_pid
113: (8)                    return self._rng
114: (4)                def __iter__(self):
115: (8)                    return self
116: (4)                def __next__(self):
117: (8)                    return ''.join(self.rng.choices(self.characters, k=8))
118: (0)            def _candidate_tempdir_list():
119: (4)                """Generate a list of candidate temporary directories which
120: (4)                _get_default_tempdir will try."""
121: (4)                dirlist = []
122: (4)                for envname in 'TMPDIR', 'TEMP', 'TMP':
123: (8)                    dirname = _os.getenv(envname)
124: (8)                    if dirname: dirlist.append(dirname)
125: (4)                if _os.name == 'nt':
126: (8)                    dirlist.extend([ _os.path.expanduser(r'~\AppData\Local\Temp'),
127: (25)                                    _os.path.expandvars(r'%SYSTEMROOT%\Temp'),
128: (25)                                    r'c:\temp', r'c:\tmp', r'\temp', r'\tmp' ])
129: (4)                else:
130: (8)                    dirlist.extend([ '/tmp', '/var/tmp', '/usr/tmp' ])
131: (4)                try:
132: (8)                    dirlist.append(_os.getcwd())
133: (4)                except (AttributeError, OSError):
134: (8)                    dirlist.append(_os.curdir)
135: (4)                return dirlist
136: (0)            def _get_default_tempdir():
137: (4)                """Calculate the default directory to use for temporary files.
138: (4)                This routine should be called exactly once.
139: (4)                We determine whether or not a candidate temp dir is usable by
140: (4)                trying to create and write to a file in that directory.  If this
141: (4)                is successful, the test file is deleted.  To prevent denial of
142: (4)                service, the name of the test file must be randomized."""
143: (4)                namer = _RandomNameSequence()
144: (4)                dirlist = _candidate_tempdir_list()
145: (4)                for dir in dirlist:
146: (8)                    if dir != _os.curdir:
147: (12)                       dir = _os.path.abspath(dir)
148: (8)                    for seq in range(100):
149: (12)                       name = next(namer)
150: (12)                       filename = _os.path.join(dir, name)
151: (12)                       try:
152: (16)                           fd = _os.open(filename, _bin_openflags, 0o600)
153: (16)                           try:
154: (20)                               try:
155: (24)                                   _os.write(fd, b'blat')
156: (20)                               finally:
157: (24)                                   _os.close(fd)
158: (16)                           finally:
159: (20)                               _os.unlink(filename)
160: (16)                           return dir
161: (12)                       except FileExistsError:
162: (16)                           pass
163: (12)                       except PermissionError:
164: (16)                           if (_os.name == 'nt' and _os.path.isdir(dir) and
165: (20)                               _os.access(dir, _os.W_OK)):
166: (20)                               continue
167: (16)                           break   # no point trying more names in this directory
168: (12)                       except OSError:
169: (16)                           break   # no point trying more names in this directory
170: (4)                raise FileNotFoundError(_errno.ENOENT,
171: (28)                                       "No usable temporary directory found in %s" %
172: (28)                                       dirlist)
173: (0)            _name_sequence = None
174: (0)            def _get_candidate_names():
175: (4)                """Common setup sequence for all user-callable interfaces."""
176: (4)                global _name_sequence
177: (4)                if _name_sequence is None:
178: (8)                    _once_lock.acquire()
179: (8)                    try:
180: (12)                       if _name_sequence is None:
181: (16)                           _name_sequence = _RandomNameSequence()
182: (8)                    finally:
183: (12)                       _once_lock.release()
184: (4)                return _name_sequence
185: (0)            def _mkstemp_inner(dir, pre, suf, flags, output_type):
186: (4)                """Code common to mkstemp, TemporaryFile, and NamedTemporaryFile."""
187: (4)                dir = _os.path.abspath(dir)
188: (4)                names = _get_candidate_names()
189: (4)                if output_type is bytes:
190: (8)                    names = map(_os.fsencode, names)
191: (4)                for seq in range(TMP_MAX):
192: (8)                    name = next(names)
193: (8)                    file = _os.path.join(dir, pre + name + suf)
194: (8)                    _sys.audit("tempfile.mkstemp", file)
195: (8)                    try:
196: (12)                       fd = _os.open(file, flags, 0o600)
197: (8)                    except FileExistsError:
198: (12)                       continue    # try again
199: (8)                    except PermissionError:
200: (12)                       if (_os.name == 'nt' and _os.path.isdir(dir) and
201: (16)                           _os.access(dir, _os.W_OK)):
202: (16)                           continue
203: (12)                       else:
204: (16)                           raise
205: (8)                    return fd, file
206: (4)                raise FileExistsError(_errno.EEXIST,
207: (26)                                     "No usable temporary file name found")
208: (0)            def _dont_follow_symlinks(func, path, *args):
209: (4)                if func in _os.supports_follow_symlinks:
210: (8)                    func(path, *args, follow_symlinks=False)
211: (4)                elif _os.name == 'nt' or not _os.path.islink(path):
212: (8)                    func(path, *args)
213: (0)            def _resetperms(path):
214: (4)                try:
215: (8)                    chflags = _os.chflags
216: (4)                except AttributeError:
217: (8)                    pass
218: (4)                else:
219: (8)                    _dont_follow_symlinks(chflags, path, 0)
220: (4)                _dont_follow_symlinks(_os.chmod, path, 0o700)
221: (0)            def gettempprefix():
222: (4)                """The default prefix for temporary directories as string."""
223: (4)                return _os.fsdecode(template)
224: (0)            def gettempprefixb():
225: (4)                """The default prefix for temporary directories as bytes."""
226: (4)                return _os.fsencode(template)
227: (0)            tempdir = None
228: (0)            def _gettempdir():
229: (4)                """Private accessor for tempfile.tempdir."""
230: (4)                global tempdir
231: (4)                if tempdir is None:
232: (8)                    _once_lock.acquire()
233: (8)                    try:
234: (12)                       if tempdir is None:
235: (16)                           tempdir = _get_default_tempdir()
236: (8)                    finally:
237: (12)                       _once_lock.release()
238: (4)                return tempdir
239: (0)            def gettempdir():
240: (4)                """Returns tempfile.tempdir as str."""
241: (4)                return _os.fsdecode(_gettempdir())
242: (0)            def gettempdirb():
243: (4)                """Returns tempfile.tempdir as bytes."""
244: (4)                return _os.fsencode(_gettempdir())
245: (0)            def mkstemp(suffix=None, prefix=None, dir=None, text=False):
246: (4)                """User-callable function to create and return a unique temporary
247: (4)                file.  The return value is a pair (fd, name) where fd is the
248: (4)                file descriptor returned by os.open, and name is the filename.
249: (4)                If 'suffix' is not None, the file name will end with that suffix,
250: (4)                otherwise there will be no suffix.
251: (4)                If 'prefix' is not None, the file name will begin with that prefix,
252: (4)                otherwise a default prefix is used.
253: (4)                If 'dir' is not None, the file will be created in that directory,
254: (4)                otherwise a default directory is used.
255: (4)                If 'text' is specified and true, the file is opened in text
256: (4)                mode.  Else (the default) the file is opened in binary mode.
257: (4)                If any of 'suffix', 'prefix' and 'dir' are not None, they must be the
258: (4)                same type.  If they are bytes, the returned name will be bytes; str
259: (4)                otherwise.
260: (4)                The file is readable and writable only by the creating user ID.
261: (4)                If the operating system uses permission bits to indicate whether a
262: (4)                file is executable, the file is executable by no one. The file
263: (4)                descriptor is not inherited by children of this process.
264: (4)                Caller is responsible for deleting the file when done with it.
265: (4)                """
266: (4)                prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)
267: (4)                if text:
268: (8)                    flags = _text_openflags
269: (4)                else:
270: (8)                    flags = _bin_openflags
271: (4)                return _mkstemp_inner(dir, prefix, suffix, flags, output_type)
272: (0)            def mkdtemp(suffix=None, prefix=None, dir=None):
273: (4)                """User-callable function to create and return a unique temporary
274: (4)                directory.  The return value is the pathname of the directory.
275: (4)                Arguments are as for mkstemp, except that the 'text' argument is
276: (4)                not accepted.
277: (4)                The directory is readable, writable, and searchable only by the
278: (4)                creating user.
279: (4)                Caller is responsible for deleting the directory when done with it.
280: (4)                """
281: (4)                prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)
282: (4)                names = _get_candidate_names()
283: (4)                if output_type is bytes:
284: (8)                    names = map(_os.fsencode, names)
285: (4)                for seq in range(TMP_MAX):
286: (8)                    name = next(names)
287: (8)                    file = _os.path.join(dir, prefix + name + suffix)
288: (8)                    _sys.audit("tempfile.mkdtemp", file)
289: (8)                    try:
290: (12)                       _os.mkdir(file, 0o700)
291: (8)                    except FileExistsError:
292: (12)                       continue    # try again
293: (8)                    except PermissionError:
294: (12)                       if (_os.name == 'nt' and _os.path.isdir(dir) and
295: (16)                           _os.access(dir, _os.W_OK)):
296: (16)                           continue
297: (12)                       else:
298: (16)                           raise
299: (8)                    return _os.path.abspath(file)
300: (4)                raise FileExistsError(_errno.EEXIST,
301: (26)                                     "No usable temporary directory name found")
302: (0)            def mktemp(suffix="", prefix=template, dir=None):
303: (4)                """User-callable function to return a unique temporary file name.  The
304: (4)                file is not created.
305: (4)                Arguments are similar to mkstemp, except that the 'text' argument is
306: (4)                not accepted, and suffix=None, prefix=None and bytes file names are not
307: (4)                supported.
308: (4)                THIS FUNCTION IS UNSAFE AND SHOULD NOT BE USED.  The file name may
309: (4)                refer to a file that did not exist at some point, but by the time
310: (4)                you get around to creating it, someone else may have beaten you to
311: (4)                the punch.
312: (4)                """
313: (4)                if dir is None:
314: (8)                    dir = gettempdir()
315: (4)                names = _get_candidate_names()
316: (4)                for seq in range(TMP_MAX):
317: (8)                    name = next(names)
318: (8)                    file = _os.path.join(dir, prefix + name + suffix)
319: (8)                    if not _exists(file):
320: (12)                       return file
321: (4)                raise FileExistsError(_errno.EEXIST,
322: (26)                                     "No usable temporary filename found")
323: (0)            class _TemporaryFileCloser:
324: (4)                """A separate object allowing proper closing of a temporary file's
325: (4)                underlying file object, without adding a __del__ method to the
326: (4)                temporary file."""
327: (4)                cleanup_called = False
328: (4)                close_called = False
329: (4)                def __init__(self, file, name, delete=True, delete_on_close=True):
330: (8)                    self.file = file
331: (8)                    self.name = name
332: (8)                    self.delete = delete
333: (8)                    self.delete_on_close = delete_on_close
334: (4)                def cleanup(self, windows=(_os.name == 'nt'), unlink=_os.unlink):
335: (8)                    if not self.cleanup_called:
336: (12)                       self.cleanup_called = True
337: (12)                       try:
338: (16)                           if not self.close_called:
339: (20)                               self.close_called = True
340: (20)                               self.file.close()
341: (12)                       finally:
342: (16)                           if self.delete and not (windows and self.delete_on_close):
343: (20)                               try:
344: (24)                                   unlink(self.name)
345: (20)                               except FileNotFoundError:
346: (24)                                   pass
347: (4)                def close(self):
348: (8)                    if not self.close_called:
349: (12)                       self.close_called = True
350: (12)                       try:
351: (16)                           self.file.close()
352: (12)                       finally:
353: (16)                           if self.delete and self.delete_on_close:
354: (20)                               self.cleanup()
355: (4)                def __del__(self):
356: (8)                    self.cleanup()
357: (0)            class _TemporaryFileWrapper:
358: (4)                """Temporary file wrapper
359: (4)                This class provides a wrapper around files opened for
360: (4)                temporary use.  In particular, it seeks to automatically
361: (4)                remove the file when it is no longer needed.
362: (4)                """
363: (4)                def __init__(self, file, name, delete=True, delete_on_close=True):
364: (8)                    self.file = file
365: (8)                    self.name = name
366: (8)                    self._closer = _TemporaryFileCloser(file, name, delete,
367: (44)                                                       delete_on_close)
368: (4)                def __getattr__(self, name):
369: (8)                    file = self.__dict__['file']
370: (8)                    a = getattr(file, name)
371: (8)                    if hasattr(a, '__call__'):
372: (12)                       func = a
373: (12)                       @_functools.wraps(func)
374: (12)                       def func_wrapper(*args, **kwargs):
375: (16)                           return func(*args, **kwargs)
376: (12)                       func_wrapper._closer = self._closer
377: (12)                       a = func_wrapper
378: (8)                    if not isinstance(a, int):
379: (12)                       setattr(self, name, a)
380: (8)                    return a
381: (4)                def __enter__(self):
382: (8)                    self.file.__enter__()
383: (8)                    return self
384: (4)                def __exit__(self, exc, value, tb):
385: (8)                    result = self.file.__exit__(exc, value, tb)
386: (8)                    self._closer.cleanup()
387: (8)                    return result
388: (4)                def close(self):
389: (8)                    """
390: (8)                    Close the temporary file, possibly deleting it.
391: (8)                    """
392: (8)                    self._closer.close()
393: (4)                def __iter__(self):
394: (8)                    for line in self.file:
395: (12)                       yield line
396: (0)            def NamedTemporaryFile(mode='w+b', buffering=-1, encoding=None,
397: (23)                                  newline=None, suffix=None, prefix=None,
398: (23)                                  dir=None, delete=True, *, errors=None,
399: (23)                                  delete_on_close=True):
400: (4)                """Create and return a temporary file.
401: (4)                Arguments:
402: (4)                'prefix', 'suffix', 'dir' -- as for mkstemp.
403: (4)                'mode' -- the mode argument to io.open (default "w+b").
404: (4)                'buffering' -- the buffer size argument to io.open (default -1).
405: (4)                'encoding' -- the encoding argument to io.open (default None)
406: (4)                'newline' -- the newline argument to io.open (default None)
407: (4)                'delete' -- whether the file is automatically deleted (default True).
408: (4)                'delete_on_close' -- if 'delete', whether the file is deleted on close
409: (7)                   (default True) or otherwise either on context manager exit
410: (7)                   (if context manager was used) or on object finalization. .
411: (4)                'errors' -- the errors argument to io.open (default None)
412: (4)                The file is created as mkstemp() would do it.
413: (4)                Returns an object with a file-like interface; the name of the file
414: (4)                is accessible as its 'name' attribute.  The file will be automatically
415: (4)                deleted when it is closed unless the 'delete' argument is set to False.
416: (4)                On POSIX, NamedTemporaryFiles cannot be automatically deleted if
417: (4)                the creating process is terminated abruptly with a SIGKILL signal.
418: (4)                Windows can delete the file even in this case.
419: (4)                """
420: (4)                prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)
421: (4)                flags = _bin_openflags
422: (4)                if _os.name == 'nt' and delete and delete_on_close:
423: (8)                    flags |= _os.O_TEMPORARY
424: (4)                if "b" not in mode:
425: (8)                    encoding = _io.text_encoding(encoding)
426: (4)                name = None
427: (4)                def opener(*args):
428: (8)                    nonlocal name
429: (8)                    fd, name = _mkstemp_inner(dir, prefix, suffix, flags, output_type)
430: (8)                    return fd
431: (4)                try:
432: (8)                    file = _io.open(dir, mode, buffering=buffering,
433: (24)                                   newline=newline, encoding=encoding, errors=errors,
434: (24)                                   opener=opener)
435: (8)                    try:
436: (12)                       raw = getattr(file, 'buffer', file)
437: (12)                       raw = getattr(raw, 'raw', raw)
438: (12)                       raw.name = name
439: (12)                       return _TemporaryFileWrapper(file, name, delete, delete_on_close)
440: (8)                    except:
441: (12)                       file.close()
442: (12)                       raise
443: (4)                except:
444: (8)                    if name is not None and not (
445: (12)                       _os.name == 'nt' and delete and delete_on_close):
446: (12)                       _os.unlink(name)
447: (8)                    raise
448: (0)            if _os.name != 'posix' or _sys.platform == 'cygwin':
449: (4)                TemporaryFile = NamedTemporaryFile
450: (0)            else:
451: (4)                _O_TMPFILE_WORKS = hasattr(_os, 'O_TMPFILE')
452: (4)                def TemporaryFile(mode='w+b', buffering=-1, encoding=None,
453: (22)                                 newline=None, suffix=None, prefix=None,
454: (22)                                 dir=None, *, errors=None):
455: (8)                    """Create and return a temporary file.
456: (8)                    Arguments:
457: (8)                    'prefix', 'suffix', 'dir' -- as for mkstemp.
458: (8)                    'mode' -- the mode argument to io.open (default "w+b").
459: (8)                    'buffering' -- the buffer size argument to io.open (default -1).
460: (8)                    'encoding' -- the encoding argument to io.open (default None)
461: (8)                    'newline' -- the newline argument to io.open (default None)
462: (8)                    'errors' -- the errors argument to io.open (default None)
463: (8)                    The file is created as mkstemp() would do it.
464: (8)                    Returns an object with a file-like interface.  The file has no
465: (8)                    name, and will cease to exist when it is closed.
466: (8)                    """
467: (8)                    global _O_TMPFILE_WORKS
468: (8)                    if "b" not in mode:
469: (12)                       encoding = _io.text_encoding(encoding)
470: (8)                    prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)
471: (8)                    flags = _bin_openflags
472: (8)                    if _O_TMPFILE_WORKS:
473: (12)                       fd = None
474: (12)                       def opener(*args):
475: (16)                           nonlocal fd
476: (16)                           flags2 = (flags | _os.O_TMPFILE) & ~_os.O_CREAT
477: (16)                           fd = _os.open(dir, flags2, 0o600)
478: (16)                           return fd
479: (12)                       try:
480: (16)                           file = _io.open(dir, mode, buffering=buffering,
481: (32)                                           newline=newline, encoding=encoding,
482: (32)                                           errors=errors, opener=opener)
483: (16)                           raw = getattr(file, 'buffer', file)
484: (16)                           raw = getattr(raw, 'raw', raw)
485: (16)                           raw.name = fd
486: (16)                           return file
487: (12)                       except IsADirectoryError:
488: (16)                           _O_TMPFILE_WORKS = False
489: (12)                       except OSError:
490: (16)                           pass
491: (8)                    fd = None
492: (8)                    def opener(*args):
493: (12)                       nonlocal fd
494: (12)                       fd, name = _mkstemp_inner(dir, prefix, suffix, flags, output_type)
495: (12)                       try:
496: (16)                           _os.unlink(name)
497: (12)                       except BaseException as e:
498: (16)                           _os.close(fd)
499: (16)                           raise
500: (12)                       return fd
501: (8)                    file = _io.open(dir, mode, buffering=buffering,
502: (24)                                   newline=newline, encoding=encoding, errors=errors,
503: (24)                                   opener=opener)
504: (8)                    raw = getattr(file, 'buffer', file)
505: (8)                    raw = getattr(raw, 'raw', raw)
506: (8)                    raw.name = fd
507: (8)                    return file
508: (0)            class SpooledTemporaryFile(_io.IOBase):
509: (4)                """Temporary file wrapper, specialized to switch from BytesIO
510: (4)                or StringIO to a real file when it exceeds a certain size or
511: (4)                when a fileno is needed.
512: (4)                """
513: (4)                _rolled = False
514: (4)                def __init__(self, max_size=0, mode='w+b', buffering=-1,
515: (17)                            encoding=None, newline=None,
516: (17)                            suffix=None, prefix=None, dir=None, *, errors=None):
517: (8)                    if 'b' in mode:
518: (12)                       self._file = _io.BytesIO()
519: (8)                    else:
520: (12)                       encoding = _io.text_encoding(encoding)
521: (12)                       self._file = _io.TextIOWrapper(_io.BytesIO(),
522: (28)                                       encoding=encoding, errors=errors,
523: (28)                                       newline=newline)
524: (8)                    self._max_size = max_size
525: (8)                    self._rolled = False
526: (8)                    self._TemporaryFileArgs = {'mode': mode, 'buffering': buffering,
527: (35)                                              'suffix': suffix, 'prefix': prefix,
528: (35)                                              'encoding': encoding, 'newline': newline,
529: (35)                                              'dir': dir, 'errors': errors}
530: (4)                def _check(self, file):
531: (8)                    if self._rolled: return
532: (8)                    max_size = self._max_size
533: (8)                    if max_size and file.tell() > max_size:
534: (12)                       self.rollover()
535: (4)                def rollover(self):
536: (8)                    if self._rolled: return
537: (8)                    file = self._file
538: (8)                    newfile = self._file = TemporaryFile(**self._TemporaryFileArgs)
539: (8)                    del self._TemporaryFileArgs
540: (8)                    pos = file.tell()
541: (8)                    if hasattr(newfile, 'buffer'):
542: (12)                       newfile.buffer.write(file.detach().getvalue())
543: (8)                    else:
544: (12)                       newfile.write(file.getvalue())
545: (8)                    newfile.seek(pos, 0)
546: (8)                    self._rolled = True
547: (4)                def __enter__(self):
548: (8)                    if self._file.closed:
549: (12)                       raise ValueError("Cannot enter context with closed file")
550: (8)                    return self
551: (4)                def __exit__(self, exc, value, tb):
552: (8)                    self._file.close()
553: (4)                def __iter__(self):
554: (8)                    return self._file.__iter__()
555: (4)                def __del__(self):
556: (8)                    if not self.closed:
557: (12)                       _warnings.warn(
558: (16)                           "Unclosed file {!r}".format(self),
559: (16)                           ResourceWarning,
560: (16)                           stacklevel=2,
561: (16)                           source=self
562: (12)                       )
563: (12)                       self.close()
564: (4)                def close(self):
565: (8)                    self._file.close()
566: (4)                @property
567: (4)                def closed(self):
568: (8)                    return self._file.closed
569: (4)                @property
570: (4)                def encoding(self):
571: (8)                    return self._file.encoding
572: (4)                @property
573: (4)                def errors(self):
574: (8)                    return self._file.errors
575: (4)                def fileno(self):
576: (8)                    self.rollover()
577: (8)                    return self._file.fileno()
578: (4)                def flush(self):
579: (8)                    self._file.flush()
580: (4)                def isatty(self):
581: (8)                    return self._file.isatty()
582: (4)                @property
583: (4)                def mode(self):
584: (8)                    try:
585: (12)                       return self._file.mode
586: (8)                    except AttributeError:
587: (12)                       return self._TemporaryFileArgs['mode']
588: (4)                @property
589: (4)                def name(self):
590: (8)                    try:
591: (12)                       return self._file.name
592: (8)                    except AttributeError:
593: (12)                       return None
594: (4)                @property
595: (4)                def newlines(self):
596: (8)                    return self._file.newlines
597: (4)                def readable(self):
598: (8)                    return self._file.readable()
599: (4)                def read(self, *args):
600: (8)                    return self._file.read(*args)
601: (4)                def read1(self, *args):
602: (8)                    return self._file.read1(*args)
603: (4)                def readinto(self, b):
604: (8)                    return self._file.readinto(b)
605: (4)                def readinto1(self, b):
606: (8)                    return self._file.readinto1(b)
607: (4)                def readline(self, *args):
608: (8)                    return self._file.readline(*args)
609: (4)                def readlines(self, *args):
610: (8)                    return self._file.readlines(*args)
611: (4)                def seekable(self):
612: (8)                    return self._file.seekable()
613: (4)                def seek(self, *args):
614: (8)                    return self._file.seek(*args)
615: (4)                def tell(self):
616: (8)                    return self._file.tell()
617: (4)                def truncate(self, size=None):
618: (8)                    if size is None:
619: (12)                       return self._file.truncate()
620: (8)                    else:
621: (12)                       if size > self._max_size:
622: (16)                           self.rollover()
623: (12)                       return self._file.truncate(size)
624: (4)                def writable(self):
625: (8)                    return self._file.writable()
626: (4)                def write(self, s):
627: (8)                    file = self._file
628: (8)                    rv = file.write(s)
629: (8)                    self._check(file)
630: (8)                    return rv
631: (4)                def writelines(self, iterable):
632: (8)                    file = self._file
633: (8)                    rv = file.writelines(iterable)
634: (8)                    self._check(file)
635: (8)                    return rv
636: (4)                def detach(self):
637: (8)                    return self._file.detach()
638: (0)            class TemporaryDirectory:
639: (4)                """Create and return a temporary directory.  This has the same
640: (4)                behavior as mkdtemp but can be used as a context manager.  For
641: (4)                example:
642: (8)                    with TemporaryDirectory() as tmpdir:
643: (12)                       ...
644: (4)                Upon exiting the context, the directory and everything contained
645: (4)                in it are removed (unless delete=False is passed or an exception
646: (4)                is raised during cleanup and ignore_cleanup_errors is not True).
647: (4)                Optional Arguments:
648: (8)                    suffix - A str suffix for the directory name.  (see mkdtemp)
649: (8)                    prefix - A str prefix for the directory name.  (see mkdtemp)
650: (8)                    dir - A directory to create this temp dir in.  (see mkdtemp)
651: (8)                    ignore_cleanup_errors - False; ignore exceptions during cleanup?
652: (8)                    delete - True; whether the directory is automatically deleted.
653: (4)                """
654: (4)                def __init__(self, suffix=None, prefix=None, dir=None,
655: (17)                            ignore_cleanup_errors=False, *, delete=True):
656: (8)                    self.name = mkdtemp(suffix, prefix, dir)
657: (8)                    self._ignore_cleanup_errors = ignore_cleanup_errors
658: (8)                    self._delete = delete
659: (8)                    self._finalizer = _weakref.finalize(
660: (12)                       self, self._cleanup, self.name,
661: (12)                       warn_message="Implicitly cleaning up {!r}".format(self),
662: (12)                       ignore_errors=self._ignore_cleanup_errors, delete=self._delete)
663: (4)                @classmethod
664: (4)                def _rmtree(cls, name, ignore_errors=False, repeated=False):
665: (8)                    def onexc(func, path, exc):
666: (12)                       if isinstance(exc, PermissionError):
667: (16)                           if repeated and path == name:
668: (20)                               if ignore_errors:
669: (24)                                   return
670: (20)                               raise
671: (16)                           try:
672: (20)                               if path != name:
673: (24)                                   _resetperms(_os.path.dirname(path))
674: (20)                               _resetperms(path)
675: (20)                               try:
676: (24)                                   _os.unlink(path)
677: (20)                               except IsADirectoryError:
678: (24)                                   cls._rmtree(path, ignore_errors=ignore_errors)
679: (20)                               except PermissionError:
680: (24)                                   if not _os.path.isdir(path) or _os.path.isjunction(path):
681: (28)                                       if ignore_errors:
682: (32)                                           return
683: (28)                                       raise
684: (24)                                   cls._rmtree(path, ignore_errors=ignore_errors,
685: (36)                                               repeated=(path == name))
686: (16)                           except FileNotFoundError:
687: (20)                               pass
688: (12)                       elif isinstance(exc, FileNotFoundError):
689: (16)                           pass
690: (12)                       else:
691: (16)                           if not ignore_errors:
692: (20)                               raise
693: (8)                    _shutil.rmtree(name, onerror=onexc)
694: (4)                @classmethod
695: (4)                def _cleanup(cls, name, warn_message, ignore_errors=False, delete=True):
696: (8)                    if delete:
697: (12)                       cls._rmtree(name, ignore_errors=ignore_errors)
698: (12)                       _warnings.warn(warn_message, ResourceWarning)
699: (4)                def __repr__(self):
700: (8)                    return "<{} {!r}>".format(self.__class__.__name__, self.name)
701: (4)                def __enter__(self):
702: (8)                    return self.name
703: (4)                def __exit__(self, exc, value, tb):
704: (8)                    if self._delete:
705: (12)                       self.cleanup()
706: (4)                def cleanup(self):
707: (8)                    if self._finalizer.detach() or _os.path.exists(self.name):
708: (12)                       self._rmtree(self.name, ignore_errors=self._ignore_cleanup_errors)

----------------------------------------

File 6 - __init__.py:

1: (0)              

----------------------------------------

File 7 - __init__.py:

1: (0)              """An interface to GraphViz."""
2: (0)              import logging
3: (0)              __author__ = "Ero Carrera"
4: (0)              __version__ = "3.0.3"
5: (0)              __license__ = "MIT"
6: (0)              _logger = logging.getLogger(__name__)
7: (0)              _logger.debug("pydot initializing")
8: (0)              _logger.debug("pydot %s", __version__)
9: (0)              from pydot.core import *  # noqa: F403, E402
10: (0)             from pydot.exceptions import *  # noqa: E402, F403

----------------------------------------

File 8 - core.py:

1: (0)              """An interface to GraphViz."""
2: (0)              import copy
3: (0)              import errno
4: (0)              import logging
5: (0)              import os
6: (0)              import re
7: (0)              import subprocess
8: (0)              import sys
9: (0)              import pydot
10: (0)             import pydot.dot_parser
11: (0)             from pydot._vendor import tempfile
12: (0)             _logger = logging.getLogger(__name__)
13: (0)             _logger.debug("pydot core module initializing")
14: (0)             GRAPH_ATTRIBUTES = {
15: (4)                 "Damping", "K", "URL", "aspect", "bb", "bgcolor",
16: (4)                 "center", "charset", "clusterrank", "colorscheme", "comment", "compound",
17: (4)                 "concentrate", "defaultdist", "dim", "dimen", "diredgeconstraints",
18: (4)                 "dpi", "epsilon", "esep", "fontcolor", "fontname", "fontnames",
19: (4)                 "fontpath", "fontsize", "id", "label", "labeljust", "labelloc",
20: (4)                 "landscape", "layers", "layersep", "layout", "levels", "levelsgap",
21: (4)                 "lheight", "lp", "lwidth", "margin", "maxiter", "mclimit", "mindist",
22: (4)                 "mode", "model", "mosek", "nodesep", "nojustify", "normalize", "nslimit",
23: (4)                 "nslimit1", "ordering", "orientation", "outputorder", "overlap",
24: (4)                 "overlap_scaling", "pack", "packmode", "pad", "page", "pagedir",
25: (4)                 "quadtree", "quantum", "rankdir", "ranksep", "ratio", "remincross",
26: (4)                 "repulsiveforce", "resolution", "root", "rotate", "searchsize", "sep",
27: (4)                 "showboxes", "size", "smoothing", "sortv", "splines", "start",
28: (4)                 "stylesheet", "target", "truecolor", "viewport", "voro_margin",
29: (4)                 "rank"
30: (0)             }
31: (0)             EDGE_ATTRIBUTES = {
32: (4)                 "URL", "arrowhead", "arrowsize", "arrowtail",
33: (4)                 "color", "colorscheme", "comment", "constraint", "decorate", "dir",
34: (4)                 "edgeURL", "edgehref", "edgetarget", "edgetooltip", "fontcolor",
35: (4)                 "fontname", "fontsize", "headURL", "headclip", "headhref", "headlabel",
36: (4)                 "headport", "headtarget", "headtooltip", "href", "id", "label",
37: (4)                 "labelURL", "labelangle", "labeldistance", "labelfloat", "labelfontcolor",
38: (4)                 "labelfontname", "labelfontsize", "labelhref", "labeltarget",
39: (4)                 "labeltooltip", "layer", "len", "lhead", "lp", "ltail", "minlen",
40: (4)                 "nojustify", "penwidth", "pos", "samehead", "sametail", "showboxes",
41: (4)                 "style", "tailURL", "tailclip", "tailhref", "taillabel", "tailport",
42: (4)                 "tailtarget", "tailtooltip", "target", "tooltip", "weight",
43: (4)                 "rank"
44: (0)             }
45: (0)             NODE_ATTRIBUTES = {
46: (4)                 "URL", "color", "colorscheme", "comment",
47: (4)                 "distortion", "fillcolor", "fixedsize", "fontcolor", "fontname",
48: (4)                 "fontsize", "group", "height", "id", "image", "imagescale", "label",
49: (4)                 "labelloc", "layer", "margin", "nojustify", "orientation", "penwidth",
50: (4)                 "peripheries", "pin", "pos", "rects", "regular", "root", "samplepoints",
51: (4)                 "shape", "shapefile", "showboxes", "sides", "skew", "sortv", "style",
52: (4)                 "target", "tooltip", "vertices", "width", "z",
53: (4)                 "texlbl",  "texmode"
54: (0)             }
55: (0)             CLUSTER_ATTRIBUTES = {
56: (4)                 "K", "URL", "bgcolor", "color", "colorscheme",
57: (4)                 "fillcolor", "fontcolor", "fontname", "fontsize", "label", "labeljust",
58: (4)                 "labelloc", "lheight", "lp", "lwidth", "nojustify", "pencolor",
59: (4)                 "penwidth", "peripheries", "sortv", "style", "target", "tooltip"
60: (0)             }
61: (0)             OUTPUT_FORMATS = {
62: (4)                 "canon",
63: (4)                 "cmap",
64: (4)                 "cmapx",
65: (4)                 "cmapx_np",
66: (4)                 "dia",
67: (4)                 "dot",
68: (4)                 "fig",
69: (4)                 "gd",
70: (4)                 "gd2",
71: (4)                 "gif",
72: (4)                 "hpgl",
73: (4)                 "imap",
74: (4)                 "imap_np",
75: (4)                 "ismap",
76: (4)                 "jpe",
77: (4)                 "jpeg",
78: (4)                 "jpg",
79: (4)                 "mif",
80: (4)                 "mp",
81: (4)                 "pcl",
82: (4)                 "pdf",
83: (4)                 "pic",
84: (4)                 "plain",
85: (4)                 "plain-ext",
86: (4)                 "png",
87: (4)                 "ps",
88: (4)                 "ps2",
89: (4)                 "svg",
90: (4)                 "svgz",
91: (4)                 "vml",
92: (4)                 "vmlz",
93: (4)                 "vrml",
94: (4)                 "vtx",
95: (4)                 "wbmp",
96: (4)                 "xdot",
97: (4)                 "xlib",
98: (0)             }
99: (0)             DEFAULT_PROGRAMS = {
100: (4)                "dot",
101: (4)                "twopi",
102: (4)                "neato",
103: (4)                "circo",
104: (4)                "fdp",
105: (4)                "sfdp",
106: (0)            }
107: (0)            def __generate_attribute_methods(Klass, attrs):
108: (4)                """Generate setter and getter methods for attributes."""
109: (4)                for attr in attrs:
110: (8)                    def __getter(self, _attr=attr):
111: (12)                       return self.get(_attr)
112: (8)                    setattr(Klass, f"get_{attr}", __getter)
113: (8)                    def __setter(self, *args, _attr=attr):
114: (12)                       return self.set(_attr, *args)
115: (8)                    setattr(Klass, f"set_{attr}", __setter)
116: (0)            def __generate_format_methods(Klass):
117: (4)                """Generate create_ and write_ methods for formats."""
118: (4)                for frmt in OUTPUT_FORMATS:
119: (8)                    def __create_method(self, f=frmt, prog=None, encoding=None):
120: (12)                       """Refer to docstring of method `create`."""
121: (12)                       return self.create(format=f, prog=prog, encoding=encoding)
122: (8)                    setattr(Klass, f"create_{frmt}", __create_method)
123: (4)                for frmt in OUTPUT_FORMATS ^ {"raw"}:
124: (8)                    def __write_method(self, path, f=frmt, prog=None, encoding=None):
125: (12)                       """Refer to docstring of method `write`."""
126: (12)                       self.write(path, format=f, prog=prog, encoding=encoding)
127: (8)                    setattr(Klass, f"write_{frmt}", __write_method)
128: (0)            def is_windows():
129: (4)                return os.name == "nt"
130: (0)            def is_anaconda():
131: (4)                import glob
132: (4)                conda_pattern = os.path.join(sys.prefix, "conda-meta\\graphviz*.json")
133: (4)                return glob.glob(conda_pattern) != []
134: (0)            def get_executable_extension():
135: (4)                if is_windows():
136: (8)                    return ".bat" if is_anaconda() else ".exe"
137: (4)                else:
138: (8)                    return ""
139: (0)            def call_graphviz(program, arguments, working_dir, **kwargs):
140: (4)                if program in DEFAULT_PROGRAMS:
141: (8)                    extension = get_executable_extension()
142: (8)                    program += extension
143: (4)                if arguments is None:
144: (8)                    arguments = []
145: (4)                env = {
146: (8)                    "PATH": os.environ.get("PATH", ""),
147: (8)                    "LD_LIBRARY_PATH": os.environ.get("LD_LIBRARY_PATH", ""),
148: (8)                    "SYSTEMROOT": os.environ.get("SYSTEMROOT", ""),
149: (4)                }
150: (4)                program_with_args = [program] + arguments
151: (4)                process = subprocess.Popen(
152: (8)                    program_with_args,
153: (8)                    env=env,
154: (8)                    cwd=working_dir,
155: (8)                    shell=False,
156: (8)                    stderr=subprocess.PIPE,
157: (8)                    stdout=subprocess.PIPE,
158: (8)                    **kwargs,
159: (4)                )
160: (4)                stdout_data, stderr_data = process.communicate()
161: (4)                return stdout_data, stderr_data, process
162: (0)            class frozendict(dict):
163: (4)                def _blocked_attribute(obj):
164: (8)                    raise AttributeError("A frozendict cannot be modified.")
165: (4)                _blocked_attribute = property(_blocked_attribute)
166: (4)                __delitem__ = __setitem__ = clear = _blocked_attribute
167: (4)                pop = popitem = setdefault = update = _blocked_attribute
168: (4)                def __new__(cls, *args, **kw):
169: (8)                    new = dict.__new__(cls)
170: (8)                    args_ = []
171: (8)                    for arg in args:
172: (12)                       if isinstance(arg, dict):
173: (16)                           arg = copy.copy(arg)
174: (16)                           for k in arg:
175: (20)                               v = arg[k]
176: (20)                               if isinstance(v, frozendict):
177: (24)                                   arg[k] = v
178: (20)                               elif isinstance(v, dict):
179: (24)                                   arg[k] = frozendict(v)
180: (20)                               elif isinstance(v, list):
181: (24)                                   v_ = []
182: (24)                                   for elm in v:
183: (28)                                       if isinstance(elm, dict):
184: (32)                                           v_.append(frozendict(elm))
185: (28)                                       else:
186: (32)                                           v_.append(elm)
187: (24)                                   arg[k] = tuple(v_)
188: (16)                           args_.append(arg)
189: (12)                       else:
190: (16)                           args_.append(arg)
191: (8)                    dict.__init__(new, *args_, **kw)
192: (8)                    return new
193: (4)                def __init__(self, *args, **kw):
194: (8)                    pass
195: (4)                def __hash__(self):
196: (8)                    try:
197: (12)                       return self._cached_hash
198: (8)                    except AttributeError:
199: (12)                       h = self._cached_hash = hash(tuple(sorted(self.items())))
200: (12)                       return h
201: (4)                def __repr__(self):
202: (8)                    dict_repr = dict.__repr__(self)
203: (8)                    return f"frozendict({dict_repr})"
204: (0)            def make_quoted(s):
205: (4)                """Transform a string into a quoted string, escaping specials."""
206: (4)                replace = {
207: (8)                    ord('"'): r"\"",
208: (8)                    ord("\n"): r"\n",
209: (8)                    ord("\r"): r"\r",
210: (4)                }
211: (4)                return rf'"{s.translate(replace)}"'
212: (0)            dot_keywords = ["graph", "subgraph", "digraph", "node", "edge", "strict"]
213: (0)            re_numeric = re.compile(r"^([0-9]+\.?[0-9]*|[0-9]*\.[0-9]+)$")
214: (0)            re_dbl_quoted = re.compile(r'^".*"$', re.S)
215: (0)            re_html = re.compile(r"^<.*>$", re.S)
216: (0)            id_re_alpha_nums = re.compile(r"^[_a-zA-Z][a-zA-Z0-9_]*$")
217: (0)            id_re_alpha_nums_with_ports = re.compile(
218: (4)                r'^[_a-zA-Z][a-zA-Z0-9_:"]*[a-zA-Z0-9_"]+$'
219: (0)            )
220: (0)            id_re_with_port = re.compile(r"^([^:]*):([^:]*)$")
221: (0)            def any_needs_quotes(s):
222: (4)                """Determine if a string needs to be quoted.
223: (4)                Returns True, False, or None if the result is indeterminate.
224: (4)                """
225: (4)                if s.isdigit():
226: (8)                    return False
227: (4)                if s.isalnum():
228: (8)                    return s[0].isdigit()
229: (4)                has_high_chars = any(ord(c) > 0x7F or ord(c) == 0 for c in s)
230: (4)                if has_high_chars and not re_dbl_quoted.match(s) and not re_html.match(s):
231: (8)                    return True
232: (4)                for test_re in [re_numeric, re_dbl_quoted, re_html]:
233: (8)                    if test_re.match(s):
234: (12)                       return False
235: (4)                return None
236: (0)            def id_needs_quotes(s):
237: (4)                """Checks whether a string is a dot language ID.
238: (4)                It will check whether the string is solely composed
239: (4)                by the characters allowed in an ID or not.
240: (4)                If the string is one of the reserved keywords it will
241: (4)                need quotes too but the user will need to add them
242: (4)                manually.
243: (4)                """
244: (4)                if s in dot_keywords:
245: (8)                    return False
246: (4)                any_result = any_needs_quotes(s)
247: (4)                if any_result is not None:
248: (8)                    return any_result
249: (4)                for test_re in [
250: (8)                    id_re_alpha_nums,
251: (8)                    id_re_alpha_nums_with_ports,
252: (4)                ]:
253: (8)                    if test_re.match(s):
254: (12)                       return False
255: (4)                m = id_re_with_port.match(s)
256: (4)                if m:
257: (8)                    return id_needs_quotes(m.group(1)) or id_needs_quotes(m.group(2))
258: (4)                return True
259: (0)            def quote_id_if_necessary(s, unquoted_keywords=None):
260: (4)                """Enclose identifier in quotes, if needed."""
261: (4)                unquoted = [
262: (8)                    w.lower() for w in list(unquoted_keywords if unquoted_keywords else [])
263: (4)                ]
264: (4)                if isinstance(s, bool):
265: (8)                    return str(s).lower()
266: (4)                if not isinstance(s, str):
267: (8)                    return s
268: (4)                if not s:
269: (8)                    return s
270: (4)                if s.lower() in unquoted:
271: (8)                    return s
272: (4)                if s.lower() in dot_keywords:
273: (8)                    return make_quoted(s)
274: (4)                if id_needs_quotes(s):
275: (8)                    return make_quoted(s)
276: (4)                return s
277: (0)            def quote_attr_if_necessary(s):
278: (4)                """Enclose attribute value in quotes, if needed."""
279: (4)                if isinstance(s, bool):
280: (8)                    return str(s).lower()
281: (4)                if not isinstance(s, str):
282: (8)                    return s
283: (4)                if s in dot_keywords:
284: (8)                    return make_quoted(s)
285: (4)                any_result = any_needs_quotes(s)
286: (4)                if any_result is not None and not any_result:
287: (8)                    return s
288: (4)                return make_quoted(s)
289: (0)            def graph_from_dot_data(s):
290: (4)                """Load graphs from DOT description in string `s`.
291: (4)                This function is NOT thread-safe due to the internal use of `pyparsing`.
292: (4)                Use a lock if needed.
293: (4)                @param s: string in [DOT language](
294: (8)                    https://en.wikipedia.org/wiki/DOT_(graph_description_language))
295: (4)                @return: Graphs that result from parsing.
296: (4)                @rtype: `list` of `pydot.Dot`
297: (4)                """
298: (4)                return pydot.dot_parser.parse_dot_data(s)
299: (0)            def graph_from_dot_file(path, encoding=None):
300: (4)                """Load graphs from DOT file at `path`.
301: (4)                This function is NOT thread-safe due to the internal use of `pyparsing`.
302: (4)                Use a lock if needed.
303: (4)                @param path: to DOT file
304: (4)                @param encoding: as passed to `io.open`.
305: (8)                    For example, `'utf-8'`.
306: (4)                @return: Graphs that result from parsing.
307: (4)                @rtype: `list` of `pydot.Dot`
308: (4)                """
309: (4)                with open(path, encoding=encoding) as f:
310: (8)                    s = f.read()
311: (4)                graphs = graph_from_dot_data(s)
312: (4)                return graphs
313: (0)            def graph_from_edges(edge_list, node_prefix="", directed=False):
314: (4)                """Creates a basic graph out of an edge list.
315: (4)                The edge list has to be a list of tuples representing
316: (4)                the nodes connected by the edge.
317: (4)                The values can be anything: bool, int, float, str.
318: (4)                If the graph is undirected by default, it is only
319: (4)                calculated from one of the symmetric halves of the matrix.
320: (4)                """
321: (4)                if directed:
322: (8)                    graph = Dot(graph_type="digraph")
323: (4)                else:
324: (8)                    graph = Dot(graph_type="graph")
325: (4)                for edge in edge_list:
326: (8)                    if isinstance(edge[0], str):
327: (12)                       src = node_prefix + edge[0]
328: (8)                    else:
329: (12)                       src = node_prefix + str(edge[0])
330: (8)                    if isinstance(edge[1], str):
331: (12)                       dst = node_prefix + edge[1]
332: (8)                    else:
333: (12)                       dst = node_prefix + str(edge[1])
334: (8)                    e = Edge(src, dst)
335: (8)                    graph.add_edge(e)
336: (4)                return graph
337: (0)            def graph_from_adjacency_matrix(matrix, node_prefix="", directed=False):
338: (4)                """Creates a basic graph out of an adjacency matrix.
339: (4)                The matrix has to be a list of rows of values
340: (4)                representing an adjacency matrix.
341: (4)                The values can be anything: bool, int, float, as long
342: (4)                as they can evaluate to True or False.
343: (4)                """
344: (4)                node_orig = 1
345: (4)                if directed:
346: (8)                    graph = Dot(graph_type="digraph")
347: (4)                else:
348: (8)                    graph = Dot(graph_type="graph")
349: (4)                for row in matrix:
350: (8)                    if not directed:
351: (12)                       skip = matrix.index(row)
352: (12)                       r = row[skip:]
353: (8)                    else:
354: (12)                       skip = 0
355: (12)                       r = row
356: (8)                    node_dest = skip + 1
357: (8)                    for e in r:
358: (12)                       if e:
359: (16)                           graph.add_edge(
360: (20)                               Edge(
361: (24)                                   f"{node_prefix}{node_orig}",
362: (24)                                   f"{node_prefix}{node_dest}",
363: (20)                               )
364: (16)                           )
365: (12)                       node_dest += 1
366: (8)                    node_orig += 1
367: (4)                return graph
368: (0)            def graph_from_incidence_matrix(matrix, node_prefix="", directed=False):
369: (4)                """Creates a basic graph out of an incidence matrix.
370: (4)                The matrix has to be a list of rows of values
371: (4)                representing an incidence matrix.
372: (4)                The values can be anything: bool, int, float, as long
373: (4)                as they can evaluate to True or False.
374: (4)                """
375: (4)                if directed:
376: (8)                    graph = Dot(graph_type="digraph")
377: (4)                else:
378: (8)                    graph = Dot(graph_type="graph")
379: (4)                for row in matrix:
380: (8)                    nodes = []
381: (8)                    c = 1
382: (8)                    for node in row:
383: (12)                       if node:
384: (16)                           nodes.append(c * node)
385: (12)                       c += 1
386: (12)                       nodes.sort()
387: (8)                    if len(nodes) == 2:
388: (12)                       graph.add_edge(
389: (16)                           Edge(
390: (20)                               f"{node_prefix}{abs(nodes[0])}",
391: (20)                               f"{node_prefix}{nodes[1]}",
392: (16)                           )
393: (12)                       )
394: (4)                if not directed:
395: (8)                    graph.set_simplify(True)
396: (4)                return graph
397: (0)            class Common:
398: (4)                """Common information to several classes.
399: (4)                Should not be directly used, several classes are derived from
400: (4)                this one.
401: (4)                """
402: (4)                def __getstate__(self):
403: (8)                    dict = copy.copy(self.obj_dict)
404: (8)                    return dict
405: (4)                def __setstate__(self, state):
406: (8)                    self.obj_dict = state
407: (4)                def __get_attribute__(self, attr):
408: (8)                    """Look for default attributes for this node"""
409: (8)                    attr_val = self.obj_dict["attributes"].get(attr, None)
410: (8)                    if attr_val is None:
411: (12)                       default_node_name = self.obj_dict["type"]
412: (12)                       if default_node_name in ("subgraph", "digraph", "cluster"):
413: (16)                           default_node_name = "graph"
414: (12)                       g = self.get_parent_graph()
415: (12)                       if g is not None:
416: (16)                           defaults = g.get_node(default_node_name)
417: (12)                       else:
418: (16)                           return None
419: (12)                       if not isinstance(defaults, (list, tuple)):
420: (16)                           defaults = [defaults]
421: (12)                       for default in defaults:
422: (16)                           attr_val = default.obj_dict["attributes"].get(attr, None)
423: (16)                           if attr_val:
424: (20)                               return attr_val
425: (8)                    else:
426: (12)                       return attr_val
427: (8)                    return None
428: (4)                def set_parent_graph(self, parent_graph):
429: (8)                    self.obj_dict["parent_graph"] = parent_graph
430: (4)                def get_parent_graph(self):
431: (8)                    return self.obj_dict.get("parent_graph", None)
432: (4)                def get_top_graph_type(self):
433: (8)                    """Find the topmost parent graph type for the current object."""
434: (8)                    parent = self.get_parent_graph()
435: (8)                    if parent is None:
436: (12)                       return None
437: (8)                    while True:
438: (12)                       parent_ = parent.get_parent_graph()
439: (12)                       if parent_ == parent:
440: (16)                           break
441: (12)                       parent = parent_
442: (8)                    return parent.obj_dict["type"]
443: (4)                def set(self, name, value):
444: (8)                    """Set an attribute value by name.
445: (8)                    Given an attribute 'name' it will set its value to 'value'.
446: (8)                    There's always the possibility of using the methods:
447: (12)                       set_'name'(value)
448: (8)                    which are defined for all the existing attributes.
449: (8)                    """
450: (8)                    self.obj_dict["attributes"][name] = value
451: (4)                def get(self, name):
452: (8)                    """Get an attribute value by name.
453: (8)                    Given an attribute 'name' it will get its value.
454: (8)                    There's always the possibility of using the methods:
455: (12)                       get_'name'()
456: (8)                    which are defined for all the existing attributes.
457: (8)                    """
458: (8)                    return self.obj_dict["attributes"].get(name, None)
459: (4)                def get_attributes(self):
460: (8)                    """Get attributes of the object"""
461: (8)                    return self.obj_dict["attributes"]
462: (4)                def set_sequence(self, seq):
463: (8)                    """Set sequence"""
464: (8)                    self.obj_dict["sequence"] = seq
465: (4)                def get_sequence(self):
466: (8)                    """Get sequence"""
467: (8)                    return self.obj_dict["sequence"]
468: (4)                @staticmethod
469: (4)                def get_indent(indent, indent_level):
470: (8)                    if isinstance(indent, (int, float)):
471: (12)                       indent_str = " " * int(indent)
472: (8)                    else:
473: (12)                       indent_str = str(indent)
474: (8)                    return indent_str * indent_level
475: (4)                @staticmethod
476: (4)                def _format_attr(key: str, value):
477: (8)                    """Turn a key-value pair into an attribute, properly quoted."""
478: (8)                    if value == "":
479: (12)                       value = '""'
480: (8)                    if value is not None:
481: (12)                       return f"{key}={quote_attr_if_necessary(value)}"
482: (8)                    return key
483: (4)                def formatted_attr_list(self):
484: (8)                    """Return a list of the class's attributes as formatted strings."""
485: (8)                    return [
486: (12)                       self._format_attr(k, v)
487: (12)                       for k, v in self.obj_dict["attributes"].items()
488: (8)                    ]
489: (4)                def attrs_string(self, prefix=""):
490: (8)                    """Format the current attributes list for output.
491: (8)                    The `prefix` string will be prepended if and only if some
492: (8)                    output is generated."""
493: (8)                    attrs = self.formatted_attr_list()
494: (8)                    if not attrs:
495: (12)                       return ""
496: (8)                    return f"{prefix}[{', '.join(attrs)}]"
497: (0)            class Node(Common):
498: (4)                """A graph node.
499: (4)                This class represents a graph's node with all its attributes.
500: (4)                node(name, attribute=value, ...)
501: (4)                name: node's name
502: (4)                All the attributes defined in the Graphviz dot language should
503: (4)                be supported.
504: (4)                """
505: (4)                def __init__(self, name="", obj_dict=None, **attrs):
506: (8)                    if obj_dict is not None:
507: (12)                       self.obj_dict = obj_dict
508: (8)                    else:
509: (12)                       self.obj_dict = {}
510: (12)                       self.obj_dict["attributes"] = dict(attrs)
511: (12)                       self.obj_dict["type"] = "node"
512: (12)                       self.obj_dict["parent_graph"] = None
513: (12)                       self.obj_dict["sequence"] = None
514: (12)                       port = None
515: (12)                       if isinstance(name, str) and not name.startswith('"'):
516: (16)                           idx = name.find(":")
517: (16)                           if idx > 0 and idx + 1 < len(name):
518: (20)                               name, port = name[:idx], name[idx:]
519: (12)                       if isinstance(name, int):
520: (16)                           name = str(name)
521: (12)                       self.obj_dict["name"] = name
522: (12)                       self.obj_dict["port"] = port
523: (4)                def __str__(self):
524: (8)                    return self.to_string()
525: (4)                def set_name(self, node_name):
526: (8)                    """Set the node's name."""
527: (8)                    self.obj_dict["name"] = node_name
528: (4)                def get_name(self):
529: (8)                    """Get the node's name."""
530: (8)                    return self.obj_dict["name"]
531: (4)                def get_port(self):
532: (8)                    """Get the node's port."""
533: (8)                    return self.obj_dict["port"]
534: (4)                def add_style(self, style):
535: (8)                    styles = self.obj_dict["attributes"].get("style", None)
536: (8)                    if not styles and style:
537: (12)                       styles = [style]
538: (8)                    else:
539: (12)                       styles = styles.split(",")
540: (12)                       styles.append(style)
541: (8)                    self.obj_dict["attributes"]["style"] = ",".join(styles)
542: (4)                def to_string(self, indent="", indent_level=1):
543: (8)                    """Return string representation of node in DOT language."""
544: (8)                    indent_str = self.get_indent(indent, indent_level)
545: (8)                    node = quote_id_if_necessary(
546: (12)                       self.obj_dict["name"], unquoted_keywords=("graph", "node", "edge")
547: (8)                    )
548: (8)                    if (
549: (12)                       node in ("graph", "node", "edge")
550: (12)                       and len(self.obj_dict.get("attributes", {})) == 0
551: (8)                    ):
552: (12)                       return ""
553: (8)                    return f"{indent_str}{node}{self.attrs_string(prefix=' ')};"
554: (0)            __generate_attribute_methods(Node, NODE_ATTRIBUTES)
555: (0)            class Edge(Common):
556: (4)                """A graph edge.
557: (4)                This class represents a graph's edge with all its attributes.
558: (4)                edge(src, dst, attribute=value, ...)
559: (4)                src: source node, subgraph or cluster
560: (4)                dst: destination node, subgraph or cluster
561: (4)                `src` and `dst` can be specified as a `Node`, `Subgraph` or
562: (4)                `Cluster` object, or as the name string of such a component.
563: (4)                All the attributes defined in the Graphviz dot language should
564: (4)                be supported.
565: (4)                Attributes can be set through the dynamically generated methods:
566: (5)                 set_[attribute name], i.e. set_label, set_fontname
567: (4)                or directly by using the instance's special dictionary:
568: (5)                 Edge.obj_dict['attributes'][attribute name], i.e.
569: (8)                    edge_instance.obj_dict['attributes']['label']
570: (8)                    edge_instance.obj_dict['attributes']['fontname']
571: (4)                """
572: (4)                def __init__(self, src="", dst="", obj_dict=None, **attrs):
573: (8)                    self.obj_dict = {}
574: (8)                    if isinstance(src, (Node, Subgraph, Cluster)):
575: (12)                       src = src.get_name()
576: (8)                    if isinstance(dst, (Node, Subgraph, Cluster)):
577: (12)                       dst = dst.get_name()
578: (8)                    points = (src, dst)
579: (8)                    self.obj_dict["points"] = points
580: (8)                    if obj_dict is None:
581: (12)                       self.obj_dict["attributes"] = dict(attrs)
582: (12)                       self.obj_dict["type"] = "edge"
583: (12)                       self.obj_dict["parent_graph"] = None
584: (12)                       self.obj_dict["sequence"] = None
585: (8)                    else:
586: (12)                       self.obj_dict = obj_dict
587: (4)                def __str__(self):
588: (8)                    return self.to_string()
589: (4)                def get_source(self):
590: (8)                    """Get the edges source node name."""
591: (8)                    return self.obj_dict["points"][0]
592: (4)                def get_destination(self):
593: (8)                    """Get the edge's destination node name."""
594: (8)                    return self.obj_dict["points"][1]
595: (4)                def __hash__(self):
596: (8)                    return hash(hash(self.get_source()) + hash(self.get_destination()))
597: (4)                def __eq__(self, edge):
598: (8)                    """Compare two edges.
599: (8)                    If the parent graph is directed, arcs linking
600: (8)                    node A to B are considered equal and A->B != B->A
601: (8)                    If the parent graph is undirected, any edge
602: (8)                    connecting two nodes is equal to any other
603: (8)                    edge connecting the same nodes, A->B == B->A
604: (8)                    """
605: (8)                    if not isinstance(edge, Edge):
606: (12)                       raise pydot.Error("Can not compare an edge to a non-edge object.")
607: (8)                    if self.get_top_graph_type() == "graph":
608: (12)                       if (
609: (16)                           self.get_source() == edge.get_source()
610: (16)                           and self.get_destination() == edge.get_destination()
611: (12)                       ) or (
612: (16)                           edge.get_source() == self.get_destination()
613: (16)                           and edge.get_destination() == self.get_source()
614: (12)                       ):
615: (16)                           return True
616: (8)                    else:
617: (12)                       if (
618: (16)                           self.get_source() == edge.get_source()
619: (16)                           and self.get_destination() == edge.get_destination()
620: (12)                       ):
621: (16)                           return True
622: (8)                    return False
623: (4)                def parse_node_ref(self, node_str):
624: (8)                    if not isinstance(node_str, str):
625: (12)                       return node_str
626: (8)                    if node_str.startswith('"') and node_str.endswith('"'):
627: (12)                       return node_str
628: (8)                    node_port_idx = node_str.rfind(":")
629: (8)                    if (
630: (12)                       node_port_idx > 0
631: (12)                       and node_str[0] == '"'
632: (12)                       and node_str[node_port_idx - 1] == '"'
633: (8)                    ):
634: (12)                       return node_str
635: (8)                    if node_port_idx > 0:
636: (12)                       a = node_str[:node_port_idx]
637: (12)                       b = node_str[node_port_idx + 1 :]
638: (12)                       node = quote_id_if_necessary(a)
639: (12)                       node += ":" + quote_id_if_necessary(b)
640: (12)                       return node
641: (8)                    return quote_id_if_necessary(node_str)
642: (4)                def to_string(self, indent="", indent_level=1):
643: (8)                    """Return string representation of edge in DOT language."""
644: (8)                    src = self.parse_node_ref(self.get_source())
645: (8)                    dst = self.parse_node_ref(self.get_destination())
646: (8)                    indent_str = self.get_indent(indent, indent_level)
647: (8)                    if isinstance(src, frozendict):
648: (12)                       sgraph = Subgraph(obj_dict=src)
649: (12)                       edge = [
650: (16)                           sgraph.to_string(
651: (20)                               indent=indent, indent_level=indent_level, inline=True
652: (16)                           )
653: (12)                       ]
654: (8)                    elif isinstance(src, int):
655: (12)                       edge = [str(src)]
656: (8)                    else:
657: (12)                       edge = [src]
658: (8)                    if self.get_top_graph_type() == "digraph":
659: (12)                       edge.append("->")
660: (8)                    else:
661: (12)                       edge.append("--")
662: (8)                    if isinstance(dst, frozendict):
663: (12)                       sgraph = Subgraph(obj_dict=dst)
664: (12)                       edge.append(
665: (16)                           sgraph.to_string(
666: (20)                               indent=indent, indent_level=indent_level, inline=True
667: (16)                           )
668: (12)                       )
669: (8)                    elif isinstance(dst, int):
670: (12)                       edge.append(str(dst))
671: (8)                    else:
672: (12)                       edge.append(dst)
673: (8)                    return f"{indent_str}{' '.join(edge)}{self.attrs_string(prefix=' ')};"
674: (0)            __generate_attribute_methods(Edge, EDGE_ATTRIBUTES)
675: (0)            class Graph(Common):
676: (4)                """Class representing a graph in Graphviz's dot language.
677: (4)                This class implements the methods to work on a representation
678: (4)                of a graph in Graphviz's dot language.
679: (4)                graph(  graph_name='G', graph_type='digraph',
680: (8)                    strict=False, suppress_disconnected=False, attribute=value, ...)
681: (4)                graph_name:
682: (8)                    the graph's name
683: (4)                graph_type:
684: (8)                    can be 'graph' or 'digraph'
685: (4)                suppress_disconnected:
686: (8)                    defaults to False, which will remove from the
687: (8)                    graph any disconnected nodes.
688: (4)                simplify:
689: (8)                    if True it will avoid displaying equal edges, i.e.
690: (8)                    only one edge between two nodes. removing the
691: (8)                    duplicated ones.
692: (4)                All the attributes defined in the Graphviz dot language should
693: (4)                be supported.
694: (4)                Attributes can be set through the dynamically generated methods:
695: (5)                 set_[attribute name], i.e. set_size, set_fontname
696: (4)                or using the instance's attributes:
697: (5)                 Graph.obj_dict['attributes'][attribute name], i.e.
698: (8)                    graph_instance.obj_dict['attributes']['label']
699: (8)                    graph_instance.obj_dict['attributes']['fontname']
700: (4)                """
701: (4)                def __init__(
702: (8)                    self,
703: (8)                    graph_name="G",
704: (8)                    obj_dict=None,
705: (8)                    graph_type="digraph",
706: (8)                    strict=False,
707: (8)                    suppress_disconnected=False,
708: (8)                    simplify=False,
709: (8)                    **attrs,
710: (4)                ):
711: (8)                    if obj_dict is not None:
712: (12)                       self.obj_dict = obj_dict
713: (8)                    else:
714: (12)                       self.obj_dict = {}
715: (12)                       self.obj_dict["attributes"] = dict(attrs)
716: (12)                       if graph_type not in ["graph", "digraph"]:
717: (16)                           raise pydot.Error(
718: (20)                               f'Invalid type "{graph_type}". '
719: (20)                               "Accepted graph types are: graph, digraph"
720: (16)                           )
721: (12)                       self.obj_dict["name"] = graph_name
722: (12)                       self.obj_dict["type"] = graph_type
723: (12)                       self.obj_dict["strict"] = strict
724: (12)                       self.obj_dict["suppress_disconnected"] = suppress_disconnected
725: (12)                       self.obj_dict["simplify"] = simplify
726: (12)                       self.obj_dict["current_child_sequence"] = 1
727: (12)                       self.obj_dict["nodes"] = {}
728: (12)                       self.obj_dict["edges"] = {}
729: (12)                       self.obj_dict["subgraphs"] = {}
730: (12)                       self.set_parent_graph(self)
731: (4)                def __str__(self):
732: (8)                    return self.to_string()
733: (4)                def get_graph_type(self):
734: (8)                    return self.obj_dict["type"]
735: (4)                def set_graph_defaults(self, **attrs):
736: (8)                    self.add_node(Node("graph", **attrs))
737: (4)                def get_graph_defaults(self, **attrs):
738: (8)                    graph_nodes = self.get_node("graph")
739: (8)                    if isinstance(graph_nodes, (list, tuple)):
740: (12)                       return [node.get_attributes() for node in graph_nodes]
741: (8)                    return graph_nodes.get_attributes()
742: (4)                def set_node_defaults(self, **attrs):
743: (8)                    """Define default node attributes.
744: (8)                    These attributes only apply to nodes added to the graph after
745: (8)                    calling this method.
746: (8)                    """
747: (8)                    self.add_node(Node("node", **attrs))
748: (4)                def get_node_defaults(self, **attrs):
749: (8)                    graph_nodes = self.get_node("node")
750: (8)                    if isinstance(graph_nodes, (list, tuple)):
751: (12)                       return [node.get_attributes() for node in graph_nodes]
752: (8)                    return graph_nodes.get_attributes()
753: (4)                def set_edge_defaults(self, **attrs):
754: (8)                    self.add_node(Node("edge", **attrs))
755: (4)                def get_edge_defaults(self, **attrs):
756: (8)                    graph_nodes = self.get_node("edge")
757: (8)                    if isinstance(graph_nodes, (list, tuple)):
758: (12)                       return [node.get_attributes() for node in graph_nodes]
759: (8)                    return graph_nodes.get_attributes()
760: (4)                def set_simplify(self, simplify):
761: (8)                    """Set whether to simplify or not.
762: (8)                    If True it will avoid displaying equal edges, i.e.
763: (8)                    only one edge between two nodes. removing the
764: (8)                    duplicated ones.
765: (8)                    """
766: (8)                    self.obj_dict["simplify"] = simplify
767: (4)                def get_simplify(self):
768: (8)                    """Get whether to simplify or not.
769: (8)                    Refer to set_simplify for more information.
770: (8)                    """
771: (8)                    return self.obj_dict["simplify"]
772: (4)                def set_type(self, graph_type):
773: (8)                    """Set the graph's type, 'graph' or 'digraph'."""
774: (8)                    self.obj_dict["type"] = graph_type
775: (4)                def get_type(self):
776: (8)                    """Get the graph's type, 'graph' or 'digraph'."""
777: (8)                    return self.obj_dict["type"]
778: (4)                def set_name(self, graph_name):
779: (8)                    """Set the graph's name."""
780: (8)                    self.obj_dict["name"] = graph_name
781: (4)                def get_name(self):
782: (8)                    """Get the graph's name."""
783: (8)                    return self.obj_dict["name"]
784: (4)                def set_strict(self, val):
785: (8)                    """Set graph to 'strict' mode.
786: (8)                    This option is only valid for top level graphs.
787: (8)                    """
788: (8)                    self.obj_dict["strict"] = val
789: (4)                def get_strict(self, val):
790: (8)                    """Get graph's 'strict' mode (True, False).
791: (8)                    This option is only valid for top level graphs.
792: (8)                    """
793: (8)                    return self.obj_dict["strict"]
794: (4)                def set_suppress_disconnected(self, val):
795: (8)                    """Suppress disconnected nodes in the output graph.
796: (8)                    This option will skip nodes in
797: (8)                    the graph with no incoming or outgoing
798: (8)                    edges. This option works also
799: (8)                    for subgraphs and has effect only in the
800: (8)                    current graph/subgraph.
801: (8)                    """
802: (8)                    self.obj_dict["suppress_disconnected"] = val
803: (4)                def get_suppress_disconnected(self, val):
804: (8)                    """Get if suppress disconnected is set.
805: (8)                    Refer to set_suppress_disconnected for more information.
806: (8)                    """
807: (8)                    return self.obj_dict["suppress_disconnected"]
808: (4)                def get_next_sequence_number(self):
809: (8)                    seq = self.obj_dict["current_child_sequence"]
810: (8)                    self.obj_dict["current_child_sequence"] += 1
811: (8)                    return seq
812: (4)                def add_node(self, graph_node):
813: (8)                    """Adds a node object to the graph.
814: (8)                    It takes a node object as its only argument and returns
815: (8)                    None.
816: (8)                    """
817: (8)                    if not isinstance(graph_node, Node):
818: (12)                       raise TypeError(
819: (16)                           "add_node() received "
820: (16)                           + "a non node class object: "
821: (16)                           + str(graph_node)
822: (12)                       )
823: (8)                    node = self.get_node(graph_node.get_name())
824: (8)                    if not node:
825: (12)                       self.obj_dict["nodes"][graph_node.get_name()] = [
826: (16)                           graph_node.obj_dict
827: (12)                       ]
828: (8)                    else:
829: (12)                       self.obj_dict["nodes"][graph_node.get_name()].append(
830: (16)                           graph_node.obj_dict
831: (12)                       )
832: (8)                    if not node or graph_node.get_parent_graph() is None:
833: (12)                       graph_node.set_parent_graph(self.get_parent_graph())
834: (8)                    graph_node.set_sequence(self.get_next_sequence_number())
835: (4)                def del_node(self, name, index=None):
836: (8)                    """Delete a node from the graph.
837: (8)                    Given a node's name all node(s) with that same name
838: (8)                    will be deleted if 'index' is not specified or set
839: (8)                    to None.
840: (8)                    If there are several nodes with that same name and
841: (8)                    'index' is given, only the node in that position
842: (8)                    will be deleted.
843: (8)                    'index' should be an integer specifying the position
844: (8)                    of the node to delete. If index is larger than the
845: (8)                    number of nodes with that name, no action is taken.
846: (8)                    If nodes are deleted it returns True. If no action
847: (8)                    is taken it returns False.
848: (8)                    """
849: (8)                    if isinstance(name, Node):
850: (12)                       name = name.get_name()
851: (8)                    if name in self.obj_dict["nodes"]:
852: (12)                       if index is not None and index < len(self.obj_dict["nodes"][name]):
853: (16)                           del self.obj_dict["nodes"][name][index]
854: (16)                           return True
855: (12)                       else:
856: (16)                           del self.obj_dict["nodes"][name]
857: (16)                           return True
858: (8)                    return False
859: (4)                def get_node(self, name):
860: (8)                    """Retrieve a node from the graph.
861: (8)                    Given a node's name the corresponding Node
862: (8)                    instance will be returned.
863: (8)                    If one or more nodes exist with that name a list of
864: (8)                    Node instances is returned.
865: (8)                    An empty list is returned otherwise.
866: (8)                    """
867: (8)                    match = []
868: (8)                    if name in self.obj_dict["nodes"]:
869: (12)                       match.extend(
870: (16)                           [
871: (20)                               Node(obj_dict=obj_dict)
872: (20)                               for obj_dict in self.obj_dict["nodes"][name]
873: (16)                           ]
874: (12)                       )
875: (8)                    return match
876: (4)                def get_nodes(self):
877: (8)                    """Get the list of Node instances."""
878: (8)                    return self.get_node_list()
879: (4)                def get_node_list(self):
880: (8)                    """Get the list of Node instances.
881: (8)                    This method returns the list of Node instances
882: (8)                    composing the graph.
883: (8)                    """
884: (8)                    node_objs = []
885: (8)                    for node in self.obj_dict["nodes"]:
886: (12)                       obj_dict_list = self.obj_dict["nodes"][node]
887: (12)                       node_objs.extend([Node(obj_dict=obj_d) for obj_d in obj_dict_list])
888: (8)                    return node_objs
889: (4)                def add_edge(self, graph_edge):
890: (8)                    """Adds an edge object to the graph.
891: (8)                    It takes a edge object as its only argument and returns
892: (8)                    None.
893: (8)                    """
894: (8)                    if not isinstance(graph_edge, Edge):
895: (12)                       raise TypeError(
896: (16)                           "add_edge() received a non edge class object: "
897: (16)                           + str(graph_edge)
898: (12)                       )
899: (8)                    edge_points = (graph_edge.get_source(), graph_edge.get_destination())
900: (8)                    if edge_points in self.obj_dict["edges"]:
901: (12)                       edge_list = self.obj_dict["edges"][edge_points]
902: (12)                       edge_list.append(graph_edge.obj_dict)
903: (8)                    else:
904: (12)                       self.obj_dict["edges"][edge_points] = [graph_edge.obj_dict]
905: (8)                    graph_edge.set_sequence(self.get_next_sequence_number())
906: (8)                    graph_edge.set_parent_graph(self.get_parent_graph())
907: (4)                def del_edge(self, src_or_list, dst=None, index=None):
908: (8)                    """Delete an edge from the graph.
909: (8)                    Given an edge's (source, destination) node names all
910: (8)                    matching edges(s) will be deleted if 'index' is not
911: (8)                    specified or set to None.
912: (8)                    If there are several matching edges and 'index' is
913: (8)                    given, only the edge in that position will be deleted.
914: (8)                    'index' should be an integer specifying the position
915: (8)                    of the edge to delete. If index is larger than the
916: (8)                    number of matching edges, no action is taken.
917: (8)                    If edges are deleted it returns True. If no action
918: (8)                    is taken it returns False.
919: (8)                    """
920: (8)                    if isinstance(src_or_list, (list, tuple)):
921: (12)                       if dst is not None and isinstance(dst, int):
922: (16)                           index = dst
923: (12)                       src, dst = src_or_list
924: (8)                    else:
925: (12)                       src, dst = src_or_list, dst
926: (8)                    if isinstance(src, Node):
927: (12)                       src = src.get_name()
928: (8)                    if isinstance(dst, Node):
929: (12)                       dst = dst.get_name()
930: (8)                    if (src, dst) in self.obj_dict["edges"]:
931: (12)                       if index is not None and index < len(
932: (16)                           self.obj_dict["edges"][(src, dst)]
933: (12)                       ):
934: (16)                           del self.obj_dict["edges"][(src, dst)][index]
935: (16)                           return True
936: (12)                       else:
937: (16)                           del self.obj_dict["edges"][(src, dst)]
938: (16)                           return True
939: (8)                    return False
940: (4)                def get_edge(self, src_or_list, dst=None):
941: (8)                    """Retrieved an edge from the graph.
942: (8)                    Given an edge's source and destination the corresponding
943: (8)                    Edge instance(s) will be returned.
944: (8)                    If one or more edges exist with that source and destination
945: (8)                    a list of Edge instances is returned.
946: (8)                    An empty list is returned otherwise.
947: (8)                    """
948: (8)                    if isinstance(src_or_list, (list, tuple)) and dst is None:
949: (12)                       edge_points = tuple(src_or_list)
950: (12)                       edge_points_reverse = (edge_points[1], edge_points[0])
951: (8)                    else:
952: (12)                       edge_points = (src_or_list, dst)
953: (12)                       edge_points_reverse = (dst, src_or_list)
954: (8)                    match = []
955: (8)                    if edge_points in self.obj_dict["edges"] or (
956: (12)                       self.get_top_graph_type() == "graph"
957: (12)                       and edge_points_reverse in self.obj_dict["edges"]
958: (8)                    ):
959: (12)                       edges_obj_dict = self.obj_dict["edges"].get(
960: (16)                           edge_points,
961: (16)                           self.obj_dict["edges"].get(edge_points_reverse, None),
962: (12)                       )
963: (12)                       for edge_obj_dict in edges_obj_dict:
964: (16)                           match.append(
965: (20)                               Edge(
966: (24)                                   edge_points[0], edge_points[1], obj_dict=edge_obj_dict
967: (20)                               )
968: (16)                           )
969: (8)                    return match
970: (4)                def get_edges(self):
971: (8)                    return self.get_edge_list()
972: (4)                def get_edge_list(self):
973: (8)                    """Get the list of Edge instances.
974: (8)                    This method returns the list of Edge instances
975: (8)                    composing the graph.
976: (8)                    """
977: (8)                    edge_objs = []
978: (8)                    for edge in self.obj_dict["edges"]:
979: (12)                       obj_dict_list = self.obj_dict["edges"][edge]
980: (12)                       edge_objs.extend([Edge(obj_dict=obj_d) for obj_d in obj_dict_list])
981: (8)                    return edge_objs
982: (4)                def add_subgraph(self, sgraph):
983: (8)                    """Adds an subgraph object to the graph.
984: (8)                    It takes a subgraph object as its only argument and returns
985: (8)                    None.
986: (8)                    """
987: (8)                    if not isinstance(sgraph, Subgraph) and not isinstance(
988: (12)                       sgraph, Cluster
989: (8)                    ):
990: (12)                       raise TypeError(
991: (16)                           "add_subgraph() received a non subgraph class object:"
992: (16)                           + str(sgraph)
993: (12)                       )
994: (8)                    if sgraph.get_name() in self.obj_dict["subgraphs"]:
995: (12)                       sgraph_list = self.obj_dict["subgraphs"][sgraph.get_name()]
996: (12)                       sgraph_list.append(sgraph.obj_dict)
997: (8)                    else:
998: (12)                       self.obj_dict["subgraphs"][sgraph.get_name()] = [sgraph.obj_dict]
999: (8)                    sgraph.set_sequence(self.get_next_sequence_number())
1000: (8)                   sgraph.set_parent_graph(self.get_parent_graph())
1001: (4)               def get_subgraph(self, name):
1002: (8)                   """Retrieved a subgraph from the graph.
1003: (8)                   Given a subgraph's name the corresponding
1004: (8)                   Subgraph instance will be returned.
1005: (8)                   If one or more subgraphs exist with the same name, a list of
1006: (8)                   Subgraph instances is returned.
1007: (8)                   An empty list is returned otherwise.
1008: (8)                   """
1009: (8)                   match = []
1010: (8)                   if name in self.obj_dict["subgraphs"]:
1011: (12)                      sgraphs_obj_dict = self.obj_dict["subgraphs"].get(name)
1012: (12)                      for obj_dict_list in sgraphs_obj_dict:
1013: (16)                          match.append(Subgraph(obj_dict=obj_dict_list))
1014: (8)                   return match
1015: (4)               def get_subgraphs(self):
1016: (8)                   return self.get_subgraph_list()
1017: (4)               def get_subgraph_list(self):
1018: (8)                   """Get the list of Subgraph instances.
1019: (8)                   This method returns the list of Subgraph instances
1020: (8)                   in the graph.
1021: (8)                   """
1022: (8)                   sgraph_objs = []
1023: (8)                   for sgraph in self.obj_dict["subgraphs"]:
1024: (12)                      obj_dict_list = self.obj_dict["subgraphs"][sgraph]
1025: (12)                      sgraph_objs.extend(
1026: (16)                          [Subgraph(obj_dict=obj_d) for obj_d in obj_dict_list]
1027: (12)                      )
1028: (8)                   return sgraph_objs
1029: (4)               def set_parent_graph(self, parent_graph):
1030: (8)                   self.obj_dict["parent_graph"] = parent_graph
1031: (8)                   for k in self.obj_dict["nodes"]:
1032: (12)                      obj_list = self.obj_dict["nodes"][k]
1033: (12)                      for obj in obj_list:
1034: (16)                          obj["parent_graph"] = parent_graph
1035: (8)                   for k in self.obj_dict["edges"]:
1036: (12)                      obj_list = self.obj_dict["edges"][k]
1037: (12)                      for obj in obj_list:
1038: (16)                          obj["parent_graph"] = parent_graph
1039: (8)                   for k in self.obj_dict["subgraphs"]:
1040: (12)                      obj_list = self.obj_dict["subgraphs"][k]
1041: (12)                      for obj in obj_list:
1042: (16)                          Graph(obj_dict=obj).set_parent_graph(parent_graph)
1043: (4)               def to_string(self, indent="", indent_level=0, inline=False):
1044: (8)                   """Return string representation of graph in DOT language.
1045: (8)                   @return: graph and subelements
1046: (8)                   @rtype: `str`
1047: (8)                   """
1048: (8)                   indent_str = self.get_indent(indent, indent_level)
1049: (8)                   child_indent = self.get_indent(indent, indent_level + 1)
1050: (8)                   graph = []
1051: (8)                   if not inline:
1052: (12)                      graph.append(indent_str)
1053: (8)                   first_line = []
1054: (8)                   if self == self.get_parent_graph() and self.obj_dict.get(
1055: (12)                      "strict", False
1056: (8)                   ):
1057: (12)                      first_line.append("strict")
1058: (8)                   graph_type = self.obj_dict["type"]
1059: (8)                   if graph_type != "subgraph" or self.obj_dict.get("show_keyword", True):
1060: (12)                      first_line.append(graph_type)
1061: (12)                      graph_name = self.obj_dict.get("name")
1062: (12)                      if graph_name:
1063: (16)                          first_line.append(quote_id_if_necessary(graph_name))
1064: (8)                   first_line.append("{\n")
1065: (8)                   graph.append(" ".join(first_line))
1066: (8)                   graph.extend(
1067: (12)                      f"{child_indent}{a};\n" for a in self.formatted_attr_list()
1068: (8)                   )
1069: (8)                   edges_done = set()
1070: (8)                   edge_obj_dicts = []
1071: (8)                   for k in self.obj_dict["edges"]:
1072: (12)                      edge_obj_dicts.extend(self.obj_dict["edges"][k])
1073: (8)                   if edge_obj_dicts:
1074: (12)                      edge_src_set, edge_dst_set = list(
1075: (16)                          zip(*[obj["points"] for obj in edge_obj_dicts])
1076: (12)                      )
1077: (12)                      edge_src_set, edge_dst_set = set(edge_src_set), set(edge_dst_set)
1078: (8)                   else:
1079: (12)                      edge_src_set, edge_dst_set = set(), set()
1080: (8)                   node_obj_dicts = []
1081: (8)                   for k in self.obj_dict["nodes"]:
1082: (12)                      node_obj_dicts.extend(self.obj_dict["nodes"][k])
1083: (8)                   sgraph_obj_dicts = []
1084: (8)                   for k in self.obj_dict["subgraphs"]:
1085: (12)                      sgraph_obj_dicts.extend(self.obj_dict["subgraphs"][k])
1086: (8)                   obj_list = [
1087: (12)                      (obj["sequence"], obj)
1088: (12)                      for obj in (edge_obj_dicts + node_obj_dicts + sgraph_obj_dicts)
1089: (8)                   ]
1090: (8)                   obj_list.sort(key=lambda x: x[0])
1091: (8)                   for idx, obj in obj_list:
1092: (12)                      if obj["type"] == "node":
1093: (16)                          node = Node(obj_dict=obj)
1094: (16)                          if self.obj_dict.get("suppress_disconnected", False):
1095: (20)                              if (
1096: (24)                                  node.get_name() not in edge_src_set
1097: (24)                                  and node.get_name() not in edge_dst_set
1098: (20)                              ):
1099: (24)                                  continue
1100: (16)                          node_str = node.to_string(
1101: (20)                              indent=indent, indent_level=indent_level + 1
1102: (16)                          )
1103: (16)                          graph.append(f"{node_str}\n")
1104: (12)                      elif obj["type"] == "edge":
1105: (16)                          edge = Edge(obj_dict=obj)
1106: (16)                          if self.obj_dict.get("simplify", False) and edge in edges_done:
1107: (20)                              continue
1108: (16)                          edge_str = edge.to_string(
1109: (20)                              indent=indent, indent_level=indent_level + 1
1110: (16)                          )
1111: (16)                          graph.append(f"{edge_str}\n")
1112: (16)                          edges_done.add(edge)
1113: (12)                      else:
1114: (16)                          sgraph_str = Subgraph(obj_dict=obj).to_string(
1115: (20)                              indent=indent, indent_level=indent_level + 1
1116: (16)                          )
1117: (16)                          graph.append(f"{sgraph_str}\n")
1118: (8)                   graph.append(f"{indent_str}}}")
1119: (8)                   if not inline:
1120: (12)                      graph.append("\n")
1121: (8)                   return "".join(graph)
1122: (0)           __generate_attribute_methods(Graph, GRAPH_ATTRIBUTES)
1123: (0)           class Subgraph(Graph):
1124: (4)               """Class representing a subgraph in Graphviz's dot language.
1125: (4)               This class implements the methods to work on a representation
1126: (4)               of a subgraph in Graphviz's dot language.
1127: (4)               subgraph(graph_name='subG',
1128: (13)                       suppress_disconnected=False,
1129: (13)                       attribute=value,
1130: (13)                       ...)
1131: (4)               graph_name:
1132: (8)                   the subgraph's name
1133: (4)               suppress_disconnected:
1134: (8)                   defaults to false, which will remove from the
1135: (8)                   subgraph any disconnected nodes.
1136: (4)               All the attributes defined in the Graphviz dot language should
1137: (4)               be supported.
1138: (4)               Attributes can be set through the dynamically generated methods:
1139: (5)                set_[attribute name], i.e. set_size, set_fontname
1140: (4)               or using the instance's attributes:
1141: (5)                Subgraph.obj_dict['attributes'][attribute name], i.e.
1142: (8)                   subgraph_instance.obj_dict['attributes']['label']
1143: (8)                   subgraph_instance.obj_dict['attributes']['fontname']
1144: (4)               """
1145: (4)               def __init__(
1146: (8)                   self,
1147: (8)                   graph_name="",
1148: (8)                   obj_dict=None,
1149: (8)                   suppress_disconnected=False,
1150: (8)                   simplify=False,
1151: (8)                   **attrs,
1152: (4)               ):
1153: (8)                   Graph.__init__(
1154: (12)                      self,
1155: (12)                      graph_name=graph_name,
1156: (12)                      obj_dict=obj_dict,
1157: (12)                      suppress_disconnected=suppress_disconnected,
1158: (12)                      simplify=simplify,
1159: (12)                      **attrs,
1160: (8)                   )
1161: (8)                   if obj_dict is None:
1162: (12)                      self.obj_dict["type"] = "subgraph"
1163: (0)           class Cluster(Graph):
1164: (4)               """Class representing a cluster in Graphviz's dot language.
1165: (4)               This class implements the methods to work on a representation
1166: (4)               of a cluster in Graphviz's dot language.
1167: (4)               cluster(graph_name='subG',
1168: (12)                      suppress_disconnected=False,
1169: (12)                      attribute=value,
1170: (12)                      ...)
1171: (4)               graph_name:
1172: (8)                   the cluster's name
1173: (8)                   (the string 'cluster' will be always prepended)
1174: (4)               suppress_disconnected:
1175: (8)                   defaults to false, which will remove from the
1176: (8)                   cluster any disconnected nodes.
1177: (4)               All the attributes defined in the Graphviz dot language should
1178: (4)               be supported.
1179: (4)               Attributes can be set through the dynamically generated methods:
1180: (5)                set_[attribute name], i.e. set_color, set_fontname
1181: (4)               or using the instance's attributes:
1182: (5)                Cluster.obj_dict['attributes'][attribute name], i.e.
1183: (8)                   cluster_instance.obj_dict['attributes']['label']
1184: (8)                   cluster_instance.obj_dict['attributes']['fontname']
1185: (4)               """
1186: (4)               def __init__(
1187: (8)                   self,
1188: (8)                   graph_name="subG",
1189: (8)                   obj_dict=None,
1190: (8)                   suppress_disconnected=False,
1191: (8)                   simplify=False,
1192: (8)                   **attrs,
1193: (4)               ):
1194: (8)                   Graph.__init__(
1195: (12)                      self,
1196: (12)                      graph_name=graph_name,
1197: (12)                      obj_dict=obj_dict,
1198: (12)                      suppress_disconnected=suppress_disconnected,
1199: (12)                      simplify=simplify,
1200: (12)                      **attrs,
1201: (8)                   )
1202: (8)                   if obj_dict is None:
1203: (12)                      self.obj_dict["type"] = "subgraph"
1204: (12)                      self.obj_dict["name"] = quote_id_if_necessary(
1205: (16)                          "cluster_" + graph_name
1206: (12)                      )
1207: (0)           __generate_attribute_methods(Cluster, CLUSTER_ATTRIBUTES)
1208: (0)           class Dot(Graph):
1209: (4)               """A container for handling a dot language file.
1210: (4)               This class implements methods to write and process
1211: (4)               a dot language file. It is a derived class of
1212: (4)               the base class 'Graph'.
1213: (4)               """
1214: (4)               def __init__(self, *argsl, **argsd):
1215: (8)                   Graph.__init__(self, *argsl, **argsd)
1216: (8)                   self.shape_files = []
1217: (8)                   self.formats = OUTPUT_FORMATS
1218: (8)                   self.prog = "dot"
1219: (4)               def __getstate__(self):
1220: (8)                   state = {
1221: (12)                      "obj_dict": copy.copy(self.obj_dict),
1222: (12)                      "prog": self.prog,
1223: (12)                      "shape_files": copy.deepcopy(self.shape_files),
1224: (12)                      "formats": copy.copy(self.formats),
1225: (8)                   }
1226: (8)                   return state
1227: (4)               def __setstate__(self, state):
1228: (8)                   if "obj_dict" not in state:
1229: (12)                      state = {"obj_dict": state}
1230: (8)                   self.obj_dict = state.get("obj_dict", {})
1231: (8)                   self.prog = state.get("prog", "dot")
1232: (8)                   self.shape_files = state.get("shape_files", [])
1233: (8)                   self.formats = state.get("formats", OUTPUT_FORMATS)
1234: (4)               def set_shape_files(self, file_paths):
1235: (8)                   """Add the paths of the required image files.
1236: (8)                   If the graph needs graphic objects to
1237: (8)                   be used as shapes or otherwise
1238: (8)                   those need to be in the same folder as
1239: (8)                   the graph is going to be rendered
1240: (8)                   from. Alternatively the absolute path to
1241: (8)                   the files can be specified when
1242: (8)                   including the graphics in the graph.
1243: (8)                   The files in the location pointed to by
1244: (8)                   the path(s) specified as arguments
1245: (8)                   to this method will be copied to
1246: (8)                   the same temporary location where the
1247: (8)                   graph is going to be rendered.
1248: (8)                   """
1249: (8)                   if isinstance(file_paths, str):
1250: (12)                      self.shape_files.append(file_paths)
1251: (8)                   if isinstance(file_paths, (list, tuple)):
1252: (12)                      self.shape_files.extend(file_paths)
1253: (4)               def set_prog(self, prog):
1254: (8)                   """Sets the default program.
1255: (8)                   Sets the default program in charge of processing
1256: (8)                   the dot file into a graph.
1257: (8)                   """
1258: (8)                   self.prog = prog
1259: (4)               def write(self, path, prog=None, format="raw", encoding=None):
1260: (8)                   """Writes a graph to a file.
1261: (8)                   Given a filename 'path' it will open/create and truncate
1262: (8)                   such file and write on it a representation of the graph
1263: (8)                   defined by the dot object in the format specified by
1264: (8)                   'format' and using the encoding specified by `encoding` for text.
1265: (8)                   The format 'raw' is used to dump the string representation
1266: (8)                   of the Dot object, without further processing.
1267: (8)                   The output can be processed by any of graphviz tools, defined
1268: (8)                   in 'prog', which defaults to 'dot'
1269: (8)                   Returns True or False according to the success of the write
1270: (8)                   operation.
1271: (8)                   There's also the preferred possibility of using:
1272: (12)                      write_'format'(path, prog='program')
1273: (8)                   which are automatically defined for all the supported formats.
1274: (8)                   [write_ps(), write_gif(), write_dia(), ...]
1275: (8)                   The encoding is passed to `open` [1].
1276: (8)                   [1] https://docs.python.org/3/library/functions.html#open
1277: (8)                   """
1278: (8)                   if prog is None:
1279: (12)                      prog = self.prog
1280: (8)                   if format == "raw":
1281: (12)                      s = self.to_string()
1282: (12)                      with open(path, mode="w", encoding=encoding) as f:
1283: (16)                          f.write(s)
1284: (8)                   else:
1285: (12)                      s = self.create(prog, format, encoding=encoding)
1286: (12)                      with open(path, mode="wb") as f:
1287: (16)                          f.write(s)
1288: (8)                   return True
1289: (4)               def create(self, prog=None, format="ps", encoding=None):
1290: (8)                   """Creates and returns a binary image for the graph.
1291: (8)                   create will write the graph to a temporary dot file in the
1292: (8)                   encoding specified by `encoding` and process it with the
1293: (8)                   program given by 'prog' (which defaults to 'twopi'), reading
1294: (8)                   the binary image output and return it as `bytes`.
1295: (8)                   There's also the preferred possibility of using:
1296: (12)                      create_'format'(prog='program')
1297: (8)                   which are automatically defined for all the supported formats,
1298: (8)                   for example:
1299: (10)                    - `create_ps()`
1300: (10)                    - `create_gif()`
1301: (10)                    - `create_dia()`
1302: (8)                   If 'prog' is a list, instead of a string,
1303: (8)                   then the fist item is expected to be the program name,
1304: (8)                   followed by any optional command-line arguments for it:
1305: (12)                      [ 'twopi', '-Tdot', '-s10' ]
1306: (8)                   @param prog: either:
1307: (10)                    - name of GraphViz executable that
1308: (12)                      can be found in the `$PATH`, or
1309: (10)                    - absolute path to GraphViz executable.
1310: (10)                    If you have added GraphViz to the `$PATH` and
1311: (10)                    use its executables as installed
1312: (10)                    (without renaming any of them)
1313: (10)                    then their names are:
1314: (12)                      - `'dot'`
1315: (12)                      - `'twopi'`
1316: (12)                      - `'neato'`
1317: (12)                      - `'circo'`
1318: (12)                      - `'fdp'`
1319: (12)                      - `'sfdp'`
1320: (10)                    On Windows, these have the notorious ".exe" extension that,
1321: (10)                    only for the above strings, will be added automatically.
1322: (10)                    The `$PATH` is inherited from `os.env['PATH']` and
1323: (10)                    passed to `subprocess.Popen` using the `env` argument.
1324: (10)                    If you haven't added GraphViz to your `$PATH` on Windows,
1325: (10)                    then you may want to give the absolute path to the
1326: (10)                    executable (for example, to `dot.exe`) in `prog`.
1327: (8)                   """
1328: (8)                   if prog is None:
1329: (12)                      prog = self.prog
1330: (8)                   assert prog is not None
1331: (8)                   if isinstance(prog, (list, tuple)):
1332: (12)                      prog, args = prog[0], prog[1:]
1333: (8)                   else:
1334: (12)                      args = []
1335: (8)                   with tempfile.TemporaryDirectory(
1336: (12)                      ignore_cleanup_errors=True
1337: (8)                   ) as tmp_dir:
1338: (12)                      fp = tempfile.NamedTemporaryFile(dir=tmp_dir, delete=False)
1339: (12)                      fp.close()
1340: (12)                      self.write(fp.name, encoding=encoding)
1341: (12)                      for img in self.shape_files:
1342: (16)                          outfile = os.path.join(tmp_dir, os.path.basename(img))
1343: (16)                          with open(img, "rb") as img_in, open(outfile, "wb") as img_out:
1344: (20)                              img_data = img_in.read()
1345: (20)                              img_out.write(img_data)
1346: (12)                      arguments = [f"-T{format}"] + args + [fp.name]
1347: (12)                      try:
1348: (16)                          stdout_data, stderr_data, process = call_graphviz(
1349: (20)                              program=prog,
1350: (20)                              arguments=arguments,
1351: (20)                              working_dir=tmp_dir,
1352: (16)                          )
1353: (12)                      except OSError as e:
1354: (16)                          if e.errno == errno.ENOENT:
1355: (20)                              args = list(e.args)
1356: (20)                              args[1] = f'"{prog}" not found in path.'
1357: (20)                              raise OSError(*args)
1358: (16)                          else:
1359: (20)                              raise
1360: (8)                   if process.returncode != 0:
1361: (12)                      code = process.returncode
1362: (12)                      print(
1363: (16)                          f'"{prog}" with args {arguments} returned code: {code}\n\n'
1364: (16)                          f"stdout, stderr:\n {stdout_data}\n{stderr_data}\n"
1365: (12)                      )
1366: (8)                   assert process.returncode == 0, (
1367: (12)                      f'"{prog}" with args {arguments} '
1368: (12)                      f"returned code: {process.returncode}"
1369: (8)                   )
1370: (8)                   return stdout_data
1371: (0)           __generate_format_methods(Dot)

----------------------------------------

File 9 - tempfile.py:

1: (0)              """Temporary files.
2: (0)              This module provides generic, low- and high-level interfaces for
3: (0)              creating temporary files and directories.  All of the interfaces
4: (0)              provided by this module can be used without fear of race conditions
5: (0)              except for 'mktemp'.  'mktemp' is subject to race conditions and
6: (0)              should not be used; it is provided for backward compatibility only.
7: (0)              The default path names are returned as str.  If you supply bytes as
8: (0)              input, all return values will be in bytes.  Ex:
9: (4)                  >>> tempfile.mkstemp()
10: (4)                 (4, '/tmp/tmptpu9nin8')
11: (4)                 >>> tempfile.mkdtemp(suffix=b'')
12: (4)                 b'/tmp/tmppbi8f0hy'
13: (0)             This module also provides some data items to the user:
14: (2)               TMP_MAX  - maximum number of names that will be tried before
15: (13)                         giving up.
16: (2)               tempdir  - If this is set to a string before the first use of
17: (13)                         any routine from this module, it will be considered as
18: (13)                         another candidate location to store temporary files.
19: (0)             """
20: (0)             __all__ = [
21: (4)                 "NamedTemporaryFile", "TemporaryFile", # high level safe interfaces
22: (4)                 "SpooledTemporaryFile", "TemporaryDirectory",
23: (4)                 "mkstemp", "mkdtemp",                  # low level safe interfaces
24: (4)                 "mktemp",                              # deprecated unsafe interface
25: (4)                 "TMP_MAX", "gettempprefix",            # constants
26: (4)                 "tempdir", "gettempdir",
27: (4)                 "gettempprefixb", "gettempdirb",
28: (3)                ]
29: (0)             import functools as _functools
30: (0)             import warnings as _warnings
31: (0)             import io as _io
32: (0)             import os as _os
33: (0)             import shutil as _shutil
34: (0)             import errno as _errno
35: (0)             from random import Random as _Random
36: (0)             import sys as _sys
37: (0)             import types as _types
38: (0)             import weakref as _weakref
39: (0)             import _thread
40: (0)             _allocate_lock = _thread.allocate_lock
41: (0)             _text_openflags = _os.O_RDWR | _os.O_CREAT | _os.O_EXCL
42: (0)             if hasattr(_os, 'O_NOFOLLOW'):
43: (4)                 _text_openflags |= _os.O_NOFOLLOW
44: (0)             _bin_openflags = _text_openflags
45: (0)             if hasattr(_os, 'O_BINARY'):
46: (4)                 _bin_openflags |= _os.O_BINARY
47: (0)             if hasattr(_os, 'TMP_MAX'):
48: (4)                 TMP_MAX = _os.TMP_MAX
49: (0)             else:
50: (4)                 TMP_MAX = 10000
51: (0)             template = "tmp"
52: (0)             _once_lock = _allocate_lock()
53: (0)             def _exists(fn):
54: (4)                 try:
55: (8)                     _os.lstat(fn)
56: (4)                 except OSError:
57: (8)                     return False
58: (4)                 else:
59: (8)                     return True
60: (0)             def _infer_return_type(*args):
61: (4)                 """Look at the type of all args and divine their implied return type."""
62: (4)                 return_type = None
63: (4)                 for arg in args:
64: (8)                     if arg is None:
65: (12)                        continue
66: (8)                     if isinstance(arg, _os.PathLike):
67: (12)                        arg = _os.fspath(arg)
68: (8)                     if isinstance(arg, bytes):
69: (12)                        if return_type is str:
70: (16)                            raise TypeError("Can't mix bytes and non-bytes in "
71: (32)                                            "path components.")
72: (12)                        return_type = bytes
73: (8)                     else:
74: (12)                        if return_type is bytes:
75: (16)                            raise TypeError("Can't mix bytes and non-bytes in "
76: (32)                                            "path components.")
77: (12)                        return_type = str
78: (4)                 if return_type is None:
79: (8)                     if tempdir is None or isinstance(tempdir, str):
80: (12)                        return str  # tempfile APIs return a str by default.
81: (8)                     else:
82: (12)                        return bytes
83: (4)                 return return_type
84: (0)             def _sanitize_params(prefix, suffix, dir):
85: (4)                 """Common parameter processing for most APIs in this module."""
86: (4)                 output_type = _infer_return_type(prefix, suffix, dir)
87: (4)                 if suffix is None:
88: (8)                     suffix = output_type()
89: (4)                 if prefix is None:
90: (8)                     if output_type is str:
91: (12)                        prefix = template
92: (8)                     else:
93: (12)                        prefix = _os.fsencode(template)
94: (4)                 if dir is None:
95: (8)                     if output_type is str:
96: (12)                        dir = gettempdir()
97: (8)                     else:
98: (12)                        dir = gettempdirb()
99: (4)                 return prefix, suffix, dir, output_type
100: (0)            class _RandomNameSequence:
101: (4)                """An instance of _RandomNameSequence generates an endless
102: (4)                sequence of unpredictable strings which can safely be incorporated
103: (4)                into file names.  Each string is eight characters long.  Multiple
104: (4)                threads can safely use the same instance at the same time.
105: (4)                _RandomNameSequence is an iterator."""
106: (4)                characters = "abcdefghijklmnopqrstuvwxyz0123456789_"
107: (4)                @property
108: (4)                def rng(self):
109: (8)                    cur_pid = _os.getpid()
110: (8)                    if cur_pid != getattr(self, '_rng_pid', None):
111: (12)                       self._rng = _Random()
112: (12)                       self._rng_pid = cur_pid
113: (8)                    return self._rng
114: (4)                def __iter__(self):
115: (8)                    return self
116: (4)                def __next__(self):
117: (8)                    return ''.join(self.rng.choices(self.characters, k=8))
118: (0)            def _candidate_tempdir_list():
119: (4)                """Generate a list of candidate temporary directories which
120: (4)                _get_default_tempdir will try."""
121: (4)                dirlist = []
122: (4)                for envname in 'TMPDIR', 'TEMP', 'TMP':
123: (8)                    dirname = _os.getenv(envname)
124: (8)                    if dirname: dirlist.append(dirname)
125: (4)                if _os.name == 'nt':
126: (8)                    dirlist.extend([ _os.path.expanduser(r'~\AppData\Local\Temp'),
127: (25)                                    _os.path.expandvars(r'%SYSTEMROOT%\Temp'),
128: (25)                                    r'c:\temp', r'c:\tmp', r'\temp', r'\tmp' ])
129: (4)                else:
130: (8)                    dirlist.extend([ '/tmp', '/var/tmp', '/usr/tmp' ])
131: (4)                try:
132: (8)                    dirlist.append(_os.getcwd())
133: (4)                except (AttributeError, OSError):
134: (8)                    dirlist.append(_os.curdir)
135: (4)                return dirlist
136: (0)            def _get_default_tempdir():
137: (4)                """Calculate the default directory to use for temporary files.
138: (4)                This routine should be called exactly once.
139: (4)                We determine whether or not a candidate temp dir is usable by
140: (4)                trying to create and write to a file in that directory.  If this
141: (4)                is successful, the test file is deleted.  To prevent denial of
142: (4)                service, the name of the test file must be randomized."""
143: (4)                namer = _RandomNameSequence()
144: (4)                dirlist = _candidate_tempdir_list()
145: (4)                for dir in dirlist:
146: (8)                    if dir != _os.curdir:
147: (12)                       dir = _os.path.abspath(dir)
148: (8)                    for seq in range(100):
149: (12)                       name = next(namer)
150: (12)                       filename = _os.path.join(dir, name)
151: (12)                       try:
152: (16)                           fd = _os.open(filename, _bin_openflags, 0o600)
153: (16)                           try:
154: (20)                               try:
155: (24)                                   _os.write(fd, b'blat')
156: (20)                               finally:
157: (24)                                   _os.close(fd)
158: (16)                           finally:
159: (20)                               _os.unlink(filename)
160: (16)                           return dir
161: (12)                       except FileExistsError:
162: (16)                           pass
163: (12)                       except PermissionError:
164: (16)                           if (_os.name == 'nt' and _os.path.isdir(dir) and
165: (20)                               _os.access(dir, _os.W_OK)):
166: (20)                               continue
167: (16)                           break   # no point trying more names in this directory
168: (12)                       except OSError:
169: (16)                           break   # no point trying more names in this directory
170: (4)                raise FileNotFoundError(_errno.ENOENT,
171: (28)                                       "No usable temporary directory found in %s" %
172: (28)                                       dirlist)
173: (0)            _name_sequence = None
174: (0)            def _get_candidate_names():
175: (4)                """Common setup sequence for all user-callable interfaces."""
176: (4)                global _name_sequence
177: (4)                if _name_sequence is None:
178: (8)                    _once_lock.acquire()
179: (8)                    try:
180: (12)                       if _name_sequence is None:
181: (16)                           _name_sequence = _RandomNameSequence()
182: (8)                    finally:
183: (12)                       _once_lock.release()
184: (4)                return _name_sequence
185: (0)            def _mkstemp_inner(dir, pre, suf, flags, output_type):
186: (4)                """Code common to mkstemp, TemporaryFile, and NamedTemporaryFile."""
187: (4)                dir = _os.path.abspath(dir)
188: (4)                names = _get_candidate_names()
189: (4)                if output_type is bytes:
190: (8)                    names = map(_os.fsencode, names)
191: (4)                for seq in range(TMP_MAX):
192: (8)                    name = next(names)
193: (8)                    file = _os.path.join(dir, pre + name + suf)
194: (8)                    _sys.audit("tempfile.mkstemp", file)
195: (8)                    try:
196: (12)                       fd = _os.open(file, flags, 0o600)
197: (8)                    except FileExistsError:
198: (12)                       continue    # try again
199: (8)                    except PermissionError:
200: (12)                       if (_os.name == 'nt' and _os.path.isdir(dir) and
201: (16)                           _os.access(dir, _os.W_OK)):
202: (16)                           continue
203: (12)                       else:
204: (16)                           raise
205: (8)                    return fd, file
206: (4)                raise FileExistsError(_errno.EEXIST,
207: (26)                                     "No usable temporary file name found")
208: (0)            def _dont_follow_symlinks(func, path, *args):
209: (4)                if func in _os.supports_follow_symlinks:
210: (8)                    func(path, *args, follow_symlinks=False)
211: (4)                elif _os.name == 'nt' or not _os.path.islink(path):
212: (8)                    func(path, *args)
213: (0)            def _resetperms(path):
214: (4)                try:
215: (8)                    chflags = _os.chflags
216: (4)                except AttributeError:
217: (8)                    pass
218: (4)                else:
219: (8)                    _dont_follow_symlinks(chflags, path, 0)
220: (4)                _dont_follow_symlinks(_os.chmod, path, 0o700)
221: (0)            def gettempprefix():
222: (4)                """The default prefix for temporary directories as string."""
223: (4)                return _os.fsdecode(template)
224: (0)            def gettempprefixb():
225: (4)                """The default prefix for temporary directories as bytes."""
226: (4)                return _os.fsencode(template)
227: (0)            tempdir = None
228: (0)            def _gettempdir():
229: (4)                """Private accessor for tempfile.tempdir."""
230: (4)                global tempdir
231: (4)                if tempdir is None:
232: (8)                    _once_lock.acquire()
233: (8)                    try:
234: (12)                       if tempdir is None:
235: (16)                           tempdir = _get_default_tempdir()
236: (8)                    finally:
237: (12)                       _once_lock.release()
238: (4)                return tempdir
239: (0)            def gettempdir():
240: (4)                """Returns tempfile.tempdir as str."""
241: (4)                return _os.fsdecode(_gettempdir())
242: (0)            def gettempdirb():
243: (4)                """Returns tempfile.tempdir as bytes."""
244: (4)                return _os.fsencode(_gettempdir())
245: (0)            def mkstemp(suffix=None, prefix=None, dir=None, text=False):
246: (4)                """User-callable function to create and return a unique temporary
247: (4)                file.  The return value is a pair (fd, name) where fd is the
248: (4)                file descriptor returned by os.open, and name is the filename.
249: (4)                If 'suffix' is not None, the file name will end with that suffix,
250: (4)                otherwise there will be no suffix.
251: (4)                If 'prefix' is not None, the file name will begin with that prefix,
252: (4)                otherwise a default prefix is used.
253: (4)                If 'dir' is not None, the file will be created in that directory,
254: (4)                otherwise a default directory is used.
255: (4)                If 'text' is specified and true, the file is opened in text
256: (4)                mode.  Else (the default) the file is opened in binary mode.
257: (4)                If any of 'suffix', 'prefix' and 'dir' are not None, they must be the
258: (4)                same type.  If they are bytes, the returned name will be bytes; str
259: (4)                otherwise.
260: (4)                The file is readable and writable only by the creating user ID.
261: (4)                If the operating system uses permission bits to indicate whether a
262: (4)                file is executable, the file is executable by no one. The file
263: (4)                descriptor is not inherited by children of this process.
264: (4)                Caller is responsible for deleting the file when done with it.
265: (4)                """
266: (4)                prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)
267: (4)                if text:
268: (8)                    flags = _text_openflags
269: (4)                else:
270: (8)                    flags = _bin_openflags
271: (4)                return _mkstemp_inner(dir, prefix, suffix, flags, output_type)
272: (0)            def mkdtemp(suffix=None, prefix=None, dir=None):
273: (4)                """User-callable function to create and return a unique temporary
274: (4)                directory.  The return value is the pathname of the directory.
275: (4)                Arguments are as for mkstemp, except that the 'text' argument is
276: (4)                not accepted.
277: (4)                The directory is readable, writable, and searchable only by the
278: (4)                creating user.
279: (4)                Caller is responsible for deleting the directory when done with it.
280: (4)                """
281: (4)                prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)
282: (4)                names = _get_candidate_names()
283: (4)                if output_type is bytes:
284: (8)                    names = map(_os.fsencode, names)
285: (4)                for seq in range(TMP_MAX):
286: (8)                    name = next(names)
287: (8)                    file = _os.path.join(dir, prefix + name + suffix)
288: (8)                    _sys.audit("tempfile.mkdtemp", file)
289: (8)                    try:
290: (12)                       _os.mkdir(file, 0o700)
291: (8)                    except FileExistsError:
292: (12)                       continue    # try again
293: (8)                    except PermissionError:
294: (12)                       if (_os.name == 'nt' and _os.path.isdir(dir) and
295: (16)                           _os.access(dir, _os.W_OK)):
296: (16)                           continue
297: (12)                       else:
298: (16)                           raise
299: (8)                    return _os.path.abspath(file)
300: (4)                raise FileExistsError(_errno.EEXIST,
301: (26)                                     "No usable temporary directory name found")
302: (0)            def mktemp(suffix="", prefix=template, dir=None):
303: (4)                """User-callable function to return a unique temporary file name.  The
304: (4)                file is not created.
305: (4)                Arguments are similar to mkstemp, except that the 'text' argument is
306: (4)                not accepted, and suffix=None, prefix=None and bytes file names are not
307: (4)                supported.
308: (4)                THIS FUNCTION IS UNSAFE AND SHOULD NOT BE USED.  The file name may
309: (4)                refer to a file that did not exist at some point, but by the time
310: (4)                you get around to creating it, someone else may have beaten you to
311: (4)                the punch.
312: (4)                """
313: (4)                if dir is None:
314: (8)                    dir = gettempdir()
315: (4)                names = _get_candidate_names()
316: (4)                for seq in range(TMP_MAX):
317: (8)                    name = next(names)
318: (8)                    file = _os.path.join(dir, prefix + name + suffix)
319: (8)                    if not _exists(file):
320: (12)                       return file
321: (4)                raise FileExistsError(_errno.EEXIST,
322: (26)                                     "No usable temporary filename found")
323: (0)            class _TemporaryFileCloser:
324: (4)                """A separate object allowing proper closing of a temporary file's
325: (4)                underlying file object, without adding a __del__ method to the
326: (4)                temporary file."""
327: (4)                cleanup_called = False
328: (4)                close_called = False
329: (4)                def __init__(self, file, name, delete=True, delete_on_close=True):
330: (8)                    self.file = file
331: (8)                    self.name = name
332: (8)                    self.delete = delete
333: (8)                    self.delete_on_close = delete_on_close
334: (4)                def cleanup(self, windows=(_os.name == 'nt'), unlink=_os.unlink):
335: (8)                    if not self.cleanup_called:
336: (12)                       self.cleanup_called = True
337: (12)                       try:
338: (16)                           if not self.close_called:
339: (20)                               self.close_called = True
340: (20)                               self.file.close()
341: (12)                       finally:
342: (16)                           if self.delete and not (windows and self.delete_on_close):
343: (20)                               try:
344: (24)                                   unlink(self.name)
345: (20)                               except FileNotFoundError:
346: (24)                                   pass
347: (4)                def close(self):
348: (8)                    if not self.close_called:
349: (12)                       self.close_called = True
350: (12)                       try:
351: (16)                           self.file.close()
352: (12)                       finally:
353: (16)                           if self.delete and self.delete_on_close:
354: (20)                               self.cleanup()
355: (4)                def __del__(self):
356: (8)                    self.cleanup()
357: (0)            class _TemporaryFileWrapper:
358: (4)                """Temporary file wrapper
359: (4)                This class provides a wrapper around files opened for
360: (4)                temporary use.  In particular, it seeks to automatically
361: (4)                remove the file when it is no longer needed.
362: (4)                """
363: (4)                def __init__(self, file, name, delete=True, delete_on_close=True):
364: (8)                    self.file = file
365: (8)                    self.name = name
366: (8)                    self._closer = _TemporaryFileCloser(file, name, delete,
367: (44)                                                       delete_on_close)
368: (4)                def __getattr__(self, name):
369: (8)                    file = self.__dict__['file']
370: (8)                    a = getattr(file, name)
371: (8)                    if hasattr(a, '__call__'):
372: (12)                       func = a
373: (12)                       @_functools.wraps(func)
374: (12)                       def func_wrapper(*args, **kwargs):
375: (16)                           return func(*args, **kwargs)
376: (12)                       func_wrapper._closer = self._closer
377: (12)                       a = func_wrapper
378: (8)                    if not isinstance(a, int):
379: (12)                       setattr(self, name, a)
380: (8)                    return a
381: (4)                def __enter__(self):
382: (8)                    self.file.__enter__()
383: (8)                    return self
384: (4)                def __exit__(self, exc, value, tb):
385: (8)                    result = self.file.__exit__(exc, value, tb)
386: (8)                    self._closer.cleanup()
387: (8)                    return result
388: (4)                def close(self):
389: (8)                    """
390: (8)                    Close the temporary file, possibly deleting it.
391: (8)                    """
392: (8)                    self._closer.close()
393: (4)                def __iter__(self):
394: (8)                    for line in self.file:
395: (12)                       yield line
396: (0)            def NamedTemporaryFile(mode='w+b', buffering=-1, encoding=None,
397: (23)                                  newline=None, suffix=None, prefix=None,
398: (23)                                  dir=None, delete=True, *, errors=None,
399: (23)                                  delete_on_close=True):
400: (4)                """Create and return a temporary file.
401: (4)                Arguments:
402: (4)                'prefix', 'suffix', 'dir' -- as for mkstemp.
403: (4)                'mode' -- the mode argument to io.open (default "w+b").
404: (4)                'buffering' -- the buffer size argument to io.open (default -1).
405: (4)                'encoding' -- the encoding argument to io.open (default None)
406: (4)                'newline' -- the newline argument to io.open (default None)
407: (4)                'delete' -- whether the file is automatically deleted (default True).
408: (4)                'delete_on_close' -- if 'delete', whether the file is deleted on close
409: (7)                   (default True) or otherwise either on context manager exit
410: (7)                   (if context manager was used) or on object finalization. .
411: (4)                'errors' -- the errors argument to io.open (default None)
412: (4)                The file is created as mkstemp() would do it.
413: (4)                Returns an object with a file-like interface; the name of the file
414: (4)                is accessible as its 'name' attribute.  The file will be automatically
415: (4)                deleted when it is closed unless the 'delete' argument is set to False.
416: (4)                On POSIX, NamedTemporaryFiles cannot be automatically deleted if
417: (4)                the creating process is terminated abruptly with a SIGKILL signal.
418: (4)                Windows can delete the file even in this case.
419: (4)                """
420: (4)                prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)
421: (4)                flags = _bin_openflags
422: (4)                if _os.name == 'nt' and delete and delete_on_close:
423: (8)                    flags |= _os.O_TEMPORARY
424: (4)                if "b" not in mode:
425: (8)                    encoding = _io.text_encoding(encoding)
426: (4)                name = None
427: (4)                def opener(*args):
428: (8)                    nonlocal name
429: (8)                    fd, name = _mkstemp_inner(dir, prefix, suffix, flags, output_type)
430: (8)                    return fd
431: (4)                try:
432: (8)                    file = _io.open(dir, mode, buffering=buffering,
433: (24)                                   newline=newline, encoding=encoding, errors=errors,
434: (24)                                   opener=opener)
435: (8)                    try:
436: (12)                       raw = getattr(file, 'buffer', file)
437: (12)                       raw = getattr(raw, 'raw', raw)
438: (12)                       raw.name = name
439: (12)                       return _TemporaryFileWrapper(file, name, delete, delete_on_close)
440: (8)                    except:
441: (12)                       file.close()
442: (12)                       raise
443: (4)                except:
444: (8)                    if name is not None and not (
445: (12)                       _os.name == 'nt' and delete and delete_on_close):
446: (12)                       _os.unlink(name)
447: (8)                    raise
448: (0)            if _os.name != 'posix' or _sys.platform == 'cygwin':
449: (4)                TemporaryFile = NamedTemporaryFile
450: (0)            else:
451: (4)                _O_TMPFILE_WORKS = hasattr(_os, 'O_TMPFILE')
452: (4)                def TemporaryFile(mode='w+b', buffering=-1, encoding=None,
453: (22)                                 newline=None, suffix=None, prefix=None,
454: (22)                                 dir=None, *, errors=None):
455: (8)                    """Create and return a temporary file.
456: (8)                    Arguments:
457: (8)                    'prefix', 'suffix', 'dir' -- as for mkstemp.
458: (8)                    'mode' -- the mode argument to io.open (default "w+b").
459: (8)                    'buffering' -- the buffer size argument to io.open (default -1).
460: (8)                    'encoding' -- the encoding argument to io.open (default None)
461: (8)                    'newline' -- the newline argument to io.open (default None)
462: (8)                    'errors' -- the errors argument to io.open (default None)
463: (8)                    The file is created as mkstemp() would do it.
464: (8)                    Returns an object with a file-like interface.  The file has no
465: (8)                    name, and will cease to exist when it is closed.
466: (8)                    """
467: (8)                    global _O_TMPFILE_WORKS
468: (8)                    if "b" not in mode:
469: (12)                       encoding = _io.text_encoding(encoding)
470: (8)                    prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)
471: (8)                    flags = _bin_openflags
472: (8)                    if _O_TMPFILE_WORKS:
473: (12)                       fd = None
474: (12)                       def opener(*args):
475: (16)                           nonlocal fd
476: (16)                           flags2 = (flags | _os.O_TMPFILE) & ~_os.O_CREAT
477: (16)                           fd = _os.open(dir, flags2, 0o600)
478: (16)                           return fd
479: (12)                       try:
480: (16)                           file = _io.open(dir, mode, buffering=buffering,
481: (32)                                           newline=newline, encoding=encoding,
482: (32)                                           errors=errors, opener=opener)
483: (16)                           raw = getattr(file, 'buffer', file)
484: (16)                           raw = getattr(raw, 'raw', raw)
485: (16)                           raw.name = fd
486: (16)                           return file
487: (12)                       except IsADirectoryError:
488: (16)                           _O_TMPFILE_WORKS = False
489: (12)                       except OSError:
490: (16)                           pass
491: (8)                    fd = None
492: (8)                    def opener(*args):
493: (12)                       nonlocal fd
494: (12)                       fd, name = _mkstemp_inner(dir, prefix, suffix, flags, output_type)
495: (12)                       try:
496: (16)                           _os.unlink(name)
497: (12)                       except BaseException as e:
498: (16)                           _os.close(fd)
499: (16)                           raise
500: (12)                       return fd
501: (8)                    file = _io.open(dir, mode, buffering=buffering,
502: (24)                                   newline=newline, encoding=encoding, errors=errors,
503: (24)                                   opener=opener)
504: (8)                    raw = getattr(file, 'buffer', file)
505: (8)                    raw = getattr(raw, 'raw', raw)
506: (8)                    raw.name = fd
507: (8)                    return file
508: (0)            class SpooledTemporaryFile(_io.IOBase):
509: (4)                """Temporary file wrapper, specialized to switch from BytesIO
510: (4)                or StringIO to a real file when it exceeds a certain size or
511: (4)                when a fileno is needed.
512: (4)                """
513: (4)                _rolled = False
514: (4)                def __init__(self, max_size=0, mode='w+b', buffering=-1,
515: (17)                            encoding=None, newline=None,
516: (17)                            suffix=None, prefix=None, dir=None, *, errors=None):
517: (8)                    if 'b' in mode:
518: (12)                       self._file = _io.BytesIO()
519: (8)                    else:
520: (12)                       encoding = _io.text_encoding(encoding)
521: (12)                       self._file = _io.TextIOWrapper(_io.BytesIO(),
522: (28)                                       encoding=encoding, errors=errors,
523: (28)                                       newline=newline)
524: (8)                    self._max_size = max_size
525: (8)                    self._rolled = False
526: (8)                    self._TemporaryFileArgs = {'mode': mode, 'buffering': buffering,
527: (35)                                              'suffix': suffix, 'prefix': prefix,
528: (35)                                              'encoding': encoding, 'newline': newline,
529: (35)                                              'dir': dir, 'errors': errors}
530: (4)                def _check(self, file):
531: (8)                    if self._rolled: return
532: (8)                    max_size = self._max_size
533: (8)                    if max_size and file.tell() > max_size:
534: (12)                       self.rollover()
535: (4)                def rollover(self):
536: (8)                    if self._rolled: return
537: (8)                    file = self._file
538: (8)                    newfile = self._file = TemporaryFile(**self._TemporaryFileArgs)
539: (8)                    del self._TemporaryFileArgs
540: (8)                    pos = file.tell()
541: (8)                    if hasattr(newfile, 'buffer'):
542: (12)                       newfile.buffer.write(file.detach().getvalue())
543: (8)                    else:
544: (12)                       newfile.write(file.getvalue())
545: (8)                    newfile.seek(pos, 0)
546: (8)                    self._rolled = True
547: (4)                def __enter__(self):
548: (8)                    if self._file.closed:
549: (12)                       raise ValueError("Cannot enter context with closed file")
550: (8)                    return self
551: (4)                def __exit__(self, exc, value, tb):
552: (8)                    self._file.close()
553: (4)                def __iter__(self):
554: (8)                    return self._file.__iter__()
555: (4)                def __del__(self):
556: (8)                    if not self.closed:
557: (12)                       _warnings.warn(
558: (16)                           "Unclosed file {!r}".format(self),
559: (16)                           ResourceWarning,
560: (16)                           stacklevel=2,
561: (16)                           source=self
562: (12)                       )
563: (12)                       self.close()
564: (4)                def close(self):
565: (8)                    self._file.close()
566: (4)                @property
567: (4)                def closed(self):
568: (8)                    return self._file.closed
569: (4)                @property
570: (4)                def encoding(self):
571: (8)                    return self._file.encoding
572: (4)                @property
573: (4)                def errors(self):
574: (8)                    return self._file.errors
575: (4)                def fileno(self):
576: (8)                    self.rollover()
577: (8)                    return self._file.fileno()
578: (4)                def flush(self):
579: (8)                    self._file.flush()
580: (4)                def isatty(self):
581: (8)                    return self._file.isatty()
582: (4)                @property
583: (4)                def mode(self):
584: (8)                    try:
585: (12)                       return self._file.mode
586: (8)                    except AttributeError:
587: (12)                       return self._TemporaryFileArgs['mode']
588: (4)                @property
589: (4)                def name(self):
590: (8)                    try:
591: (12)                       return self._file.name
592: (8)                    except AttributeError:
593: (12)                       return None
594: (4)                @property
595: (4)                def newlines(self):
596: (8)                    return self._file.newlines
597: (4)                def readable(self):
598: (8)                    return self._file.readable()
599: (4)                def read(self, *args):
600: (8)                    return self._file.read(*args)
601: (4)                def read1(self, *args):
602: (8)                    return self._file.read1(*args)
603: (4)                def readinto(self, b):
604: (8)                    return self._file.readinto(b)
605: (4)                def readinto1(self, b):
606: (8)                    return self._file.readinto1(b)
607: (4)                def readline(self, *args):
608: (8)                    return self._file.readline(*args)
609: (4)                def readlines(self, *args):
610: (8)                    return self._file.readlines(*args)
611: (4)                def seekable(self):
612: (8)                    return self._file.seekable()
613: (4)                def seek(self, *args):
614: (8)                    return self._file.seek(*args)
615: (4)                def tell(self):
616: (8)                    return self._file.tell()
617: (4)                def truncate(self, size=None):
618: (8)                    if size is None:
619: (12)                       return self._file.truncate()
620: (8)                    else:
621: (12)                       if size > self._max_size:
622: (16)                           self.rollover()
623: (12)                       return self._file.truncate(size)
624: (4)                def writable(self):
625: (8)                    return self._file.writable()
626: (4)                def write(self, s):
627: (8)                    file = self._file
628: (8)                    rv = file.write(s)
629: (8)                    self._check(file)
630: (8)                    return rv
631: (4)                def writelines(self, iterable):
632: (8)                    file = self._file
633: (8)                    rv = file.writelines(iterable)
634: (8)                    self._check(file)
635: (8)                    return rv
636: (4)                def detach(self):
637: (8)                    return self._file.detach()
638: (0)            class TemporaryDirectory:
639: (4)                """Create and return a temporary directory.  This has the same
640: (4)                behavior as mkdtemp but can be used as a context manager.  For
641: (4)                example:
642: (8)                    with TemporaryDirectory() as tmpdir:
643: (12)                       ...
644: (4)                Upon exiting the context, the directory and everything contained
645: (4)                in it are removed (unless delete=False is passed or an exception
646: (4)                is raised during cleanup and ignore_cleanup_errors is not True).
647: (4)                Optional Arguments:
648: (8)                    suffix - A str suffix for the directory name.  (see mkdtemp)
649: (8)                    prefix - A str prefix for the directory name.  (see mkdtemp)
650: (8)                    dir - A directory to create this temp dir in.  (see mkdtemp)
651: (8)                    ignore_cleanup_errors - False; ignore exceptions during cleanup?
652: (8)                    delete - True; whether the directory is automatically deleted.
653: (4)                """
654: (4)                def __init__(self, suffix=None, prefix=None, dir=None,
655: (17)                            ignore_cleanup_errors=False, *, delete=True):
656: (8)                    self.name = mkdtemp(suffix, prefix, dir)
657: (8)                    self._ignore_cleanup_errors = ignore_cleanup_errors
658: (8)                    self._delete = delete
659: (8)                    self._finalizer = _weakref.finalize(
660: (12)                       self, self._cleanup, self.name,
661: (12)                       warn_message="Implicitly cleaning up {!r}".format(self),
662: (12)                       ignore_errors=self._ignore_cleanup_errors, delete=self._delete)
663: (4)                @classmethod
664: (4)                def _rmtree(cls, name, ignore_errors=False, repeated=False):
665: (8)                    def onexc(func, path, exc):
666: (12)                       if isinstance(exc, PermissionError):
667: (16)                           if repeated and path == name:
668: (20)                               if ignore_errors:
669: (24)                                   return
670: (20)                               raise
671: (16)                           try:
672: (20)                               if path != name:
673: (24)                                   _resetperms(_os.path.dirname(path))
674: (20)                               _resetperms(path)
675: (20)                               try:
676: (24)                                   _os.unlink(path)
677: (20)                               except IsADirectoryError:
678: (24)                                   cls._rmtree(path, ignore_errors=ignore_errors)
679: (20)                               except PermissionError:
680: (24)                                   if not _os.path.isdir(path) or _os.path.isjunction(path):
681: (28)                                       if ignore_errors:
682: (32)                                           return
683: (28)                                       raise
684: (24)                                   cls._rmtree(path, ignore_errors=ignore_errors,
685: (36)                                               repeated=(path == name))
686: (16)                           except FileNotFoundError:
687: (20)                               pass
688: (12)                       elif isinstance(exc, FileNotFoundError):
689: (16)                           pass
690: (12)                       else:
691: (16)                           if not ignore_errors:
692: (20)                               raise
693: (8)                    _shutil.rmtree(name, onerror=onexc)
694: (4)                @classmethod
695: (4)                def _cleanup(cls, name, warn_message, ignore_errors=False, delete=True):
696: (8)                    if delete:
697: (12)                       cls._rmtree(name, ignore_errors=ignore_errors)
698: (12)                       _warnings.warn(warn_message, ResourceWarning)
699: (4)                def __repr__(self):
700: (8)                    return "<{} {!r}>".format(self.__class__.__name__, self.name)
701: (4)                def __enter__(self):
702: (8)                    return self.name
703: (4)                def __exit__(self, exc, value, tb):
704: (8)                    if self._delete:
705: (12)                       self.cleanup()
706: (4)                def cleanup(self):
707: (8)                    if self._finalizer.detach() or _os.path.exists(self.name):
708: (12)                       self._rmtree(self.name, ignore_errors=self._ignore_cleanup_errors)

----------------------------------------

File 10 - __init__.py:

1: (0)              

----------------------------------------

File 11 - __init__.py:

1: (0)              

----------------------------------------

File 12 - dot_parser.py:

1: (0)              """Graphviz's dot language parser.
2: (0)              The dotparser parses GraphViz files in
3: (0)              dot and dot files and transforms them
4: (0)              into a class representation defined by `pydot`.
5: (0)              Author: Michael Krause <michael@krause-software.de>
6: (0)              Fixes by: Ero Carrera <ero.carrera@gmail.com>
7: (0)              """
8: (0)              import logging
9: (0)              from pyparsing import (
10: (4)                 CaselessLiteral,
11: (4)                 CharsNotIn,
12: (4)                 Combine,
13: (4)                 Forward,
14: (4)                 Group,
15: (4)                 Literal,
16: (4)                 OneOrMore,
17: (4)                 Optional,
18: (4)                 ParseException,
19: (4)                 ParseResults,
20: (4)                 QuotedString,
21: (4)                 Word,
22: (4)                 cStyleComment,
23: (4)                 nums,
24: (4)                 pyparsing_unicode,
25: (4)                 restOfLine,
26: (0)             )
27: (0)             import pydot
28: (0)             __author__ = ["Michael Krause", "Ero Carrera"]
29: (0)             __license__ = "MIT"
30: (0)             _logger = logging.getLogger(__name__)
31: (0)             _logger.debug("pydot dot_parser module initializing")
32: (0)             class P_AttrList:
33: (4)                 def __init__(self, toks):
34: (8)                     self.attrs = {}
35: (8)                     i = 0
36: (8)                     while i < len(toks):
37: (12)                        attrname = toks[i]
38: (12)                        if i + 2 < len(toks) and toks[i + 1] == "=":
39: (16)                            attrvalue = toks[i + 2]
40: (16)                            i += 3
41: (12)                        else:
42: (16)                            attrvalue = None
43: (16)                            i += 1
44: (12)                        self.attrs[attrname] = attrvalue
45: (4)                 def __repr__(self):
46: (8)                     name = self.__class__.__name__
47: (8)                     return f"{name}({self.attrs!r})"
48: (0)             class DefaultStatement(P_AttrList):
49: (4)                 def __init__(self, default_type, attrs):
50: (8)                     self.default_type = default_type
51: (8)                     self.attrs = attrs
52: (4)                 def __repr__(self):
53: (8)                     name = self.__class__.__name__
54: (8)                     return f"{name}({self.default_type}, {self.attrs!r})"
55: (0)             def push_top_graph_stmt(s, loc, toks):
56: (4)                 attrs = {}
57: (4)                 top_graphs = []
58: (4)                 g = None
59: (4)                 for element in toks:
60: (8)                     if (
61: (12)                        isinstance(element, (ParseResults, tuple, list))
62: (12)                        and len(element) == 1
63: (12)                        and isinstance(element[0], str)
64: (8)                     ):
65: (12)                        element = element[0]
66: (8)                     if element == "strict":
67: (12)                        attrs["strict"] = True
68: (8)                     elif element in ["graph", "digraph"]:
69: (12)                        attrs = {}
70: (12)                        g = pydot.Dot(graph_type=element, **attrs)
71: (12)                        attrs["type"] = element
72: (12)                        top_graphs.append(g)
73: (8)                     elif isinstance(element, str):
74: (12)                        g.set_name(element)
75: (8)                     elif isinstance(element, pydot.Subgraph):
76: (12)                        g.obj_dict["attributes"].update(element.obj_dict["attributes"])
77: (12)                        g.obj_dict["edges"].update(element.obj_dict["edges"])
78: (12)                        g.obj_dict["nodes"].update(element.obj_dict["nodes"])
79: (12)                        g.obj_dict["subgraphs"].update(element.obj_dict["subgraphs"])
80: (12)                        g.set_parent_graph(g)
81: (8)                     elif isinstance(element, P_AttrList):
82: (12)                        attrs.update(element.attrs)
83: (8)                     elif isinstance(element, (ParseResults, list)):
84: (12)                        add_elements(g, element)
85: (8)                     else:
86: (12)                        raise ValueError(f"Unknown element statement: {element}")
87: (4)                 for g in top_graphs:
88: (8)                     update_parent_graph_hierarchy(g)
89: (4)                 if len(top_graphs) == 1:
90: (8)                     return top_graphs[0]
91: (4)                 return top_graphs
92: (0)             def update_parent_graph_hierarchy(g, parent_graph=None, level=0):
93: (4)                 if parent_graph is None:
94: (8)                     parent_graph = g
95: (4)                 for key_name in ("edges",):
96: (8)                     if isinstance(g, pydot.frozendict):
97: (12)                        item_dict = g
98: (8)                     else:
99: (12)                        item_dict = g.obj_dict
100: (8)                    if key_name not in item_dict:
101: (12)                       continue
102: (8)                    for key, objs in item_dict[key_name].items():
103: (12)                       for obj in objs:
104: (16)                           if (
105: (20)                               "parent_graph" in obj
106: (20)                               and obj["parent_graph"].get_parent_graph() == g
107: (16)                           ):
108: (20)                               if obj["parent_graph"] is g:
109: (24)                                   pass
110: (20)                               else:
111: (24)                                   obj["parent_graph"].set_parent_graph(parent_graph)
112: (16)                           if key_name == "edges" and len(key) == 2:
113: (20)                               for idx, vertex in enumerate(obj["points"]):
114: (24)                                   if isinstance(
115: (28)                                       vertex,
116: (28)                                       (pydot.Graph, pydot.Subgraph, pydot.Cluster),
117: (24)                                   ):
118: (28)                                       vertex.set_parent_graph(parent_graph)
119: (24)                                   if isinstance(vertex, pydot.frozendict):
120: (28)                                       if vertex["parent_graph"] is g:
121: (32)                                           pass
122: (28)                                       else:
123: (32)                                           vertex["parent_graph"].set_parent_graph(
124: (36)                                               parent_graph
125: (32)                                           )
126: (0)            def add_defaults(element, defaults):
127: (4)                d = element.__dict__
128: (4)                for key, value in defaults.items():
129: (8)                    if not d.get(key):
130: (12)                       d[key] = value
131: (0)            def add_elements(
132: (4)                g, toks, defaults_graph=None, defaults_node=None, defaults_edge=None
133: (0)            ):
134: (4)                if defaults_graph is None:
135: (8)                    defaults_graph = {}
136: (4)                if defaults_node is None:
137: (8)                    defaults_node = {}
138: (4)                if defaults_edge is None:
139: (8)                    defaults_edge = {}
140: (4)                for elm_idx, element in enumerate(toks):
141: (8)                    if isinstance(element, (pydot.Subgraph, pydot.Cluster)):
142: (12)                       add_defaults(element, defaults_graph)
143: (12)                       g.add_subgraph(element)
144: (8)                    elif isinstance(element, pydot.Node):
145: (12)                       add_defaults(element, defaults_node)
146: (12)                       g.add_node(element)
147: (8)                    elif isinstance(element, pydot.Edge):
148: (12)                       add_defaults(element, defaults_edge)
149: (12)                       g.add_edge(element)
150: (8)                    elif isinstance(element, ParseResults):
151: (12)                       for e in element:
152: (16)                           add_elements(
153: (20)                               g, [e], defaults_graph, defaults_node, defaults_edge
154: (16)                           )
155: (8)                    elif isinstance(element, DefaultStatement):
156: (12)                       if element.default_type == "graph":
157: (16)                           default_graph_attrs = pydot.Node("graph", **element.attrs)
158: (16)                           g.add_node(default_graph_attrs)
159: (12)                       elif element.default_type == "node":
160: (16)                           default_node_attrs = pydot.Node("node", **element.attrs)
161: (16)                           g.add_node(default_node_attrs)
162: (12)                       elif element.default_type == "edge":
163: (16)                           default_edge_attrs = pydot.Node("edge", **element.attrs)
164: (16)                           g.add_node(default_edge_attrs)
165: (16)                           defaults_edge.update(element.attrs)
166: (12)                       else:
167: (16)                           raise ValueError(
168: (20)                               f"Unknown DefaultStatement: {element.default_type}"
169: (16)                           )
170: (8)                    elif isinstance(element, P_AttrList):
171: (12)                       g.obj_dict["attributes"].update(element.attrs)
172: (8)                    else:
173: (12)                       raise ValueError(f"Unknown element statement: {element}")
174: (0)            def push_graph_stmt(s, loc, toks):
175: (4)                g = pydot.Subgraph("")
176: (4)                add_elements(g, toks)
177: (4)                return g
178: (0)            def push_subgraph_stmt(s, loc, toks):
179: (4)                g = pydot.Subgraph("")
180: (4)                for e in toks:
181: (8)                    if len(e) == 3:
182: (12)                       e[2].set_name(e[1])
183: (12)                       if e[0] == "subgraph":
184: (16)                           e[2].obj_dict["show_keyword"] = True
185: (12)                       return e[2]
186: (8)                    else:
187: (12)                       if e[0] == "subgraph":
188: (16)                           e[1].obj_dict["show_keyword"] = True
189: (12)                       return e[1]
190: (4)                return g
191: (0)            def push_default_stmt(s, loc, toks):
192: (4)                default_type = toks[0][0]
193: (4)                if len(toks) > 1:
194: (8)                    attrs = toks[1].attrs
195: (4)                else:
196: (8)                    attrs = {}
197: (4)                if default_type in ["graph", "node", "edge"]:
198: (8)                    return DefaultStatement(default_type, attrs)
199: (4)                else:
200: (8)                    raise ValueError(f"Unknown default statement: {toks}")
201: (0)            def push_attr_list(s, loc, toks):
202: (4)                p = P_AttrList(toks)
203: (4)                return p
204: (0)            def get_port(node):
205: (4)                if len(node) > 1:
206: (8)                    if isinstance(node[1], ParseResults):
207: (12)                       if len(node[1][0]) == 2:
208: (16)                           if node[1][0][0] == ":":
209: (20)                               return node[1][0][1]
210: (4)                return None
211: (0)            def do_node_ports(node):
212: (4)                node_port = ""
213: (4)                if len(node) > 1:
214: (8)                    node_port = "".join([str(a) + str(b) for a, b in node[1]])
215: (4)                return node_port
216: (0)            def push_edge_stmt(s, loc, toks):
217: (4)                tok_attrs = [a for a in toks if isinstance(a, P_AttrList)]
218: (4)                attrs = {}
219: (4)                for a in tok_attrs:
220: (8)                    attrs.update(a.attrs)
221: (4)                e = []
222: (4)                if isinstance(toks[0][0], pydot.Graph):
223: (8)                    n_prev = pydot.frozendict(toks[0][0].obj_dict)
224: (4)                else:
225: (8)                    n_prev = toks[0][0] + do_node_ports(toks[0])
226: (4)                if isinstance(toks[2][0], ParseResults):
227: (8)                    n_next_list = [[n.get_name()] for n in toks[2][0]]
228: (8)                    for n_next in list(n_next_list):
229: (12)                       n_next_port = do_node_ports(n_next)
230: (12)                       e.append(pydot.Edge(n_prev, n_next[0] + n_next_port, **attrs))
231: (4)                elif isinstance(toks[2][0], pydot.Graph):
232: (8)                    e.append(
233: (12)                       pydot.Edge(n_prev, pydot.frozendict(toks[2][0].obj_dict), **attrs)
234: (8)                    )
235: (4)                elif isinstance(toks[2][0], pydot.Node):
236: (8)                    node = toks[2][0]
237: (8)                    if node.get_port() is not None:
238: (12)                       name_port = node.get_name() + ":" + node.get_port()
239: (8)                    else:
240: (12)                       name_port = node.get_name()
241: (8)                    e.append(pydot.Edge(n_prev, name_port, **attrs))
242: (4)                elif isinstance(toks[2][0], str):
243: (8)                    for n_next in list(tuple(toks)[2::2]):
244: (12)                       if isinstance(n_next, P_AttrList) or not isinstance(
245: (16)                           n_next[0], str
246: (12)                       ):
247: (16)                           continue
248: (12)                       n_next_port = do_node_ports(n_next)
249: (12)                       e.append(pydot.Edge(n_prev, n_next[0] + n_next_port, **attrs))
250: (12)                       n_prev = n_next[0] + n_next_port
251: (4)                else:
252: (8)                    raise Exception(
253: (12)                       f"Edge target {toks[2][0]} with type {type(toks[2][0])}"
254: (12)                       " unsupported."
255: (8)                    )
256: (4)                return e
257: (0)            def push_node_stmt(s, loc, toks):
258: (4)                if len(toks) == 2:
259: (8)                    attrs = toks[1].attrs
260: (4)                else:
261: (8)                    attrs = {}
262: (4)                node_name = toks[0]
263: (4)                if isinstance(node_name, list) or isinstance(node_name, tuple):
264: (8)                    if len(node_name) > 0:
265: (12)                       node_name = node_name[0]
266: (4)                n = pydot.Node(str(node_name), **attrs)
267: (4)                return n
268: (0)            graphparser = None
269: (0)            def graph_definition():
270: (4)                global graphparser
271: (4)                if not graphparser:
272: (8)                    colon = Literal(":")
273: (8)                    lbrace = Literal("{")
274: (8)                    rbrace = Literal("}")
275: (8)                    lbrack = Literal("[")
276: (8)                    rbrack = Literal("]")
277: (8)                    equals = Literal("=")
278: (8)                    comma = Literal(",")
279: (8)                    semi = Literal(";")
280: (8)                    minus = Literal("-")
281: (8)                    strict_ = CaselessLiteral("strict")
282: (8)                    graph_ = CaselessLiteral("graph")
283: (8)                    digraph_ = CaselessLiteral("digraph")
284: (8)                    subgraph_ = CaselessLiteral("subgraph")
285: (8)                    node_ = CaselessLiteral("node")
286: (8)                    edge_ = CaselessLiteral("edge")
287: (8)                    identifier = Word(
288: (12)                       pyparsing_unicode.BasicMultilingualPlane.alphanums + "_."
289: (8)                    ).setName("identifier")
290: (8)                    double_quoted_string = QuotedString(
291: (12)                       '"', multiline=True, unquoteResults=False, escChar="\\"
292: (8)                    )
293: (8)                    html_text = Forward()
294: (8)                    inner_html = OneOrMore(CharsNotIn("<>") | html_text)
295: (8)                    html_text << "<" + inner_html + ">"
296: (8)                    html_text.setParseAction(lambda arr: "".join(arr))
297: (8)                    ID = (identifier | html_text | double_quoted_string).setName("ID")
298: (8)                    float_number = Combine(
299: (12)                       Optional(minus) + OneOrMore(Word(nums + "."))
300: (8)                    ).setName("float_number")
301: (8)                    righthand_id = (float_number | ID).setName("righthand_id")
302: (8)                    port = (
303: (12)                       Group(Group(colon + ID) + Group(colon + ID))
304: (12)                       | Group(Group(colon + ID))
305: (8)                    ).setName("port")
306: (8)                    node_id = ID + Optional(port)
307: (8)                    a_list = OneOrMore(
308: (12)                       ID + Optional(equals + righthand_id) + Optional(comma.suppress())
309: (8)                    ).setName("a_list")
310: (8)                    attr_list = OneOrMore(
311: (12)                       lbrack.suppress() + Optional(a_list) + rbrack.suppress()
312: (8)                    ).setName("attr_list")
313: (8)                    attr_stmt = (Group(graph_ | node_ | edge_) + attr_list).setName(
314: (12)                       "attr_stmt"
315: (8)                    )
316: (8)                    edgeop = (Literal("--") | Literal("->")).setName("edgeop")
317: (8)                    stmt_list = Forward()
318: (8)                    graph_stmt = Group(
319: (12)                       lbrace.suppress()
320: (12)                       + Optional(stmt_list)
321: (12)                       + rbrace.suppress()
322: (12)                       + Optional(semi.suppress())
323: (8)                    ).setName("graph_stmt")
324: (8)                    edge_point = Forward()
325: (8)                    edgeRHS = OneOrMore(edgeop + edge_point)
326: (8)                    edge_stmt = edge_point + edgeRHS + Optional(attr_list)
327: (8)                    subgraph = Group(subgraph_ + Optional(ID) + graph_stmt).setName(
328: (12)                       "subgraph"
329: (8)                    )
330: (8)                    edge_point << Group(subgraph | graph_stmt | node_id).setName(
331: (12)                       "edge_point"
332: (8)                    )
333: (8)                    node_stmt = (
334: (12)                       node_id + Optional(attr_list) + Optional(semi.suppress())
335: (8)                    ).setName("node_stmt")
336: (8)                    assignment = (ID + equals + righthand_id).setName("assignment")
337: (8)                    stmt = (
338: (12)                       assignment
339: (12)                       | edge_stmt
340: (12)                       | attr_stmt
341: (12)                       | subgraph
342: (12)                       | graph_stmt
343: (12)                       | node_stmt
344: (8)                    ).setName("stmt")
345: (8)                    stmt_list << OneOrMore(stmt + Optional(semi.suppress()))
346: (8)                    graphparser = OneOrMore(
347: (12)                       (
348: (16)                           Optional(strict_)
349: (16)                           + Group(graph_ | digraph_)
350: (16)                           + Optional(ID)
351: (16)                           + graph_stmt
352: (12)                       ).setResultsName("graph")
353: (8)                    )
354: (8)                    singleLineComment = Group("//" + restOfLine) | Group("#" + restOfLine)
355: (8)                    graphparser.ignore(singleLineComment)
356: (8)                    graphparser.ignore(cStyleComment)
357: (8)                    assignment.setParseAction(push_attr_list)
358: (8)                    a_list.setParseAction(push_attr_list)
359: (8)                    edge_stmt.setParseAction(push_edge_stmt)
360: (8)                    node_stmt.setParseAction(push_node_stmt)
361: (8)                    attr_stmt.setParseAction(push_default_stmt)
362: (8)                    subgraph.setParseAction(push_subgraph_stmt)
363: (8)                    graph_stmt.setParseAction(push_graph_stmt)
364: (8)                    graphparser.setParseAction(push_top_graph_stmt)
365: (4)                return graphparser
366: (0)            def parse_dot_data(s):
367: (4)                """Parse DOT description in (unicode) string `s`.
368: (4)                This function is NOT thread-safe due to the internal use of `pyparsing`.
369: (4)                Use a lock if needed.
370: (4)                @return: Graphs that result from parsing.
371: (4)                @rtype: `list` of `pydot.Dot`
372: (4)                """
373: (4)                try:
374: (8)                    graphparser = graph_definition()
375: (8)                    graphparser.parseWithTabs()
376: (8)                    tokens = graphparser.parseString(s)
377: (8)                    return list(tokens)
378: (4)                except ParseException as err:
379: (8)                    print(err.line)
380: (8)                    print(" " * (err.column - 1) + "^")
381: (8)                    print(err)
382: (8)                    return None

----------------------------------------

File 13 - exceptions.py:

1: (0)              """Exception classes for pydot."""
2: (0)              class PydotException(Exception):
3: (4)                  """Base class for exceptions in Pydot.
4: (4)                  This base class will not be raised directly.
5: (4)                  Catch this base class to catch all derived exceptions, though be
6: (4)                  aware that pydot may raise Python built-in exceptions or pyparsing
7: (4)                  exceptions as well.
8: (4)                  """
9: (0)              class Error(PydotException):
10: (4)                 """General error handling class."""
11: (4)                 def __init__(self, value):
12: (8)                     self.value = value
13: (4)                 def __str__(self):
14: (8)                     return self.value

----------------------------------------

File 14 - test_pydot.py:

1: (0)              """Unit testing of `pydot`."""
2: (0)              import functools
3: (0)              import importlib
4: (0)              import os
5: (0)              import pickle
6: (0)              import string
7: (0)              import sys
8: (0)              import textwrap
9: (0)              import unittest
10: (0)             from hashlib import sha256
11: (0)             import chardet
12: (0)             import pydot
13: (0)             from parameterized import parameterized
14: (0)             from pydot._vendor import tempfile
15: (0)             TEST_ERROR_DIR = os.getenv("TEST_ERROR_DIR", None)
16: (0)             TEST_PROGRAM = "dot"
17: (0)             TESTS_DIR_1 = "my_tests"
18: (0)             TESTS_DIR_2 = "graphs"
19: (0)             _test_root = os.path.dirname(os.path.abspath(__file__))
20: (0)             class RenderResult:
21: (4)                 """Results object returned by Renderer methods."""
22: (4)                 def __init__(self, data):
23: (8)                     self._data = data
24: (4)                 @property
25: (4)                 def data(self):
26: (8)                     """Get the raw image data for the result."""
27: (8)                     return self._data
28: (4)                 @functools.cached_property
29: (4)                 def checksum(self):
30: (8)                     """Get the sha256 checksum for the result."""
31: (8)                     return sha256(self.data).hexdigest()
32: (0)             class Renderer:
33: (4)                 """Call pydot renderers for data files."""
34: (4)                 @classmethod
35: (4)                 def graphviz(cls, filename, encoding):
36: (8)                     with open(filename, encoding=encoding) as stdin:
37: (12)                        stdout_data, stderr_data, process = pydot.call_graphviz(
38: (16)                            program=TEST_PROGRAM,
39: (16)                            arguments=["-Tjpe"],
40: (16)                            working_dir=os.path.dirname(filename),
41: (16)                            stdin=stdin,
42: (12)                        )
43: (8)                     assert process.returncode == 0, stderr_data
44: (8)                     return RenderResult(stdout_data)
45: (4)                 @classmethod
46: (4)                 def pydot(cls, filename, encoding):
47: (8)                     c = pydot.graph_from_dot_file(filename, encoding=encoding)
48: (8)                     if not c:
49: (12)                        raise RuntimeError("No data returned from pydot!")
50: (8)                     jpe_data = bytearray()
51: (8)                     for g in c:
52: (12)                        jpe_data.extend(
53: (16)                            g.create(prog=TEST_PROGRAM, format="jpe", encoding=encoding)
54: (12)                        )
55: (8)                     return RenderResult(jpe_data)
56: (0)             def _load_test_cases(casedir):
57: (4)                 """Return a list of testcase files,
58: (4)                 Returns a list of tuples of the form:
59: (8)                     ("case_file_name", "case_file_name.dot", "path/to/directory")
60: (4)                 """
61: (4)                 global _test_root
62: (4)                 path = os.path.join(_test_root, casedir)
63: (4)                 dot_files = filter(lambda x: x.endswith(".dot"), os.listdir(path))
64: (4)                 def _case_name(fname: str) -> str:
65: (8)                     """No str.removesuffix() until Python 3.9."""
66: (8)                     if sys.version_info < (3, 9):
67: (12)                        return fname
68: (8)                     return fname.removesuffix(".dot")
69: (4)                 return [(_case_name(dot_file), dot_file, path) for dot_file in dot_files]
70: (0)             def _compare_images(fname: str, pydot: RenderResult, gv: RenderResult) -> bool:
71: (4)                 """Compare two RenderResult objects for the named test.
72: (4)                 If the images differ and a ``TEST_ERROR_DIR`` has been provided, create
73: (4)                 a subdir for the test and dump both images there for examination."""
74: (4)                 if pydot.checksum == gv.checksum:
75: (8)                     return True
76: (4)                 if TEST_ERROR_DIR is not None:
77: (8)                     dirname = fname.replace(".", "_")
78: (8)                     out_dir = os.path.join(os.path.normpath(TEST_ERROR_DIR), dirname)
79: (8)                     os.makedirs(out_dir)
80: (8)                     pydot_path = os.path.join(out_dir, "err_pydot.jpeg")
81: (8)                     gv_path = os.path.join(out_dir, "err_graphviz.jpeg")
82: (8)                     with open(pydot_path, "wb") as p, open(gv_path, "wb") as g:
83: (12)                        p.write(pydot.data)
84: (12)                        g.write(gv.data)
85: (4)                 return False
86: (0)             class PydotTestCase(unittest.TestCase):
87: (4)                 def setUp(self):
88: (8)                     self._reset_graphs()
89: (4)                 def _reset_graphs(self):
90: (8)                     self.graph_directed = pydot.Graph("testgraph", graph_type="digraph")
91: (0)             class TestGraphAPI(PydotTestCase):
92: (4)                 def test_keep_graph_type(self):
93: (8)                     g = pydot.Dot(graph_name="Test", graph_type="graph")
94: (8)                     self.assertEqual(g.get_type(), "graph")
95: (8)                     g = pydot.Dot(graph_name="Test", graph_type="digraph")
96: (8)                     self.assertEqual(g.get_type(), "digraph")
97: (4)                 def test_add_style(self):
98: (8)                     node = pydot.Node("mynode")
99: (8)                     node.add_style("abc")
100: (8)                    self.assertEqual(node.get_style(), "abc")
101: (8)                    node.add_style("def")
102: (8)                    self.assertEqual(node.get_style(), "abc,def")
103: (8)                    node.add_style("ghi")
104: (8)                    self.assertEqual(node.get_style(), "abc,def,ghi")
105: (4)                def test_create_simple_graph_with_node(self):
106: (8)                    g = pydot.Dot()
107: (8)                    g.set_type("digraph")
108: (8)                    node = pydot.Node("legend")
109: (8)                    node.set("shape", "box")
110: (8)                    g.add_node(node)
111: (8)                    node.set("label", "mine")
112: (8)                    s = g.to_string()
113: (8)                    expected = "digraph G {\nlegend [shape=box, label=mine];\n}\n"
114: (8)                    assert s == expected
115: (4)                def test_attribute_with_implicit_value(self):
116: (8)                    d = 'digraph {\na -> b[label="hi", decorate];\n}'
117: (8)                    graphs = pydot.graph_from_dot_data(d)
118: (8)                    (g,) = graphs
119: (8)                    attrs = g.get_edges()[0].get_attributes()
120: (8)                    self.assertEqual("decorate" in attrs, True)
121: (4)                def test_subgraphs(self):
122: (8)                    g = pydot.Graph()
123: (8)                    s = pydot.Subgraph("foo")
124: (8)                    self.assertEqual(g.get_subgraphs(), [])
125: (8)                    self.assertEqual(g.get_subgraph_list(), [])
126: (8)                    g.add_subgraph(s)
127: (8)                    self.assertEqual(g.get_subgraphs()[0].get_name(), s.get_name())
128: (8)                    self.assertEqual(g.get_subgraph_list()[0].get_name(), s.get_name())
129: (4)                def test_graph_pickling(self):
130: (8)                    g = pydot.Graph()
131: (8)                    s = pydot.Subgraph("foo")
132: (8)                    g.add_subgraph(s)
133: (8)                    g.add_edge(pydot.Edge("A", "B"))
134: (8)                    g.add_edge(pydot.Edge("A", "C"))
135: (8)                    g.add_edge(pydot.Edge(("D", "E")))
136: (8)                    g.add_node(pydot.Node("node!"))
137: (8)                    pickle.dumps(g)
138: (4)                def test_dot_pickling(self):
139: (8)                    g = pydot.Dot()
140: (8)                    g.set_prog("neato")
141: (8)                    g.set_shape_files("dummy.png")
142: (8)                    pkl = pickle.dumps(g)
143: (8)                    g2 = pickle.loads(pkl)
144: (8)                    self.assertIsInstance(g2, pydot.Dot)
145: (8)                    self.assertEqual(g2.prog, "neato")
146: (8)                    self.assertEqual(g2.shape_files[0], "dummy.png")
147: (4)                def test_unicode_ids(self):
148: (8)                    node1 = '"ano"'
149: (8)                    node2 = '""'
150: (8)                    g = pydot.Dot()
151: (8)                    g.set_charset("latin1")
152: (8)                    g.add_node(pydot.Node(node1))
153: (8)                    g.add_node(pydot.Node(node2))
154: (8)                    g.add_edge(pydot.Edge(node1, node2))
155: (8)                    self.assertEqual(g.get_node(node1)[0].get_name(), node1)
156: (8)                    self.assertEqual(g.get_node(node2)[0].get_name(), node2)
157: (8)                    self.assertEqual(g.get_edges()[0].get_source(), node1)
158: (8)                    self.assertEqual(g.get_edges()[0].get_destination(), node2)
159: (8)                    graphs = pydot.graph_from_dot_data(g.to_string())
160: (8)                    (g2,) = graphs
161: (8)                    self.assertEqual(g2.get_node(node1)[0].get_name(), node1)
162: (8)                    self.assertEqual(g2.get_node(node2)[0].get_name(), node2)
163: (8)                    self.assertEqual(g2.get_edges()[0].get_source(), node1)
164: (8)                    self.assertEqual(g2.get_edges()[0].get_destination(), node2)
165: (4)                def test_graph_simplify(self):
166: (8)                    g = pydot.Graph()
167: (8)                    g.add_edge(pydot.Edge("a", "b"))
168: (8)                    g.add_edge(pydot.Edge("a", "b"))
169: (8)                    g.add_edge(pydot.Edge("b", "a"))
170: (8)                    g.add_edge(pydot.Edge("b", "a"))
171: (8)                    test_combinations = [
172: (12)                       (
173: (16)                           "graph",
174: (16)                           False,
175: (16)                           "graph G { a -- b; a -- b; b -- a; b -- a; }",
176: (12)                       ),
177: (12)                       (
178: (16)                           "graph",
179: (16)                           True,
180: (16)                           "graph G { a -- b; }",
181: (12)                       ),
182: (12)                       (
183: (16)                           "digraph",
184: (16)                           False,
185: (16)                           "digraph G { a -> b; a -> b; b -> a; b -> a; }",
186: (12)                       ),
187: (12)                       (
188: (16)                           "digraph",
189: (16)                           True,
190: (16)                           "digraph G { a -> b; b -> a; }",
191: (12)                       ),
192: (8)                    ]
193: (8)                    expected_concat = observed_concat = ""
194: (8)                    for graph_type, simplify, expected in test_combinations:
195: (12)                       expected_concat += (
196: (16)                           f"graph_type {graph_type}, simplify {simplify}: {expected}\n"
197: (12)                       )
198: (12)                       g.set_type(graph_type)
199: (12)                       g.set_simplify(simplify)
200: (12)                       try:
201: (16)                           observed = " ".join(g.to_string().split())
202: (12)                       except (NameError, TypeError) as e:
203: (16)                           type_name = type(e).__name__
204: (16)                           observed = f"{type_name}: {e}"
205: (12)                       observed_concat += (
206: (16)                           f"graph_type {graph_type}, simplify {simplify}: {observed}\n"
207: (12)                       )
208: (8)                    self.maxDiff = None
209: (8)                    self.assertMultiLineEqual(expected_concat, observed_concat)
210: (4)                def test_multiple_graphs(self):
211: (8)                    graph_data = "graph A { a->b };\ngraph B {c->d}"
212: (8)                    graphs = pydot.graph_from_dot_data(graph_data)
213: (8)                    n = len(graphs)
214: (8)                    assert n == 2, n
215: (8)                    names = [g.get_name() for g in graphs]
216: (8)                    assert names == ["A", "B"], names
217: (4)                def test_numeric_node_id(self):
218: (8)                    self._reset_graphs()
219: (8)                    self.graph_directed.add_node(pydot.Node(1))
220: (8)                    self.assertEqual(self.graph_directed.get_nodes()[0].get_name(), "1")
221: (4)                def test_numeric_quoting(self):
222: (8)                    num = pydot.Node("12", label=1.4, width=".75")
223: (8)                    non = pydot.Node("1.2.3", label="1.4.0")
224: (8)                    self.assertEqual(num.to_string(), "12 [label=1.4, width=.75];")
225: (8)                    self.assertEqual(non.to_string(), '"1.2.3" [label="1.4.0"];')
226: (4)                def test_quoted_node_id(self):
227: (8)                    self._reset_graphs()
228: (8)                    self.graph_directed.add_node(pydot.Node('"node"'))
229: (8)                    self.assertEqual(
230: (12)                       self.graph_directed.get_nodes()[0].get_name(), '"node"'
231: (8)                    )
232: (4)                def test_quoted_node_id_to_string_no_attributes(self):
233: (8)                    self._reset_graphs()
234: (8)                    self.graph_directed.add_node(pydot.Node('"node"'))
235: (8)                    self.assertEqual(
236: (12)                       self.graph_directed.get_nodes()[0].to_string(), '"node";'
237: (8)                    )
238: (4)                def test_keyword_node_id(self):
239: (8)                    self._reset_graphs()
240: (8)                    self.graph_directed.add_node(pydot.Node("node"))
241: (8)                    self.assertEqual(self.graph_directed.get_nodes()[0].get_name(), "node")
242: (4)                def test_keyword_node_id_to_string_no_attributes(self):
243: (8)                    self._reset_graphs()
244: (8)                    self.graph_directed.add_node(pydot.Node("node"))
245: (8)                    self.assertEqual(self.graph_directed.get_nodes()[0].to_string(), "")
246: (4)                def test_keyword_node_id_to_string_with_attributes(self):
247: (8)                    self._reset_graphs()
248: (8)                    self.graph_directed.add_node(pydot.Node("node", shape="box"))
249: (8)                    self.assertEqual(
250: (12)                       self.graph_directed.get_nodes()[0].to_string(), "node [shape=box];"
251: (8)                    )
252: (4)                def test_comma_separated_attribute_values_to_string(self):
253: (8)                    self._reset_graphs()
254: (8)                    self.graph_directed.add_node(
255: (12)                       pydot.Node("node", color="green", style="rounded,filled")
256: (8)                    )
257: (8)                    self.assertEqual(
258: (12)                       self.graph_directed.get_nodes()[0].to_string(),
259: (12)                       'node [color=green, style="rounded,filled"];',
260: (8)                    )
261: (4)                def test_attribute_string_values_quoting(self):
262: (8)                    self._reset_graphs()
263: (8)                    self.graph_directed.add_node(
264: (12)                       pydot.Node("node", length=1.234, size="2.345", radius="9,876")
265: (8)                    )
266: (8)                    self.assertEqual(
267: (12)                       self.graph_directed.get_nodes()[0].to_string(),
268: (12)                       'node [length=1.234, size=2.345, radius="9,876"];',
269: (8)                    )
270: (4)                def test_names_of_a_thousand_nodes(self):
271: (8)                    self._reset_graphs()
272: (8)                    names = {f"node_{i:05d}" for i in range(10**3)}
273: (8)                    for name in names:
274: (12)                       self.graph_directed.add_node(pydot.Node(name, label=name))
275: (8)                    self.assertEqual(
276: (12)                       {n.get_name() for n in self.graph_directed.get_nodes()}, names
277: (8)                    )
278: (4)                def test_executable_not_found_exception(self):
279: (8)                    graph = pydot.Dot("graphname", graph_type="digraph")
280: (8)                    self.assertRaises(Exception, graph.create, prog="dothehe")
281: (4)                def test_graph_add_node_argument_type(self):
282: (8)                    self._reset_graphs()
283: (8)                    self.assertRaises(TypeError, self.graph_directed.add_node, 1)
284: (8)                    self.assertRaises(TypeError, self.graph_directed.add_node, "a")
285: (4)                def test_graph_add_edge_argument_type(self):
286: (8)                    self._reset_graphs()
287: (8)                    self.assertRaises(TypeError, self.graph_directed.add_edge, 1)
288: (8)                    self.assertRaises(TypeError, self.graph_directed.add_edge, "a")
289: (4)                def test_graph_add_subgraph_argument_type(self):
290: (8)                    self._reset_graphs()
291: (8)                    self.assertRaises(TypeError, self.graph_directed.add_subgraph, 1)
292: (8)                    self.assertRaises(TypeError, self.graph_directed.add_subgraph, "a")
293: (4)                def test_node_parenting(self):
294: (8)                    g = pydot.Dot()
295: (8)                    n = pydot.Node("node a")
296: (8)                    n2 = pydot.Node("node a")
297: (8)                    g.add_node(n)
298: (8)                    g.add_node(n2)
299: (8)                    nodes = g.get_node('"node a"')
300: (8)                    for node in nodes:
301: (12)                       assert node.get_parent_graph() == g
302: (8)                    sg = pydot.Subgraph("sub sg")
303: (8)                    sg_n = pydot.Node("node a")
304: (8)                    sg.add_node(sg_n)
305: (8)                    self.assertEqual(sg_n.get_parent_graph(), sg)
306: (8)                    g.add_node(sg_n)
307: (8)                    self.assertEqual(sg_n.get_parent_graph(), sg)
308: (8)                    g.add_subgraph(sg)
309: (8)                    self.assertEqual(sg_n.get_parent_graph(), g)
310: (4)                def test_quoting(self):
311: (8)                    g = pydot.Dot()
312: (8)                    g.add_node(pydot.Node("test", label=string.printable))
313: (8)                    data = g.create(format="jpe")
314: (8)                    self.assertEqual(len(data) > 0, True)
315: (4)                def test_keyword_quoting(self):
316: (8)                    g = pydot.Dot(graph_name="graph", graph_type="graph")
317: (8)                    g.add_node(pydot.Node("digraph", color="red"))
318: (8)                    g.add_node(pydot.Node("strict", shape="box"))
319: (8)                    g.add_node(pydot.Node("A", label="digraph"))
320: (8)                    g.add_node(pydot.Node("B", label="subgraph"))
321: (8)                    g.add_node(pydot.Node("edge", style="dashed"))
322: (8)                    g.add_edge(pydot.Edge("A", "B", xlabel="node"))
323: (8)                    formatted = g.to_string()
324: (8)                    self.assertEqual(
325: (12)                       formatted,
326: (12)                       textwrap.dedent("""\
327: (16)                           graph "graph" {
328: (16)                           "digraph" [color=red];
329: (16)                           "strict" [shape=box];
330: (16)                           A [label="digraph"];
331: (16)                           B [label="subgraph"];
332: (16)                           edge [style=dashed];
333: (16)                           A -- B [xlabel="node"];
334: (16)                           }
335: (16)                           """),
336: (8)                    )
337: (4)                def test_alphanum_quoting(self):
338: (8)                    """Test the fix for issue #408."""
339: (8)                    g = pydot.Dot(graph_name="issue408", graph_type="graph")
340: (8)                    n1 = pydot.Node(
341: (12)                       "11herbs", label="and 11 spices", fontsize=12, height="1"
342: (8)                    )
343: (8)                    n2 = pydot.Node("nooks9nooks", fontsize="14pt", height="2in")
344: (8)                    g.add_node(n1)
345: (8)                    g.add_node(n2)
346: (8)                    g.add_edge(pydot.Edge(n1, n2, minlength="4pt"))
347: (8)                    self.assertEqual(
348: (12)                       g.to_string(),
349: (12)                       textwrap.dedent("""\
350: (16)                           graph issue408 {
351: (16)                           "11herbs" [label="and 11 spices", fontsize=12, height=1];
352: (16)                           nooks9nooks [fontsize="14pt", height="2in"];
353: (16)                           "11herbs" -- nooks9nooks [minlength="4pt"];
354: (16)                           }
355: (16)                           """),
356: (8)                    )
357: (4)                def test_alphanum_quoting2(self):
358: (8)                    """Test the fix for issue #418."""
359: (8)                    g = pydot.Dot(graph_name="issue418", graph_type="graph")
360: (8)                    n1 = pydot.Node("foo.bar", color="red")
361: (8)                    n2 = pydot.Node("baz", color="blue")
362: (8)                    g.add_node(n1)
363: (8)                    g.add_node(n2)
364: (8)                    g.add_edge(pydot.Edge(n1, n2))
365: (8)                    self.assertEqual(
366: (12)                       g.to_string(),
367: (12)                       textwrap.dedent("""\
368: (16)                           graph issue418 {
369: (16)                           "foo.bar" [color=red];
370: (16)                           baz [color=blue];
371: (16)                           "foo.bar" -- baz;
372: (16)                           }
373: (16)                           """),
374: (8)                    )
375: (4)                def test_edge_quoting(self):
376: (8)                    """Test the fix for issue #383 (pydot 3.0.0)."""
377: (8)                    g = pydot.Graph("", graph_type="digraph")
378: (8)                    g.add_node(pydot.Node("Node^A"))
379: (8)                    g.add_node(pydot.Node("Node^B"))
380: (8)                    g.add_edge(pydot.Edge("Node^A", "Node^B"))
381: (8)                    self.assertEqual(
382: (12)                       g.to_string(),
383: (12)                       textwrap.dedent("""\
384: (12)                       digraph {
385: (12)                       "Node^A";
386: (12)                       "Node^B";
387: (12)                       "Node^A" -> "Node^B";
388: (12)                       }
389: (12)                       """),
390: (8)                    )
391: (4)                def test_id_storage_and_lookup(self):
392: (8)                    g = pydot.Graph()
393: (8)                    a = pydot.Node("my node")
394: (8)                    b = pydot.Node('"node B"')
395: (8)                    e = pydot.Edge(a, b)
396: (8)                    g.add_node(a)
397: (8)                    g.add_node(b)
398: (8)                    g.add_edge(e)
399: (8)                    a_out = g.get_node("my node")[0]
400: (8)                    b_out = g.get_node('"node B"')[0]
401: (8)                    self.assertEqual(g.get_node("node B"), [])
402: (8)                    self.assertEqual(id(a_out.obj_dict), id(a.obj_dict))
403: (8)                    self.assertEqual(id(b_out.obj_dict), id(b.obj_dict))
404: (8)                    e_out = g.get_edge("my node", '"node B"')[0]
405: (8)                    self.assertEqual(id(e_out.obj_dict), id(e.obj_dict))
406: (8)                    sg = pydot.Subgraph("sub graph", graph_type="graph")
407: (8)                    sgA = pydot.Node("sg A")
408: (8)                    sgB = pydot.Node('"sg B"')
409: (8)                    sg.add_node(sgA)
410: (8)                    sg.add_node(sgB)
411: (8)                    g.add_subgraph(sg)
412: (8)                    sg_out = g.get_subgraph("sub graph")[0]
413: (8)                    self.assertEqual(id(sg_out.obj_dict), id(sg.obj_dict))
414: (8)                    g_nodes_out = g.get_nodes()
415: (8)                    self.assertEqual(id(g_nodes_out[0].obj_dict), id(a.obj_dict))
416: (8)                    self.assertEqual(id(g_nodes_out[1].obj_dict), id(b.obj_dict))
417: (8)                    g_edges_out = g.get_edges()
418: (8)                    self.assertEqual(id(g_edges_out[0].obj_dict), id(e.obj_dict))
419: (8)                    g_sg_out = g.get_subgraphs()
420: (8)                    self.assertEqual(id(g_sg_out[0].obj_dict), id(sg.obj_dict))
421: (8)                    sg_nodes_out = sg.get_nodes()
422: (8)                    self.assertEqual(id(sg_nodes_out[0].obj_dict), id(sgA.obj_dict))
423: (8)                    self.assertEqual(id(sg_nodes_out[1].obj_dict), id(sgB.obj_dict))
424: (8)                    self.assertEqual(sg.get_edges(), [])
425: (4)                def test_dot_args(self):
426: (8)                    g = pydot.Dot()
427: (8)                    u = pydot.Node("a")
428: (8)                    g.add_node(u)
429: (8)                    with tempfile.TemporaryDirectory(
430: (12)                       ignore_cleanup_errors=True
431: (8)                    ) as tmp_dir:
432: (12)                       outfile = os.path.join(tmp_dir, "test.svg")
433: (12)                       g.write_svg(outfile, prog=["twopi", "-Goverlap=scale"])
434: (4)                def test_edge_equality_basics_3_same_points_not_not_equal(self):
435: (8)                    g = pydot.Graph()
436: (8)                    e1 = pydot.Edge("a", "b")
437: (8)                    e2 = pydot.Edge("a", "b")
438: (8)                    g.add_edge(e1)
439: (8)                    g.add_edge(e2)
440: (8)                    self.assertFalse(e1 != e2)
441: (4)                def test_edge_point_namestr(self):
442: (8)                    self._reset_graphs()
443: (8)                    self.graph_directed.add_edge(pydot.Edge("a", "b"))
444: (8)                    self.assertEqual(
445: (12)                       self.graph_directed.get_edges()[0].to_string(), "a -> b;"
446: (8)                    )
447: (4)                def test_edge_point_object_node(self):
448: (8)                    self._reset_graphs()
449: (8)                    self.graph_directed.add_edge(
450: (12)                       pydot.Edge(pydot.Node("a"), pydot.Node("b"))
451: (8)                    )
452: (8)                    self.assertEqual(
453: (12)                       self.graph_directed.get_edges()[0].to_string(), "a -> b;"
454: (8)                    )
455: (4)                def test_edge_point_object_subgraph(self):
456: (8)                    self._reset_graphs()
457: (8)                    self.graph_directed.add_edge(
458: (12)                       pydot.Edge(pydot.Subgraph("a"), pydot.Subgraph("b"))
459: (8)                    )
460: (8)                    self.assertEqual(
461: (12)                       self.graph_directed.get_edges()[0].to_string(), "a -> b;"
462: (8)                    )
463: (4)                def test_edge_point_object_cluster(self):
464: (8)                    self._reset_graphs()
465: (8)                    self.graph_directed.add_edge(
466: (12)                       pydot.Edge(pydot.Cluster("a"), pydot.Cluster("b"))
467: (8)                    )
468: (8)                    self.assertEqual(
469: (12)                       self.graph_directed.get_edges()[0].to_string(),
470: (12)                       "cluster_a -> cluster_b;",
471: (8)                    )
472: (4)                def test_graph_from_adjacency_matrix(self):
473: (8)                    g = pydot.graph_from_adjacency_matrix(
474: (12)                       [[0, 1, 0], [1, 0, 0], [0, 1, 1]], directed=True
475: (8)                    )
476: (8)                    s = " ".join(g.to_string().split())
477: (8)                    self.assertEqual(s, "digraph G { 1 -> 2; 2 -> 1; 3 -> 2; 3 -> 3; }")
478: (8)                    g = pydot.graph_from_adjacency_matrix(
479: (12)                       [[0, 1, 0], [1, 0, 0], [0, 0, 1]], directed=False
480: (8)                    )
481: (8)                    s = " ".join(g.to_string().split())
482: (8)                    self.assertEqual(s, "graph G { 1 -- 2; 3 -- 3; }")
483: (4)                def test_graph_from_incidence_matrix(self):
484: (8)                    g = pydot.graph_from_incidence_matrix(
485: (12)                       [[-1, 1, 0], [1, -1, 0], [0, 1, -1]], directed=True
486: (8)                    )
487: (8)                    s = " ".join(g.to_string().split())
488: (8)                    self.assertEqual(s, "digraph G { 1 -> 2; 2 -> 1; 3 -> 2; }")
489: (8)                    g = pydot.graph_from_incidence_matrix(
490: (12)                       [[1, 1, 0], [0, 1, 1]], directed=False
491: (8)                    )
492: (8)                    s = " ".join(g.to_string().split())
493: (8)                    self.assertEqual(s, "graph G { 1 -- 2; 2 -- 3; }")
494: (4)                def test_version(self):
495: (8)                    self.assertIsInstance(pydot.__version__, str)
496: (4)                def test_logging_init(self):
497: (8)                    with self.assertLogs("pydot", level="DEBUG") as cm:
498: (12)                       importlib.reload(pydot)
499: (12)                       importlib.reload(pydot.core)
500: (12)                       importlib.reload(pydot.dot_parser)
501: (8)                    self.assertEqual(
502: (12)                       cm.output,
503: (12)                       [
504: (16)                           "DEBUG:pydot:pydot initializing",
505: (16)                           f"DEBUG:pydot:pydot {pydot.__version__}",
506: (16)                           "DEBUG:pydot.core:pydot core module initializing",
507: (16)                           "DEBUG:pydot.dot_parser:pydot dot_parser module initializing",
508: (12)                       ],
509: (8)                    )
510: (8)                    importlib.reload(pydot)
511: (0)            class TestShapeFiles(PydotTestCase):
512: (4)                shapefile_dir = os.path.join(_test_root, "from-past-to-future")
513: (4)                @unittest.skipUnless(
514: (8)                    os.path.isdir(shapefile_dir),
515: (8)                    "Skipping tests that involve images,"
516: (8)                    + " they can be found in the git repository",
517: (4)                )
518: (4)                def test_graph_with_shapefiles(self):
519: (8)                    dot_file = os.path.join(self.shapefile_dir, "from-past-to-future.dot")
520: (8)                    pngs = [
521: (12)                       os.path.join(self.shapefile_dir, fname)
522: (12)                       for fname in os.listdir(self.shapefile_dir)
523: (12)                       if fname.endswith(".png")
524: (8)                    ]
525: (8)                    with open(dot_file) as f:
526: (12)                       graph_data = f.read()
527: (8)                    graphs = pydot.graph_from_dot_data(graph_data)
528: (8)                    self.assertIsNotNone(graphs)
529: (8)                    if not isinstance(graphs, list):
530: (12)                       return
531: (8)                    g = graphs.pop()
532: (8)                    g.set_shape_files(pngs)
533: (8)                    rendered = RenderResult(g.create(format="jpe"))
534: (8)                    graphviz = Renderer.graphviz(dot_file, encoding="ascii")
535: (8)                    if not _compare_images("from-past-to-future", rendered, graphviz):
536: (12)                       raise AssertionError(
537: (16)                           "from-past-to-future.dot: "
538: (16)                           f"{rendered.checksum} != {graphviz.checksum} "
539: (16)                           "(found pydot vs graphviz difference)"
540: (12)                       )
541: (0)            class RenderedTestCase(PydotTestCase):
542: (4)                def _render_and_compare_dot_file(self, fdir, fname):
543: (8)                    encodings = {"Latin1.dot": "latin-1"}
544: (8)                    fpath = os.path.join(fdir, fname)
545: (8)                    with open(fpath, "rb") as f:
546: (12)                       s = f.read()
547: (8)                    estimate = chardet.detect(s)
548: (8)                    encoding = encodings.get(fname, estimate["encoding"])
549: (8)                    rendered = Renderer.pydot(
550: (12)                       fpath,
551: (12)                       encoding,
552: (8)                    )
553: (8)                    graphviz = Renderer.graphviz(
554: (12)                       fpath,
555: (12)                       encoding,
556: (8)                    )
557: (8)                    if not _compare_images(fname, rendered, graphviz):
558: (12)                       raise AssertionError(
559: (16)                           f"{fname}: {rendered.checksum} != {graphviz.checksum} "
560: (16)                           "(found pydot vs graphviz difference)"
561: (12)                       )
562: (0)            class TestMyRegressions(RenderedTestCase):
563: (4)                """Perform regression tests in my_tests dir."""
564: (4)                @parameterized.expand(functools.partial(_load_test_cases, TESTS_DIR_1))
565: (4)                def test_regression(self, _, fname, path):
566: (8)                    self._render_and_compare_dot_file(path, fname)
567: (0)            class TestGraphvizRegressions(RenderedTestCase):
568: (4)                """Perform regression tests in graphs dir."""
569: (4)                @parameterized.expand(functools.partial(_load_test_cases, TESTS_DIR_2))
570: (4)                def test_regression(self, _, fname, path):
571: (8)                    self._render_and_compare_dot_file(path, fname)

----------------------------------------

File 15 - SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRYCOMBINER_aligner_20_characters_for_pythons_codes.py:

1: (0)              import os
2: (0)              from datetime import datetime
3: (0)              def get_file_info(root_folder):
4: (4)                  file_info_list = []
5: (4)                  for root, dirs, files in os.walk(root_folder):
6: (8)                      for file in files:
7: (12)                         try:
8: (16)                             if file.endswith('.py'):
9: (20)                                 file_path = os.path.join(root, file)
10: (20)                                creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
11: (20)                                modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))
12: (20)                                file_extension = os.path.splitext(file)[1].lower()
13: (20)                                file_info_list.append([file, file_path, creation_time, modified_time, file_extension, root])
14: (12)                        except Exception as e:
15: (16)                            print(f"Error processing file {file}: {e}")
16: (4)                 file_info_list.sort(key=lambda x: (x[2], x[3], len(x[0]), x[4]))  # Sort by creation, modification time, name length, extension
17: (4)                 return file_info_list
18: (0)             def process_file(file_info_list):
19: (4)                 combined_output = []
20: (4)                 for idx, (file_name, file_path, creation_time, modified_time, file_extension, root) in enumerate(file_info_list):
21: (8)                     with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
22: (12)                        content = f.read()
23: (12)                        content = "\n".join([line for line in content.split('\n') if line.strip() and not line.strip().startswith("#")])
24: (12)                        content = content.replace('\t', '    ')
25: (12)                        processed_lines = []
26: (12)                        for i, line in enumerate(content.split('\n')):
27: (16)                            leading_spaces = len(line) - len(line.lstrip(' '))
28: (16)                            line_number_str = f"{i+1}: ({leading_spaces})"
29: (16)                            padding = ' ' * (20 - len(line_number_str))
30: (16)                            processed_line = f"{line_number_str}{padding}{line}"
31: (16)                            processed_lines.append(processed_line)
32: (12)                        content_with_line_numbers = "\n".join(processed_lines)
33: (12)                        combined_output.append(f"File {idx + 1} - {file_name}:\n")
34: (12)                        combined_output.append(content_with_line_numbers)
35: (12)                        combined_output.append("\n" + "-"*40 + "\n")
36: (4)                 return combined_output
37: (0)             root_folder_path = '.'  # Set this to the desired folder
38: (0)             file_info_list = get_file_info(root_folder_path)
39: (0)             combined_output = process_file(file_info_list)
40: (0)             output_file = 'SANJOYNATHQHENOMENOLOGYGEOMETRIFYINGTRIGONOMETRY_combined_python_files_20_chars.txt'
41: (0)             with open(output_file, 'w', encoding='utf-8') as logfile:
42: (4)                 logfile.write("\n".join(combined_output))
43: (0)             print(f"Processed file info logged to {output_file}")

----------------------------------------
